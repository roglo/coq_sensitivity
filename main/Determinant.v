(* determinant *)

Set Nested Proofs Allowed.
Set Implicit Arguments.

Require Import Utf8 Arith.
Import List List.ListNotations.
Import Init.Nat.

Require Import Misc RingLike IterAdd IterMul.
Require Import PermutationFun SortingFun.
Require Import MyVector Matrix PermutSeq Signature.
Require Import NatRingLike.
Import matrix_Notations.

Definition set_minus {A} (eqb : A → _) E F :=
  filter (λ e, negb (member eqb e F)) E.

Notation "E ⊂ F" := (incl E F) (at level 70).

Section a.

Context {T : Type}.
Context (ro : ring_like_op T).
Context (rp : ring_like_prop T).

(*
 * three definitions of determinant
 *)

(*
   definition 1
   det n M recursively computes determinant

      0     n-1
      |     |
      v     v
     ---------    ---------   ---------   ---------
0    |x      |    | x     |   |  x    |   |   x   |
     | ......| -  |. .....| + |.. ....| - |... ...| + etc.
     | ......|    |. .....|   |.. ....|   |... ...|
n-1  | ......|    |. .....|   |.. ....|   |... ...|
     ---------    ---------   ---------   ---------

   each term is the term "x" multiplied by det (n-1) of
   the sub-matrix represented by the dots. The "x" goes through
   the first row.
*)

Fixpoint determinant_loop n (M : matrix T) :=
  match n with
  | 0 => 1%F
  | S n' =>
      ∑ (j = 1, n),
      minus_one_pow (S j) * mat_el M 1 j *
      determinant_loop n' (subm 1 j M)
  end.

Definition det M := determinant_loop (mat_nrows M) M.
Arguments det M%M.

(* definition 2
   determinant by sum of products involving all permutations of columns,
   aka "Leibniz formula";
   sum of product of the factors a_{i,σ(i)} where σ goes through all
   permutations of the naturals of the interval [0, n-1].
   The permutations generated are in the same order as the
   terms generated by the determinant defined by induction on
   the size of the matrix.
     The order happens to be the canonical (alphabetical) order.
   Example for n=3
     = [[0; 1; 2]; [0; 2; 1]; [1; 0; 2]; [1; 2; 0]; [2; 0; 1]; [2; 1; 0]]
   Having the same terms order, the proof of equality of both definitions
   of both determinants is easy.
   This definitions holds n! terms.
   See PermutSeq.v *)

Definition det' (M : matrix T) :=
  let n := mat_nrows M in
  ∑ (k = 0, fact n - 1),
    ε (canon_sym_gr_list n k) *
    ∏ (i = 1, n), mat_el M i ((canon_sym_gr_list n k).(i) + 1).

Arguments det' M%M.

(* definition 3
   determinant by sum of products like in definition 2, but running with all
   combinations of columns, even with repetitions; the signatures ε of the
   terms using twice the same column are 0 by definition of ε; the
   remaining terms, whose ε is not 0, i.e. 1 or -1, are the ones when all
   selected columns are different. It holds n^n terms *)

Definition all_comb n := list_prodn (repeat (seq 1 n) n).

(*
Compute (all_comb 3).
Compute (list_prodn (repeat (seq 0 10) 2)).
*)

Definition det'' (M : matrix T) :=
  let n := mat_nrows M in
  ∑ (l ∈ all_comb n), ε l * ∏ (i = 1, n), mat_el M i l.(i).

(* *)

Theorem fold_det : ∀ M, determinant_loop (mat_nrows M) M = det M.
Proof. easy. Qed.

Theorem determinant_zero : ∀ (M : matrix T),
  determinant_loop 0 M = 1%F.
Proof. easy. Qed.

Theorem determinant_succ : ∀ n (M : matrix T),
  determinant_loop (S n) M =
     ∑ (j = 1, S n),
     minus_one_pow (S j) * mat_el M 1 j *
     determinant_loop n (subm 1 j M).
Proof. easy. Qed.

(*
End a.
Compute (length (list_prodn [[2;3];[5;7;2];[8;3];[7;2]])).
Compute (length (list_prodn [[3;7;4;1];[0;6;2;7];[1;3;1;1];[18;3;2;1]])).
Compute (length (list_prodn [[3;7;4;1];[0;6;2;7];[1;3;1;1];[18;3;1]])).
Compute (length (list_prodn [[7;4;1];[0;6;2;7];[1;3;1;1];[18;3;1]])).
Compute (length (list_prodn [[7;4;1];[2;7];[1;3;1;1];[18;3;1]])).
Arguments det {T ro} M%M.
Arguments det' {T ro} M%M.
Arguments det'' {T ro} M%M.
Require Import RnglAlg.Qrl.
Require Import RnglAlg.Rational.
Import Q.Notations.
Open Scope Q_scope.
Compute (let M := mk_mat [[3;7;4;1];[0;6;2;7];[1;3;1;1];[18;3;2;1]] in det M).
Compute (let M := mk_mat [[3;7;4;1];[0;6;2;7];[1;3;1;1];[18;3;2;1]] in det' M).
Compute (let M := mk_mat [[3;7;4;1];[0;6;2;7];[1;3;1;1];[18;3;2;1]] in det'' M).
Compute (let M := mk_mat [] in det M).
Compute (let M := mk_mat [] in det' M).
Compute (let M := mk_mat [] in det'' M).
Compute (let M := mk_mat [[3]] in det M).
Compute (let M := mk_mat [[3]] in det' M).
Compute (let M := mk_mat [[3]] in det'' M).
*)

Theorem rngl_summation_list_incl : ∀ A eqd la lb (f : A → T),
  NoDup la
  → NoDup lb
  → la ⊂ lb
  → ∑ (a ∈ la), f a =
    ∑ (a ∈ lb), if ListDec.In_dec eqd a la then f a else 0.
Proof.
intros * Hnda Hndb Hlab.
induction la as [| a]. {
  cbn.
  rewrite rngl_summation_list_empty; [ | easy ].
  symmetry.
  now apply all_0_rngl_summation_list_0.
}
rewrite rngl_summation_list_cons.
specialize (NoDup_remove [] la a Hnda) as H1.
cbn in H1.
destruct H1 as (Hnd1, Hala).
specialize (IHla Hnd1).
rewrite IHla; [ | now intros i Hi; apply Hlab; right ].
assert (Ha : a ∈ lb) by now apply Hlab; left.
apply In_split in Ha.
destruct Ha as (lb1 & lb2 & Hlb); rewrite Hlb.
do 2 rewrite rngl_summation_list_app.
do 2 rewrite rngl_summation_list_cons.
destruct (ListDec.In_dec eqd a la) as [H| H]; [ easy | clear H ].
rewrite rngl_add_0_l.
destruct (ListDec.In_dec eqd a (a :: la)) as [H| H]; [ clear H | ]. 2: {
  now exfalso; apply H; left.
}
symmetry; rewrite rngl_add_comm, rngl_add_assoc.
rewrite rngl_add_add_swap.
f_equal; [ f_equal | ]. {
  apply rngl_summation_list_eq_compat.
  intros i Hi.
  destruct (ListDec.In_dec eqd i (a :: la)) as [H1| H1]. {
    destruct (ListDec.In_dec eqd i la) as [H| H]; [ easy | ].
    destruct H1 as [H1| H1]; [ clear H | easy ].
    subst i.
    rewrite Hlb in Hndb.
    apply NoDup_remove_2 in Hndb.
    exfalso; apply Hndb.
    now apply in_or_app; left.
  }
  destruct (ListDec.In_dec eqd i la) as [H2| H2]; [ | easy ].
  now exfalso; apply H1; right.
} {
  apply rngl_summation_list_eq_compat.
  intros i Hi.
  destruct (ListDec.In_dec eqd i (a :: la)) as [H1| H1]. {
    destruct (ListDec.In_dec eqd i la) as [H| H]; [ easy | ].
    destruct H1 as [H1| H1]; [ clear H | easy ].
    subst i.
    rewrite Hlb in Hndb.
    apply NoDup_remove_2 in Hndb.
    exfalso; apply Hndb.
    now apply in_or_app; right.
  }
  destruct (ListDec.In_dec eqd i la) as [H2| H2]; [ | easy ].
  now exfalso; apply H1; right.
}
Qed.

Theorem App_list_length : ∀ A B l (f : A → list B),
  length (App (a ∈ l), f a) = ∑ (a ∈ l), length (f a).
Proof.
intros.
induction l as [| a]; [ easy | ].
rewrite App_list_cons, app_length.
rewrite rngl_summation_list_cons.
now rewrite IHl.
Qed.

Theorem List_flat_map_length : ∀ A B (f : A → list B) l,
  length (flat_map f l) = ∑ (a ∈ l), length (f a).
Proof.
intros.
induction l as [| a]; [ now rewrite iter_list_empty | cbn ].
rewrite app_length.
rewrite rngl_summation_list_cons.
now cbn; f_equal.
Qed.

Theorem list_prodn_length : ∀ A (ll : list (list A)),
  ll ≠ []
  → length (list_prodn ll) = ∏ (l ∈ ll), length l.
Proof.
intros * Hll.
revert Hll.
induction ll as [| l1]; intros; [ easy | clear Hll; cbn ].
rewrite rngl_product_list_cons.
rewrite List_flat_map_length.
erewrite iter_list_eq_compat. 2: {
  intros i Hi.
  now rewrite map_length.
}
cbn - [ rngl_zero rngl_add rngl_one rngl_mul ].
destruct ll as [| l2]. {
  rewrite rngl_product_list_empty; [ | easy ].
  rewrite rngl_mul_1_r.
  cbn - [ rngl_zero rngl_add ].
  induction l1 as [| a]; [ easy | ].
  rewrite rngl_summation_list_cons.
  now rewrite IHl1.
}
rewrite IHll; [ | easy ].
remember (∏ (i ∈ l2 :: ll), length i) as x eqn:Hx.
induction l1 as [| a]; [ easy | ].
rewrite rngl_summation_list_cons.
now rewrite IHl1.
Qed.

Theorem rngl_product_same_length : ∀ A (ll : list (list A)) n,
  (∀ l, l ∈ ll → length l = n)
  → ∏ (l ∈ ll), length l = n ^ length ll.
Proof.
intros * Hll.
induction ll as [| l]; [ now rewrite iter_list_empty | ].
rewrite rngl_product_list_cons; cbn.
rewrite Hll; [ f_equal | now left ].
apply IHll.
intros l1 Hl1.
now apply Hll; right.
Qed.

Theorem all_comb_length : ∀ n, n ≠ 0 → length (all_comb n) = n ^ n.
Proof.
intros * Hnz.
unfold all_comb.
rewrite list_prodn_length; [ | now destruct n ].
rewrite rngl_product_same_length with (n := n). 2: {
  intros l Hl.
  apply repeat_spec in Hl; subst l.
  apply seq_length.
}
f_equal; apply repeat_length.
Qed.

Fixpoint all_comb_inv n l :=
  match l with
  | [] => 0
  | a :: l' => pred a * n ^ length l' + all_comb_inv n l'
  end.

Fixpoint old_all_comb_inv_loop n l :=
  match l with
  | [] => 0
  | a :: l' => pred a + n * old_all_comb_inv_loop n l'
  end.

Definition old_all_comb_inv n l := old_all_comb_inv_loop n (rev l).

(*
Compute (
  let n := 3 in
  map (λ l, (all_comb_inv n l, old_all_comb_inv n l)) (all_comb n)
).
*)

Theorem in_list_prodn_repeat_iff : ∀ m n l,
  n = 0 ∧ l = [] ∨
  n ≠ 0 ∧ length l = n ∧ (∀ i : nat, i ∈ l → 1 ≤ i ≤ m)
  ↔ l ∈ list_prodn (repeat (seq 1 m) n).
Proof.
intros.
split. {
  intros [(Hnz, H1)| (Hnz & Hn & Hm)]; [ now subst n l; left | ].
  subst n.
  revert m Hm.
  induction l as [| a]; intros; [ easy | clear Hnz; cbn ].
  apply in_flat_map.
  exists a.
  split. {
    apply in_seq.
    specialize (Hm a (or_introl eq_refl)).
    split; [ easy | cbn ].
    now apply -> Nat.succ_le_mono.
  } {
    apply in_map_iff.
    exists l.
    split; [ easy | ].
    remember (repeat (seq 1 m) (length l)) as ll eqn:Hll; symmetry in Hll.
    destruct ll as [| l1]. {
      apply List_eq_repeat_nil in Hll.
      apply length_zero_iff_nil in Hll; subst l.
      now left.
    }
    cbn.
    destruct l as [| b]; [ easy | ].
    cbn in Hll.
    injection Hll; clear Hll; intros Hll H; subst l1.
    destruct m. {
      specialize (Hm _ (or_introl eq_refl)); flia Hm.
    }
    specialize (IHl (Nat.neq_succ_0 _)).
    specialize (IHl (S m)) as H1.
    assert (H : ∀ i, i ∈ b :: l → 1 ≤ i ≤ S m). {
      intros i Hi.
      now apply Hm; right.
    }
    specialize (H1 H); clear H.
    cbn - [ seq ] in H1.
    now rewrite Hll in H1.
  }
} {
  intros Hl.
  revert m l Hl.
  induction n; intros; [ now left; destruct Hl | right ].
  split; [ easy | ].
  cbn in Hl.
  apply in_flat_map in Hl.
  destruct Hl as (a & Ha & Hl).
  apply in_map_iff in Hl.
  destruct Hl as (l2 & Hl & Hl2); subst l.
  apply in_seq in Ha.
  apply IHn in Hl2.
  destruct Hl2 as [(Hnz, Hl2)| Hl2]. {
    subst n l2.
    split; [ easy | ].
    intros i Hi.
    destruct Hi as [Hi| Hi]; [ subst i | easy ].
    flia Ha.
  }
  destruct Hl2 as (Hnz & Hl2 & Hm).
  split; [ now cbn; f_equal | ].
  intros j Hj.
  destruct Hj as [Hj| Hj]; [ subst j | now apply Hm ].
  flia Ha.
}
Qed.

Theorem in_all_comb_iff : ∀ n l,
  n = 0 ∧ l = [] ∨
  n ≠ 0 ∧ length l = n ∧ (∀ i, i ∈ l → 1 ≤ i ≤ n)
  ↔ l ∈ all_comb n.
Proof.
intros.
now apply in_list_prodn_repeat_iff.
Qed.

Theorem NoDup_list_prodn_repeat : ∀ m n,
  NoDup (list_prodn (repeat (seq 1 m) n)).
Proof.
intros.
revert m.
induction n; intros. {
  constructor; [ easy | constructor ].
}
cbn.
specialize (IHn m) as H1.
remember (list_prodn (repeat (seq 1 m) n)) as ll eqn:Hll.
rewrite flat_map_concat_map.
apply NoDup_concat_if. {
  intros l Hl.
  apply in_map_iff in Hl.
  destruct Hl as (i & Hl & Hi); subst l.
  apply FinFun.Injective_map_NoDup; [ | easy ].
  intros j k Hjk.
  now injection Hjk.
}
intros i j Hij a Ha.
destruct (lt_dec i m) as [Him| Him]. 2: {
  apply Nat.nlt_ge in Him.
  rewrite nth_overflow in Ha; [ easy | now rewrite List_map_seq_length ].
}
rewrite (List_map_nth' 0) in Ha; [ | now rewrite seq_length ].
destruct (lt_dec j m) as [Hjm| Hjm]. 2: {
  apply Nat.nlt_ge in Hjm.
  rewrite nth_overflow; [ easy | now rewrite List_map_seq_length ].
}
rewrite (List_map_nth' 0); [ | now rewrite seq_length ].
intros Hb.
apply in_map_iff in Ha.
apply in_map_iff in Hb.
destruct Ha as (u & H & Ha); subst a.
destruct Hb as (v & H & Hb).
injection H; clear H; intros H Hji; subst v.
rewrite seq_nth in Hji; [ | easy ].
rewrite seq_nth in Hji; [ | easy ].
now apply Nat.succ_inj in Hji; symmetry in Hji.
Qed.

Theorem NoDup_all_comb : ∀ n, NoDup (all_comb n).
Proof.
intros n.
unfold all_comb.
apply NoDup_list_prodn_repeat.
Qed.

Theorem all_comb_inj : ∀ n i j,
  n ≠ 0
  → i < n ^ n
  → j < n ^ n
  → nth i (all_comb n) [] = nth j (all_comb n) []
  → i = j.
Proof.
intros * Hnz Hi Hj Hij.
apply (NoDup_nth (all_comb n) []); [ | | | easy ]. {
  apply NoDup_all_comb.
} {
  now rewrite all_comb_length.
} {
  now rewrite all_comb_length.
}
Qed.

(* det and det' are equal *)

Theorem det_is_det' :
  rngl_is_comm = true →
  rngl_has_opp = true →
  rngl_has_inv = true →
  rngl_has_1_neq_0 = true →
  ∀ (M : matrix T),
  is_square_matrix M = true
  → det M = det' M.
Proof.
intros Hic Hop Hin H10 * Hm.
unfold det'.
remember (mat_nrows M) as n eqn:Hr; symmetry in Hr.
unfold det.
rewrite Hr.
revert M Hm Hr.
induction n; intros. {
  cbn.
  rewrite rngl_summation_only_one.
  rewrite all_1_rngl_product_1; [ | intros * Hi; flia Hi ].
  unfold ε, iter_seq, iter_list; cbn.
  now do 3 rewrite rngl_mul_1_l.
}
rewrite determinant_succ.
destruct (Nat.eq_dec n 0) as [Hnz| Hnz]. {
  subst n; cbn.
  rewrite rngl_summation_only_one; cbn.
  rewrite rngl_summation_only_one; cbn.
  rewrite rngl_product_only_one; cbn.
  unfold ε; cbn.
  do 2 rewrite rngl_product_only_one; cbn.
  now rewrite rngl_mul_1_r.
}
erewrite rngl_summation_eq_compat. 2: {
  intros i Hi.
  rewrite IHn; cycle 1. {
    apply is_squ_mat_subm; [ rewrite Hr | rewrite Hr; flia Hi | easy ].
    split; [ easy | now apply -> Nat.succ_le_mono ].
  } {
    rewrite mat_nrows_subm, Hr; cbn.
    apply Nat.sub_0_r.
  }
  easy.
}
cbn - [ canon_sym_gr_list fact nth ].
clear IHn.
erewrite rngl_summation_eq_compat. 2: {
  intros i Hi.
  rewrite rngl_mul_summation_distr_l; [ | now left ].
  easy.
}
cbn - [ canon_sym_gr_list fact nth ].
rewrite (rngl_summation_shift 1); [ | flia ].
rewrite Nat.sub_diag, Nat_sub_succ_1.
rewrite rngl_summation_summation_distr.
rewrite <- Nat.sub_succ_l; [ | apply Nat.neq_0_lt_0, fact_neq_0 ].
rewrite Nat_sub_succ_1.
rewrite <- Nat_fact_succ.
apply rngl_summation_eq_compat.
intros k Hk.
(* elimination of "mat_el M 1 (1 + k / (n!)" *)
symmetry.
rewrite rngl_product_split_first; [ | flia ].
rewrite Nat.sub_diag.
rewrite Nat.add_1_r.
cbn - [ canon_sym_gr_list nth ].
remember (mat_el M 1 _) as x eqn:Hx.
rewrite rngl_mul_comm; [ | easy ].
symmetry.
rewrite <- rngl_mul_assoc.
rewrite rngl_mul_comm; [ | easy ].
do 3 rewrite <- rngl_mul_assoc.
f_equal.
(* elimination done *)
(* separation factors "∏" and "ε" *)
rewrite rngl_mul_comm; [ | easy ].
rewrite <- rngl_mul_assoc.
f_equal. {
  (* equality of the two "∏" *)
  rewrite (rngl_product_shift 1); [ | flia Hnz ].
  rewrite Nat.sub_diag.
  rewrite (rngl_product_shift 2 2); [ | flia Hnz ].
  rewrite Nat.sub_diag.
  rewrite Nat.sub_succ.
  apply rngl_product_eq_compat.
  intros i Hi.
  rewrite Nat.add_comm, Nat.add_sub.
  unfold mat_el.
  do 3 rewrite Nat.add_sub.
  replace (2 + i - 1) with (S i) by flia.
  cbn - [ subm fact ].
  rewrite (List_map_nth' 0). 2: {
    rewrite canon_sym_gr_list_length; flia Hi Hnz.
  }
  cbn - [ butn ].
  rewrite (List_map_nth' []). 2: {
    apply is_scm_mat_iff in Hm.
    destruct Hm as (Hcr & Hc).
    rewrite butn_length, fold_mat_nrows, Hr.
    cbn; flia Hi Hnz.
  }
  rewrite Nat.sub_0_r.
  unfold succ_when_ge, Nat.b2n.
  rewrite if_leb_le_dec.
  destruct (le_dec (k / n!) _) as [H1| H1]. {
    rewrite nth_butn_before; [ | easy ].
    rewrite nth_butn_before; [ | easy ].
    now rewrite (Nat.add_1_r i).
  } {
    apply Nat.nle_gt in H1.
    rewrite Nat.add_0_r.
    rewrite nth_butn_after; [ | easy ].
    rewrite nth_butn_before; [ | easy ].
    now rewrite Nat.add_1_r.
  }
  (* end proof equality of the two "∏" *)
}
(* equality of the two "ε" *)
symmetry.
rewrite minus_one_pow_succ; [ | easy ].
rewrite minus_one_pow_succ; [ | easy ].
rewrite rngl_opp_involutive; [ | easy ].
apply ε_of_sym_gr_permut_succ; try easy.
apply (le_lt_trans _ ((S n)! - 1)); [ easy | ].
apply Nat.sub_lt; [ | easy ].
apply Nat.le_succ_l, Nat.neq_0_lt_0, fact_neq_0.
Qed.

(* det' and det'' are equal *)

Theorem det'_is_det'' :
  rngl_has_opp = true →
  rngl_has_eqb = true →
  ∀ (M : matrix T), mat_nrows M ≠ 0 → det' M = det'' M.
Proof.
intros Hop Heq * Hnz.
unfold det''.
remember (mat_nrows M) as n eqn:Hn.
unfold det'.
rewrite <- Hn.
specialize (fact_neq_0 n) as Hfnz.
specialize (Nat.pow_nonzero n n Hnz) as Hpnz.
erewrite rngl_summation_change_var. 2: {
  intros i Hi.
  apply canon_sym_gr_list_inv_canon_sym_gr_list with (n := n).
  flia Hi Hfnz.
}
rewrite Nat.sub_0_r.
replace (λ i, canon_sym_gr_list n i) with (canon_sym_gr_list n) by easy.
rewrite <- Nat.sub_succ_l; [ | flia Hfnz ].
rewrite Nat.sub_succ, Nat.sub_0_r.
replace (map _ _) with (canon_sym_gr_list_list n) by easy.
erewrite rngl_summation_list_eq_compat. 2: {
  intros i Hi.
  rewrite canon_sym_gr_list_canon_sym_gr_list_inv. 2: {
    apply in_map_iff in Hi.
    destruct Hi as (j & Hji & Hj); subst i.
    apply in_seq in Hj.
    now apply canon_sym_gr_list_is_permut.
  }
  easy.
}
cbn.
assert (Hincl : canon_sym_gr_list_list n ⊂ map (map pred) (all_comb n)). {
  intros l Hl.
  apply in_map_iff in Hl.
  apply in_map_iff.
  destruct Hl as (i & Hil & Hi).
  subst l.
  apply in_seq in Hi; cbn in Hi; destruct Hi as (_, Hi).
  exists (map S (canon_sym_gr_list n i)).
  rewrite map_map.
  erewrite map_ext_in. 2: {
    intros j Hj.
    now rewrite Nat.pred_succ.
  }
  rewrite map_id.
  split; [ easy | ].
  apply in_all_comb_iff.
  right.
  split; [ easy | ].
  split; [ now rewrite map_length, canon_sym_gr_list_length | ].
  intros j Hj.
  apply in_map_iff in Hj.
  destruct Hj as (k & Hkj & Hk).
  subst j.
  split; [ flia | ].
  apply Nat.le_succ_l.
  apply (In_nth _ _ 0) in Hk.
  destruct Hk as (j & Hj & Hjk).
  rewrite canon_sym_gr_list_length in Hj; subst k.
  now apply canon_sym_gr_list_ub.
}
symmetry.
replace (all_comb n) with (map (λ l, map S (map pred l)) (all_comb n)). 2: {
  erewrite map_ext_in. 2: {
    intros l Hl.
    rewrite map_map.
    apply in_all_comb_iff in Hl.
    destruct Hl as [Hl| Hl]; [ now exfalso | ].
    destruct Hl as (_ & _ & Hl).
    erewrite map_ext_in. 2: {
      intros i Hi.
      specialize (Hl i Hi).
      rewrite Nat.succ_pred_pos; [ | flia Hl ].
      easy.
    }
    now rewrite map_id.
  }
  apply map_id.
}
rewrite <- map_map.
rewrite rngl_summation_list_map.
assert (H1 :
  ∑ (l ∈ map (map pred) (all_comb n)),
  ε l * ∏ (j = 1, n), mat_el M j (l.(j) + 1) =
  ∑ (l ∈ map (map pred) (all_comb n)),
  if ListDec.In_dec (list_eq_dec Nat.eq_dec) l (canon_sym_gr_list_list n) then
    ε l * ∏ (j = 1, n), mat_el M j (l.(j) + 1)
  else 0). {
  apply rngl_summation_list_eq_compat.
  intros l Hl.
  destruct (ListDec.In_dec (list_eq_dec Nat.eq_dec)) as [H1| H1]; [ easy | ].
  assert (H : ε l = 0%F). {
    apply ε_when_dup; [ easy | easy | ].
    intros Hnd.
    apply H1; clear H1.
    apply in_map_iff.
    apply in_map_iff in Hl.
    destruct Hl as (l1 & H & Hl); subst l; rename l1 into l.
    apply in_all_comb_iff in Hl.
    destruct Hl as [Hl| Hl]; [ easy | ].
    destruct Hl as (_ & Hln & Hin).
    exists (canon_sym_gr_list_inv n (map pred l)).
    assert (Hp : is_permut n (map pred l)). {
      unfold is_permut.
      split; [ split | ]; [ | easy | now rewrite map_length ].
      intros j Hj.
      rewrite map_length, Hln.
      apply in_map_iff in Hj.
      destruct Hj as (a & Hj & Ha); subst j.
      specialize (Hin _ Ha).
      flia Hin.
    }
    split; [ now apply canon_sym_gr_list_canon_sym_gr_list_inv | ].
    apply in_seq.
    split; [ easy | ].
    rewrite Nat.add_0_l.
    now apply canon_sym_gr_list_inv_ub.
  }
  rewrite H.
  now apply rngl_mul_0_l; left.
}
erewrite rngl_summation_list_eq_compat. 2: {
  intros l Hl.
  rewrite ε_map_S.
  erewrite rngl_product_eq_compat. 2: {
    intros i Hi.
    unfold ff_app.
    rewrite (List_map_nth' 0). 2: {
      apply in_map_iff in Hl.
      destruct Hl as (l1 & H & Hl); subst l.
      rename l1 into l.
      rewrite map_length.
      apply in_all_comb_iff in Hl.
      destruct Hl as [Hl| Hl]; [ easy | ].
      destruct Hl as (_ & Hln & Hin).
      rewrite Hln; flia Hi.
    }
    rewrite <- Nat.add_1_r.
    easy.
  }
  easy.
}
cbn.
rewrite H1.
symmetry.
apply rngl_summation_list_incl; [ | | easy ]. {
  unfold canon_sym_gr_list_list.
  apply (NoDup_map_iff 0).
  rewrite seq_length.
  intros * Hi Hj Hij.
  rewrite seq_nth in Hij; [ | easy ].
  rewrite seq_nth in Hij; [ | easy ].
  cbn in Hij.
  now apply (canon_sym_gr_list_inj n).
} {
  apply NoDup_map_inv with (f := map S).
  rewrite map_map.
  erewrite map_ext_in. 2: {
    intros l Hl.
    rewrite map_map.
    erewrite map_ext_in. 2: {
      intros i Hi.
      apply in_all_comb_iff in Hl.
      destruct Hl as [Hl| Hl]; [ now exfalso | ].
      destruct Hl as (_ & _ & Hl).
      specialize (Hl i Hi).
      rewrite Nat.succ_pred_pos; [ | flia Hl ].
      easy.
    }
    now rewrite map_id.
  }
  rewrite map_id.
  apply NoDup_all_comb.
}
Qed.

(* multilinearity *)

Theorem determinant_multilinear :
  rngl_is_comm = true →
  rngl_has_opp = true →
  rngl_has_inv = true →
  rngl_has_1_neq_0 = true →
  ∀ n (M : matrix T) i a b U V,
  is_square_matrix M = true
  → mat_nrows M = n
  → vect_size U = n
  → vect_size V = n
  → 1 ≤ i ≤ n
  → det (mat_repl_vect' i M (a × U + b × V)%V) =
       (a * det (mat_repl_vect' i M U) +
        b * det (mat_repl_vect' i M V))%F.
Proof.
intros Hic Hop Hin H10 * Hsm Hr Hu Hv Hi.
specialize (square_matrix_ncols _ Hsm) as Hcn.
(* using the snd version of determinants: determinant' *)
rewrite det_is_det'; try easy. 2: {
  apply mat_repl_vect_is_square; [ congruence | cbn | easy ].
  rewrite map2_length.
  do 2 rewrite map_length, fold_vect_size.
  rewrite Hu, Hv.
  now rewrite Nat.min_id.
}
rewrite det_is_det'; try easy. 2: {
  apply mat_repl_vect_is_square; [ congruence | congruence | easy ].
}
rewrite det_is_det'; try easy. 2: {
  apply mat_repl_vect_is_square; [ congruence | congruence | easy ].
}
unfold det'.
(* simplification of the lhs *)
remember (a × U + b × V)%V as UV eqn:HUV.
assert (Hvm : vect_size UV = mat_nrows M). {
  rewrite Hr, HUV; cbn.
  rewrite map2_length.
  do 2 rewrite map_length.
  do 2 rewrite fold_vect_size.
  rewrite Hu, Hv.
  apply Nat.min_id.
}
rewrite mat_repl_vect_nrows; [ | easy ].
rewrite mat_repl_vect_nrows; [ | congruence ].
rewrite mat_repl_vect_nrows; [ | congruence ].
rewrite Hr.
erewrite rngl_summation_eq_compat. 2: {
  intros k Hk.
  assert (Hkn : k < n!). {
    eapply le_lt_trans; [ apply Hk | ].
    apply Nat.sub_lt; [ | flia ].
    apply Nat.neq_0_lt_0, fact_neq_0.
  }
  erewrite rngl_product_eq_compat. 2: {
    intros j Hj.
    rewrite mat_el_repl_vect; cycle 1. {
      now apply squ_mat_is_corr.
    } {
      subst UV; cbn.
      rewrite map2_length.
      do 2 rewrite map_length.
      do 2 rewrite fold_vect_size.
      rewrite Hu, Hv, Nat.min_id.
      flia Hj.
    } {
      rewrite Hr; flia Hj.
    } {
      rewrite Hcn, Hr.
      rewrite Nat.add_1_r.
      split; [ flia | ].
      apply canon_sym_gr_list_ub; [ easy | flia Hj ].
    } {
      now rewrite Hcn, Hr.
    }
    unfold vect_el', ff_app.
    cbn - [ Nat.eq_dec ].
    easy.
  }
  easy.
}
cbn - [ mat_el ].
(* put a and b inside the sigma in the rhs *)
rewrite rngl_mul_summation_distr_l; [ | now left ].
rewrite rngl_mul_summation_distr_l; [ | now left ].
symmetry.
erewrite rngl_summation_eq_compat. 2: {
  intros k Hk.
  assert (Hkn : k < fact n). {
    specialize (fact_neq_0 n) as Hnz.
    flia Hk Hnz.
  }
  rewrite rngl_mul_assoc.
  rewrite (rngl_mul_comm Hic a).
  erewrite rngl_product_eq_compat. 2: {
    intros j Hj.
    rewrite mat_el_repl_vect; cycle 1. {
      now apply squ_mat_is_corr.
    } {
      rewrite Hu; flia Hj.
    } {
      rewrite Hr; flia Hj.
    } {
      cbn.
      rewrite Hcn, Hr, Nat.add_1_r.
      split; [ flia | ].
      apply canon_sym_gr_list_ub; [ easy | flia Hj ].
    } {
      now rewrite Hcn, Hr.
    }
    now unfold vect_el'; cbn.
  }
  easy.
}
rewrite rngl_add_comm.
erewrite rngl_summation_eq_compat. 2: {
  intros k Hk.
  assert (Hkn : k < fact n). {
    specialize (fact_neq_0 n) as Hnz.
    flia Hk Hnz.
  }
  rewrite rngl_mul_assoc.
  rewrite (rngl_mul_comm Hic b).
  erewrite rngl_product_eq_compat. 2: {
    intros j Hj.
    rewrite mat_el_repl_vect; cycle 1. {
      now apply squ_mat_is_corr.
    } {
      rewrite Hv; flia Hj.
    } {
      rewrite Hr; flia Hj.
    } {
      rewrite Hcn, Hr, Nat.add_1_r.
      split; [ flia | ].
      apply canon_sym_gr_list_ub; [ easy | flia Hj ].
    } {
      now rewrite Hcn, Hr.
    }
    now unfold vect_el'; cbn.
  }
  easy.
}
rewrite rngl_add_comm.
(* make one summation *)
rewrite <- rngl_summation_add_distr.
apply rngl_summation_eq_compat.
intros k Hk.
do 2 rewrite <- rngl_mul_assoc.
rewrite <- rngl_mul_add_distr_l.
(* elimination of the ε-s *)
f_equal.
(* *)
assert (Hkn : k < fact n). {
  specialize (fact_neq_0 n) as Hnz.
  flia Hk Hnz.
}
assert (H : i - 1 < n) by flia Hi.
specialize (canon_sym_gr_surjective Hkn H) as Hp; clear H.
destruct Hp as (p & Hp & Hpp).
rewrite (rngl_product_split (p + 1)); [ | flia Hp ].
rewrite rngl_product_split_last; [ | flia ].
erewrite rngl_product_eq_compat. 2: {
  intros j Hj.
  replace (j - 1 - 1) with (j - 2) by flia.
  destruct (Nat.eq_dec (nth (j - 2) (canon_sym_gr_list n k) 0 + 1) i)
    as [Hpj| Hpj]. {
    exfalso.
    rewrite <- Hpj in Hpp.
    rewrite Nat.add_sub in Hpp.
    symmetry in Hpp.
    apply nth_canon_sym_gr_list_inj1 in Hpp; [ | easy | flia Hp Hj | easy ].
    flia Hj Hpp.
  }
  easy.
}
rewrite (rngl_mul_comm Hic (iter_seq _ _ _ _)).
rewrite rngl_add_comm.
rewrite (rngl_product_split (p + 1)); [ | flia Hp ].
rewrite rngl_product_split_last; [ | flia ].
erewrite rngl_product_eq_compat. 2: {
  intros j Hj.
  replace (j - 1 - 1) with (j - 2) by flia.
  destruct (Nat.eq_dec (nth (j - 2) (canon_sym_gr_list n k) 0 + 1) i)
    as [Hpj| Hpj]. {
    exfalso.
    rewrite <- Hpj, Nat.add_sub in Hpp.
    symmetry in Hpp.
    apply nth_canon_sym_gr_list_inj1 in Hpp; [ | easy | flia Hp Hj | easy ].
    flia Hj Hpp.
  }
  easy.
}
rewrite (rngl_mul_comm Hic (iter_seq _ _ _ _)).
rewrite rngl_add_comm.
symmetry.
rewrite (rngl_product_split (p + 1)); [ | flia Hp ].
rewrite rngl_product_split_last; [ | flia ].
erewrite rngl_product_eq_compat. 2: {
  intros j Hj.
  replace (j - 1 - 1) with (j - 2) by flia.
  destruct (Nat.eq_dec (nth (j - 2) (canon_sym_gr_list n k) 0 + 1) i)
    as [Hpj| Hpj]. {
    exfalso.
    rewrite <- Hpj, Nat.add_sub in Hpp.
    symmetry in Hpp.
    apply nth_canon_sym_gr_list_inj1 in Hpp; [ | easy | flia Hp Hj | easy ].
    flia Hj Hpp.
  }
  easy.
}
rewrite (rngl_mul_comm Hic (iter_seq _ _ _ _)).
rewrite Nat.add_sub.
unfold ff_app in Hpp.
rewrite Hpp.
destruct (Nat.eq_dec i i) as [H| H]; [ clear H | easy ].
do 4 rewrite rngl_mul_assoc.
subst UV.
cbn - [ mat_el ].
rewrite map2_nth with (a := 0%F) (b := 0%F); cycle 1. {
  now rewrite map_length, fold_vect_size, Hu.
} {
  now rewrite map_length, fold_vect_size, Hv.
}
rewrite (List_map_nth' 0%F); [ | now rewrite fold_vect_size, Hu ].
rewrite (List_map_nth' 0%F); [ | now rewrite fold_vect_size, Hv ].
do 2 rewrite fold_vect_el.
rewrite Nat.sub_add; [ | flia Hi ].
rewrite <- if_eqb_eq_dec, Nat.eqb_refl.
rewrite <- if_eqb_eq_dec, Nat.eqb_refl.
rewrite <- if_eqb_eq_dec, Nat.eqb_refl.
(* elimination of the following term (q) *)
remember
  (∏ (i0 = 2, p + 1),
   mat_el M (i0 - 1) (nth (i0 - 2) (canon_sym_gr_list n k) O + 1))
  as q eqn:Hq.
rewrite (rngl_mul_mul_swap Hic _ _ q).
do 3 rewrite (rngl_mul_comm Hic _ q).
do 5 rewrite <- rngl_mul_assoc.
rewrite <- rngl_mul_add_distr_l.
f_equal.
clear q Hq.
erewrite rngl_product_eq_compat. 2: {
  intros j Hj.
  destruct (Nat.eq_dec (nth (j - 1) (canon_sym_gr_list n k) 0 + 1) i)
    as [Hpj| Hpj]. {
    rewrite <- Hpj, Nat.add_sub in Hpp.
    symmetry in Hpp.
    apply nth_canon_sym_gr_list_inj1 in Hpp; [ | easy | flia Hp Hj | easy ].
    flia Hj Hpp.
  }
  easy.
}
symmetry.
erewrite rngl_product_eq_compat. 2: {
  intros j Hj.
  destruct (Nat.eq_dec (nth (j - 1) (canon_sym_gr_list n k) 0 + 1) i)
    as [Hpj| Hpj]. {
    rewrite <- Hpj, Nat.add_sub in Hpp.
    symmetry in Hpp.
    apply nth_canon_sym_gr_list_inj1 in Hpp; [ | easy | flia Hp Hj | easy ].
    flia Hj Hpp.
  }
  easy.
}
rewrite rngl_add_comm.
erewrite rngl_product_eq_compat. 2: {
  intros j Hj.
  destruct (Nat.eq_dec (nth (j - 1) (canon_sym_gr_list n k) 0 + 1) i)
    as [Hpj| Hpj]. {
    rewrite <- Hpj, Nat.add_sub in Hpp.
    symmetry in Hpp.
    apply nth_canon_sym_gr_list_inj1 in Hpp; [ | easy | flia Hp Hj | easy ].
    flia Hj Hpp.
  }
  easy.
}
cbn.
rewrite rngl_add_comm.
do 2 rewrite rngl_mul_assoc.
now rewrite <- rngl_mul_add_distr_r.
Qed.

Definition mat_swap_rows i1 i2 (M : matrix T) :=
  mk_mat (list_swap_elem [] (mat_list_list M) (i1 - 1) (i2 - 1)).

Theorem mat_swap_rows_is_square : ∀ (M : matrix T) p q,
  1 ≤ p ≤ mat_nrows M
  → 1 ≤ q ≤ mat_nrows M
  → is_square_matrix M = true
  → is_square_matrix (mat_swap_rows p q M) = true.
Proof.
intros * Hp Hq Hsm.
remember (mat_nrows M) as n eqn:Hr.
symmetry in Hr.
specialize (square_matrix_ncols _ Hsm) as Hcn.
specialize (squ_mat_is_corr M Hsm) as Hco.
apply is_scm_mat_iff in Hsm.
apply is_scm_mat_iff.
destruct Hsm as (Hcr & Hc).
cbn; unfold list_swap_elem.
rewrite List_map_seq_length.
unfold mat_swap_rows, list_swap_elem; cbn.
split. {
  unfold mat_ncols; cbn.
  rewrite fold_mat_nrows; rewrite Hr.
  rewrite (List_map_hd 0); [ | rewrite seq_length; flia Hp ].
  rewrite List_seq_hd; [ | flia Hp ].
  rewrite Hc; [ now intros Hn; subst n | ].
  apply nth_In; rewrite fold_mat_nrows; rewrite Hr.
  unfold transposition.
  do 2 rewrite if_eqb_eq_dec.
  destruct (Nat.eq_dec 0 (p - 1)); [ flia Hq | ].
  destruct (Nat.eq_dec 0 (q - 1)); [ flia Hp | ].
  flia Hp.
} {
  intros la Hla.
  apply in_map_iff in Hla.
  rewrite fold_mat_nrows, Hr in Hla.
  destruct Hla as (a & Ha & Hla).
  apply in_seq in Hla; subst la.
  rewrite fold_corr_mat_ncols; [ easy | easy | rewrite Hr ].
  unfold transposition.
  do 2 rewrite if_eqb_eq_dec.
  destruct (Nat.eq_dec a (p - 1)); [ flia Hq | ].
  destruct (Nat.eq_dec a (q - 1)); [ flia Hp | ].
  easy.
}
Qed.

Theorem mat_swap_rows_nrows : ∀ (M : matrix T) p q,
  mat_nrows (mat_swap_rows p q M) = mat_nrows M.
Proof.
intros.
unfold mat_swap_rows; cbn.
unfold list_swap_elem.
rewrite map_length.
now rewrite seq_length.
Qed.

Theorem mat_swap_rows_ncols : ∀ (M : matrix T),
  is_correct_matrix M = true
  → ∀ p q, 1 ≤ p ≤ mat_nrows M → 1 ≤ q ≤ mat_nrows M →
  mat_ncols (mat_swap_rows p q M) = mat_ncols M.
Proof.
intros * Hcm * Hp Hq.
generalize Hcm; intros H.
apply is_scm_mat_iff in H.
destruct H as (Hcr, Hc).
destruct (Nat.eq_dec (mat_nrows M) 0) as [Hrz| Hrz]. {
  destruct M as (ll); cbn in Hrz.
  now apply length_zero_iff_nil in Hrz; subst ll.
}
apply Nat.neq_0_lt_0 in Hrz.
unfold mat_swap_rows; cbn.
unfold list_swap_elem.
unfold mat_ncols; cbn.
do 2 rewrite List_hd_nth_0.
rewrite fold_corr_mat_ncols; [ | easy | easy ].
destruct M as (ll); cbn.
destruct ll as [| la]; [ easy | cbn ].
unfold transposition.
do 2 rewrite if_eqb_eq_dec.
destruct (Nat.eq_dec 0 (p - 1)) as [Hpz| Hpz]. {
  destruct q; [ easy | ].
  destruct q; [ easy | ].
  rewrite Nat_sub_succ_1.
  cbn - [ In ] in Hcr, Hc, Hq.
  apply Hc; right.
  apply nth_In; flia Hq.
}
destruct (Nat.eq_dec 0 (q - 1)) as [Hqz| Hqz]. {
  destruct p; [ easy | ].
  destruct p; [ easy | ].
  rewrite Nat_sub_succ_1.
  cbn - [ In ] in Hcr, Hc, Hp.
  apply Hc; right.
  apply nth_In; flia Hp.
}
easy.
Qed.

Theorem nth_transposition_canon_sym_gr_list_inj : ∀ n k p q i j,
  k < n!
  → p < n
  → q < n
  → i < n
  → j < n
  → nth (transposition p q i) (canon_sym_gr_list n k) 0 =
    nth (transposition p q j) (canon_sym_gr_list n k) 0
  → i = j.
Proof.
intros * Hkn Hpn Hqn Hin Hjn Hij.
unfold transposition in Hij.
do 4 rewrite if_eqb_eq_dec in Hij.
destruct (Nat.eq_dec i p) as [Hip| Hip]. {
  destruct (Nat.eq_dec j p) as [Hjp| Hjp]; [ congruence | ].
  destruct (Nat.eq_dec j q) as [Hjq| Hjq]. {
    apply nth_canon_sym_gr_list_inj1 in Hij; [ | easy | easy | easy ].
    congruence.
  }
  apply Nat.neq_sym in Hjq.
  now apply nth_canon_sym_gr_list_inj1 in Hij.
}
destruct (Nat.eq_dec i q) as [Hiq| Hiq]. {
  destruct (Nat.eq_dec j p) as [Hjp| Hjp]. {
    apply nth_canon_sym_gr_list_inj1 in Hij; [ | easy | easy | easy ].
    congruence.
  }
  destruct (Nat.eq_dec j q) as [Hjq| Hjq]; [ congruence | ].
  apply Nat.neq_sym in Hjp.
  now apply nth_canon_sym_gr_list_inj1 in Hij.
}
destruct (Nat.eq_dec j p) as [Hjp| Hjp]. {
  now apply nth_canon_sym_gr_list_inj1 in Hij.
}
destruct (Nat.eq_dec j q) as [Hjq| Hjq]. {
  now apply nth_canon_sym_gr_list_inj1 in Hij.
}
now apply nth_canon_sym_gr_list_inj1 in Hij.
Qed.

Theorem determinant_alternating : in_charac_0_field →
  ∀ (M : matrix T) p q,
  p ≠ q
  → 1 ≤ p ≤ mat_nrows M
  → 1 ≤ q ≤ mat_nrows M
  → is_square_matrix M = true
  → det (mat_swap_rows p q M) = (- det M)%F.
Proof.
intros Hif * Hpq Hp Hq Hsm.
remember (mat_nrows M) as n eqn:Hr; symmetry in Hr.
rewrite det_is_det'; try now destruct Hif. 2: {
  rewrite <- Hr in Hp, Hq.
  now apply mat_swap_rows_is_square.
}
unfold det'.
rewrite mat_swap_rows_nrows.
rewrite Hr.
erewrite rngl_summation_eq_compat. 2: {
  intros k Hk.
  rewrite (rngl_product_shift 1); [ | flia Hp ].
  rewrite Nat.sub_diag.
  erewrite rngl_product_eq_compat. 2: {
    intros i Hi.
    now rewrite Nat.add_comm, Nat.add_sub.
  }
  easy.
}
cbn - [ mat_swap_rows ].
erewrite rngl_summation_eq_compat. 2: {
  intros k Hk.
  rewrite rngl_product_change_var with
    (g := transposition (p - 1) (q - 1)) (h := transposition (p - 1) (q - 1)).
  2: {
    intros i Hi.
    apply transposition_involutive.
  }
  rewrite Nat.sub_0_r.
  rewrite <- Nat.sub_succ_l; [ | flia Hp ].
  rewrite Nat_sub_succ_1.
  easy.
}
cbn - [ mat_swap_rows ].
assert (Hp' : p - 1 < n) by flia Hp.
assert (Hq' : q - 1 < n) by flia Hq.
erewrite rngl_summation_eq_compat. 2: {
  intros k Hk.
  destruct Hif as (Hic & Hop & Hin & H10 & Hit & Hde & Hch) in Hsm.
  rewrite (rngl_product_list_permut _ Nat.eqb_eq) with
      (lb := seq 0 n); [ | easy | ]. 2: {
    remember (map _ _) as la eqn:Hla.
    replace n with (length la) by now rewrite Hla, List_map_seq_length.
    apply permut_list_permutation_iff.
    subst la.
    now apply transposition_is_permut.
  }
  easy.
}
cbn - [ mat_swap_rows ].
erewrite rngl_summation_eq_compat. 2: {
  intros k Hk.
  assert (Hkn : k < n!). {
    specialize (fact_neq_0 n) as Hn.
    flia Hk Hn.
  }
  erewrite rngl_product_list_eq_compat. 2: {
    intros i Hi.
    replace (mat_el _ _ _) with
      (mat_el M (i + 1)
         (ff_app (canon_sym_gr_list n k) (transposition (p - 1) (q - 1) i) + 1)).
    2: {
      unfold ff_app; cbn.
      unfold mat_el; f_equal.
      unfold list_swap_elem.
      do 2 rewrite Nat.add_sub.
      rewrite (List_map_nth' 0). 2: {
        rewrite seq_length.
        rewrite fold_mat_nrows, Hr.
        apply in_seq in Hi.
        now apply transposition_lt.
      }
      rewrite fold_mat_nrows, Hr.
      unfold transposition.
      do 2 rewrite if_eqb_eq_dec.
      destruct (Nat.eq_dec i (p - 1)) as [Hip| Hip]. {
        subst i.
        rewrite seq_nth; [ | easy ].
        rewrite Nat.add_0_l.
        rewrite Nat.eqb_refl.
        apply Nat.neq_sym in Hpq.
        destruct (Nat.eq_dec (q - 1) (p - 1)) as [H| H]; [ | easy ].
        now rewrite H.
      }
      rewrite if_eqb_eq_dec.
      destruct (Nat.eq_dec i (q - 1)) as [Hiq| Hiq]. {
        subst i.
        rewrite seq_nth; [ | easy ].
        rewrite Nat.add_0_l.
        rewrite <- if_eqb_eq_dec.
        now rewrite Nat.eqb_refl.
      }
      apply in_seq in Hi.
      rewrite seq_nth; [ | easy ].
      rewrite Nat.add_0_l.
      rewrite if_eqb_eq_dec.
      destruct (Nat.eq_dec i (p - 1)) as [H| H]; [ easy | clear H ].
      now destruct (Nat.eq_dec i (q - 1)).
    }
    easy.
  }
  easy.
}
cbn.
set (f := λ k, list_swap_elem 0 (canon_sym_gr_list n k) (p - 1) (q - 1)).
erewrite rngl_summation_eq_compat. 2: {
  intros k Hk.
  erewrite rngl_product_list_eq_compat. 2: {
    intros i Hi.
    apply in_seq in Hi.
    replace (ff_app _ _) with
       (ff_app (list_swap_elem 0 (canon_sym_gr_list n k) (p - 1) (q - 1)) i).
    2: {
(* lemme à faire *)
      unfold list_swap_elem.
      unfold ff_app.
      rewrite (List_map_nth' 0). 2: {
        now rewrite seq_length, canon_sym_gr_list_length.
      }
      rewrite seq_nth; [ easy | now rewrite canon_sym_gr_list_length ].
    }
    fold (f k).
    easy.
  }
  easy.
}
cbn.
erewrite rngl_summation_eq_compat. 2: {
  intros k Hk.
  assert (Hkn : k < n!). {
    specialize (fact_neq_0 n) as Hn.
    flia Hk Hn.
  }
  erewrite rngl_product_seq_product; [ | flia Hp ].
  rewrite Nat.add_0_l.
  replace (canon_sym_gr_list n k) with
     (map (λ i, ff_app (f k) (transposition (p - 1) (q - 1) i)) (seq 0 n)).
  2: {
    rewrite List_map_nth_seq with (d := 0).
    rewrite canon_sym_gr_list_length.
    apply map_ext_in.
    intros i Hi; cbn.
    apply in_seq in Hi.
    unfold ff_app, f, list_swap_elem.
    rewrite (List_map_nth' 0). 2: {
      rewrite seq_length, canon_sym_gr_list_length.
      now apply transposition_lt.
    }
    rewrite seq_nth. 2: {
      rewrite canon_sym_gr_list_length.
      now apply transposition_lt.
    }
    rewrite Nat.add_0_l.
    now rewrite transposition_involutive.
  }
  replace (map (λ i, ff_app (f k) (transposition (p - 1) (q - 1) i)) (seq 0 n))
  with (f k ° map (λ i, transposition (p - 1) (q - 1) i) (seq 0 n)). 2: {
    unfold "°"; cbn.
    now rewrite map_map.
  }
  rewrite sign_comp; [ | easy | ]. 2: {
    split. 2: {
      rewrite List_map_seq_length.
      unfold f.
      rewrite list_swap_elem_length.
      symmetry.
      apply canon_sym_gr_list_length.
    }
    split. {
      intros i Hi.
      rewrite List_map_seq_length.
      apply In_nth with (d := 0) in Hi.
      rewrite List_map_seq_length in Hi.
      destruct Hi as (j & Hj & Hji).
      rewrite (List_map_nth' 0) in Hji; [ | now rewrite seq_length ].
      rewrite seq_nth in Hji; [ | easy ].
      rewrite <- Hji.
      now apply transposition_lt.
    }
    apply (NoDup_map_iff 0).
    rewrite seq_length.
    intros i j Hi Hj Hij.
    rewrite seq_nth in Hij; [ | easy ].
    rewrite seq_nth in Hij; [ | easy ].
    cbn in Hij.
    unfold transposition in Hij.
    do 4 rewrite if_eqb_eq_dec in Hij.
    destruct (Nat.eq_dec i (p - 1)) as [Hip| Hip]. {
      subst i.
      destruct (Nat.eq_dec j (p - 1)) as [Hjp| Hjp]; [ easy | ].
      symmetry in Hij.
      destruct (Nat.eq_dec j (q - 1)); [ | easy ].
      congruence.
    }
    destruct (Nat.eq_dec i (q - 1)) as [Hiq| Hiq]. {
      subst i.
      symmetry in Hij.
      destruct (Nat.eq_dec j (p - 1)) as [Hjp| Hjp]; [ easy | ].
      now destruct (Nat.eq_dec j (q - 1)).
    }
    destruct (Nat.eq_dec j (p - 1)) as [Hjp| Hjp]; [ easy | ].
    now destruct (Nat.eq_dec j (q - 1)).
  }
  easy.
}
cbn.
erewrite rngl_summation_eq_compat. 2: {
  intros k (_, Hk).
  destruct Hif as (Hic & Hop & Hin & H10 & Hit & Hde & Hch) in Hsm.
  rewrite (rngl_mul_comm Hic (ε (f k))).
  rewrite <- rngl_mul_assoc.
  rewrite transposition_signature; try easy.
  flia Hp Hq Hpq.
}
cbn - [ f ].
rewrite <- rngl_mul_summation_distr_l; [ | now destruct Hif; left ].
rewrite rngl_mul_opp_l; [ | now destruct Hif ].
f_equal.
rewrite rngl_mul_1_l.
symmetry.
set (g := λ k, canon_sym_gr_list_inv n (f k)).
rewrite rngl_summation_change_var with (g0 := g) (h := g). 2: {
  intros k (_, Hk).
  assert (Hkn : k < n!). {
    specialize (fact_neq_0 n) as Hn.
    flia Hk Hn.
  }
  unfold g, f.
  unfold list_swap_elem.
  do 2 rewrite canon_sym_gr_list_length.
  erewrite map_ext_in. 2: {
    intros i Hi; apply in_seq in Hi.
    rewrite canon_sym_gr_list_canon_sym_gr_list_inv. 2: {
(* lemme à faire ? *)
      split; [ | now rewrite map_length, seq_length ].
      split. {
        intros j Hj.
        rewrite map_length, seq_length.
        apply in_map_iff in Hj.
        destruct Hj as (m & Hmj & Hm).
        apply in_seq in Hm.
        rewrite <- Hmj.
        apply canon_sym_gr_list_ub; [ easy | ].
        apply transposition_lt; [ flia Hp | flia Hq | easy ].
      } {
        apply (NoDup_map_iff 0).
        rewrite seq_length.
        intros u v Hu Hv Huv.
        rewrite seq_nth in Huv; [ | easy ].
        rewrite seq_nth in Huv; [ | easy ].
        cbn in Huv.
        now apply nth_transposition_canon_sym_gr_list_inj in Huv.
      }
    }
    rewrite (List_map_nth' 0). 2: {
      rewrite seq_length.
      now apply transposition_lt.
    }
    rewrite seq_nth. 2: {
      now apply transposition_lt.
    }
    rewrite Nat.add_0_l.
    rewrite transposition_involutive.
    easy.
  }
  rewrite <- List_map_nth_seq'; [ | now rewrite canon_sym_gr_list_length ].
  now apply canon_sym_gr_list_inv_canon_sym_gr_list.
}
rewrite Nat.sub_0_r.
rewrite <- Nat.sub_succ_l; [ | apply Nat.neq_0_lt_0, fact_neq_0 ].
rewrite Nat_sub_succ_1.
rewrite (rngl_summation_list_permut _ Nat.eqb_eq) with (lb := seq 0 n!);
    cycle 1. {
  remember (map _ _) as la eqn:Hla.
  replace n! with (length la) by now rewrite Hla, List_map_seq_length.
  apply permut_list_permutation_iff.
  subst la.
(* lemma to do? *)
  unfold g, f.
  split. {
    intros i Hi.
    rewrite map_length, seq_length.
    apply in_map_iff in Hi.
    destruct Hi as (j & Hji & Hj).
    apply in_seq in Hj.
    rewrite <- Hji.
    apply canon_sym_gr_list_inv_ub.
    apply list_swap_elem_is_permut; [ easy | easy | ].
    now apply canon_sym_gr_list_is_permut.
  } {
    apply (NoDup_map_iff 0).
    rewrite seq_length.
    intros i j Hi Hj Hij.
    rewrite seq_nth in Hij; [ | easy ].
    rewrite seq_nth in Hij; [ | easy ].
    do 2 rewrite Nat.add_0_l in Hij.
    apply rank_of_permut_in_canon_gr_list_inj in Hij; cycle 1. {
      apply list_swap_elem_is_permut; [ easy | easy | ].
      now apply canon_sym_gr_list_is_permut.
    } {
      apply list_swap_elem_is_permut; [ easy | easy | ].
      now apply canon_sym_gr_list_is_permut.
    }
(* lemme à faire ? *)
    unfold list_swap_elem in Hij.
    do 2 rewrite canon_sym_gr_list_length in Hij.
    apply nth_canon_sym_gr_list_inj2 with (n := n); [ easy | easy | ].
    intros k Hkn.
    apply ext_in_map with (a := transposition (p - 1) (q - 1) k) in Hij. 2: {
      apply in_seq.
      split; [ flia | ].
      now apply transposition_lt.
    }
    now rewrite transposition_involutive in Hij.
  }
}
rewrite det_is_det'; try now destruct Hif.
unfold det'.
rewrite rngl_summation_seq_summation; [ | apply fact_neq_0 ].
rewrite Nat.add_0_l.
rewrite Hr.
apply rngl_summation_eq_compat.
intros k Hk.
assert (Hkn : k < n!). {
  specialize (fact_neq_0 n) as Hn.
  flia Hk Hn.
}
assert (Hc : canon_sym_gr_list n k = f (g k)). {
  unfold g, f.
  rewrite canon_sym_gr_list_canon_sym_gr_list_inv. 2: {
    apply list_swap_elem_is_permut; [ easy | easy | ].
    now apply canon_sym_gr_list_is_permut.
  }
  rewrite list_swap_elem_involutive; [ easy | | ]. {
    now rewrite canon_sym_gr_list_length.
  } {
    now rewrite canon_sym_gr_list_length.
  }
}
f_equal; [ now rewrite Hc | ].
rewrite (rngl_product_shift 1); [ | flia Hp ].
apply rngl_product_eq_compat.
intros i Hi.
rewrite Nat.add_comm, Nat.add_sub.
now rewrite Hc.
Qed.

Theorem determinant_same_rows : in_charac_0_field →
  ∀ (M : matrix T) p q,
  is_square_matrix M = true
  → p ≠ q
  → 1 ≤ p ≤ mat_nrows M
  → 1 ≤ q ≤ mat_nrows M
  → (∀ j, 1 ≤ j → mat_el M p j = mat_el M q j)
  → det M = 0%F.
Proof.
intros (Hic & Hop & Hin & H10 & Hit & Hde & Hch) * Hsm Hpq Hpn Hqn Hjpq.
remember (mat_nrows M) as n eqn:Hr; symmetry in Hr.
specialize (square_matrix_ncols M Hsm) as Hc.
assert (HM : det M = (- det M)%F). {
  rewrite <- Hr in Hpn, Hqn.
  rewrite <- determinant_alternating with (p := p) (q := q); try easy.
  f_equal.
  destruct M as (ll); cbn in *.
  unfold mat_swap_rows; cbn; f_equal.
  rewrite (List_map_nth_seq ll) with (d := []) at 1.
  apply map_ext_in.
  intros i Hi; apply in_seq in Hi.
  unfold transposition.
  do 2 rewrite if_eqb_eq_dec.
  destruct (Nat.eq_dec i (p - 1)) as [Hip| Hip]. {
    subst i.
    rewrite List_map_nth_seq with (d := 0%F); symmetry.
    rewrite List_map_nth_seq with (d := 0%F); symmetry.
    apply is_scm_mat_iff in Hsm.
    cbn in Hsm.
    destruct Hsm as (Hcz, Hsm).
    rewrite Hsm; [ | now apply nth_In ].
    rewrite Hsm; [ | apply nth_In; flia Hqn ].
    apply map_ext_in.
    intros j Hj.
    specialize (Hjpq (S j)).
    rewrite Nat_sub_succ_1 in Hjpq.
    apply Hjpq; flia.
  }
  destruct (Nat.eq_dec i (q - 1)) as [Hiq| Hiq]. {
    subst i.
    rewrite List_map_nth_seq with (d := 0%F); symmetry.
    rewrite List_map_nth_seq with (d := 0%F); symmetry.
    apply is_scm_mat_iff in Hsm.
    cbn in Hsm.
    destruct Hsm as (Hcz, Hsm).
    rewrite Hsm; [ | now apply nth_In ].
    rewrite Hsm; [ | apply nth_In; flia Hpn ].
    apply map_ext_in.
    intros j Hj.
    specialize (Hjpq (S j)).
    rewrite Nat_sub_succ_1 in Hjpq.
    symmetry; apply Hjpq; flia.
  }
  easy.
}
apply rngl_add_move_0_r in HM; [ | easy ].
apply eq_rngl_add_same_0 in HM; try easy; [ now left | ].
apply Bool.orb_true_iff.
now left.
Qed.

(* transpositions list of permutation *)

Fixpoint first_non_fixpoint it i σ :=
  match it with
  | 0 => None
  | S it' => if i =? σ i then first_non_fixpoint it' (i + 1) σ else Some i
  end.

Fixpoint tlopf_loop it n (σ : nat → nat) :=
  match it with
  | 0 => []
  | S it' =>
      match first_non_fixpoint n 0 σ with
      | None => []
      | Some i =>
          let σ' := comp (transposition i (σ i)) σ in
          (i, σ i) :: tlopf_loop it' n σ'
      end
  end.

(* *)

Definition mat_mul_row_by_scal n k (M : matrix T) s :=
  mk_mat
    (map
       (λ i,
        map
          (λ j, if Nat.eq_dec i k then (s * mat_el M i j)%F else mat_el M i j)
          (seq 1 n))
       (seq 1 n)).

(* If we multiply a row (column) of A by a number, the determinant of
   A will be multiplied by the same number. *)
(* https://math.vanderbilt.edu/sapirmv/msapir/proofdet1.html
   point 1 *)

(* If the i-th row (column) in A is a sum of the i-th row (column) of
   a matrix B and the i-th row (column) of a matrix C and all other
   rows in B and C are equal to the corresponding rows in A (that is B
   and C differ from A by one row only), then det(A)=det(B)+det(C). *)
(* https://math.vanderbilt.edu/sapirmv/msapir/proofdet1.html
   point 2 *)

(* Well, since my definition of the discriminant only covers the
   row 0, we can prove that only when i=0; this will able us to
   prove the next theorem, swapping rows by going via row 0 *)

Theorem det_add_row_row : ∀ n (A B C : matrix T),
  n ≠ 0
  → mat_nrows A = n
  → mat_nrows B = n
  → mat_nrows C = n
  → is_square_matrix A = true
  → is_square_matrix B = true
  → is_square_matrix C = true
  → (∀ j, mat_el A 1 j = (mat_el B 1 j + mat_el C 1 j)%F)
  → (∀ i j, i ≠ 1 → mat_el B i j = mat_el A i j)
  → (∀ i j, i ≠ 1 → mat_el C i j = mat_el A i j)
  → det A = (det B + det C)%F.
Proof.
intros * Hnz Hra Hrb Hrc Hsma Hsmb Hsmc Hbc Hb Hc.
specialize (square_matrix_ncols _ Hsma) as Hca.
specialize (square_matrix_ncols _ Hsmb) as Hcb.
rewrite Hra in Hca.
rewrite Hrb in Hcb.
destruct n; [ easy | clear Hnz; cbn ].
assert (Hab : ∀ j, subm 1 j A = subm 1 j B). {
  intros.
  destruct A as (lla).
  destruct B as (llb).
  cbn in *.
  unfold subm; f_equal.
  cbn - [ butn ].
  rewrite (List_map_nth_seq lla []).
  rewrite (List_map_nth_seq llb []).
  rewrite Hra, Hrb.
  do 2 rewrite <- map_butn.
  do 2 rewrite map_map.
  apply map_ext_in.
  intros u Hu.
  destruct (Nat.eq_dec u 0) as [Huz| Huz]. {
    subst u; cbn in Hu.
    now apply in_seq in Hu.
  }
  rewrite (List_map_nth_seq (nth u lla []) 0%F).
  rewrite (List_map_nth_seq (nth u llb []) 0%F).
  apply is_scm_mat_iff in Hsma.
  destruct Hsma as (_ & Hca').
  apply in_butn, in_seq in Hu.
  rewrite Hca'. 2: {
    cbn; apply nth_In.
    now rewrite Hra.
  }
  apply is_scm_mat_iff in Hsmb.
  destruct Hsmb as (_ & Hcb').
  rewrite Hcb'. 2: {
    cbn; apply nth_In.
    now rewrite Hrb.
  }
  f_equal; cbn; rewrite Hra, Hrb.
  apply map_ext_in.
  intros v Hv.
  apply in_seq in Hv.
  specialize (Hb (S u) (S v)).
  do 2 rewrite Nat_sub_succ_1 in Hb.
  symmetry; apply Hb; intros H; apply Huz.
  now apply Nat.succ_inj in H.
}
assert (Hac : ∀ j, subm 1 j A = subm 1 j C). {
  intros.
  destruct A as (lla).
  destruct C as (llc).
  cbn in *.
  unfold subm; f_equal.
  cbn - [ butn ].
  rewrite (List_map_nth_seq lla []).
  rewrite (List_map_nth_seq llc []).
  rewrite Hra, Hrc.
  do 2 rewrite <- map_butn.
  do 2 rewrite map_map.
  apply map_ext_in.
  intros u Hu.
  destruct (Nat.eq_dec u 0) as [Huz| Huz]. {
    subst u; cbn in Hu.
    now apply in_seq in Hu.
  }
  rewrite (List_map_nth_seq (nth u lla []) 0%F).
  rewrite (List_map_nth_seq (nth u llc []) 0%F).
  apply is_scm_mat_iff in Hsma.
  destruct Hsma as (_ & Hca').
  apply in_butn, in_seq in Hu.
  rewrite Hca'. 2: {
    cbn; apply nth_In.
    now rewrite Hra.
  }
  apply is_scm_mat_iff in Hsmc.
  destruct Hsmc as (_ & Hcc').
  rewrite Hcc'. 2: {
    cbn; apply nth_In.
    now rewrite Hrc.
  }
  f_equal; cbn; rewrite Hra, Hrc.
  apply map_ext_in.
  intros v Hv.
  apply in_seq in Hv.
  specialize (Hc (S u) (S v)).
  do 2 rewrite Nat_sub_succ_1 in Hc.
  symmetry; apply Hc; intros H; apply Huz.
  now apply Nat.succ_inj in H.
}
unfold det; rewrite Hra, Hrb, Hrc.
cbn.
erewrite rngl_summation_eq_compat. 2: {
  intros j Hj.
  rewrite Hbc.
  rewrite rngl_mul_add_distr_l.
  rewrite rngl_mul_add_distr_r.
  rewrite Hab at 1.
  rewrite Hac at 1.
  easy.
}
cbn.
now apply rngl_summation_add_distr.
Qed.

Theorem rngl_product_seq_permut :
  rngl_is_comm = true →
  ∀ n σ (f : nat → T),
  n ≠ 0
  → is_permut n σ
  → ∏ (i = 0, n - 1), f (ff_app σ i) = ∏ (i = 0, n - 1), f i.
Proof.
intros Hic * Hnz Hσ.
destruct n; [ easy | clear Hnz ].
rewrite Nat_sub_succ_1.
destruct Hσ as ((Hs, Hinj) & Hσl).
revert σ Hs Hinj Hσl.
induction n; intros; cbn. {
  do 2 rewrite rngl_product_only_one.
  destruct σ as [| a l]; [ easy | ].
  destruct l; [ | easy ].
  specialize (Hs a (or_introl eq_refl)).
  now apply Nat.lt_1_r in Hs; subst a.
}
set
  (g := λ i,
   if lt_dec i (ff_app (isort_rank Nat.leb σ) (S n)) then i else i + 1).
set (σ' := map (λ i, ff_app σ (g i)) (seq 0 (S n))).
assert (Hσ'l : length σ' = S n). {
  now unfold σ'; rewrite List_map_seq_length.
}
move g after Hσl; move σ' after Hσl.
specialize (IHn σ').
rewrite Hσ'l in IHn.
assert (Hs' : ∀ x, x ∈ σ' → x < S n). {
  intros x Hx.
  apply in_map_iff in Hx.
  destruct Hx as (i & Hxi & Hi); apply in_seq in Hi.
  rewrite <- Hxi.
  unfold g.
  destruct (lt_dec i _) as [His| His]. {
    specialize (Hs (ff_app σ i)) as H1.
    assert (H : ff_app σ i ∈ σ) by (apply nth_In; rewrite Hσl; flia Hi).
    specialize (H1 H); clear H.
    rewrite Hσl in H1.
    enough (H : ff_app σ i ≠ S n) by flia H1 H; intros Hσs.
    rewrite <- Hσs in His.
    rewrite permut_isort_permut in His; [ | easy | rewrite Hσl; flia Hi ].
    now apply lt_irrefl in His.
  } {
    rewrite Nat.add_1_r.
    specialize (Hs (ff_app σ (S i))) as H1.
    assert (H : ff_app σ (S i) ∈ σ). {
      apply nth_In; rewrite Hσl.
      now apply -> Nat.succ_lt_mono.
    }
    specialize (H1 H); clear H.
    rewrite Hσl in H1.
    enough (H : ff_app σ (S i) ≠ S n) by flia H1 H; intros Hσs.
    rewrite <- Hσs in His.
    rewrite permut_isort_permut in His; [ | easy | rewrite Hσl; flia Hi ].
    now apply His.
  }
}
move Hs' before Hs.
specialize (IHn Hs').
assert (H : NoDup σ'). {
  apply nat_NoDup.
  intros i j Hi Hj Hij; unfold σ', ff_app in Hij.
  rewrite Hσ'l in Hi, Hj.
  rewrite (List_map_nth' 0) in Hij; [ | now rewrite seq_length ].
  rewrite (List_map_nth' 0) in Hij; [ | now rewrite seq_length ].
  rewrite seq_nth in Hij; [ | easy ].
  rewrite seq_nth in Hij; [ | easy ].
  do 2 rewrite Nat.add_0_l in Hij.
  unfold g in Hij; cbn in Hij.
  specialize (NoDup_nat _ Hinj) as Hinj'.
  rewrite Hσl in Hinj'.
  destruct (lt_dec i _) as [His| His]. {
    destruct (lt_dec j _) as [Hjs| Hjs]. {
      apply Hinj' in Hij; [ easy | flia Hi | flia Hj ].
    }
    rewrite Nat.add_1_r in Hij.
    apply Nat.nlt_ge in Hjs.
    apply Hinj' in Hij; [ flia His Hjs Hij | flia Hi | ].
    now apply -> Nat.succ_lt_mono.
  }
  apply Nat.nlt_ge in His.
  rewrite Nat.add_1_r in Hij.
  destruct (lt_dec j _) as [Hjs| Hjs]. {
    apply Hinj' in Hij; [ flia His Hjs Hij | | flia Hj ].
    now apply -> Nat.succ_lt_mono.
  }
  rewrite Nat.add_1_r in Hij.
  apply Nat.succ_lt_mono in Hi, Hj.
  apply Hinj' in Hij; [ | easy | easy ].
  now apply Nat.succ_inj in Hij.
}
specialize (IHn H eq_refl); clear H.
remember (ff_app (isort_rank Nat.leb σ) (S n)) as k eqn:Hk.
destruct (Nat.eq_dec k (S n)) as [Hksn| Hksn]. {
  erewrite rngl_product_eq_compat in IHn. 2: {
    intros i Hi.
    unfold σ', g; cbn - [ seq ].
    unfold ff_app.
    rewrite (List_map_nth' 0); [ | rewrite seq_length; flia Hi ].
    rewrite seq_nth; [ | flia Hi ].
    rewrite Nat.add_0_l.
    destruct (lt_dec i k) as [H| H]; [ easy | flia Hksn Hi H ].
  }
  cbn in IHn.
  rewrite rngl_product_split_last; [ | flia ].
  rewrite rngl_product_succ_succ' with (g0 := λ i, f (ff_app σ i)).
  symmetry.
  rewrite rngl_product_split_last; [ | flia ].
  rewrite rngl_product_succ_succ'.
  symmetry; unfold ff_app at 1.
  rewrite IHn; f_equal; f_equal.
  rewrite Hk in Hksn.
  rewrite <- Hksn at 1.
  apply permut_permut_isort; [ easy | now rewrite Hσl ].
}
specialize (isort_rank_is_permut_list Nat.leb) as H1.
specialize (H1 σ).
rewrite rngl_product_split with (j := k) in IHn. 2: {
  split; [ flia | ].
  destruct H1 as (H1 & H2).
  apply -> Nat.succ_le_mono.
  rewrite isort_rank_length, Hσl in H1.
  specialize (H1 k).
  assert (H : k ∈ isort_rank Nat.leb σ). {
    rewrite Hk.
    apply nth_In.
    now rewrite isort_rank_length, Hσl.
  }
  specialize (H1 H); clear H.
  flia Hksn H1.
}
rewrite rngl_product_split_last in IHn; [ | flia ].
destruct (Nat.eq_dec k 0) as [Hkz| Hkz]. {
  move Hkz at top; subst k.
  rewrite rngl_product_empty in IHn; [ | flia ].
  rewrite rngl_mul_1_l, Nat.add_0_l in IHn.
  unfold σ' in IHn at 1.
  cbn - [ seq ] in IHn.
  unfold ff_app in IHn at 1.
  rewrite (List_map_nth' 0) in IHn; [ | rewrite seq_length; flia ].
  rewrite seq_nth in IHn; [ | flia ].
  rewrite Nat.add_0_l in IHn.
  erewrite rngl_product_eq_compat in IHn. 2: {
    intros i Hi.
    unfold ff_app, σ'.
    rewrite (List_map_nth' 0); [ | rewrite seq_length; flia Hi ].
    rewrite seq_nth; [ | flia Hi ].
    rewrite Nat.add_0_l.
    easy.
  }
  symmetry.
  rewrite rngl_product_split_last; [ | flia ].
  rewrite rngl_product_succ_succ'.
  rewrite <- IHn.
  symmetry.
  rewrite rngl_product_split_first; [ | flia ].
  rewrite rngl_product_succ_succ.
  rewrite rngl_product_split_first; [ | flia ].
  rewrite rngl_mul_comm; [ | easy ].
  do 2 rewrite <- rngl_mul_assoc.
  f_equal.
  f_equal. 2: {
    f_equal; rewrite Hk.
    apply permut_permut_isort; [ easy | now rewrite Hσl ].
  }
  apply rngl_product_eq_compat.
  intros i Hi.
  unfold g; rewrite Nat.add_1_r.
  destruct (lt_dec i 0) as [H| H]; [ flia Hi H | easy ].
}
erewrite rngl_product_eq_compat in IHn. 2: {
  intros i Hi.
  unfold σ'; cbn - [ seq ].
  assert (H : i - 1 < S n). {
    destruct H1 as (H1, H2).
    specialize (H1 k).
    assert (H : k ∈ isort_rank Nat.leb σ). {
      rewrite Hk; unfold ff_app.
      apply nth_In.
      now rewrite isort_rank_length, Hσl.
    }
    specialize (H1 H); clear H.
    rewrite isort_rank_length, Hσl in H1.
    flia H1 Hi.
  }
  unfold ff_app at 1.
  rewrite (List_map_nth' 0); [ | now rewrite seq_length ].
  rewrite seq_nth; [ | easy ].
  rewrite Nat.add_0_l.
  unfold g.
  clear H.
  destruct (lt_dec (i - 1) k) as [H| H]; [ | flia Hi H ].
  easy.
}
cbn - [ seq ] in IHn.
destruct k; [ easy | clear Hkz ].
rewrite rngl_product_succ_succ' with (g0 := λ i, f (ff_app σ i)) in IHn.
erewrite rngl_product_eq_compat with (b := S k + 1) in IHn. 2: {
  intros i Hi.
  unfold ff_app, σ'.
  rewrite (List_map_nth' 0); [ | rewrite seq_length; flia Hi ].
  rewrite seq_nth; [ | flia Hi ].
  rewrite Nat.add_0_l.
  unfold g.
  destruct (lt_dec i (S k)) as [H| H]; [ flia Hi H | easy ].
}
cbn in IHn.
rewrite rngl_mul_mul_swap in IHn; [ | easy ].
symmetry.
rewrite rngl_product_split_last; [ | flia ].
rewrite rngl_product_succ_succ'.
rewrite <- IHn.
symmetry.
rewrite rngl_product_split with (j := k). 2: {
  split; [ flia | ].
  rewrite Hk.
  destruct H1 as (H1, H2).
  rewrite isort_rank_length, Hσl in H1.
  apply Nat.lt_le_incl.
  apply H1, nth_In.
  now rewrite isort_rank_length, Hσl.
}
do 2 rewrite <- rngl_mul_assoc.
f_equal.
rewrite rngl_product_split_last. 2: {
  rewrite Nat.add_1_r, Hk.
  destruct H1 as (H1, H2).
  rewrite isort_rank_length, Hσl in H1.
  apply Nat.lt_succ_r.
  apply H1, nth_In.
  now rewrite isort_rank_length, Hσl.
}
rewrite rngl_product_succ_succ' with (g0 := λ i, f (ff_app σ i)).
rewrite rngl_product_split_first. 2: {
  rewrite Nat.add_1_r.
  destruct H1 as (H1, H2).
  rewrite isort_rank_length, Hσl in H1.
  specialize (H1 (S k)).
  assert (H : S k ∈ isort_rank Nat.leb σ). {
    rewrite Hk.
    apply nth_In.
    now rewrite isort_rank_length, Hσl.
  }
  specialize (H1 H); clear H.
  flia Hksn H1.
}
replace (ff_app σ (k + 1)) with (S n). 2: {
  rewrite Nat.add_1_r.
  rewrite Hk.
  symmetry.
  apply permut_permut_isort; [ easy | now rewrite Hσl ].
}
rewrite <- rngl_mul_assoc.
rewrite rngl_mul_comm; [ | easy ].
rewrite rngl_mul_assoc.
f_equal.
destruct
  (Nat.eq_dec (ff_app (isort_rank Nat.leb σ) (S n)) n) as [H7| H7]. {
  rewrite H7 in Hk.
  rewrite Nat.add_1_r.
  rewrite Hk.
  rewrite rngl_product_empty; [ | flia ].
  rewrite rngl_product_empty; [ | flia ].
  rewrite (List_map_nth' 0); [ | rewrite seq_length; flia Hk ].
  rewrite seq_nth; [ | flia Hk ].
  unfold g; cbn.
  destruct (lt_dec (S k) (S k)) as [H| H]; [ flia H | clear H ].
  now rewrite Nat.add_1_r, Hk.
}
assert (Hkn : S (k + 1) ≤ n). {
  rewrite Nat.add_1_r.
  destruct H1 as (H1, H2).
  apply Nat.le_succ_l.
  rewrite isort_rank_length, Hσl in H1.
  specialize (H1 (S k)).
  assert (H : S k ∈ isort_rank Nat.leb σ). {
    rewrite Hk.
    apply nth_In.
    now rewrite isort_rank_length, Hσl.
  }
  specialize (H1 H); clear H.
  rewrite <- Hk in H7.
  flia Hksn H1 H7.
}
rewrite rngl_product_split_first; [ | easy ].
rewrite <- rngl_mul_assoc.
rewrite rngl_mul_comm; [ | easy ].
unfold g.
rewrite (List_map_nth' 0); [ | rewrite seq_length; flia Hkn ].
rewrite seq_nth; [ | flia Hkn ].
rewrite Nat.add_1_r.
cbn.
destruct (lt_dec (S k) (S k)) as [H| H]; [ flia H | clear H ].
rewrite Nat.add_1_r.
f_equal.
symmetry.
rewrite rngl_product_split_last; [ | flia Hkn ].
rewrite Nat.add_1_r.
f_equal.
apply rngl_product_eq_compat.
intros i Hi.
rewrite Nat.sub_add; [ easy | flia Hi ].
Qed.

Theorem rngl_product_map_permut :
  rngl_is_comm = true →
   ∀ n f σ,
  is_permut n σ
  → ∏ (i ∈ map (ff_app σ) (seq 0 n)), f i = ∏ (i = 1, n), f (i - 1)%nat.
Proof.
intros Hic * Hσ.
destruct (Nat.eq_dec n 0) as [Hnz| Hnz]; [ now subst n | ].
rewrite (rngl_product_list_permut _ Nat.eqb_eq) with
    (lb := seq 0 n); [ | easy | ]. 2: {
  destruct Hσ as (H1, H2).
  rewrite <- H2 at 1.
  rewrite <- List_map_ff_app_seq, <- H2.
  now apply permut_list_permutation_iff.
}
unfold iter_seq.
rewrite Nat_sub_succ_1.
rewrite <- seq_shift.
replace n with (S (n - 1) - 0) by flia Hnz.
rewrite <- rngl_product_change_var; [ easy | ].
intros i Hi.
now rewrite Nat.sub_succ, Nat.sub_0_r.
Qed.

Theorem det_by_any_sym_gr : in_charac_0_field →
  ∀ n (M : matrix T) (sg : list (list nat)),
  n ≠ 0
  → mat_nrows M = n
  → is_square_matrix M = true
  → is_sym_gr_list n sg
  → det M =
    ∑ (k = 0, n! - 1),
    ε (nth k sg []) *
    ∏ (i = 1, n), mat_el M i (ff_app (nth k sg []) (i - 1) + 1).
Proof.
intros Hif * Hnz Hr Hsm Hsg.
rewrite det_is_det'; try now destruct Hif.
unfold det'.
rewrite Hr.
set (g := λ i, canon_sym_gr_list_inv n (nth i sg [])).
set (h := λ i, sym_gr_inv sg (canon_sym_gr_list n i)).
rewrite rngl_summation_change_var with (g0 := g) (h0 := h). 2: {
  intros i (_, Hi).
  unfold g, h.
  rewrite (nth_sym_gr_inv_sym_gr Hsg). 2: {
    apply canon_sym_gr_list_is_permut.
    specialize (fact_neq_0 n) as H.
    flia Hi H.
  }
  apply canon_sym_gr_list_inv_canon_sym_gr_list.
  specialize (fact_neq_0 n) as H.
  flia Hi H.
}
rewrite Nat.sub_0_r.
rewrite <- Nat.sub_succ_l; [ | apply Nat.neq_0_lt_0, fact_neq_0 ].
rewrite Nat_sub_succ_1.
erewrite rngl_summation_list_eq_compat. 2: {
  intros i Hi.
  apply in_map_iff in Hi.
  destruct Hi as (j & Hji & Hj).
  apply in_seq in Hj.
  unfold g.
  rewrite canon_sym_gr_list_canon_sym_gr_list_inv. 2: {
    split. {
      apply Hsg; rewrite <- Hji.
      now apply (sym_gr_inv_lt _ Hnz).
    } {
      destruct Hsg as (H1 & H2 & H3).
      apply H1; rewrite <- Hji.
      now apply (sym_gr_inv_lt _ Hnz).
    }
  }
  easy.
}
cbn.
apply (rngl_summation_list_permut _ Nat.eqb_eq).
rewrite Nat.sub_0_r.
rewrite <- Nat.sub_succ_l; [ | apply Nat.neq_0_lt_0, fact_neq_0 ].
rewrite Nat_sub_succ_1.
remember (map _ _) as la eqn:Hla.
replace n! with (length la) by now rewrite Hla, List_map_seq_length.
apply permut_list_permutation_iff.
subst la.
(* lemma to do? *)
unfold h.
split. {
  intros i Hi.
  rewrite List_map_seq_length.
  apply in_map_iff in Hi.
  destruct Hi as (j & Hji & Hj).
  apply in_seq in Hj.
  rewrite <- Hji.
  rewrite <- sym_gr_size with (sg := sg); [ | easy ].
  now apply (sym_gr_inv_lt _ Hnz).
} {
  apply (NoDup_map_iff 0).
  rewrite seq_length.
  intros i j Hi Hj Hij.
  rewrite seq_nth in Hij; [ | easy ].
  rewrite seq_nth in Hij; [ | easy ].
  do 2 rewrite Nat.add_0_l in Hij.
  apply (@sym_gr_inv_inj n) in Hij; [ | easy | | ]; cycle 1. {
    now apply canon_sym_gr_list_is_permut.
  } {
    now apply canon_sym_gr_list_is_permut.
  }
  now apply canon_sym_gr_list_inj in Hij.
}
Qed.

Theorem map_ff_app_permut_permut_is_permut : ∀ n l1 l2,
  is_permut n l1
  → is_permut n l2
  → is_permut n (map (ff_app l1) l2).
Proof.
intros n l σ (Hl1, Hl2) (Hσ1, Hσ2).
split; [ | now rewrite map_length ].
split. {
  intros i Hi; apply in_map_iff in Hi.
  destruct Hi as (j & Hji & Hj).
  rewrite map_length.
  rewrite <- Hji.
  rewrite Hσ2, <- Hl2.
  apply permut_list_ub; [ easy | ].
  rewrite Hl2, <- Hσ2.
  now apply Hσ1.
} {
  apply (NoDup_map_iff 0).
  intros u v Hu Hv Huv.
  destruct Hl1 as (Ha1, Hn1).
  apply (NoDup_nat _ Hn1) in Huv; cycle 1. {
    rewrite Hl2, <- Hσ2.
    now apply Hσ1, nth_In.
  } {
    rewrite Hl2, <- Hσ2.
    now apply Hσ1, nth_In.
  }
  destruct Hσ1 as (Hσa1, Hσn1).
  now apply (NoDup_nat _ Hσn1) in Huv.
}
Qed.

Theorem det_any_permut_l : in_charac_0_field →
  ∀ n (M : matrix T) (σ : list nat),
  n ≠ 0
  → mat_nrows M = n
  → is_square_matrix M = true
  → is_permut n σ
  → det M =
    (∑ (μ ∈ canon_sym_gr_list_list n), ε μ * ε σ *
     ∏ (k = 0, n - 1), mat_el M (ff_app σ k + 1) (ff_app μ k + 1))%F.
Proof.
intros Hif * Hnz Hr Hsm Hσ.
erewrite rngl_summation_list_eq_compat. 2: {
  intros μ Hμ.
  assert (Hpμ : is_permut n μ). {
    apply in_map_iff in Hμ.
    destruct Hμ as (i & Hiμ & Hi).
    apply in_seq in Hi.
    rewrite <- Hiμ.
    now apply canon_sym_gr_list_is_permut.
  }
  remember (μ ° isort_rank Nat.leb σ) as ν eqn:Hν.
  assert (Hσν : ν ° σ = μ). {
    rewrite Hν.
    assert (H : length (isort_rank Nat.leb σ) = n). {
      rewrite isort_rank_length; apply Hσ.
    }
    rewrite <- (permut_comp_assoc _ H Hσ); clear H.
    rewrite permut_comp_isort_rank_l; [ | now destruct Hσ ].
    apply comp_1_r.
    destruct Hσ, Hpμ; congruence.
  }
  subst ν.
  rewrite <- Hσν at 1.
  replace (ε ((μ ° isort_rank Nat.leb σ) ° σ)) with
      (ε (μ ° isort_rank Nat.leb σ) * ε σ)%F. 2: {
    destruct Hσ.
    rewrite <- sign_comp; [ easy | easy | ].
    now rewrite comp_length, isort_rank_length.
  }
  rewrite <- (rngl_mul_assoc _ (ε σ) (ε σ)).
  rewrite NoDup_ε_square; [ | now destruct Hif | ]. 2: {
    now destruct Hσ as ((_, H), _).
  }
  rewrite rngl_mul_1_r.
  easy.
}
cbn.
unfold canon_sym_gr_list_list.
rewrite rngl_summation_list_map.
rewrite rngl_summation_seq_summation; [ | apply fact_neq_0 ].
rewrite Nat.add_0_l.
erewrite rngl_summation_eq_compat. 2: {
  intros i (_, Hi).
  rewrite rngl_product_change_var with
      (g := ff_app (isort_rank Nat.leb σ)) (h := ff_app σ). 2: {
    intros j Hj.
    apply permut_isort_permut; [ now destruct Hσ | ].
    destruct Hσ as (Hσp, Hσl); rewrite Hσl.
    flia Hj Hnz.
  }
  rewrite Nat.sub_0_r.
  rewrite <- Nat.sub_succ_l; [ | flia Hnz ].
  rewrite Nat_sub_succ_1.
  erewrite rngl_product_list_eq_compat. 2: {
    intros j Hj.
    apply in_map_iff in Hj.
    destruct Hj as (k & Hkj & Hk).
    apply in_seq in Hk.
    rewrite permut_permut_isort; [ | now destruct Hσ | ]. 2: {
      rewrite <- Hkj.
      destruct Hσ as (H1, H2).
      rewrite <- H2 in Hk.
      now apply permut_list_ub.
    }
    easy.
  }
  cbn.
  rewrite rngl_product_map_permut; [ | now destruct Hif | easy ].
  easy.
}
cbn.
set
  (sg := map (λ k, canon_sym_gr_list n k ° isort_rank Nat.leb σ) (seq 0 n!)).
erewrite rngl_summation_eq_compat. 2: {
  intros k Hk.
  assert (Hkn : k < n!). {
    specialize (fact_neq_0 n) as H.
    flia Hk H.
  }
  replace (_ ° _) with (nth k sg []). 2: {
    unfold sg.
    rewrite (List_map_nth' 0); [ | now rewrite seq_length ].
    now rewrite seq_nth.
  }
  erewrite rngl_product_eq_compat. 2: {
    intros i Hi.
    rewrite Nat.sub_add; [ | flia Hi ].
    replace (ff_app _ _) with (ff_app (nth k sg []) (i - 1)). 2: {
      unfold sg.
      rewrite (List_map_nth' 0); [ | now rewrite seq_length ].
      rewrite seq_nth; [ | easy ].
      rewrite Nat.add_0_l.
      unfold "°".
      unfold ff_app.
      rewrite (List_map_nth' 0). 2: {
        rewrite isort_rank_length.
        destruct Hσ as (H1, H2); rewrite H2.
        flia Hi.
      }
      easy.
    }
    easy.
  }
  easy.
}
cbn.
apply det_by_any_sym_gr; try easy.
unfold sg.
split. {
  rewrite List_map_seq_length.
  intros i Hi.
  rewrite (List_map_nth' 0); [ | now rewrite seq_length ].
  rewrite seq_nth; [ | easy ].
  rewrite Nat.add_0_l.
  split. {
    unfold "°"; cbn.
    rewrite map_length.
    rewrite isort_rank_length.
    now destruct Hσ.
  } {
    apply (comp_is_permut_list n). {
      now apply canon_sym_gr_list_is_permut.
    } {
      now apply isort_rank_is_permut; destruct Hσ.
    }
  }
}
split. {
  rewrite List_map_seq_length.
  intros i j Hi Hj Hij.
  rewrite (List_map_nth' 0) in Hij; [ | now rewrite seq_length ].
  rewrite (List_map_nth' 0) in Hij; [ | now rewrite seq_length ].
  rewrite seq_nth in Hij; [ | easy ].
  rewrite seq_nth in Hij; [ | easy ].
  do 2 rewrite Nat.add_0_l in Hij.
  unfold "°" in Hij.
  specialize (ext_in_map Hij) as H1.
  apply (nth_canon_sym_gr_list_inj2 n); [ easy | easy | ].
  intros k Hk.
  apply H1.
  apply (permutation_in_iff Nat.eqb_eq) with (lb := seq 0 n). 2: {
    clear - Hk.
    induction n; intros; [ easy | ].
    rewrite seq_S; cbn.
    apply in_or_app.
    destruct (Nat.eq_dec k n) as [Hkn| Hkn]. {
      now subst k; right; left.
    }
    left; apply IHn; flia Hk Hkn.
  }
  replace n with (length (isort_rank Nat.leb σ)). 2: {
    rewrite isort_rank_length.
    now destruct Hσ.
  }
  apply permut_list_permutation_iff.
  apply isort_rank_is_permut_list.
} {
  intros l Hl.
  apply in_map_iff.
  destruct Hl as (Hl1, Hl2).
  destruct Hσ as (Hσ1, Hσ2).
  exists (canon_sym_gr_list_inv n (l ° σ)).
  rewrite canon_sym_gr_list_canon_sym_gr_list_inv. 2: {
    now apply map_ff_app_permut_permut_is_permut.
  }
  split. {
    rewrite <- (permut_comp_assoc n); [ | easy | ]. 2: {
      now apply isort_rank_is_permut.
    }
    rewrite permut_comp_isort_rank_r; [ | easy ].
    apply comp_1_r.
    congruence.
  }
  apply in_seq.
  split; [ easy | ].
  rewrite Nat.add_0_l.
  apply canon_sym_gr_list_inv_ub.
  now apply map_ff_app_permut_permut_is_permut.
}
Qed.

Theorem isort_rank_inj2 : ∀ l1 l2,
  is_permut_list l1
  → is_permut_list l2
  → isort_rank Nat.leb l1 = isort_rank Nat.leb l2
  → l1 = l2.
Proof.
intros * Hpl1 Hpl2 Hill.
assert (Hll : length l1 = length l2). {
  apply List_eq_iff in Hill.
  now do 2 rewrite isort_rank_length in Hill.
}
apply (f_equal (comp_list l1)) in Hill.
(**)
rewrite comp_isort_rank_r in Hill.
rewrite permut_isort_leb in Hill; [ | easy ].
apply (f_equal (λ l, comp_list l l2)) in Hill.
rewrite comp_1_l in Hill; [ | now rewrite Hll; destruct Hpl2 ].
rewrite <- (@permut_comp_assoc (length l2)) in Hill; [ | | easy ]. 2: {
  apply isort_rank_length.
}
rewrite permut_comp_isort_rank_l in Hill; [ | easy ].
now rewrite comp_1_r in Hill.
Qed.

Theorem det_any_permut_r : in_charac_0_field →
  ∀ n (M : matrix T) (σ : list nat),
  n ≠ 0
  → mat_nrows M = n
  → is_square_matrix M = true
  → is_permut n σ
  → det M =
    (∑ (μ ∈ canon_sym_gr_list_list n), ε μ * ε σ *
     ∏ (k = 0, n - 1), mat_el M (ff_app μ k + 1) (ff_app σ k + 1))%F.
Proof.
intros Hif * Hnz Hr Hsm Hσ.
erewrite rngl_summation_list_eq_compat. 2: {
  intros μ Hμ.
  assert (Hpμ : is_permut n μ). {
    apply in_map_iff in Hμ.
    destruct Hμ as (i & Hiμ & Hi).
    apply in_seq in Hi.
    rewrite <- Hiμ.
    now apply canon_sym_gr_list_is_permut.
  }
  remember (σ ° isort_rank Nat.leb μ) as ν eqn:Hν.
  assert (Hσν : ν ° μ = σ). {
    rewrite Hν.
    assert (H : length (isort_rank Nat.leb μ) = n). {
      rewrite isort_rank_length.
      apply Hpμ.
    }
    rewrite <- (permut_comp_assoc _ H); clear H; [ | apply Hpμ ].
    rewrite permut_comp_isort_rank_l; [ | now destruct Hpμ ].
    apply comp_1_r.
    destruct Hσ, Hpμ; congruence.
  }
  subst ν.
  rewrite <- Hσν at 1.
  replace (ε ((σ ° isort_rank Nat.leb μ) ° μ)) with
      (ε (σ ° isort_rank Nat.leb μ) * ε μ)%F. 2: {
    destruct Hif.
    rewrite <- sign_comp; [ easy | easy | ].
    rewrite comp_length, isort_rank_length.
    now destruct Hpμ.
  }
  destruct Hif as (Hic & Hop & Hiv & Hit & H10 & Hde & Hch) in Hsm.
  rewrite (rngl_mul_comm Hic _ (ε μ)).
  rewrite rngl_mul_assoc.
  rewrite NoDup_ε_square; [ | easy | now destruct Hpμ as ((_, H), _) ].
  rewrite rngl_mul_1_l.
  easy.
}
cbn.
unfold canon_sym_gr_list_list.
rewrite rngl_summation_list_map.
rewrite rngl_summation_seq_summation; [ | apply fact_neq_0 ].
rewrite Nat.add_0_l.
erewrite rngl_summation_eq_compat. 2: {
  intros i (_, Hi).
  assert (Hc : is_permut n (canon_sym_gr_list n i)). {
    apply canon_sym_gr_list_is_permut.
    specialize (fact_neq_0 n) as H.
    flia Hi H.
  }
  rewrite rngl_product_change_var with
      (g := ff_app (isort_rank Nat.leb (canon_sym_gr_list n i)))
      (h := ff_app (canon_sym_gr_list n i)). 2: {
    intros j (_, Hj).
    apply permut_isort_permut. 2: {
      rewrite canon_sym_gr_list_length; flia Hj Hnz.
    }
    apply canon_sym_gr_list_is_permut.
    specialize (fact_neq_0 n) as H.
    flia Hi H.
  }
  rewrite Nat.sub_0_r.
  rewrite <- Nat.sub_succ_l; [ | flia Hnz ].
  rewrite Nat_sub_succ_1.
  erewrite rngl_product_list_eq_compat. 2: {
    intros j Hj.
    apply in_map_iff in Hj.
    destruct Hj as (k & Hkj & Hk).
    apply in_seq in Hk.
    rewrite permut_permut_isort; [ easy | | ]. {
      apply canon_sym_gr_list_is_permut_list.
      specialize (fact_neq_0 n) as H.
      flia Hi H.
    }
    rewrite <- Hkj.
    apply permut_list_ub; [ apply Hc | ].
    now rewrite canon_sym_gr_list_length.
  }
  cbn.
  destruct Hif as (Hic & Hop & Hiv & Hit & H10 & Hde & Hch) in Hsm.
  rewrite rngl_product_map_permut; [ | easy | easy ].
  easy.
}
cbn.
set
  (sg :=
     map (λ k, σ ° isort_rank Nat.leb (canon_sym_gr_list n k)) (seq 0 n!)).
erewrite rngl_summation_eq_compat. 2: {
  intros k Hk.
  assert (Hkn : k < n!). {
    specialize (fact_neq_0 n) as H.
    flia Hk H.
  }
  replace (_ ° _) with (nth k sg []). 2: {
    unfold sg.
    rewrite (List_map_nth' 0); [ | now rewrite seq_length ].
    now rewrite seq_nth.
  }
  erewrite rngl_product_eq_compat. 2: {
    intros i Hi.
    rewrite Nat.sub_add; [ | flia Hi ].
    replace (ff_app _ _) with (ff_app (nth k sg []) (i - 1)). 2: {
      unfold sg.
      rewrite (List_map_nth' 0); [ | now rewrite seq_length ].
      rewrite seq_nth; [ | easy ].
      rewrite Nat.add_0_l.
      unfold "°".
      unfold ff_app.
      rewrite (List_map_nth' 0). 2: {
        rewrite isort_rank_length.
        rewrite canon_sym_gr_list_length.
        flia Hi.
      }
      easy.
    }
    easy.
  }
  easy.
}
cbn.
apply det_by_any_sym_gr; try easy.
unfold sg.
split. {
  rewrite List_map_seq_length.
  intros i Hi.
  rewrite (List_map_nth' 0); [ | now rewrite seq_length ].
  rewrite seq_nth; [ | easy ].
  rewrite Nat.add_0_l.
  split. {
    unfold "°"; cbn.
    rewrite map_length.
    rewrite isort_rank_length.
    apply canon_sym_gr_list_length.
  } {
    apply (comp_is_permut_list n); [ easy | ].
    apply isort_rank_is_permut.
    now apply canon_sym_gr_list_is_permut.
  }
}
split. {
  rewrite List_map_seq_length.
  intros i j Hi Hj Hij.
  rewrite (List_map_nth' 0) in Hij; [ | now rewrite seq_length ].
  rewrite (List_map_nth' 0) in Hij; [ | now rewrite seq_length ].
  rewrite seq_nth in Hij; [ | easy ].
  rewrite seq_nth in Hij; [ | easy ].
  do 2 rewrite Nat.add_0_l in Hij.
  unfold "°" in Hij.
  apply (f_equal (map (ff_app (isort_rank Nat.leb σ)))) in Hij.
  do 2 rewrite map_map in Hij.
  erewrite map_ext_in in Hij. 2: {
    intros k Hk.
    apply (In_nth _ _ 0) in Hk.
    destruct Hk as (u & Hu1 & Hu2).
    rewrite permut_isort_permut; [ | now destruct Hσ | ]. 2: {
      rewrite <- Hu2.
      eapply Nat.lt_le_trans. {
        apply permut_list_ub; [ | easy ].
        apply isort_rank_is_permut_list.
      }
      rewrite isort_rank_length.
      rewrite canon_sym_gr_list_length.
      now destruct Hσ as (_, Hσl); rewrite Hσl.
    }
    easy.
  }
  symmetry in Hij.
  erewrite map_ext_in in Hij. 2: {
    intros k Hk.
    apply (In_nth _ _ 0) in Hk.
    destruct Hk as (u & Hu1 & Hu2).
    rewrite permut_isort_permut; [ | now destruct Hσ | ]. 2: {
      rewrite <- Hu2.
      eapply Nat.lt_le_trans. {
        apply permut_list_ub; [ | easy ].
        apply isort_rank_is_permut_list.
      }
      rewrite isort_rank_length.
      rewrite canon_sym_gr_list_length.
      now destruct Hσ as (_, Hσl); rewrite Hσl.
    }
    easy.
  }
  symmetry in Hij.
  do 2 rewrite map_id in Hij.
  apply isort_rank_inj2 in Hij; cycle 1. {
    now apply canon_sym_gr_list_is_permut_list.
  } {
    now apply canon_sym_gr_list_is_permut_list.
  }
  now apply canon_sym_gr_list_inj in Hij.
} {
  intros l Hl.
  apply in_map_iff.
  exists (canon_sym_gr_list_inv n (isort_rank Nat.leb l ° σ)).
  rewrite canon_sym_gr_list_canon_sym_gr_list_inv. 2: {
    apply comp_is_permut; [ | easy ].
    apply isort_rank_is_permut.
    now destruct Hl.
  }
  rewrite (permut_isort_rank_comp n); [ | | | easy ]; cycle 1. {
    apply NoDup_isort_rank.
  } {
    rewrite isort_rank_length.
    now destruct Hl.
  }
  rewrite (permut_comp_assoc n); cycle 1. {
    rewrite isort_rank_length.
    now destruct Hσ.
  } {
    do 2 apply isort_rank_is_permut.
    now destruct Hl.
  }
  rewrite permut_comp_isort_rank_r; [ | now destruct Hσ ].
  rewrite comp_1_l. 2: {
    intros i Hi.
    apply in_isort_rank in Hi.
    rewrite isort_rank_length in Hi.
    destruct Hσ, Hl; congruence.
  }
  rewrite permut_isort_rank_involutive; [ | now destruct Hl ].
  split; [ easy | ].
  apply in_seq.
  split; [ easy | ].
  apply canon_sym_gr_list_inv_ub.
  apply comp_is_permut; [ | easy ].
  apply isort_rank_is_permut.
  now destruct Hl.
}
Qed.

Theorem determinant_transpose : in_charac_0_field →
  ∀ (M : matrix T),
  is_square_matrix M = true
  → det M⁺ = det M.
Proof.
intros Hif * Hsm.
remember (mat_nrows M) as n eqn:Hr; symmetry in Hr.
destruct (Nat.eq_dec n 0) as [Hnz| Hnz]. {
  unfold det.
  rewrite mat_transp_nrows, Hr.
  rewrite square_matrix_ncols; [ | easy ].
  now rewrite Hr, Hnz.
}
specialize (mat_transp_is_square M Hsm) as Hts.
assert (Hs : is_permut n (seq 0 n)) by apply seq_is_permut.
assert (Hr' : mat_nrows M⁺ = n). {
  now rewrite mat_transp_nrows, square_matrix_ncols.
}
rewrite (det_any_permut_l Hif M Hnz Hr Hsm Hs).
rewrite (det_any_permut_r Hif (M⁺)%M Hnz Hr' Hts Hs).
apply rngl_summation_list_eq_compat.
intros p Hp.
f_equal.
apply rngl_product_eq_compat.
intros k Hk.
unfold mat_transp.
unfold ff_app; cbn.
do 2 rewrite Nat.add_sub.
rewrite seq_nth; [ | flia Hk Hnz ].
assert (Hpr : ff_app p k < mat_nrows M). {
  apply in_map_iff in Hp.
  destruct Hp as (i & Hi & His).
  apply in_seq in His.
  rewrite <- Hi.
  rewrite Hr.
  apply canon_sym_gr_list_ub; [ easy | ].
  flia Hnz Hk.
}
rewrite (List_map_nth' 0). 2: {
  now rewrite seq_length, square_matrix_ncols.
}
rewrite (List_map_nth' 0); [ | rewrite seq_length, Hr; flia Hk Hnz ].
rewrite seq_nth; [ | rewrite Hr; flia Hk Hnz ].
rewrite Nat.add_0_l.
rewrite seq_nth; [ | now rewrite square_matrix_ncols ].
now do 2 rewrite Nat.add_1_r.
Qed.

Theorem det_subm_transp : in_charac_0_field →
  ∀ i j (M : matrix T),
  is_square_matrix M = true
  → 1 ≤ i ≤ mat_ncols M
  → 1 ≤ j ≤ mat_nrows M
  → det (subm j i M) = det (subm i j M⁺).
Proof.
intros Hif * Hsm Hi Hj.
rewrite <- determinant_transpose; [ | easy | ]. 2: {
  rewrite square_matrix_ncols in Hi; [ | easy ].
  now apply is_squ_mat_subm.
}
now rewrite mat_subm_transp.
Qed.

End a.

Arguments det {T ro} M%M.
Arguments det' {T}%type {ro} M%M.
Arguments det'' {T}%type {ro} M%M.
Arguments determinant_alternating {T}%type {ro rp} _ M%M [p q]%nat.
Arguments determinant_loop {T}%type {ro} n%nat M%M.
Arguments determinant_same_rows {T}%type {ro rp} _ M%M [p q]%nat.
Arguments determinant_transpose {T ro rp} _ M%M.
Arguments det_is_det' {T}%type {ro rp} _ M%M.
Arguments det'_is_det'' {T ro rp} _ _ M%M.
Arguments det_subm_transp {T ro rp} _ [i j]%nat.

