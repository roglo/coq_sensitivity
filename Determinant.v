(* determinant *)

Set Nested Proofs Allowed.
Set Implicit Arguments.

Require Import Utf8 Arith.
Require Import Permutation.
Import List List.ListNotations.

Require Import Misc RingLike IterAdd IterMul.
Require Import MyVector Matrix PermutSeq Signature.
Import matrix_Notations.

Definition list_of_fun {A} n (f : _ → A) := map f (seq 0 n).
Definition fun_of_list {A} (d : A) l i := nth i l d.

Section a.

Context {T : Type}.
Context (ro : ring_like_op T).
Context (rp : ring_like_prop T).

(*
   determinant n M recursively computes determinant

      0     n-1
      |     |
      v     v
     ---------    ---------   ---------   ---------
0    |x      |    | x     |   |  x    |   |   x   |
     | ......| -  |. .....| + |.. ....| - |... ...| + etc.
     | ......|    |. .....|   |.. ....|   |... ...|
n-1  | ......|    |. .....|   |.. ....|   |... ...|
     ---------    ---------   ---------   ---------

   each term is the term "x" multiplied by det (n-1) of
   the sub-matrix represented by the dots. The "x" goes through
   the first row.
*)

Fixpoint determinant_loop n (M : matrix T) :=
  (match n with
   | 0 => λ _, 1%F
   | S n' =>
       λ M' : matrix T,
       ∑ (j = 0, n'),
       minus_one_pow j * mat_el M' 0 j * determinant_loop n' (subm M' 0 j)
   end) M.

Definition determinant M := determinant_loop (mat_nrows M) M.
Arguments determinant M%M.

Theorem fold_determinant : ∀ M,
  determinant_loop (mat_nrows M) M = determinant M.
Proof. easy. Qed.

Theorem determinant_zero : ∀ (M : matrix T),
  determinant_loop 0 M = 1%F.
Proof. easy. Qed.

Theorem determinant_succ : ∀ n (M : matrix T),
  determinant_loop (S n) M =
     ∑ (j = 0, n),
     minus_one_pow j * mat_el M 0 j * determinant_loop n (subm M 0 j).
Proof. easy. Qed.

Definition mat_permut_rows_fun (σ : nat → nat) (M : matrix T) :=
  mk_mat (map (λ i, nth (σ i) (mat_list_list M) []) (seq 0 (mat_nrows M))).

(* the following versions of computing the determinant should
   (to be proven) be equivalent; perhaps could help for proving
   Cramer's rule of resolving equations *)

Definition det_from_row {n} (M : matrix T) i :=
  (minus_one_pow i *
   ∑ (j = 0, n),
     minus_one_pow j * mat_el M i j * determinant_loop n (subm M i j))%F.

Definition det_from_col {n} (M : matrix T) j :=
  (minus_one_pow j *
   ∑ (i = 0, n - 1),
     minus_one_pow i * mat_el M i j * determinant_loop n (subm M i j))%F.

(* Alternative version of the determinant: sum of product of the
   factors a_{i,σ(i)} where σ goes through all permutations of
   the naturals of the interval [0, n-1].
   The permutations generated are in the same order as the
   terms generated by the determinant defined by induction on
   the size of the matrix.
     The order happens to be the canonical (alphabetical) order.
   Example for n=3
     = [[0; 1; 2]; [0; 2; 1]; [1; 0; 2]; [1; 2; 0]; [2; 0; 1]; [2; 1; 0]]
   Having the same terms order, the proof of equality of both definitions
   of both determinants is easy.
   See PermutSeq.v *)

(* definition of determinant by sum of products involving all
   permutations *)

Definition determinant' n (M : matrix T) :=
  ∑ (k = 0, fact n - 1),
    ε n (canon_sym_gr_list n k) *
    ∏ (i = 1, n), mat_el M (i - 1) (ff_app (canon_sym_gr_list n k) (i - 1)).

Arguments determinant' n%nat M%M.

(* Proof that both definitions of determinants are equal *)

Theorem det_is_det_by_canon_permut : in_field →
  ∀ (M : matrix T),
  is_square_matrix M = true
  → determinant M = determinant' (mat_nrows M) M.
Proof.
intros (Hic & Hop & Hin & H10 & Hit & Hde & Hch) * Hm.
unfold determinant'.
remember (mat_nrows M) as n eqn:Hr; symmetry in Hr.
unfold determinant.
rewrite Hr.
revert M Hm Hr.
induction n; intros. {
  cbn.
  rewrite rngl_summation_only_one.
  unfold ε, iter_seq, iter_list; cbn.
  rewrite rngl_mul_1_r.
  rewrite rngl_div_1_r; [ easy | now left | easy ].
}
rewrite determinant_succ.
destruct (Nat.eq_dec n 0) as [Hnz| Hnz]. {
  subst n; cbn.
  rewrite rngl_summation_only_one; cbn.
  rewrite rngl_summation_only_one; cbn.
  rewrite rngl_product_only_one; cbn.
  unfold ε; cbn.
  do 4 rewrite rngl_product_only_one; cbn.
  rewrite rngl_mul_1_r.
  rewrite rngl_div_1_r; [ easy | now left | easy ].
}
erewrite rngl_summation_eq_compat. 2: {
  intros i Hi.
  rewrite IHn; cycle 1. {
    apply is_squ_mat_subm; [ now rewrite Hr | rewrite Hr; flia Hi | easy ].
  } {
    rewrite mat_nrows_subm, Hr; cbn.
    apply Nat.sub_0_r.
  }
  easy.
}
cbn - [ canon_sym_gr_list fact nth ].
clear IHn.
erewrite rngl_summation_eq_compat. 2: {
  intros i Hi.
  rewrite rngl_mul_summation_distr_l; [ | now left ].
  easy.
}
cbn - [ canon_sym_gr_list fact nth ].
rewrite rngl_summation_summation_distr.
rewrite <- Nat.sub_succ_l; [ | apply Nat.neq_0_lt_0, fact_neq_0 ].
rewrite Nat_sub_succ_1.
rewrite <- Nat_fact_succ.
apply rngl_summation_eq_compat.
intros k Hk.
(* elimination of "mat_el M 0 (k / (n!)" *)
symmetry.
rewrite rngl_product_split_first; [ | flia ].
rewrite Nat.sub_diag.
cbn [ canon_sym_gr_list nth ].
remember (mat_el M 0 _) as x eqn:Hx.
rewrite rngl_mul_comm; [ | easy ].
symmetry.
rewrite <- rngl_mul_assoc.
rewrite rngl_mul_comm; [ | easy ].
do 3 rewrite <- rngl_mul_assoc.
f_equal.
(* elimination done *)
(* separation factors "∏" and "ε" *)
rewrite rngl_mul_comm; [ | easy ].
rewrite <- rngl_mul_assoc.
f_equal. {
  (* equality of the two "∏" *)
  rewrite rngl_product_shift; [ | flia Hnz ].
  rewrite (rngl_product_shift _ 2); [ | flia Hnz ].
  rewrite Nat.sub_succ.
  apply rngl_product_eq_compat.
  intros i Hi.
  rewrite Nat.add_comm, Nat.add_sub.
  replace (2 + i - 1) with (S i) by flia.
  unfold mat_el.
  unfold ff_app.
  cbn - [ subm fact ].
  rewrite (List_map_nth' 0); [ | rewrite length_canon_sym_gr_list; flia Hi Hnz ].
  cbn - [ butn ].
  rewrite (List_map_nth' []). 2: {
    apply is_scm_mat_iff in Hm.
    destruct Hm as (Hcr & Hc).
    rewrite butn_length, fold_mat_nrows, Hr.
    cbn; flia Hi Hnz.
  }
  unfold succ_when_ge, Nat.b2n.
  rewrite if_leb_le_dec.
  destruct (le_dec (k / n!) _) as [H1| H1]. {
    rewrite nth_butn_before; [ | easy ].
    rewrite nth_butn_before; [ | easy ].
    now rewrite (Nat.add_1_r i).
  } {
    apply Nat.nle_gt in H1.
    rewrite Nat.add_0_r.
    rewrite nth_butn_after; [ | easy ].
    rewrite nth_butn_before; [ | easy ].
    now rewrite Nat.add_1_r.
  }
  (* end proof equality of the two "∏" *)
}
(* equality of the two "ε" *)
symmetry.
apply ε_of_sym_gr_permut_succ; try easy.
apply (le_lt_trans _ ((S n)! - 1)); [ easy | ].
apply Nat.sub_lt; [ | easy ].
apply Nat.le_succ_l, Nat.neq_0_lt_0, fact_neq_0.
Qed.

(* multilinearity *)

Theorem determinant_multilinear : in_field →
  ∀ n (M : matrix T) i a b U V,
  is_square_matrix M = true
  → mat_nrows M = n
  → vect_size U = n
  → vect_size V = n
  → i < n
  → determinant (mat_repl_vect i M (a × U + b × V)%V) =
       (a * determinant (mat_repl_vect i M U) +
        b * determinant (mat_repl_vect i M V))%F.
Proof.
intros Hif * Hsm Hr Hu Hv Hi.
specialize (square_matrix_ncols _ Hsm) as Hcn.
(* using the snd version of determinants: determinant' *)
rewrite (det_is_det_by_canon_permut Hif). 2: {
  apply mat_repl_vect_is_square; [ congruence | cbn | easy ].
  rewrite map2_length.
  do 2 rewrite map_length, fold_vect_size.
  rewrite Hu, Hv.
  now rewrite Nat.min_id.
}
rewrite (det_is_det_by_canon_permut Hif). 2: {
  apply mat_repl_vect_is_square; [ congruence | congruence | easy ].
}
rewrite (det_is_det_by_canon_permut Hif). 2: {
  apply mat_repl_vect_is_square; [ congruence | congruence | easy ].
}
unfold determinant'.
(* simplification of the lhs *)
remember (a × U + b × V)%V as UV eqn:HUV.
assert (Hvm : vect_size UV = mat_nrows M). {
  rewrite Hr, HUV; cbn.
  rewrite map2_length.
  do 2 rewrite map_length.
  do 2 rewrite fold_vect_size.
  rewrite Hu, Hv.
  apply Nat.min_id.
}
erewrite rngl_summation_eq_compat. 2: {
  intros k Hk.
  assert (Hkn : k < n!). {
    eapply le_lt_trans; [ apply Hk | ].
    rewrite mat_repl_vect_nrows; [ | easy ].
    rewrite Hr.
    apply Nat.sub_lt; [ | flia ].
    apply Nat.neq_0_lt_0, fact_neq_0.
  }
  erewrite rngl_product_eq_compat. 2: {
    intros j Hj.
    rewrite HUV in Hj; cbn in Hj.
    do 2 rewrite map2_length in Hj.
    do 2 rewrite map_length in Hj.
    do 2 rewrite fold_vect_size in Hj.
    rewrite fold_mat_nrows, Hr, Hu, Hv in Hj.
    do 2 rewrite Nat.min_id in Hj.
    rewrite mat_el_repl_vect; cycle 1. {
      now apply squ_mat_is_corr.
    } {
      subst UV; cbn.
      rewrite map2_length.
      do 2 rewrite map_length.
      do 2 rewrite fold_vect_size.
      rewrite Hu, Hv, Nat.min_id.
      flia Hj.
    } {
      rewrite Hr; flia Hj.
    } {
      unfold ff_app.
      rewrite Hcn.
      rewrite mat_repl_vect_nrows; [ | easy ].
      rewrite Hr.
      apply canon_sym_gr_list_ub; [ easy | flia Hj ].
    } {
      now rewrite Hcn, Hr.
    }
    unfold vect_el, ff_app.
    cbn - [ Nat.eq_dec ].
    rewrite map2_length, fold_mat_nrows, fold_vect_size.
    rewrite Hvm, Hr, Nat.min_id.
    easy.
  }
  easy.
}
cbn - [ mat_el ].
(* put a and b inside the sigma in the rhs *)
rewrite rngl_mul_summation_distr_l; [ | now destruct Hif; left ].
rewrite rngl_mul_summation_distr_l; [ | now destruct Hif; left ].
symmetry.
erewrite rngl_summation_eq_compat. 2: {
  intros k Hk.
  rewrite map2_length, fold_mat_nrows, fold_vect_size in Hk |-*.
  rewrite Hr, Hu, Nat.min_id in Hk |-*.
  assert (Hkn : k < fact n). {
    specialize (fact_neq_0 n) as Hnz.
    flia Hk Hnz.
  }
  rewrite rngl_mul_assoc.
  destruct Hif as (Hic & Hop & Hin & H10 & Hit & Hde & Hch) in Hsm.
  rewrite (rngl_mul_comm Hic a).
  erewrite rngl_product_eq_compat. 2: {
    intros j Hj.
    rewrite mat_el_repl_vect; cycle 1. {
      now apply squ_mat_is_corr.
    } {
      rewrite Hu; flia Hj.
    } {
      rewrite Hr; flia Hj.
    } {
      cbn.
      rewrite Hcn, Hr.
      apply canon_sym_gr_list_ub; [ easy | flia Hj ].
    } {
      now rewrite Hcn, Hr.
    }
    now unfold vect_el, ff_app; cbn.
  }
  easy.
}
do 3 rewrite map2_length, fold_mat_nrows, fold_vect_size.
rewrite Hvm, Hr, Hu, Hv, Nat.min_id.
rewrite rngl_add_comm.
erewrite rngl_summation_eq_compat. 2: {
  intros k Hk.
  assert (Hkn : k < fact n). {
    specialize (fact_neq_0 n) as Hnz.
    flia Hk Hnz.
  }
  rewrite rngl_mul_assoc.
  destruct Hif as (Hic & Hop & Hin & H10 & Hit & Hde & Hch) in Hsm.
  rewrite (rngl_mul_comm Hic b).
  erewrite rngl_product_eq_compat. 2: {
    intros j Hj.
    rewrite mat_el_repl_vect; cycle 1. {
      now apply squ_mat_is_corr.
    } {
      rewrite Hv; flia Hj.
    } {
      rewrite Hr; flia Hj.
    } {
      rewrite Hcn, Hr.
      apply canon_sym_gr_list_ub; [ easy | flia Hj ].
    } {
      now rewrite Hcn, Hr.
    }
    now unfold vect_el, ff_app; cbn.
  }
  easy.
}
rewrite rngl_add_comm.
(* make one summation *)
rewrite <- rngl_summation_add_distr.
apply rngl_summation_eq_compat.
intros k Hk.
do 2 rewrite <- rngl_mul_assoc.
rewrite <- rngl_mul_add_distr_l.
(* elimination of the ε-s *)
f_equal.
(* *)
assert (Hkn : k < fact n). {
  specialize (fact_neq_0 n) as Hnz.
  flia Hk Hnz.
}
specialize (canon_sym_gr_surjective Hkn Hi) as Hp.
destruct Hp as (p & Hp & Hpp).
rewrite (rngl_product_split (p + 1)); [ | flia Hp ].
rewrite rngl_product_split_last; [ | flia ].
erewrite rngl_product_eq_compat. 2: {
  intros j Hj.
  replace (j - 1 - 1) with (j - 2) by flia.
  destruct (Nat.eq_dec (nth (j - 2) (canon_sym_gr_list n k) 0) i)
    as [Hpj| Hpj]. {
    exfalso.
    rewrite <- Hpp in Hpj.
    apply nth_canon_sym_gr_list_inj1 in Hpj; [ | easy | flia Hp Hj | easy ].
    flia Hj Hpj.
  }
  easy.
}
destruct Hif as (Hic & Hop & Hin & H10 & Hit & Hde & Hch) in Hsm.
rewrite (rngl_mul_comm Hic (iter_seq _ _ _ _)).
rewrite rngl_add_comm.
rewrite (rngl_product_split (p + 1)); [ | flia Hp ].
rewrite rngl_product_split_last; [ | flia ].
erewrite rngl_product_eq_compat. 2: {
  intros j Hj.
  replace (j - 1 - 1) with (j - 2) by flia.
  destruct (Nat.eq_dec (nth (j - 2) (canon_sym_gr_list n k) 0) i)
    as [Hpj| Hpj]. {
    exfalso.
    rewrite <- Hpp in Hpj.
    apply nth_canon_sym_gr_list_inj1 in Hpj; [ | easy | flia Hp Hj | easy ].
    flia Hj Hpj.
  }
  easy.
}
rewrite (rngl_mul_comm Hic (iter_seq _ _ _ _)).
rewrite rngl_add_comm.
symmetry.
rewrite (rngl_product_split (p + 1)); [ | flia Hp ].
rewrite rngl_product_split_last; [ | flia ].
erewrite rngl_product_eq_compat. 2: {
  intros j Hj.
  replace (j - 1 - 1) with (j - 2) by flia.
  destruct (Nat.eq_dec (nth (j - 2) (canon_sym_gr_list n k) 0) i)
    as [Hpj| Hpj]. {
    exfalso.
    rewrite <- Hpp in Hpj.
    apply nth_canon_sym_gr_list_inj1 in Hpj; [ | easy | flia Hp Hj | easy ].
    flia Hj Hpj.
  }
  easy.
}
rewrite (rngl_mul_comm Hic (iter_seq _ _ _ _)).
rewrite Nat.add_sub.
unfold ff_app in Hpp.
rewrite Hpp.
destruct (Nat.eq_dec i i) as [H| H]; [ clear H | easy ].
do 4 rewrite rngl_mul_assoc.
subst UV.
cbn - [ mat_el ].
rewrite map2_nth with (a := 0%F) (b := 0%F); cycle 1. {
  now rewrite map_length, fold_vect_size, Hu.
} {
  now rewrite map_length, fold_vect_size, Hv.
}
rewrite (List_map_nth' 0%F); [ | now rewrite fold_vect_size, Hu ].
rewrite (List_map_nth' 0%F); [ | now rewrite fold_vect_size, Hv ].
do 2 rewrite fold_vect_el.
(* elimination of the following term (q) *)
remember
  (∏ (i0 = 2, p + 1),
   mat_el M (i0 - 2) (nth (i0 - 2) (canon_sym_gr_list n k) O))
  as q eqn:Hq.
rewrite (rngl_mul_mul_swap Hic _ _ q).
do 3 rewrite (rngl_mul_comm Hic _ q).
do 5 rewrite <- rngl_mul_assoc.
rewrite <- rngl_mul_add_distr_l.
f_equal.
clear q Hq.
erewrite rngl_product_eq_compat. 2: {
  intros j Hj.
  destruct (Nat.eq_dec (nth (j - 1) (canon_sym_gr_list n k) 0) i)
    as [Hpj| Hpj]. {
    rewrite <- Hpp in Hpj.
    apply nth_canon_sym_gr_list_inj1 in Hpj; [ | easy | flia Hp Hj | easy ].
    flia Hj Hpj.
  }
  easy.
}
symmetry.
erewrite rngl_product_eq_compat. 2: {
  intros j Hj.
  destruct (Nat.eq_dec (nth (j - 1) (canon_sym_gr_list n k) 0) i)
    as [Hpj| Hpj]. {
    rewrite <- Hpp in Hpj.
    apply nth_canon_sym_gr_list_inj1 in Hpj; [ | easy | flia Hp Hj | easy ].
    flia Hj Hpj.
  }
  easy.
}
rewrite rngl_add_comm.
erewrite rngl_product_eq_compat. 2: {
  intros j Hj.
  destruct (Nat.eq_dec (nth (j - 1) (canon_sym_gr_list n k) 0) i)
    as [Hpj| Hpj]. {
    rewrite <- Hpp in Hpj.
    apply nth_canon_sym_gr_list_inj1 in Hpj; [ | easy | flia Hp Hj | easy ].
    flia Hj Hpj.
  }
  easy.
}
cbn.
rewrite rngl_add_comm.
do 2 rewrite rngl_mul_assoc.
now rewrite <- rngl_mul_add_distr_r.
Qed.

(* list of terms in determinant' (determinant by sum of products of
   permutations *)

Definition determinant'_list n (M : matrix T) :=
  map (λ k,
    (ε_permut n k *
     ∏ (i = 1, n),
     mat_el M (i - 1) (ff_app (canon_sym_gr_list n k) (i - 1)))%F)
    (seq 0 n!).

Arguments determinant'_list n%nat M%M.

Theorem determinant'_by_list : in_field →
  ∀ n (M : matrix T),
  determinant' n M = ∑ (k = 0, fact n - 1), nth k (determinant'_list n M) 0.
Proof.
intros (Hic & Hop & Hin & H10 & Hit & Hde & Hch) *.
unfold determinant', determinant'_list.
apply rngl_summation_eq_compat; intros k Hk.
assert (Hkn : k < fact n). {
  specialize (fact_neq_0 n) as Hn.
  flia Hk Hn.
}
rewrite List_map_nth' with (a := 0); [ | now rewrite seq_length ].
rewrite seq_nth; [ | easy ].
rewrite Nat.add_0_l.
f_equal.
now apply ε_of_permut_ε.
Qed.

Definition mat_swap_rows i1 i2 (M : matrix T) :=
  mk_mat (list_swap_elem [] (mat_list_list M) i1 i2).

Theorem list_swap_scal_0_succ_cons : ∀ A (d : A) j a l,
  list_swap_elem d (a :: l) 0 (S j) =
  nth j l d :: map (λ i, if i =? j then a else nth i l d) (seq 0 (length l)).
Proof.
intros.
cbn - [ nth ].
f_equal.
rewrite <- seq_shift, map_map.
apply map_ext_in.
intros i Hi; apply in_seq in Hi.
unfold transposition.
cbn - [ nth ].
do 2 rewrite if_eqb_eq_dec.
now destruct (Nat.eq_dec i j).
Qed.

Theorem mat_swap_rows_is_square : ∀ (M : matrix T) p q,
  p < mat_nrows M
  → q < mat_nrows M
  → is_square_matrix M = true
  → is_square_matrix (mat_swap_rows p q M) = true.
Proof.
intros * Hp Hq Hsm.
remember (mat_nrows M) as n eqn:Hr.
symmetry in Hr.
specialize (square_matrix_ncols _ Hsm) as Hcn.
specialize (squ_mat_is_corr M Hsm) as Hco.
apply is_scm_mat_iff in Hsm.
apply is_scm_mat_iff.
destruct Hsm as (Hcr & Hc).
cbn; unfold list_swap_elem.
rewrite List_map_seq_length.
unfold mat_swap_rows, list_swap_elem; cbn.
split. {
  unfold mat_ncols; cbn.
  rewrite fold_mat_nrows; rewrite Hr.
  rewrite (List_map_hd 0); [ | rewrite seq_length; flia Hp ].
  rewrite List_seq_hd; [ | flia Hp ].
  rewrite Hc; [ now intros Hn; subst n | ].
  apply nth_In; rewrite fold_mat_nrows; rewrite Hr.
  unfold transposition.
  do 2 rewrite if_eqb_eq_dec.
  destruct (Nat.eq_dec 0 p); [ easy | ].
  destruct (Nat.eq_dec 0 q); [ easy | ].
  flia Hp.
} {
  intros la Hla.
  apply in_map_iff in Hla.
  rewrite fold_mat_nrows, Hr in Hla.
  destruct Hla as (a & Ha & Hla).
  apply in_seq in Hla; subst la.
  rewrite fold_corr_mat_ncols; [ easy | easy | rewrite Hr ].
  unfold transposition.
  do 2 rewrite if_eqb_eq_dec.
  destruct (Nat.eq_dec a p); [ easy | ].
  destruct (Nat.eq_dec a q); [ easy | ].
  easy.
}
Qed.

Theorem mat_swap_rows_nrows : ∀ (M : matrix T) p q,
  mat_nrows (mat_swap_rows p q M) = mat_nrows M.
Proof.
intros.
unfold mat_swap_rows; cbn.
unfold list_swap_elem.
rewrite map_length.
now rewrite seq_length.
Qed.

Theorem is_permut_canon_transp : ∀ n k p q,
  k < n!
  → p < n
  → q < n
  → is_permut n (list_swap_elem 0 (canon_sym_gr_list n k) p q).
Proof.
intros * Hkn Hpn Hqn.
split. {
  split. {
    intros j Hj.
    rewrite length_list_swap_elem, length_canon_sym_gr_list.
    unfold list_swap_elem in Hj.
    rewrite length_canon_sym_gr_list in Hj.
    apply in_map_iff in Hj.
    destruct Hj as (i & Hij & Hi).
    apply in_seq in Hi.
    rewrite <- Hij.
    unfold transposition.
    do 2 rewrite if_eqb_eq_dec.
    destruct (Nat.eq_dec i p) as [Hip| Hip]. {
      now apply canon_sym_gr_list_ub.
    }
    destruct (Nat.eq_dec i q) as [Hiq| Hiq]. {
      now apply canon_sym_gr_list_ub.
    }
    now apply canon_sym_gr_list_ub.
  } {
    intros u v Hu Hv Huv.
    rewrite length_list_swap_elem in Hu, Hv.
    unfold list_swap_elem in Huv.
    rewrite length_canon_sym_gr_list in Hu, Hv, Huv.
    unfold ff_app in Huv.
    rewrite (List_map_nth' 0) in Huv; [ | now rewrite seq_length ].
    rewrite (List_map_nth' 0) in Huv; [ | now rewrite seq_length ].
    rewrite seq_nth in Huv; [ | easy ].
    rewrite seq_nth in Huv; [ | easy ].
    cbn in Huv.
    assert (Htu : transposition p q u < n) by now apply transposition_lt.
    assert (Htv : transposition p q v < n) by now apply transposition_lt.
    apply nth_canon_sym_gr_list_inj1 in Huv; [ | easy | easy | easy ].
    now apply transposition_injective in Huv.
  }
}
rewrite length_list_swap_elem.
apply length_canon_sym_gr_list.
Qed.

Theorem nth_transposition_canon_sym_gr_list_inj : ∀ n k p q i j,
  k < n!
  → p < n
  → q < n
  → i < n
  → j < n
  → nth (transposition p q i) (canon_sym_gr_list n k) 0 =
    nth (transposition p q j) (canon_sym_gr_list n k) 0
  → i = j.
Proof.
intros * Hkn Hpn Hqn Hin Hjn Hij.
unfold transposition in Hij.
do 4 rewrite if_eqb_eq_dec in Hij.
destruct (Nat.eq_dec i p) as [Hip| Hip]. {
  destruct (Nat.eq_dec j p) as [Hjp| Hjp]; [ congruence | ].
  destruct (Nat.eq_dec j q) as [Hjq| Hjq]. {
    apply nth_canon_sym_gr_list_inj1 in Hij; [ | easy | easy | easy ].
    congruence.
  }
  apply Nat.neq_sym in Hjq.
  now apply nth_canon_sym_gr_list_inj1 in Hij.
}
destruct (Nat.eq_dec i q) as [Hiq| Hiq]. {
  destruct (Nat.eq_dec j p) as [Hjp| Hjp]. {
    apply nth_canon_sym_gr_list_inj1 in Hij; [ | easy | easy | easy ].
    congruence.
  }
  destruct (Nat.eq_dec j q) as [Hjq| Hjq]; [ congruence | ].
  apply Nat.neq_sym in Hjp.
  now apply nth_canon_sym_gr_list_inj1 in Hij.
}
destruct (Nat.eq_dec j p) as [Hjp| Hjp]. {
  now apply nth_canon_sym_gr_list_inj1 in Hij.
}
destruct (Nat.eq_dec j q) as [Hjq| Hjq]. {
  now apply nth_canon_sym_gr_list_inj1 in Hij.
}
now apply nth_canon_sym_gr_list_inj1 in Hij.
Qed.

Theorem determinant_alternating : in_field →
  ∀ (M : matrix T) p q,
  p ≠ q
  → p < mat_nrows M
  → q < mat_nrows M
  → is_square_matrix M = true
  → determinant (mat_swap_rows p q M) = (- determinant M)%F.
Proof.
intros Hif * Hpq Hp Hq Hsm.
remember (mat_nrows M) as n eqn:Hr; symmetry in Hr.
rewrite det_is_det_by_canon_permut; [ | easy | ]. 2: {
  rewrite <- Hr in Hp, Hq.
  now apply mat_swap_rows_is_square.
}
unfold determinant'.
rewrite mat_swap_rows_nrows.
rewrite Hr.
erewrite rngl_summation_eq_compat. 2: {
  intros k Hk.
  rewrite rngl_product_shift; [ | flia Hp ].
  erewrite rngl_product_eq_compat. 2: {
    intros i Hi.
    now rewrite Nat.add_comm, Nat.add_sub.
  }
  easy.
}
cbn - [ mat_swap_rows ].
erewrite rngl_summation_eq_compat. 2: {
  intros k Hk.
  rewrite rngl_product_change_var with
    (g := transposition p q) (h := transposition p q). 2: {
    intros i Hi.
    apply transposition_involutive.
  }
  rewrite Nat.sub_0_r.
  rewrite <- Nat.sub_succ_l; [ | flia Hp ].
  rewrite Nat_sub_succ_1.
  easy.
}
cbn - [ mat_swap_rows ].
erewrite rngl_summation_eq_compat. 2: {
  intros k Hk.
  destruct Hif as (Hic & Hop & Hin & H10 & Hit & Hde & Hch) in Hsm.
  rewrite rngl_product_list_permut with (l2 := seq 0 n); [ | easy | ]. 2: {
    apply permut_list_Permutation.
    now apply transposition_is_permut.
  }
  easy.
}
cbn - [ mat_swap_rows ].
erewrite rngl_summation_eq_compat. 2: {
  intros k Hk.
  assert (Hkn : k < n!). {
    specialize (fact_neq_0 n) as Hn.
    flia Hk Hn.
  }
  erewrite rngl_product_list_eq_compat. 2: {
    intros i Hi.
    replace (mat_el _ _ _) with
      (mat_el M i
         (ff_app (canon_sym_gr_list n k) (transposition p q i))). 2: {
      unfold ff_app; cbn.
      unfold mat_el; f_equal.
      unfold list_swap_elem.
      rewrite (List_map_nth' 0). 2: {
        rewrite seq_length.
        rewrite fold_mat_nrows, Hr.
        apply in_seq in Hi.
        now apply transposition_lt.
      }
      rewrite fold_mat_nrows, Hr.
      unfold transposition.
      do 2 rewrite if_eqb_eq_dec.
      destruct (Nat.eq_dec i p) as [Hip| Hip]. {
        subst i.
        rewrite seq_nth; [ | easy ].
        rewrite Nat.add_0_l.
        rewrite Nat.eqb_refl.
        apply Nat.neq_sym in Hpq.
        now destruct (Nat.eq_dec q p).
      }
      rewrite if_eqb_eq_dec.
      destruct (Nat.eq_dec i q) as [Hiq| Hiq]. {
        subst i.
        rewrite seq_nth; [ | easy ].
        rewrite Nat.add_0_l.
        rewrite <- if_eqb_eq_dec.
        now rewrite Nat.eqb_refl.
      }
      apply in_seq in Hi.
      rewrite seq_nth; [ | easy ].
      rewrite Nat.add_0_l.
      rewrite if_eqb_eq_dec.
      destruct (Nat.eq_dec i p) as [H| H]; [ easy | clear H ].
      now destruct (Nat.eq_dec i q).
    }
    easy.
  }
  easy.
}
cbn.
set (f := λ k, list_swap_elem 0 (canon_sym_gr_list n k) p q).
erewrite rngl_summation_eq_compat. 2: {
  intros k Hk.
  erewrite rngl_product_list_eq_compat. 2: {
    intros i Hi.
    apply in_seq in Hi.
    replace (ff_app _ _) with
       (ff_app (list_swap_elem 0 (canon_sym_gr_list n k) p q) i). 2: {
(* lemme à faire *)
      unfold list_swap_elem.
      unfold ff_app.
      rewrite (List_map_nth' 0). 2: {
        now rewrite seq_length, length_canon_sym_gr_list.
      }
      rewrite seq_nth; [ easy | now rewrite length_canon_sym_gr_list ].
    }
    fold (f k).
    easy.
  }
  easy.
}
cbn.
erewrite rngl_summation_eq_compat. 2: {
  intros k Hk.
  assert (Hkn : k < n!). {
    specialize (fact_neq_0 n) as Hn.
    flia Hk Hn.
  }
  erewrite rngl_product_seq_product; [ | flia Hp ].
  rewrite Nat.add_0_l.
  replace (canon_sym_gr_list n k) with
     (map (λ i, ff_app (f k) (transposition p q i)) (seq 0 n)). 2: {
    rewrite List_map_nth_seq with (d := 0).
    rewrite length_canon_sym_gr_list.
    apply map_ext_in.
    intros i Hi; cbn.
    apply in_seq in Hi.
    unfold ff_app, f, list_swap_elem.
    rewrite (List_map_nth' 0). 2: {
      rewrite seq_length, length_canon_sym_gr_list.
      now apply transposition_lt.
    }
    rewrite seq_nth. 2: {
      rewrite length_canon_sym_gr_list.
      now apply transposition_lt.
    }
    rewrite Nat.add_0_l.
    now rewrite transposition_involutive.
  }
  replace (map (λ i, ff_app (f k) (transposition p q i)) (seq 0 n))
  with (f k ° map (λ i, transposition p q i) (seq 0 n)). 2: {
    unfold "°"; cbn.
    now rewrite map_map.
  }
  rewrite signature_comp; [ easy | easy | | ]. {
    split. 2: {
      unfold f.
      rewrite length_list_swap_elem.
      apply length_canon_sym_gr_list.
    }
    split. {
      intros i Hi.
      apply In_nth with (d := 0) in Hi.
      destruct Hi as (j & Hj & Hji).
      rewrite <- Hji.
      apply permut_list_ub; [ | easy ].
      unfold f.
      apply list_swap_elem_is_permut_list. {
        now rewrite length_canon_sym_gr_list.
      } {
        now rewrite length_canon_sym_gr_list.
      } {
        now apply canon_sym_gr_list_is_permut.
      }
    }
    unfold f, ff_app.
    rewrite length_list_swap_elem.
    rewrite length_canon_sym_gr_list.
    intros i j Hi Hj Hij.
(* lemme à faire ? *)
    unfold list_swap_elem in Hij.
    rewrite (List_map_nth' 0) in Hij. 2: {
      now rewrite seq_length, length_canon_sym_gr_list.
    }
    rewrite (List_map_nth' 0) in Hij. 2: {
      now rewrite seq_length, length_canon_sym_gr_list.
    }
    rewrite seq_nth in Hij; [ | now rewrite length_canon_sym_gr_list ].
    rewrite seq_nth in Hij; [ | now rewrite length_canon_sym_gr_list ].
    cbn in Hij.
    now apply nth_transposition_canon_sym_gr_list_inj in Hij.
  }
  now apply transposition_is_permut.
}
cbn.
erewrite rngl_summation_eq_compat. 2: {
  intros k (_, Hk).
  destruct Hif as (Hic & Hop & Hin & H10 & Hit & Hde & Hch) in Hsm.
  rewrite (rngl_mul_comm Hic (ε n (f k))).
  rewrite <- rngl_mul_assoc.
  now rewrite transposition_signature.
}
cbn - [ f ].
rewrite <- rngl_mul_summation_distr_l; [ | now destruct Hif; left ].
rewrite rngl_mul_opp_l; [ | now destruct Hif ].
f_equal.
rewrite rngl_mul_1_l.
symmetry.
set (g := λ k, canon_sym_gr_list_inv n (f k)).
rewrite rngl_summation_change_var with (g0 := g) (h := g). 2: {
  intros k (_, Hk).
  assert (Hkn : k < n!). {
    specialize (fact_neq_0 n) as Hn.
    flia Hk Hn.
  }
  unfold g, f.
  unfold list_swap_elem.
  do 2 rewrite length_canon_sym_gr_list.
  erewrite map_ext_in. 2: {
    intros i Hi; apply in_seq in Hi.
    rewrite permut_in_canon_sym_gr_of_its_rank. 2: {
(* lemme à faire ? *)
      split; [ | now rewrite map_length, seq_length ].
      split. {
        intros j Hj.
        rewrite map_length, seq_length.
        apply in_map_iff in Hj.
        destruct Hj as (m & Hmj & Hm).
        apply in_seq in Hm.
        rewrite <- Hmj.
        apply canon_sym_gr_list_ub; [ easy | ].
        now apply transposition_lt.
      } {
        rewrite map_length, seq_length.
        intros u v Hu Hv.
        unfold ff_app.
        rewrite (List_map_nth' 0); [ | now rewrite seq_length ].
        rewrite (List_map_nth' 0); [ | now rewrite seq_length ].
        rewrite seq_nth; [ | easy ].
        rewrite seq_nth; [ | easy ].
        do 2 rewrite Nat.add_0_l.
        intros Huv.
        now apply nth_transposition_canon_sym_gr_list_inj in Huv.
      }
    }
    rewrite (List_map_nth' 0). 2: {
      now rewrite seq_length; apply transposition_lt.
    }
    rewrite seq_nth; [ | now apply transposition_lt ].
    rewrite Nat.add_0_l.
    rewrite transposition_involutive.
    easy.
  }
  rewrite <- List_map_nth_seq'; [ | now rewrite length_canon_sym_gr_list ].
  now apply canon_sym_gr_inv_of_canon_sym_gr.
}
rewrite Nat.sub_0_r.
rewrite <- Nat.sub_succ_l; [ | apply Nat.neq_0_lt_0, fact_neq_0 ].
rewrite Nat_sub_succ_1.
rewrite rngl_summation_list_permut with (l2 := seq 0 n!). 2: {
  apply permut_list_Permutation.
(* lemma to do? *)
  unfold g, f.
  split; [ | now rewrite map_length, seq_length ].
  split. {
    intros i Hi.
    rewrite map_length, seq_length.
    apply in_map_iff in Hi.
    destruct Hi as (j & Hji & Hj).
    apply in_seq in Hj.
    rewrite <- Hji.
    apply canon_sym_gr_list_inv_ub.
    apply list_swap_elem_is_permut; [ easy | easy | ].
    now apply canon_sym_gr_list_is_permut.
  } {
    rewrite map_length, seq_length.
    intros i j Hi Hj Hij.
    unfold ff_app in Hij.
    rewrite (List_map_nth' 0) in Hij; [ | now rewrite seq_length ].
    rewrite (List_map_nth' 0) in Hij; [ | now rewrite seq_length ].
    rewrite seq_nth in Hij; [ | easy ].
    rewrite seq_nth in Hij; [ | easy ].
    do 2 rewrite Nat.add_0_l in Hij.
(* lemme à faire ? *)
    apply rank_of_permut_in_canon_gr_list_inj in Hij; cycle 1. {
      apply list_swap_elem_is_permut; [ easy | easy | ].
      now apply canon_sym_gr_list_is_permut.
    } {
      apply list_swap_elem_is_permut; [ easy | easy | ].
      now apply canon_sym_gr_list_is_permut.
    }
(* lemme à faire ? *)
    unfold list_swap_elem in Hij.
    do 2 rewrite length_canon_sym_gr_list in Hij.
    apply nth_canon_sym_gr_list_inj2 with (n := n); [ easy | easy | ].
    intros k Hkn.
    apply ext_in_map with (a := transposition p q k) in Hij. 2: {
      apply in_seq.
      split; [ flia | ].
      now apply transposition_lt.
    }
    now rewrite transposition_involutive in Hij.
  }
}
rewrite det_is_det_by_canon_permut; [ | easy | easy ].
rewrite Hr.
unfold determinant'.
rewrite rngl_summation_seq_summation; [ | apply fact_neq_0 ].
rewrite Nat.add_0_l.
apply rngl_summation_eq_compat.
intros k Hk.
assert (Hkn : k < n!). {
  specialize (fact_neq_0 n) as Hn.
  flia Hk Hn.
}
assert (Hc : canon_sym_gr_list n k = f (g k)). {
  unfold g, f.
  rewrite permut_in_canon_sym_gr_of_its_rank. 2: {
    apply list_swap_elem_is_permut; [ easy | easy | ].
    now apply canon_sym_gr_list_is_permut.
  }
  rewrite list_swap_elem_involutive; [ easy | | ]. {
    now rewrite length_canon_sym_gr_list.
  } {
    now rewrite length_canon_sym_gr_list.
  }
}
f_equal; [ now rewrite Hc | ].
rewrite rngl_product_shift; [ | flia Hp ].
apply rngl_product_eq_compat.
intros i Hi.
rewrite Nat.add_comm, Nat.add_sub.
now rewrite Hc.
Qed.

Theorem determinant_same_rows : in_field →
  ∀ (M : matrix T) p q,
  is_square_matrix M = true
  → p ≠ q
  → p < mat_nrows M
  → q < mat_nrows M
  → (∀ j, mat_el M p j = mat_el M q j)
  → determinant M = 0%F.
Proof.
intros (Hic & Hop & Hin & H10 & Hit & Hde & Hch) * Hsm Hpq Hpn Hqn Hjpq.
remember (mat_nrows M) as n eqn:Hr; symmetry in Hr.
specialize (square_matrix_ncols M Hsm) as Hc.
assert (HM : determinant M = (- determinant M)%F). {
  rewrite <- Hr in Hpn, Hqn.
  rewrite <- determinant_alternating with (p := p) (q := q); try easy.
  f_equal.
  destruct M as (ll); cbn in *.
  unfold mat_swap_rows; cbn; f_equal.
  rewrite (List_map_nth_seq ll) with (d := []) at 1.
  apply map_ext_in.
  intros i Hi; apply in_seq in Hi.
  unfold transposition.
  do 2 rewrite if_eqb_eq_dec.
  destruct (Nat.eq_dec i p) as [Hip| Hip]. {
    subst i.
    rewrite List_map_nth_seq with (d := 0%F); symmetry.
    rewrite List_map_nth_seq with (d := 0%F); symmetry.
    apply is_scm_mat_iff in Hsm.
    cbn in Hsm.
    destruct Hsm as (Hcz, Hsm).
    rewrite Hsm; [ | now apply nth_In ].
    rewrite Hsm; [ | now apply nth_In ].
    apply map_ext_in.
    intros j Hj.
    apply Hjpq.
  }
  destruct (Nat.eq_dec i q) as [Hiq| Hiq]. {
    subst i.
    rewrite List_map_nth_seq with (d := 0%F); symmetry.
    rewrite List_map_nth_seq with (d := 0%F); symmetry.
    apply is_scm_mat_iff in Hsm.
    cbn in Hsm.
    destruct Hsm as (Hcz, Hsm).
    rewrite Hsm; [ | now apply nth_In ].
    rewrite Hsm; [ | now apply nth_In ].
    apply map_ext_in.
    intros j Hj.
    symmetry; apply Hjpq.
  }
  easy.
}
apply rngl_add_move_0_r in HM; [ | easy ].
apply eq_rngl_add_same_0 in HM; try easy; [ now left | ].
apply Bool.orb_true_iff.
now left.
Qed.

(* transpositions list of permutation *)

Fixpoint first_non_fixpoint it i σ :=
  match it with
  | 0 => None
  | S it' => if i =? σ i then first_non_fixpoint it' (i + 1) σ else Some i
  end.

Fixpoint tlopf_loop it n (σ : nat → nat) :=
  match it with
  | 0 => []
  | S it' =>
      match first_non_fixpoint n 0 σ with
      | None => []
      | Some i =>
          let σ' := comp (transposition i (σ i)) σ in
          (i, σ i) :: tlopf_loop it' n σ'
      end
  end.

Theorem first_non_fixpoint_Some_iff : ∀ σ it i j,
  first_non_fixpoint it i σ = Some j
  ↔ i ≤ j ∧ j - i < it ∧ (∀ k, i ≤ k < j → σ k = k) ∧ σ j ≠ j.
Proof.
intros.
split. {
  intros Hs.
  revert σ i j Hs.
  induction it; intros; [ easy | cbn in Hs ].
  rewrite if_eqb_eq_dec in Hs.
  destruct (Nat.eq_dec i (σ i)) as [Hii| Hii]. {
    specialize (IHit σ (i + 1) j Hs) as (H1 & H2 & H3 & H4).
    split; [ flia H1 | ].
    split; [ flia H2 | ].
    split; [ | easy ].
    intros k Hk.
    destruct (Nat.eq_dec i k) as [Hik| Hik]; [ now subst k | ].
    apply H3; flia Hk Hik.
  } {
    injection Hs; clear Hs; intros; subst j.
    split; [ flia | ].
    split; [ flia | ].
    split; [ | now apply Nat.neq_sym ].
    intros k Hk; flia Hk.
  }
} {
  intros (Hij & Hji & Hj & Hjj).
  revert i j Hij Hji Hj Hjj.
  induction it; intros; [ easy | cbn ].
  rewrite if_eqb_eq_dec.
  destruct (Nat.eq_dec i (σ i)) as [Hii| Hii]. {
    assert (Heij : i ≠ j) by now intros H; symmetry in Hii; subst i.
    apply IHit; [ flia Hij Hji Heij | flia Hij Hji Heij | | easy ].
    intros k Hk.
    apply Hj.
    flia Hk.
  }
  destruct (Nat.eq_dec i j) as [Heij| Heij]; [ congruence | exfalso ].
  assert (H : i ≤ i < j) by flia Hij Heij.
  specialize (Hj _ H) as H1.
  now symmetry in H1.
}
Qed.

Theorem first_non_fixpoint_None_if : ∀ σ it i,
  first_non_fixpoint it i σ = None
  → ∀ k, i ≤ k < i + it → k = σ k.
Proof.
intros * Hs k Hik.
revert σ i k Hik Hs.
induction it; intros; [ flia Hik | ].
cbn in Hs.
rewrite if_eqb_eq_dec in Hs.
destruct (Nat.eq_dec i (σ i)) as [H1| H1]; [ | easy ].
destruct (Nat.eq_dec i k) as [H2| H2]; [ now subst i | ].
eapply IHit; [ | apply Hs ].
flia Hik H2.
Qed.

Theorem first_non_fixpoint_enough_iter : ∀ n m σ i j,
  n ≤ m
  → first_non_fixpoint n i σ = Some j
  → first_non_fixpoint m i σ = Some j.
Proof.
intros * Hnm Hij.
revert i j n σ Hnm Hij.
induction m; intros; cbn. {
  now apply Nat.le_0_r in Hnm; subst n.
}
rewrite if_eqb_eq_dec.
destruct (Nat.eq_dec i (σ i)) as [Hii| Hii]. {
  destruct n; [ easy | ].
  cbn in Hij.
  rewrite <- Hii, Nat.eqb_refl in Hij.
  apply Nat.succ_le_mono in Hnm.
  now apply IHm with (n := n).
}
apply first_non_fixpoint_Some_iff in Hij.
destruct Hij as (Hij & Hjin & Hikj & Hjj).
destruct (Nat.eq_dec i j) as [H1| H1]; [ now subst i | ].
exfalso; apply Hii; symmetry.
apply Hikj.
split; [ flia | flia Hij H1 ].
Qed.

(* If we add a row (column) of A multiplied by a scalar k to another
   row (column) of A, then the determinant will not change. *)
(* https://math.vanderbilt.edu/sapirmv/msapir/proofdet1.html *)
(* doing it only when the first row is 0; can be generalized later *)

Definition mat_add_row_mul_scal_row n (M : matrix T) i1 v i2 :=
  mk_mat
    (map
      (λ i,
       map
         (λ j,
          if Nat.eq_dec i i1 then (mat_el M i1 j + v * mat_el M i2 j)%F
          else mat_el M i j)
         (seq 0 n))
     (seq 0 n)).

(* *)

Definition mat_mul_row_by_scal n k (M : matrix T) s :=
  mk_mat
    (map
       (λ i,
        map
          (λ j, if Nat.eq_dec i k then (s * mat_el M i j)%F else mat_el M i j)
          (seq 0 n))
       (seq 0 n)).

Theorem subm_mat_mul_row_by_scal : ∀ (A : matrix T) i v,
  is_square_matrix A = true
  → subm (mat_mul_row_by_scal (mat_nrows A) 0 A v) 0 i = subm A 0 i.
Proof.
intros * Hsm.
remember (mat_nrows A) as n eqn:Hr; symmetry in Hr.
unfold subm.
f_equal.
f_equal.
unfold butn.
do 2 rewrite firstn_O.
f_equal.
do 2 rewrite List_skipn_1.
destruct A as (ll).
destruct ll as [| la ll]; [ now subst n; cbn | ].
apply is_scm_mat_iff in Hsm.
cbn in Hsm.
destruct Hsm as (Hcr & Hc).
destruct n; [ easy | ].
cbn in Hr.
apply Nat.succ_inj in Hr.
cbn - [ mat_mul_row_by_scal ].
rewrite List_map_nth_seq with (d := []).
rewrite Hr.
cbn - [ seq mat_el ].
rewrite List_map_tl.
remember (tl (seq 0 (S n))) as x eqn:Hx.
cbn in Hx; subst x.
rewrite <- seq_shift.
rewrite map_map.
apply map_ext_in.
intros j Hj.
apply in_seq in Hj.
destruct Hj as (_, Hj).
rewrite List_map_nth_seq with (d := 0%F).
rewrite Hc. 2: {
  right.
  apply nth_In.
  now rewrite Hr.
}
rewrite Hr.
apply map_ext_in.
intros k Hk.
now destruct (Nat.eq_dec (S j) 0).
Qed.

(* If we multiply a row (column) of A by a number, the determinant of
   A will be multiplied by the same number. *)
(* https://math.vanderbilt.edu/sapirmv/msapir/proofdet1.html
   point 1 *)

(* Well, since my definition of the determinant only covers the
   row 0, we can prove that only when i=0; this will able us to
   prove next theorems, swapping rows by going via row 0 *)

Theorem det_mul_row_0_by_scal :
  rngl_has_opp = true ∨ rngl_has_sous = true →
  rngl_is_comm = true →
  ∀ (A : matrix T) v,
  mat_nrows A ≠ 0
  → is_square_matrix A = true
  → determinant (mat_mul_row_by_scal (mat_nrows A) 0 A v) =
    (v * determinant A)%F.
Proof.
intros Hom Hic * Hnz Hsm.
remember (mat_nrows A) as n eqn:Hr; symmetry in Hr.
destruct n; [ easy | clear Hnz ].
unfold determinant; rewrite Hr.
cbn - [ mat_mul_row_by_scal ].
rewrite rngl_mul_summation_distr_l; [ | easy ].
cbn - [ seq ].
rewrite List_map_seq_length.
rewrite determinant_succ.
apply rngl_summation_eq_compat.
intros i (_, Hi).
symmetry.
rewrite (rngl_mul_comm Hic).
symmetry.
do 3 rewrite <- rngl_mul_assoc.
f_equal.
rewrite rngl_mul_assoc, (rngl_mul_mul_swap Hic).
rewrite (rngl_mul_comm Hic _ v).
f_equal. {
  destruct i; [ easy | cbn ].
  rewrite (List_map_nth' 0); [ | now rewrite seq_length ].
  now rewrite seq_nth.
}
f_equal.
rewrite <- Hr.
now apply subm_mat_mul_row_by_scal.
Qed.

(* If the i-th row (column) in A is a sum of the i-th row (column) of
   a matrix B and the i-th row (column) of a matrix C and all other
   rows in B and C are equal to the corresponding rows in A (that is B
   and C differ from A by one row only), then det(A)=det(B)+det(C). *)
(* https://math.vanderbilt.edu/sapirmv/msapir/proofdet1.html
   point 2 *)

(* Well, since my definition of the discriminant only covers the
   row 0, we can prove that only when i=0; this will able us to
   prove the next theorem, swapping rows by going via row 0 *)

Theorem det_sum_row_row : ∀ n (A B C : matrix T),
  n ≠ 0
  → mat_nrows A = n
  → mat_nrows B = n
  → mat_nrows C = n
  → is_square_matrix A = true
  → is_square_matrix B = true
  → is_square_matrix C = true
  → (∀ j, mat_el A 0 j = (mat_el B 0 j + mat_el C 0 j)%F)
  → (∀ i j, i ≠ 0 → mat_el B i j = mat_el A i j)
  → (∀ i j, i ≠ 0 → mat_el C i j = mat_el A i j)
  → determinant A = (determinant B + determinant C)%F.
Proof.
intros * Hnz Hra Hrb Hrc Hsma Hsmb Hsmc Hbc Hb Hc.
specialize (square_matrix_ncols _ Hsma) as Hca.
specialize (square_matrix_ncols _ Hsmb) as Hcb.
rewrite Hra in Hca.
rewrite Hrb in Hcb.
destruct n; [ easy | clear Hnz; cbn ].
assert (Hab : ∀ j, subm A 0 j = subm B 0 j). {
  intros.
  destruct A as (lla).
  destruct B as (llb).
  cbn in *.
  unfold subm; f_equal.
  cbn - [ butn ].
  rewrite (List_map_nth_seq lla []).
  rewrite (List_map_nth_seq llb []).
  rewrite Hra, Hrb.
  do 2 rewrite <- map_butn.
  do 2 rewrite map_map.
  apply map_ext_in.
  intros u Hu.
  destruct (Nat.eq_dec u 0) as [Huz| Huz]. {
    subst u; cbn in Hu.
    now apply in_seq in Hu.
  }
  rewrite (List_map_nth_seq (nth u lla []) 0%F).
  rewrite (List_map_nth_seq (nth u llb []) 0%F).
  apply is_scm_mat_iff in Hsma.
  destruct Hsma as (_ & Hca').
  apply in_butn, in_seq in Hu.
  rewrite Hca'. 2: {
    cbn; apply nth_In.
    now rewrite Hra.
  }
  apply is_scm_mat_iff in Hsmb.
  destruct Hsmb as (_ & Hcb').
  rewrite Hcb'. 2: {
    cbn; apply nth_In.
    now rewrite Hrb.
  }
  f_equal; cbn; rewrite Hra, Hrb.
  apply map_ext_in.
  intros v Hv.
  apply in_seq in Hv.
  now symmetry; apply Hb.
}
assert (Hac : ∀ j, subm A 0 j = subm C 0 j). {
  intros.
  intros.
  destruct A as (lla).
  destruct C as (llc).
  cbn in *.
  unfold subm; f_equal.
  cbn - [ butn ].
  rewrite (List_map_nth_seq lla []).
  rewrite (List_map_nth_seq llc []).
  rewrite Hra, Hrc.
  do 2 rewrite <- map_butn.
  do 2 rewrite map_map.
  apply map_ext_in.
  intros u Hu.
  destruct (Nat.eq_dec u 0) as [Huz| Huz]. {
    subst u; cbn in Hu.
    now apply in_seq in Hu.
  }
  rewrite (List_map_nth_seq (nth u lla []) 0%F).
  rewrite (List_map_nth_seq (nth u llc []) 0%F).
  apply is_scm_mat_iff in Hsma.
  destruct Hsma as (_ & Hca').
  apply in_butn, in_seq in Hu.
  rewrite Hca'. 2: {
    cbn; apply nth_In.
    now rewrite Hra.
  }
  apply is_scm_mat_iff in Hsmc.
  destruct Hsmc as (_ & Hcc').
  rewrite Hcc'. 2: {
    cbn; apply nth_In.
    now rewrite Hrc.
  }
  f_equal; cbn; rewrite Hra, Hrc.
  apply map_ext_in.
  intros v Hv.
  apply in_seq in Hv.
  now symmetry; apply Hc.
}
unfold determinant; rewrite Hra, Hrb, Hrc.
cbn.
erewrite rngl_summation_eq_compat. 2: {
  intros j Hj.
  rewrite Hbc.
  rewrite rngl_mul_add_distr_l.
  rewrite rngl_mul_add_distr_r.
  rewrite Hab at 1.
  rewrite Hac at 1.
  easy.
}
cbn.
now apply rngl_summation_add_distr.
Qed.

(* If two rows (columns) in A are equal then det(A)=0. *)
(* https://math.vanderbilt.edu/sapirmv/msapir/proofdet1.html
   point 3 *)
(* doing it only when the first row is 0; can be generalized later *)

Definition δ_lt i k := Nat.b2n (i <? k).

Theorem subm_subm_swap : ∀ (A : matrix T) i j k l,
  subm (subm A i j) k l =
  subm (subm A (k + δ_lt i k) (l + δ_lt j l)) (i - δ_lt k i) (j - δ_lt l j).
Proof.
intros.
rewrite mat_eq_map_seq; symmetry.
rewrite mat_eq_map_seq; symmetry.
f_equal.
unfold δ_lt.
do 4 rewrite mat_nrows_subm.
unfold Nat.b2n; do 8 rewrite if_ltb_lt_dec.
destruct (lt_dec i (mat_nrows A)) as [Hir| Hir]. 2: {
  apply Nat.nlt_ge in Hir.
  rewrite Nat.sub_0_r.
  destruct (lt_dec i k) as [Hik| Hik]. {
    destruct (lt_dec k i) as [H| H]; [ flia Hik H | clear H ].
    rewrite Nat.sub_0_r.
    destruct (lt_dec k (mat_nrows A)) as [H| H]; [ flia Hir Hik H | clear H ].
    rewrite Nat.sub_0_r.
    destruct (lt_dec (k + 1) (mat_nrows A)) as [H| H]; [ flia Hir Hik H | ].
    clear H; rewrite Nat.sub_0_r.
    destruct (lt_dec i (mat_nrows A)) as [H| H]; [ flia Hir H | clear H ].
    rewrite Nat.sub_0_r.
    apply map_ext_in.
    intros u Hu; apply in_seq in Hu.
    destruct (lt_dec j l) as [Hjl| Hjl]. {
      destruct (lt_dec l j) as [H| H]; [ flia Hjl H | clear H ].
      rewrite Nat.sub_0_r.
      unfold subm; cbn.
      do 6 rewrite map_butn.
      rewrite nth_butn_after; [ | flia Hik Hir Hu ].
      rewrite nth_butn_after; [ | flia Hir Hu ].
      rewrite nth_butn_after; [ | flia Hir Hu ].
      rewrite nth_butn_after; [ | flia Hik Hir Hu ].
      do 2 rewrite map_map.
      f_equal.
      apply map_ext_in.
      intros la Hla.
      apply butn_butn; flia Hjl.
    } {
      apply Nat.nlt_ge in Hjl.
      rewrite Nat.add_0_r.
      destruct (lt_dec l j) as [Hlj| Hlj]. 2: {
        apply Nat.nlt_ge in Hlj.
        replace l with j by flia Hjl Hlj.
        clear l Hjl Hlj.
        rewrite Nat.sub_0_r.
        rewrite subm_subm_r_r; [ easy | flia Hik ].
      }
      rewrite (@subm_out_l _ (k + 1) i A); [ | flia Hir Hik | easy ].
      rewrite (@subm_out_l _ k i); cycle 1. {
        rewrite mat_nrows_subm; flia Hir Hik.
      } {
        rewrite mat_nrows_subm; flia Hir.
      }
      symmetry.
      destruct (lt_dec l (j - 1)) as [Hlj1| Hlj1]. 2: {
        apply Nat.nlt_ge in Hlj1.
        replace j with (l + 1) by flia Hlj Hlj1.
        rewrite Nat.add_sub.
        f_equal; f_equal.
        now apply subm_subm_l_l.
      }
      f_equal; f_equal.
      rewrite subm_subm_l_l; [ | flia Hlj1 ].
      rewrite Nat.sub_add; [ easy | flia Hlj ].
    }
  } {
    apply Nat.nlt_ge in Hik.
    rewrite Nat.add_0_r.
    destruct (lt_dec k i) as [Hki| Hki]. 2: {
      replace k with i by flia Hik Hki.
      clear k Hik Hki.
      destruct (lt_dec i (mat_nrows A)) as [H| H]; [ flia Hir H | clear H ].
      do 2 rewrite Nat.sub_0_r.
      destruct (lt_dec i (mat_nrows A)) as [H| H]; [ flia Hir H | clear H ].
      rewrite Nat.sub_0_r.
      destruct (lt_dec j l) as [Hjl| Hjl]. {
        rewrite subm_subm_l_l; [ | flia Hjl ].
        destruct (lt_dec l j) as [H| H]; [ flia Hjl H | clear H ].
        now rewrite Nat.sub_0_r.
      } {
        destruct (lt_dec l j) as [Hlj| Hlj]. 2: {
          replace l with j by flia Hjl Hlj.
          now rewrite Nat.add_0_r, Nat.sub_0_r.
        }
        rewrite Nat.add_0_r.
        symmetry.
        destruct (lt_dec l (j - 1)) as [Hlj1| Hlj1]. 2: {
          replace j with (l + 1) by flia Hlj Hlj1.
          rewrite Nat.add_sub.
          clear j Hjl Hlj Hlj1.
          rename l into j.
          now rewrite subm_subm_l_l.
        }
        clear Hjl Hlj.
        rewrite subm_subm_l_l; [ | flia Hlj1 ].
        rewrite Nat.sub_add; [ easy | flia Hlj1 ].
      }
    } {
      destruct (lt_dec k (mat_nrows A)) as [Hkr| Hkr]. {
        destruct (lt_dec (i - 1) (mat_nrows A - 1)) as [H| H];
          [ flia Hir H | clear H ].
        rewrite Nat.sub_0_r.
        destruct (lt_dec j l) as [Hjl| Hjl]. {
          destruct (lt_dec l j) as [H| H]; [ flia Hjl H | clear H ].
          rewrite Nat.sub_0_r.
          apply map_ext_in.
          intros m Hm.
          f_equal; f_equal; clear m Hm.
          rewrite subm_subm_exch; [ easy | easy | flia Hjl ].
        }
        destruct (lt_dec l j) as [Hlj| Hlj]. {
          rewrite Nat.add_0_r.
          apply map_ext_in.
          intros m Hm.
          f_equal; f_equal; clear m Hm.
          now apply subm_subm_exch'.
        }
        rewrite Nat.add_0_r, Nat.sub_0_r.
        replace l with j by flia Hjl Hlj.
        clear l Hjl Hlj.
        apply map_ext_in.
        intros l Hl.
        apply in_seq in Hl.
        destruct (lt_dec k (i - 1)) as [Hki1| Hki1]. {
          symmetry.
          rewrite subm_subm_r_r; [ | flia Hki1 ].
          rewrite Nat.sub_add; [ easy | flia Hki ].
        }
        assert (Hk : k = mat_nrows A - 1) by flia Hir Hki Hkr Hki1.
        assert (Hi : i = mat_nrows A) by flia Hir Hki Hkr Hki1.
        assert (Hr : mat_nrows A ≠ 0) by flia Hkr.
        clear Hir Hik Hki Hkr Hki1.
        rewrite <- Hi in Hl, Hk, Hr.
        replace i with (k + 1) by flia Hk Hi Hr.
        rewrite Nat.add_sub.
        rewrite subm_subm_l_l; [ | easy ].
        unfold subm; cbn.
        rewrite (List_map_nth' []). 2: {
          rewrite butn_length, map_length.
          rewrite butn_length, fold_mat_nrows.
          unfold Nat.b2n.
          do 2 rewrite if_ltb_lt_dec.
          rewrite <- Hi.
          destruct (lt_dec (k + 1) i) as [H| H]; [ flia Hk H | clear H ].
          rewrite Nat.sub_0_r.
          destruct (lt_dec k i) as [H| H]; [ flia Hl H | clear H ].
          rewrite Nat.sub_0_r; flia Hl Hi.
        }
        rewrite nth_butn_after; [ | flia Hl Hk ].
        rewrite (List_map_nth' []). 2: {
          rewrite butn_length, fold_mat_nrows, <- Hi.
          unfold Nat.b2n; rewrite if_ltb_lt_dec.
          destruct (lt_dec (k + 1) i); flia Hl Hi.
        }
        rewrite nth_butn_after; [ | flia Hl Hk ].
        do 3 rewrite map_butn.
        rewrite nth_butn_after; [ | flia Hl Hk ].
        rewrite nth_butn_after; [ | flia Hl Hk ].
        rewrite (List_map_nth' []). 2: {
          rewrite map_length, fold_mat_nrows, <- Hi; flia Hl.
        }
        rewrite (List_map_nth' []). 2: {
          rewrite fold_mat_nrows, <- Hi; flia Hl.
        }
        now rewrite butn_butn.
      }
      apply Nat.nlt_ge in Hkr.
      rewrite Nat.sub_0_r.
      destruct (lt_dec (i - 1) (mat_nrows A)) as [Hi1r| Hi1r]. 2: {
        apply Nat.nlt_ge in Hi1r.
        rewrite Nat.sub_0_r.
        apply map_ext_in.
        intros m Hm; apply in_seq in Hm.
        destruct (lt_dec j l) as [Hjl| Hjl]. {
          destruct (lt_dec l j) as [H| H]; [ flia Hjl H | clear H ].
          rewrite Nat.sub_0_r.
          rewrite subm_subm_exch; [ easy | easy | flia Hjl ].
        } {
          apply Nat.nlt_ge in Hjl.
          rewrite Nat.add_0_r.
          f_equal; f_equal.
          destruct (lt_dec l j) as [Hlj| Hlj]. 2: {
            replace l with j by flia Hjl Hlj.
            rewrite Nat.sub_0_r.
            destruct (lt_dec k (i - 1)) as [Hki1| Hki1]. {
              symmetry; rewrite subm_subm_r_r; [ | flia Hki1 ].
              rewrite Nat.sub_add; [ easy | flia Hki1 ].
            } {
              replace i with (k + 1) by flia Hki Hki1.
              rewrite Nat.add_sub.
              rewrite subm_subm_l_l; [ | easy ].
              rewrite (@subm_out_l _ (k + 1) k); [ | flia Hkr | easy ].
              now apply subm_subm_l_l.
            }
          } {
            now rewrite subm_subm_exch'.
          }
        }
      }
      flia Hki Hkr Hi1r.
    }
  }
}
destruct (lt_dec k (mat_nrows A - 1)) as [Hkr1| Hkr1]. 2: {
  apply Nat.nlt_ge in Hkr1.
  rewrite Nat.sub_0_r.
  destruct (lt_dec i k) as [Hik| Hik]. {
    destruct (lt_dec k i) as [H| H]; [ flia Hik H | clear H ].
    rewrite Nat.sub_0_r.
    destruct (lt_dec (k + 1) (mat_nrows A)) as [H| H]; [ flia Hkr1 H | ].
    clear H; rewrite Nat.sub_0_r.
    destruct (lt_dec i (mat_nrows A)) as [H| H]; [ clear H | flia Hir H ].
    apply map_ext_in.
    intros m Hm; apply in_seq in Hm.
    f_equal; f_equal.
    destruct (lt_dec j l) as [Hjl| Hjl]. {
      destruct (lt_dec l j) as [H| H]; [ flia Hjl H | clear H ].
      rewrite Nat.sub_0_r.
      symmetry.
      rewrite subm_subm_exch'; [ | flia Hik | flia Hjl ].
      now do 2 rewrite Nat.add_sub.
    } {
      apply Nat.nlt_ge in Hjl.
      rewrite Nat.add_0_r.
      destruct (lt_dec l j) as [Hlj| Hlj]. 2: {
        replace l with j by flia Hjl Hlj.
        rewrite Nat.sub_0_r.
        apply subm_subm_r_r; flia Hik.
      } {
        symmetry.
        destruct (lt_dec l (j - 1)) as [Hlj1| Hlj1]. {
          rewrite subm_subm_exch; [ | flia Hik | flia Hlj1 ].
          rewrite Nat.add_sub.
          rewrite Nat.sub_add; [ easy | flia Hlj ].
        }
        replace l with (j - 1) by flia Hlj Hlj1.
        rewrite <- subm_subm_exch''; [ | flia Hik ].
        rewrite Nat.sub_add; [ easy | flia Hlj ].
      }
    }
  } {
    apply Nat.nlt_ge in Hik.
    replace k with i by flia Hir Hkr1 Hik.
    assert (Hir1 : i = mat_nrows A - 1) by flia Hir Hkr1 Hik.
    assert (Hrz : mat_nrows A ≠ 0) by flia Hir.
    clear k Hir Hkr1 Hik.
    rewrite Nat.add_0_r.
    destruct (lt_dec i i) as [H| H]; [ flia H | clear H ].
    destruct (lt_dec i (mat_nrows A)) as [H| H]; [ | flia Hrz Hir1 H ].
    clear H; rewrite Nat.sub_0_r.
    destruct (lt_dec i (mat_nrows A - 1)) as [H| H]; [ flia Hir1 H | ].
    clear H; rewrite Nat.sub_0_r.
    apply map_ext_in.
    intros k Hk; apply in_seq in Hk.
    destruct (lt_dec j l) as [Hjl| Hjl]. {
      destruct (lt_dec l j) as [H| H]; [ flia Hjl H | clear H ].
      rewrite Nat.sub_0_r.
      rewrite subm_subm_l_l; [ easy | flia Hjl ].
    } {
      destruct (lt_dec l j) as [Hlj| Hlj]. 2: {
        replace l with j by flia Hjl Hlj.
        now rewrite Nat.add_0_r, Nat.sub_0_r.
      }
      clear Hjl; rewrite Nat.add_0_r.
      destruct (lt_dec l (j - 1)) as [Hlj1| Hlj1]. {
        symmetry.
        rewrite subm_subm_l_l; [ | flia Hlj ].
        rewrite Nat.sub_add; [ easy | flia Hlj ].
      }
      replace l with (j - 1) by flia Hlj Hlj1.
      symmetry.
      rewrite subm_subm_l_l; [ | easy ].
      rewrite Nat.sub_add; [ easy | flia Hlj ].
    }
  }
}
destruct (lt_dec i k) as [Hik| Hik]. {
  destruct (lt_dec (k + 1) (mat_nrows A)) as [H| H]; [ | flia Hkr1 H ].
  clear H.
  destruct (lt_dec k i) as [H| H]; [ flia Hik H | clear H ].
  rewrite Nat.sub_0_r.
  destruct (lt_dec i (mat_nrows A - 1)) as [Hir1| Hir1]. 2: {
    flia Hir Hir1 Hkr1 Hik.
  }
  apply map_ext_in.
  intros m Hm; apply in_seq in Hm.
  destruct (lt_dec j l) as [Hjl| Hjl]. {
    destruct (lt_dec l j) as [H| H]; [ flia Hjl H | clear H ].
    rewrite Nat.sub_0_r.
    symmetry.
    rewrite subm_subm_exch'; [ | flia Hik | flia Hjl ].
    now do 2 rewrite Nat.add_sub.
  } {
    destruct (lt_dec l j) as [Hlj| Hlj]. {
      rewrite Nat.add_0_r.
      f_equal; f_equal.
      destruct (lt_dec l (j - 1)) as [Hlj1| Hlj1]. {
        symmetry.
        rewrite subm_subm_exch; [ | flia Hik | flia Hlj1 ].
        rewrite Nat.sub_add; [ | flia Hlj ].
        now rewrite Nat.add_sub.
      }
      replace j with (l + 1) by flia Hlj Hlj1.
      rewrite Nat.add_sub.
      symmetry.
      rewrite subm_subm_exch''; [ easy | flia Hik ].
    }
    rewrite Nat.add_0_r, Nat.sub_0_r.
    f_equal; f_equal.
    replace j with l by flia Hjl Hlj.
    apply subm_subm_r_r; flia Hik.
  }
} {
  apply Nat.nlt_ge in Hik.
  rewrite Nat.add_0_r.
  destruct (lt_dec k i) as [Hki| Hki]. {
    destruct (lt_dec k (mat_nrows A)) as [H| H]; [ clear H | flia Hkr1 H ].
    destruct (lt_dec (i - 1) (mat_nrows A - 1)) as [H| H];
      [ clear H | flia Hir Hki H ].
    apply map_ext_in.
    intros m Hm; apply in_seq in Hm.
    destruct (lt_dec j l) as [Hjl| Hjl]. {
      destruct (lt_dec l j) as [H| H]; [ flia Hjl H | clear H ].
      rewrite Nat.sub_0_r.
      f_equal; f_equal.
      rewrite subm_subm_exch; [ easy | easy | flia Hjl ].
    }
    apply Nat.nlt_ge in Hjl.
    rewrite Nat.add_0_r.
    destruct (lt_dec l j) as [Hlj| Hlj]. 2: {
      rewrite Nat.sub_0_r.
      replace l with j by flia Hjl Hlj.
      f_equal; f_equal.
      destruct (lt_dec k (i - 1)) as [Hki1| Hki1]. {
        symmetry.
        rewrite subm_subm_r_r; [ | flia Hki1 ].
        rewrite Nat.sub_add; [ easy | flia Hki ].
      }
      replace i with (k + 1) by flia Hki Hki1.
      rewrite Nat.add_sub.
      rewrite subm_subm_l_l; [ | easy ].
      rewrite subm_subm_exch; [ | flia | easy ].
      now rewrite Nat.add_sub.
    }
    f_equal; f_equal.
    now apply subm_subm_exch'.
  }
  replace i with k by flia Hik Hki.
  clear i Hir Hik Hki.
  rename k into i.
  rewrite Nat.sub_0_r.
  destruct (lt_dec i (mat_nrows A)) as [H| H]; [ clear H | flia Hkr1 H ].
  destruct (lt_dec i (mat_nrows A - 1)) as [H| H]; [ | flia Hkr1 H ].
  clear H.
  apply map_ext_in.
  intros k Hk; apply in_seq in Hk.
  f_equal; f_equal.
  destruct (lt_dec j l) as [Hjl| Hjl]. {
    destruct (lt_dec l j) as [H| H]; [ flia Hjl H | clear H ].
    rewrite Nat.sub_0_r.
    rewrite subm_subm_l_l; [ easy | flia Hjl ].
  }
  rewrite Nat.add_0_r.
  destruct (lt_dec l j) as [Hlj| Hlj]. {
    symmetry.
    rewrite subm_subm_l_l; [ | flia Hlj ].
    rewrite Nat.sub_add; [ easy | flia Hlj ].
  }
  rewrite Nat.sub_0_r.
  now replace l with j by flia Hjl Hlj.
}
Qed.

End a.

Arguments determinant {T ro} M%M.
Arguments determinant_alternating {T}%type {ro rp} _ M%M [p q]%nat.
Arguments determinant_same_rows {T}%type {ro rp} _ M%M [p q]%nat.
Arguments det_from_row {T}%type {ro} {n}%nat M%M i%nat.
Arguments det_from_col {T}%type {ro} {n}%nat M%M j%nat.
Arguments det_is_det_by_canon_permut {T}%type {ro rp} _ M%M.
Arguments subm {T} M%M i%nat j%nat.
