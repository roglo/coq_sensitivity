Set Nested Proofs Allowed.
Set Implicit Arguments.

Require Import Utf8 Arith Bool.
Require Import Permutation.
Import List List.ListNotations.

Require Import Misc RingLike MyVector Matrix PermutSeq.
Require Import RLsummation RLproduct.
Import matrix_Notations.

Section a.

Context {T : Type}.
Context (ro : ring_like_op T).
Context (rp : ring_like_prop T).

(* determinant *)

Fixpoint det_loop {n} (M : matrix n n T) i :=
  match i with
  | 0 => 1%F
  | S i' =>
      (Σ (j = 0, i'),
       minus_one_pow j * mat_el M 0 j * det_loop (subm M 0 j) i')%F
  end.

Definition mat_permut_fun_rows n (σ : nat → nat) (M : matrix n n T) :=
  mk_mat n n (λ i j, mat_el M (σ i) j).

Definition mat_permut_rows n (σ : vector n nat) (M : matrix n n T) :=
  mat_permut_fun_rows (vect_el σ) M.

Definition determinant {n} (M : matrix n n T) := det_loop M n.

(* the following versions of computing the determinant should
   (to be proven) be equivalent; perhaps could help for proving
   Cramer's rule of resolving equations *)

Definition det_from_row {n} (M : matrix n n T) i :=
  (minus_one_pow i *
   Σ (j = 0, n - 1),
     minus_one_pow j * mat_el M i j * determinant (subm M i j))%F.

Definition det_from_col {n} (M : matrix n n T) j :=
  (minus_one_pow j *
   Σ (i = 0, n - 1),
     minus_one_pow i * mat_el M i j * determinant (subm M i j))%F.

(* Alternative version of the determinant: sum of product of the
   factors a_{i,σ(i)} where σ goes through all permutations of
   the naturals of the interval [0, n-1].
   The permutations generated are in the same order as the
   terms generated by the determinant defined by induction on
   the size of the matrix.
     The order happens to be the canonical (alphabetical) order.
   Example for n=3
     = [[0; 1; 2]; [0; 2; 1]; [1; 0; 2]; [1; 2; 0]; [2; 0; 1]; [2; 1; 0]]
   Having the same terms order, the proof of equality of both definitions
   of both determinants is easy.
   See PermutSeq.v *)

Theorem rngl_summation_change_var : ∀ A b e f g (h : _ → A),
  (∀ i, b ≤ i ≤ e → g (h i) = i)
  → (Σ (i = b, e), f i = Σ (i ∈ map h (seq b (S e - b))), f (g i))%F.
Proof.
intros * Hgh.
unfold iter_seq, iter_list.
rewrite List_fold_left_map.
apply List_fold_left_ext_in.
intros i c Hi.
f_equal; f_equal; symmetry.
apply Hgh.
apply in_seq in Hi.
flia Hi.
Qed.

(* definition of determinant by sum of products involving all
   permutations *)

Definition determinant' n (M : matrix n n T) :=
  (Σ (k = 0, fact n - 1), ε (canon_permut n k) *
   Π (i = 1, n), mat_el M (i - 1) (vect_el (canon_permut n k) (i - 1)%nat))%F.

(* Proof that both definitions of determinants are equal *)

Theorem det_is_det_by_canon_permut :
  rngl_is_comm = true →
  rngl_has_opp = true →
  rngl_has_inv = true →
  rngl_is_integral = true →
  rngl_has_1_neq_0 = true →
  rngl_has_dec_eq = true →
  rngl_characteristic = 0 →
  ∀ n (M : matrix n n T), determinant M = determinant' M.
Proof.
intros Hic Hop Hin Hit H10 Hde Hch *.
unfold determinant, determinant'.
destruct n; intros. {
  unfold iter_seq, iter_list.
  cbn; rewrite rngl_add_0_l.
  unfold ε, ε_fun, iter_seq, iter_list; cbn.
  rewrite rngl_div_1_r; [ | now left | easy ].
  symmetry; apply rngl_mul_1_l.
}
erewrite rngl_summation_eq_compat. 2: {
  intros i Hi.
  rewrite rngl_product_succ_succ.
  erewrite rngl_product_eq_compat. 2: {
    intros j Hj.
    now rewrite Nat.sub_succ, Nat.sub_0_r.
  }
  easy.
}
cbn - [ fact det_loop canon_permut ε ].
revert M.
induction n; intros. {
  cbn.
  unfold ε, ε_fun, iter_seq, iter_list; cbn.
  do 2 rewrite rngl_add_0_l.
  do 3 rewrite rngl_mul_1_l.
  rewrite rngl_div_1_r; [ | now left | easy ].
  rewrite rngl_mul_1_l.
  now rewrite rngl_mul_1_r.
}
remember (S n) as sn.
cbn - [ fact "mod" "/" canon_permut ]; subst sn.
erewrite rngl_summation_eq_compat. 2: {
  intros i Hi.
  now rewrite IHn.
}
cbn - [ fact "mod" "/" canon_permut ].
erewrite rngl_summation_eq_compat. 2: {
  intros i Hi.
  now rewrite rngl_mul_summation_distr_l.
}
cbn - [ fact "mod" "/" canon_permut ].
rewrite rngl_summation_summation_distr; [ | easy ].
rewrite <- Nat.sub_succ_l; [ | apply lt_O_fact ].
rewrite Nat.sub_succ, Nat.sub_0_r.
rewrite <- Nat_fact_succ.
symmetry.
erewrite rngl_summation_eq_compat. 2: {
  intros i Hi.
  rewrite rngl_product_split_first; [ | flia ].
  rewrite rngl_product_succ_succ.
  easy.
}
cbn - [ fact "mod" "/" canon_permut ].
symmetry.
apply rngl_summation_eq_compat.
intros k Hk.
do 2 rewrite rngl_mul_assoc.
f_equal. 2: {
  apply rngl_product_eq_compat.
  intros i Hi.
  now rewrite Nat.add_1_r.
}
rewrite rngl_mul_mul_swap; [ | easy ].
symmetry.
f_equal.
apply ε_of_canon_permut_succ; try easy.
specialize (fact_neq_0 (S (S n))) as Hnz.
flia Hk Hnz.
Qed.

(* multilinearity *)

Theorem determinant_multilinear :
  rngl_is_comm = true →
  rngl_has_opp = true →
  rngl_has_inv = true →
  rngl_is_integral = true →
  rngl_has_1_neq_0 = true →
  rngl_has_dec_eq = true →
  rngl_characteristic = 0 →
  ∀ n (M : matrix n n T) i a b U V,
    i < n
    → determinant (mat_repl_vect i M (a × U + b × V)%V) =
         (a * determinant (mat_repl_vect i M U) +
          b * determinant (mat_repl_vect i M V))%F.
Proof.
intros Hic Hop Hin Hit H10 Hde Hch * Hi.
rewrite det_is_det_by_canon_permut; try easy.
rewrite det_is_det_by_canon_permut; try easy.
rewrite det_is_det_by_canon_permut; try easy.
unfold determinant'.
erewrite rngl_summation_eq_compat. 2: {
  intros k Hk.
  erewrite rngl_product_eq_compat. 2: {
    intros j Hj.
    now cbn.
  }
  easy.
}
cbn.
rewrite rngl_mul_summation_distr_l.
rewrite rngl_mul_summation_distr_l.
symmetry.
erewrite rngl_summation_eq_compat. 2: {
  intros k Hk.
  rewrite rngl_mul_assoc.
  now rewrite (rngl_mul_comm Hic a).
}
rewrite rngl_add_comm.
erewrite rngl_summation_eq_compat. 2: {
  intros k Hk.
  rewrite rngl_mul_assoc.
  now rewrite (rngl_mul_comm Hic b).
}
rewrite rngl_add_comm.
rewrite <- rngl_summation_add_distr; [ | easy ].
apply rngl_summation_eq_compat.
intros k Hk.
do 2 rewrite <- rngl_mul_assoc.
rewrite <- rngl_mul_add_distr_l.
f_equal.
assert (Hkn : k < fact n). {
  specialize (fact_neq_0 n) as Hnz.
  flia Hk Hnz.
}
specialize (canon_permut_vect_surjective Hkn Hi) as Hp.
destruct Hp as (p & Hp & Hpp).
rewrite (rngl_product_split (p + 1)); [ | flia Hp ].
rewrite rngl_product_split_last; [ | flia ].
erewrite rngl_product_eq_compat. 2: {
  intros j Hj.
  replace (j - 1 - 1) with (j - 2) by flia.
  destruct (Nat.eq_dec (vect_el (canon_permut n k) (j - 2)) i) as [Hpj| Hpj]. {
    exfalso.
    rewrite <- Hpp in Hpj.
    apply canon_permut_vect_injective in Hpj; [ | easy | flia Hp Hj | easy ].
    flia Hj Hpj.
  }
  easy.
}
rewrite (rngl_mul_comm Hic (iter_seq _ _ _ _)).
rewrite rngl_add_comm.
rewrite (rngl_product_split (p + 1)); [ | flia Hp ].
rewrite rngl_product_split_last; [ | flia ].
erewrite rngl_product_eq_compat. 2: {
  intros j Hj.
  replace (j - 1 - 1) with (j - 2) by flia.
  destruct (Nat.eq_dec (vect_el (canon_permut n k) (j - 2)) i) as [Hpj| Hpj]. {
    exfalso.
    rewrite <- Hpp in Hpj.
    apply canon_permut_vect_injective in Hpj; [ | easy | flia Hp Hj | easy ].
    flia Hj Hpj.
  }
  easy.
}
rewrite (rngl_mul_comm Hic (iter_seq _ _ _ _)).
rewrite rngl_add_comm.
symmetry.
rewrite (rngl_product_split (p + 1)); [ | flia Hp ].
rewrite rngl_product_split_last; [ | flia ].
erewrite rngl_product_eq_compat. 2: {
  intros j Hj.
  replace (j - 1 - 1) with (j - 2) by flia.
  destruct (Nat.eq_dec (vect_el (canon_permut n k) (j - 2)) i) as [Hpj| Hpj]. {
    exfalso.
    rewrite <- Hpp in Hpj.
    apply canon_permut_vect_injective in Hpj; [ | easy | flia Hp Hj | easy ].
    flia Hj Hpj.
  }
  easy.
}
rewrite (rngl_mul_comm Hic (iter_seq _ _ _ _)).
rewrite Nat.add_sub.
rewrite Hpp.
destruct (Nat.eq_dec i i) as [H| H]; [ clear H | easy ].
do 4 rewrite rngl_mul_assoc.
remember
  (Π (i0 = 2, p + 1),
   mat_el M (i0 - 2) (vect_el (canon_permut n k) (i0 - 2)%nat))%F
  as q eqn:Hq.
rewrite (rngl_mul_mul_swap Hic _ _ q).
do 3 rewrite (rngl_mul_comm Hic _ q).
do 5 rewrite <- rngl_mul_assoc.
rewrite <- rngl_mul_add_distr_l.
f_equal.
clear q Hq.
erewrite rngl_product_eq_compat. 2: {
  intros j Hj.
  destruct (Nat.eq_dec (vect_el (canon_permut n k) (j - 1)) i) as [Hpj| Hpj]. {
    rewrite <- Hpp in Hpj.
    apply canon_permut_vect_injective in Hpj; [ | easy | flia Hp Hj | easy ].
    flia Hj Hpj.
  }
  easy.
}
symmetry.
erewrite rngl_product_eq_compat. 2: {
  intros j Hj.
  destruct (Nat.eq_dec (vect_el (canon_permut n k) (j - 1)) i) as [Hpj| Hpj]. {
    rewrite <- Hpp in Hpj.
    apply canon_permut_vect_injective in Hpj; [ | easy | flia Hp Hj | easy ].
    flia Hj Hpj.
  }
  easy.
}
rewrite rngl_add_comm.
erewrite rngl_product_eq_compat. 2: {
  intros j Hj.
  destruct (Nat.eq_dec (vect_el (canon_permut n k) (j - 1)) i) as [Hpj| Hpj]. {
    rewrite <- Hpp in Hpj.
    apply canon_permut_vect_injective in Hpj; [ | easy | flia Hp Hj | easy ].
    flia Hj Hpj.
  }
  easy.
}
cbn.
rewrite rngl_add_comm.
do 2 rewrite rngl_mul_assoc.
now rewrite <- rngl_mul_add_distr_r.
Qed.

(* list of terms in determinant' (determinant by sum of products of
   permutations *)

Definition determinant'_list {n} (M : matrix n n T) :=
  map (λ k,
    (ε_canon_permut n k *
     Π (i = 1, n), mat_el M (i - 1) (vect_el (canon_permut n k) (i - 1)%nat))%F)
    (seq 0 (fact n)).

Theorem determinant'_by_list :
  rngl_is_comm = true →
  rngl_has_opp = true →
  rngl_has_inv = true →
  rngl_has_1_neq_0 = true →
  rngl_is_integral = true →
  rngl_has_dec_eq = true →
  rngl_characteristic = 0 →
  ∀ n (M : matrix n n T),
  determinant' M = (Σ (k = 0, fact n - 1), nth k (determinant'_list M) 0)%F.
Proof.
intros Hic Hop Hin H10 Hit Hde Hch *.
unfold determinant', determinant'_list.
apply rngl_summation_eq_compat; intros k Hk.
assert (Hkn : k < fact n). {
  specialize (fact_neq_0 n) as Hn.
  flia Hk Hn.
}
rewrite List_map_nth_in with (a := 0); [ | now rewrite seq_length ].
rewrite seq_nth; [ | easy ].
rewrite Nat.add_0_l.
f_equal.
now apply ε_of_canon_permut_ε.
Qed.

Theorem rngl_summation_permut : ∀ n l1 l2,
  Permutation l1 l2
  → length l1 = n
  → length l2 = n
  → (Σ (i = 0, n - 1), nth i l1 0 = Σ (i = 0, n - 1), nth i l2 0)%F.
Proof.
intros * Hl H1 H2.
destruct n. {
  apply length_zero_iff_nil in H1.
  apply length_zero_iff_nil in H2.
  now subst l1 l2.
}
rewrite Nat.sub_succ, Nat.sub_0_r.
revert n H1 H2.
induction Hl; intros; [ easy | | | ]. {
  cbn in H1, H2.
  apply Nat.succ_inj in H1.
  apply Nat.succ_inj in H2.
  rewrite rngl_summation_split_first; [ symmetry | easy | flia ].
  rewrite rngl_summation_split_first; [ symmetry | easy | flia ].
  destruct n; [ easy | ].
  do 2 rewrite rngl_summation_succ_succ.
  now rewrite IHHl.
} {
  destruct n; [ easy | ].
  cbn in H1, H2.
  do 2 apply Nat.succ_inj in H1.
  do 2 apply Nat.succ_inj in H2.
  rewrite rngl_summation_split_first; [ symmetry | easy | flia ].
  rewrite rngl_summation_split_first; [ symmetry | easy | flia ].
  rewrite rngl_summation_split_first; [ symmetry | easy | flia ].
  rewrite rngl_summation_split_first; [ symmetry | easy | flia ].
  do 2 rewrite rngl_add_assoc.
  do 2 rewrite rngl_summation_succ_succ.
  f_equal; [ apply rngl_add_comm | ].
  apply rngl_summation_eq_compat.
  intros i Hi; cbn.
  destruct i; [ flia Hi | easy ].
} {
  specialize (Permutation_length Hl2) as H3.
  rewrite H2 in H3.
  rewrite IHHl1; [ | easy | easy ].
  now rewrite IHHl2.
}
Qed.

Theorem det_is_det_by_any_permut :
  rngl_is_comm = true →
  rngl_has_opp = true →
  rngl_has_inv = true →
  rngl_is_integral = true →
  rngl_has_1_neq_0 = true →
  rngl_has_dec_eq = true →
  rngl_characteristic = 0 →
  ∀ n (M : matrix n n T) l,
  Permutation l (determinant'_list M)
  → determinant M = (Σ (k = 0, fact n - 1), nth k l 0)%F.
Proof.
intros Hic Hop Hin Hit H10 Hde Hch * Hl.
rewrite det_is_det_by_canon_permut; try easy.
rewrite determinant'_by_list; try easy.
apply rngl_summation_permut; [ now symmetry | | ]. {
  unfold determinant'_list.
  now rewrite map_length, seq_length.
} {
  apply Permutation_length in Hl.
  unfold determinant'_list in Hl.
  now rewrite map_length, seq_length in Hl.
}
Qed.

(* yet another definition of determinant *)

Definition determinant'' p q n (M : matrix n n T) :=
  (Σ (k = 0, fact n - 1), ε_canon_permut n k *
   Π (i = 1, n),
   mat_el M (i - 1) (vect_el (canon_permut_swap_last p q n k) (i - 1)%nat))%F.

Definition determinant''_list p q {n} (M : matrix n n T) :=
  map (λ k,
    (ε_canon_permut n k *
     Π (i = 1, n),
     mat_el M (i - 1) (vect_el (canon_permut_swap_last p q n k) (i - 1)%nat))%F)
    (seq 0 (fact n)).

Theorem determinant''_by_list : ∀ n p q (M : matrix n n T),
  determinant'' p q M =
    (Σ (k = 0, fact n - 1), nth k (determinant''_list p q M) 0)%F.
Proof.
intros.
unfold determinant'', determinant''_list.
apply rngl_summation_eq_compat; intros k Hk.
assert (Hkn : k < fact n). {
  specialize (fact_neq_0 n) as Hn.
  flia Hk Hn.
}
rewrite List_map_nth_in with (a := 0); [ | now rewrite seq_length ].
rewrite seq_nth; [ | easy ].
now rewrite Nat.add_0_l.
Qed.

Definition mat_swap_rows n i1 i2 (M : matrix n n T) :=
  mk_mat n n
    (λ i j,
     if Nat.eq_dec i i1 then mat_el M i2 j
     else if Nat.eq_dec i i2 then mat_el M i1 j
     else mat_el M i j).

Theorem determinant_alternating :
  rngl_is_comm = true →
  rngl_has_opp = true →
  rngl_has_inv = true →
  rngl_is_integral = true →
  rngl_has_1_neq_0 = true →
  rngl_has_dec_eq = true →
  rngl_characteristic = 0 →
  ∀ n (M : matrix n n T) p q,
  p ≠ q
  → p < n
  → q < n
  → determinant (mat_swap_rows p q M) = (- determinant M)%F.
Proof.
intros Hic Hop Hin Hit H10 Hde Hch * Hpq Hp Hq.
rewrite det_is_det_by_canon_permut; try easy.
unfold determinant'.
erewrite rngl_summation_eq_compat. 2: {
  intros k Hk.
  rewrite rngl_product_shift; [ | flia Hp ].
  erewrite rngl_product_eq_compat. 2: {
    intros i Hi.
    now rewrite Nat.add_comm, Nat.add_sub.
  }
  easy.
}
cbn - [ mat_swap_rows ].
erewrite rngl_summation_eq_compat. 2: {
  intros k Hk.
  rewrite rngl_product_change_var with
    (g := transposition p q) (h := transposition p q). 2: {
    intros i Hi.
    apply transposition_involutive.
  }
  rewrite Nat.sub_0_r.
  rewrite <- Nat.sub_succ_l; [ | flia Hp ].
  rewrite Nat.sub_succ, Nat.sub_0_r.
  easy.
}
cbn - [ mat_swap_rows ].
erewrite rngl_summation_eq_compat. 2: {
  intros k Hk.
  rewrite rngl_product_list_permut with (l2 := seq 0 n); [ | easy | ]. 2: {
    apply permut_fun_Permutation.
    now apply transposition_is_permut_fun.
  }
  easy.
}
cbn - [ mat_swap_rows ].
erewrite rngl_summation_eq_compat. 2: {
  intros k Hk.
  erewrite rngl_product_list_eq_compat. 2: {
    intros i Hi.
    replace (mat_el _ _ _) with
      (mat_el M i (vect_el (canon_permut n k) (transposition p q i))). 2: {
      cbn.
      unfold transposition.
      do 2 rewrite if_eqb_eq_dec.
      destruct (Nat.eq_dec i p) as [Hip| Hip]. {
        subst i.
        apply Nat.neq_sym in Hpq.
        destruct (Nat.eq_dec q p) as [Hqp| Hqp]; [ easy | ].
        now destruct (Nat.eq_dec q q).
      }
      destruct (Nat.eq_dec i q) as [Hiq| Hiq]. {
        subst i.
        apply Nat.neq_sym in Hpq.
        now destruct (Nat.eq_dec p p).
      }
      destruct (Nat.eq_dec i p) as [H| H]; [ easy | clear H ].
      destruct (Nat.eq_dec i q) as [H| H]; [ easy | clear H ].
      easy.
    }
    easy.
  }
  easy.
}
cbn - [ mat_swap_rows ].
set (f := λ k, vect_swap_elem (canon_permut n k) p q).
erewrite rngl_summation_eq_compat. 2: {
  intros k Hk.
  assert (Hkn : k < n!). {
    specialize (fact_neq_0 n) as Hn.
    flia Hk Hn.
  }
  erewrite rngl_product_seq_product; [ | flia Hp ].
  rewrite Nat.add_0_l.
  erewrite rngl_product_eq_compat. 2: {
    intros i Hi.
    now replace (vect_el _ _) with (vect_el (f k) i).
  }
  cbn - [ f ].
  replace (canon_permut n k) with
    (mk_vect n (λ i, vect_el (f k) (transposition p q i))). 2: {
    apply vector_eq.
    intros i Hi; cbn.
    now rewrite transposition_involutive.
  }
  replace (mk_vect n (λ i, vect_el (f k) (transposition p q i))) with
    (f k ° mk_vect n (transposition p q)) by easy.
  rewrite signature_comp; try easy. {
    subst f; cbn.
    split; cbn. {
      intros i Hi.
      apply vect_el_permut_ub; [ now apply canon_permut_is_permut | ].
      now apply transposition_lt.
    } {
      intros * Hi Hj Hij.
      apply canon_permut_vect_injective in Hij; [ | easy | | ]; cycle 1. {
        now apply transposition_lt.
      } {
        now apply transposition_lt.
      }
      now apply transposition_injective in Hij.
    }
  } {
    split; cbn. {
      intros i Hi.
      now apply transposition_lt.
    } {
      intros * Hi Hj Hij.
      now apply transposition_injective in Hij.
    }
  }
}
cbn - [ f ].
erewrite rngl_summation_eq_compat. 2: {
  intros k (_, Hk).
  rewrite (rngl_mul_comm Hic (ε (f k))).
  rewrite <- rngl_mul_assoc.
  now rewrite transposition_signature.
}
cbn - [ f ].
rewrite <- rngl_mul_summation_distr_l.
rewrite rngl_mul_opp_l; [ | easy ].
f_equal.
rewrite rngl_mul_1_l.
symmetry.
set (g := λ k, nat_of_canon_permut (f k)).
rewrite rngl_summation_change_var with (g := g) (h := g). 2: {
  intros k (_, Hk).
  assert (Hkn : k < n!). {
    specialize (fact_neq_0 n) as Hn.
    flia Hk Hn.
  }
  unfold g, f.
  rewrite permut_nat_of_canon_permut. 2: {
    apply vect_swap_elem_is_permut; [ easy | easy | ].
    now apply canon_permut_is_permut.
  }
  rewrite vect_swap_elem_involutive.
  now apply nat_of_canon_permut_permut.
}
rewrite Nat.sub_0_r.
rewrite <- Nat.sub_succ_l; [ | apply Nat.neq_0_lt_0, fact_neq_0 ].
rewrite Nat.sub_succ, Nat.sub_0_r.
rewrite rngl_summation_list_permut with (l2 := seq 0 n!); [ | easy | ]. 2: {
  apply permut_fun_Permutation.
  unfold g, f.
  split. {
    intros i Hi.
    apply nat_of_canon_permut_upper_bound.
    apply vect_swap_elem_is_permut; [ easy | easy | ].
    now apply canon_permut_is_permut.
  } {
    intros * Hi Hj Hij.
    apply nat_of_canon_permut_injective in Hij; cycle 1. {
      apply vect_swap_elem_is_permut; [ easy | easy | ].
      now apply canon_permut_is_permut.
    } {
      apply vect_swap_elem_is_permut; [ easy | easy | ].
      now apply canon_permut_is_permut.
    }
    apply vect_swap_elem_injective in Hij.
    now apply canon_permut_injective in Hij.
  }
}
erewrite rngl_summation_list_eq_compat. 2: {
  intros k Hk.
  assert (Hkn : k < n!). {
    apply in_seq in Hk.
    specialize (fact_neq_0 n) as Hn.
    flia Hk Hn.
  }
  unfold g, f.
  rewrite permut_nat_of_canon_permut. 2: {
    apply vect_swap_elem_is_permut; [ easy | easy | ].
    now apply canon_permut_is_permut.
  }
  rewrite vect_swap_elem_involutive.
  easy.
}
rewrite det_is_det_by_canon_permut; try easy.
unfold determinant'.
rewrite rngl_summation_seq_summation; [ | apply fact_neq_0 ].
rewrite Nat.add_0_l.
apply rngl_summation_eq_compat.
intros k Hk; f_equal.
rewrite rngl_product_shift; [ | flia Hp ].
apply rngl_product_eq_compat.
intros i Hi.
now rewrite Nat.add_comm, Nat.add_sub.
Qed.

(* transpositions list of permutation *)

Fixpoint first_non_fixpoint it i σ :=
  match it with
  | 0 => None
  | S it' => if i =? σ i then first_non_fixpoint it' (i + 1) σ else Some i
  end.

Fixpoint tvop_loop it n (σ : nat → nat) :=
  match it with
  | 0 => []
  | S it' =>
      match first_non_fixpoint n 0 σ with
      | None => []
      | Some i =>
          let σ' k :=
            if σ k =? i then σ i else if σ k =? σ i then i else σ k
          in
          (i, σ i) :: tvop_loop it' n σ'
      end
  end.

Definition transp_list_of_permut_fun n (σ : nat → nat) := tvop_loop n n σ.

Definition transp_list_of_permut {n} (σ : vector n nat) :=
  transp_list_of_permut_fun n (vect_el σ).

Definition transp_fun_of_nat_pair '(i, j) := transposition i j.

Definition transp_of_nat_pair n '(i, j) :=
  mk_vect n (transp_fun_of_nat_pair (i, j)).

Definition vect_size {T n} (v : vector n T) := n.

Compute transp_list_of_permut (vect_of_list 0 [0;5;1;2;4;3]).
Compute transp_list_of_permut (vect_of_list 0 [0;4;1;2;5;3]).
Compute (transp_list_of_permut (vect_of_list 0 [1;0;2;3;4;5])).
Compute (transp_list_of_permut (vect_of_list 0 [1;2;0;3;4;5])).
Compute (transp_list_of_permut (vect_of_list 0 [5;4;3;2;1;0])).
Compute (transp_list_of_permut (vect_of_list 0 [4;0;1;2;3;5])).
(*
     = [(0, 4); (1, 4); (2, 4); (3, 4)]
     = τ 3 4 ° τ 2 4 ° τ 1 4 ° τ 0 4 ° id
[0;1;2;3;4;5] → τ 0 4
[4;1;2;3;0;5] → τ 1 4
[4;0;2;3;1;5] → τ 2 4
[4;0;1;3;2;5] → τ 3 4
[4;0;1;2;3;5]
*)

Compute (transp_list_of_permut (vect_of_list 0 [3;4;0;1;2;5])).
Compute let n := 4 in map (λ k, list_of_vect (canon_permut n k)) (seq 0 n!).
Compute let n := 4 in map (λ k, (list_of_vect (canon_permut n k), transp_list_of_permut (canon_permut n k))) (seq 0 n!).

Compute let σ := vect_of_list 0 [1;2;0] in let n := vect_size σ in list_of_vect (iter_list (map (transp_of_nat_pair n) (transp_list_of_permut σ)) (λ σ τ, τ ° σ) σ).
Compute let σ := vect_of_list 0 [1;2;0] in let n := vect_size σ in list_of_vect (iter_list (map (transp_of_nat_pair n) (transp_list_of_permut σ)) (λ σ τ, σ ° τ) (mk_vect n (λ i, i))).

Compute let σ := vect_of_list 0 [0;5;1;2;4;3] in let n := vect_size σ in list_of_vect (iter_list (map (transp_of_nat_pair n) (transp_list_of_permut σ)) (λ σ τ, τ ° σ) σ).
Compute let σ := vect_of_list 0 [0;5;1;2;4;3] in let n := vect_size σ in list_of_vect (iter_list (map (transp_of_nat_pair n) (transp_list_of_permut σ)) (λ σ τ, σ ° τ) (mk_vect n (λ i, i))).

...

Compute let σ := vect_of_list 0 [3;4;0;1;2;5] in let n := vect_size σ in list_of_vect (iter_list (map (transp_of_nat_pair n) (transp_list_of_permut σ)) (λ σ τ, τ ° σ) σ).

...


Compute let σ := vect_of_list 0 [1;2;0] in let n := vect_size σ in list_of_vect (iter_list (map (transp_of_nat_pair n) (transp_list_of_permut σ)) (λ σ τ, σ ° τ) σ).

Compute let σ := vect_of_list 0 [0;5;1;2;4;3] in let n := vect_size σ in list_of_vect (iter_list (map (transp_of_nat_pair n) (transp_list_of_permut σ)) (λ σ τ, σ ° τ) σ).
Compute let σ := vect_of_list 0 [3;4;0;1;2;5] in let n := vect_size σ in list_of_vect (iter_list (map (transp_of_nat_pair n) (transp_list_of_permut σ)) (λ σ τ, σ ° τ) σ).

...

Theorem glop : ∀ n σ,
  n ≠ 0
  → is_permut_fun σ n
  → ∀ k it,
    n ≤ it
    → iter_list (map transp_fun_of_nat_pair (tvop_loop n it σ)) comp σ k = k.
Proof.
intros * Hnz Hp * Hit.
destruct it; [ flia Hnz Hit | ].
cbn.
remember (first_non_fixpoint n 0 σ) as x eqn:Hx; symmetry in Hx.
destruct x as [(i, j)| ]. {
  cbn.
  unfold iter_list; cbn.
...

Theorem apply_transp_list_of_permut_is_id : ∀ n (σ : nat → nat),
  is_permut_fun σ n
  → ∀ i,
    iter_list
      (map transp_fun_of_nat_pair (transp_list_of_permut_fun n σ))
      comp σ i = i.
Proof.
intros * Hp k.
unfold transp_list_of_permut_fun.
...

Theorem apply_transp_list_of_permut : ∀ n (σ : vector n nat),
  is_permut σ
  → iter_list (map (transp_of_nat_pair n) (transp_list_of_permut σ))
      (λ v τ, τ ° v) σ =
    mk_vect n (λ i, i).
Proof.
intros * Hp.
apply vector_eq.
intros i Hi; cbn.
unfold transp_of_nat_pair.
unfold transp_list_of_permut.
rename i into k.
...

Theorem determinant_alternating_permut_fun :
  rngl_is_comm = true →
  rngl_has_opp = true →
  rngl_has_inv = true →
  rngl_is_integral = true →
  rngl_has_1_neq_0 = true →
  rngl_has_dec_eq = true →
  rngl_characteristic = 0 →
  ∀ n (M : matrix n n T) σ,
  n ≠ 0
  → is_permut_fun σ n
  → determinant (mat_permut_fun_rows σ M) = (ε_fun σ n * determinant M)%F.
Proof.
intros Hic Hop Hin Hit H10 Hde Hch * Hnz Hp.
(* prove that any permutation is a sequence of transpositions
   then apply determinant alternating in sequence *)
...
Check determinant_alternating.
Check det_is_det_by_any_permut.
Print determinant'_list.
...
intros Hic Hop Hin Hit H10 Hde Hch * Hnz Hp.
destruct n; [ easy | clear Hnz; cbn ].
revert σ M Hp.
induction n; intros. {
  cbn.
  unfold iter_seq, iter_list; cbn.
  do 2 rewrite rngl_add_0_l.
  do 2 rewrite rngl_mul_1_l, rngl_mul_1_r.
  destruct Hp as (Hp1, Hp2).
  specialize (Hp1 0 Nat.lt_0_1).
  apply Nat.lt_1_r in Hp1; rewrite Hp1.
  symmetry; rewrite <- rngl_mul_1_l; f_equal.
  unfold ε, ε_fun; cbn.
  unfold iter_seq, iter_list; cbn.
  apply rngl_mul_inv_r; [ now left | ].
  do 2 rewrite rngl_mul_1_l.
  now apply rngl_1_neq_0.
}
cbn.
...
*)

Theorem determinant_alternating_permut :
  rngl_is_comm = true →
  rngl_has_opp = true →
  rngl_has_inv = true →
  rngl_is_integral = true →
  rngl_has_1_neq_0 = true →
  rngl_has_dec_eq = true →
  rngl_characteristic = 0 →
  ∀ n (M : matrix n n T) σ,
  n ≠ 0
  → is_permut σ
  → determinant (mat_permut_rows σ M) = (ε σ * determinant M)%F.
Proof.
intros Hic Hop Hin Hit H10 Hde Hch * Hnz Hp.
...
now apply determinant_alternating_permut_fun.
...
*)

(* If we add a row (column) of A multiplied by a scalar k to another
   row (column) of A, then the determinant will not change. *)
(* https://math.vanderbilt.edu/sapirmv/msapir/proofdet1.html *)
(* doing it only when the first row is 0; can be generalized later *)

Definition mat_add_row_mul_scal_row n (M : matrix n n T) i1 v i2 :=
  mk_mat n n
    (λ i j,
     if Nat.eq_dec i i1 then (mat_el M i1 j + v * mat_el M i2 j)%F
     else mat_el M i j).

(* *)

Definition mat_mul_row_by_scal n k (M : matrix n n T) s :=
  mk_mat n n
    (λ i j,
     if Nat.eq_dec i k then (s * mat_el M i j)%F else mat_el M i j).

(* If we multiply a row (column) of A by a number, the determinant of
   A will be multiplied by the same number. *)
(* https://math.vanderbilt.edu/sapirmv/msapir/proofdet1.html
   point 1 *)

(* Well, since my definition of the discriminant only covers the
   row 0, we can prove that only when i=0; this will able us to
   prove next theorems, swapping rows by going via row 0 *)

Theorem det_mul_row_0_by_scal :
  rngl_is_comm = true →
  ∀ n (A : matrix n n T) v,
  n ≠ 0
  → determinant (mat_mul_row_by_scal 0 A v) = (v * determinant A)%F.
Proof.
intros Hic * Hnz.
unfold determinant; cbn.
destruct n; [ easy | clear Hnz ].
cbn.
rewrite rngl_mul_summation_distr_l.
apply rngl_summation_eq_compat.
intros j Hj.
rewrite (rngl_mul_comm Hic (minus_one_pow j)).
do 2 rewrite <- rngl_mul_assoc.
f_equal.
rewrite (rngl_mul_comm Hic (mat_el A 0 j)).
do 2 rewrite <- rngl_mul_assoc.
f_equal.
rewrite rngl_mul_comm; [ f_equal | easy ].
f_equal.
apply matrix_eq; cbn.
rename j into k; rename Hj into Hk.
intros i j Hi Hj.
destruct (Nat.eq_dec (i + 1) 0) as [H| H]; [ flia H | easy ].
Qed.

(* If the i-th row (column) in A is a sum of the i-th row (column) of
   a matrix B and the i-th row (column) of a matrix C and all other
   rows in B and C are equal to the corresponding rows in A (that is B
   and C differ from A by one row only), then det(A)=det(B)+det(C). *)
(* https://math.vanderbilt.edu/sapirmv/msapir/proofdet1.html
   point 2 *)

(* Well, since my definition of the discriminant only covers the
   row 0, we can prove that only when i=0; this will able us to
   prove the next theorem, swapping rows by going via row 0 *)

Theorem det_sum_row_row : ∀ n (A B C : matrix n n T),
  n ≠ 0
  → (∀ j, mat_el A 0 j = (mat_el B 0 j + mat_el C 0 j)%F)
  → (∀ i j, i ≠ 0 → mat_el B i j = mat_el A i j)
  → (∀ i j, i ≠ 0 → mat_el C i j = mat_el A i j)
  → determinant A = (determinant B + determinant C)%F.
Proof.
intros * Hnz Hbc Hb Hc.
unfold determinant.
destruct n; [ easy | clear Hnz ].
cbn.
assert (Hab : ∀ j, subm A 0 j = subm B 0 j). {
  intros.
  apply matrix_eq; cbn.
  intros i j' Hi Hj'.
  destruct (lt_dec j' j); symmetry; apply Hb; flia.
}
assert (Hac : ∀ j, subm A 0 j = subm C 0 j). {
  intros.
  apply matrix_eq; cbn.
  intros i j' Hi Hj'.
  destruct (lt_dec j' j); symmetry; apply Hc; flia.
}
erewrite rngl_summation_eq_compat. 2: {
  intros j Hj.
  rewrite Hbc.
  rewrite rngl_mul_add_distr_l.
  rewrite rngl_mul_add_distr_r.
  rewrite Hab at 1.
  rewrite Hac at 1.
  easy.
}
cbn.
now apply rngl_summation_add_distr.
Qed.

(* If two rows (columns) in A are equal then det(A)=0. *)
(* https://math.vanderbilt.edu/sapirmv/msapir/proofdet1.html
   point 3 *)
(* doing it only when the first row is 0; can be generalized later *)

Definition δ_lt i k := Nat.b2n (i <? k).

Theorem subm_subm_swap : ∀ n (A : matrix n n T) i j k l,
  subm (subm A i j) k l =
  subm (subm A (k + δ_lt i k) (l + δ_lt j l)) (i - δ_lt k i) (j - δ_lt l j).
Proof.
intros.
apply matrix_eq; cbn.
intros i' j' Hi' Hj'.
f_equal. {
  do 2 rewrite <- Nat.add_assoc; f_equal.
  rewrite Nat.add_comm.
  unfold δ_lt.
  remember (k <=? i') as a eqn:Ha.
  remember (i <=? i' + Nat.b2n a) as b eqn:Hb.
  remember (i <? k) as c eqn:Hc.
  remember (k <? i) as d eqn:Hd.
  remember (i - Nat.b2n d <=? i') as e eqn:He.
  remember (k + Nat.b2n c <=? i' + Nat.b2n e) as f eqn:Hf.
  move b before a; move c before b; move d before c; move e before d.
  move f before e.
  symmetry in Ha, Hb, Hc, Hd, He, Hf.
  destruct a, b, d, e, f; cbn; try easy; exfalso. {
    apply Nat.leb_le in Ha; apply Nat.leb_le in Hb; apply Nat.leb_le in Hd.
    apply Nat.leb_le in He; apply Nat.leb_nle in Hf.
    destruct c; [ apply Nat.ltb_lt in Hc; flia Ha Hb Hc Hd He Hf | ].
    cbn in Hf.
    apply Nat.ltb_nlt in Hc; flia Ha Hb Hc Hd He Hf.
  } {
    apply Nat.leb_le in Ha; apply Nat.leb_le in Hb; apply Nat.leb_le in Hd.
    apply Nat.leb_nle in He; apply Nat.leb_le in Hf.
    destruct c; [ apply Nat.ltb_lt in Hc; flia Ha Hb Hc Hd He Hf | ].
    apply Nat.ltb_nlt in Hc; flia Ha Hb Hc Hd He Hf.
  } {
    apply Nat.leb_le in Ha; apply Nat.leb_le in Hb; apply Nat.leb_le in Hd.
    apply Nat.leb_nle in He; apply Nat.leb_nle in Hf.
    destruct c; [ apply Nat.ltb_lt in Hc; flia Ha Hb Hc Hd He Hf | ].
    apply Nat.ltb_nlt in Hc; flia Ha Hb Hc Hd He Hf.
  } {
    apply Nat.leb_le in Ha; apply Nat.leb_le in Hb; apply Nat.leb_nle in Hd.
    apply Nat.leb_le in He; apply Nat.leb_nle in Hf.
    destruct c; [ apply Nat.ltb_lt in Hc; flia Ha Hb Hc Hd He Hf | ].
    cbn in Hf.
    apply Nat.ltb_nlt in Hc; flia Ha Hb Hc Hd He Hf.
  } {
    apply Nat.leb_le in Ha; apply Nat.leb_le in Hb; apply Nat.leb_nle in Hd.
    apply Nat.leb_nle in He; apply Nat.leb_le in Hf.
    destruct c; [ apply Nat.ltb_lt in Hc; flia Ha Hb Hc Hd He Hf | ].
    apply Nat.ltb_nlt in Hc; flia Ha Hb Hc Hd He Hf.
  } {
    apply Nat.leb_le in Ha; apply Nat.leb_le in Hb; apply Nat.leb_nle in Hd.
    apply Nat.leb_nle in He; apply Nat.leb_nle in Hf.
    destruct c; [ apply Nat.ltb_lt in Hc; flia Ha Hb Hc Hd He Hf | ].
    apply Nat.ltb_nlt in Hc; flia Ha Hb Hc Hd He Hf.
  } {
    apply Nat.leb_le in Ha; apply Nat.leb_nle in Hb; apply Nat.leb_le in Hd.
    apply Nat.leb_le in He; apply Nat.leb_le in Hf.
    destruct c; [ apply Nat.ltb_lt in Hc; flia Ha Hb Hc Hd He Hf | ].
    apply Nat.ltb_nlt in Hc; flia Ha Hb Hc Hd He Hf.
  } {
    apply Nat.leb_le in Ha; apply Nat.leb_nle in Hb; apply Nat.leb_le in Hd.
    apply Nat.leb_nle in He; apply Nat.leb_nle in Hf.
    destruct c; [ apply Nat.ltb_lt in Hc; flia Ha Hb Hc Hd He Hf | ].
    apply Nat.ltb_nlt in Hc; flia Ha Hb Hc Hd He Hf.
  } {
    apply Nat.leb_le in Ha; apply Nat.leb_nle in Hb; apply Nat.leb_nle in Hd.
    apply Nat.leb_le in He; apply Nat.leb_le in Hf.
    destruct c; [ apply Nat.ltb_lt in Hc; flia Ha Hb Hc Hd He Hf | ].
    apply Nat.ltb_nlt in Hc; flia Ha Hb Hc Hd He Hf.
  } {
    apply Nat.leb_le in Ha; apply Nat.leb_nle in Hb; apply Nat.leb_nle in Hd.
    apply Nat.leb_nle in He; apply Nat.leb_nle in Hf.
    destruct c; [ apply Nat.ltb_lt in Hc; flia Ha Hb Hc Hd He Hf | ].
    apply Nat.ltb_nlt in Hc; flia Ha Hb Hc Hd He Hf.
  } {
    apply Nat.leb_nle in Ha; apply Nat.leb_le in Hb; apply Nat.leb_le in Hd.
    apply Nat.leb_le in He; apply Nat.leb_le in Hf.
    destruct c; [ apply Nat.ltb_lt in Hc; flia Ha Hb Hc Hd He Hf | ].
    cbn in He.
    apply Nat.ltb_nlt in Hc; flia Ha Hb Hc Hd He Hf.
  } {
    apply Nat.leb_nle in Ha; apply Nat.leb_le in Hb; apply Nat.leb_le in Hd.
    apply Nat.leb_nle in He; apply Nat.leb_nle in Hf.
    destruct c; [ apply Nat.ltb_lt in Hc; flia Ha Hb Hc Hd He Hf | ].
    cbn in Hb.
    apply Nat.ltb_nlt in Hc; flia Ha Hb Hc Hd He Hf.
  } {
    apply Nat.leb_nle in Ha; apply Nat.leb_le in Hb; apply Nat.leb_nle in Hd.
    apply Nat.leb_le in He; apply Nat.leb_le in Hf.
    destruct c; [ apply Nat.ltb_lt in Hc; flia Ha Hb Hc Hd He Hf | ].
    cbn in Hb.
    apply Nat.ltb_nlt in Hc; flia Ha Hb Hc Hd He Hf.
  } {
    apply Nat.leb_nle in Ha; apply Nat.leb_le in Hb; apply Nat.leb_nle in Hd.
    apply Nat.leb_nle in He; apply Nat.leb_nle in Hf.
    destruct c; [ apply Nat.ltb_lt in Hc; flia Ha Hb Hc Hd He Hf | ].
    apply Nat.ltb_nlt in Hc; flia Ha Hb Hc Hd He Hf.
  } {
    apply Nat.leb_nle in Ha; apply Nat.leb_nle in Hb; apply Nat.leb_le in Hd.
    apply Nat.leb_le in He; apply Nat.leb_le in Hf.
    destruct c; [ apply Nat.ltb_lt in Hc; flia Ha Hb Hc Hd He Hf | ].
    cbn in He.
    apply Nat.ltb_nlt in Hc; flia Ha Hb Hc Hd He Hf.
  } {
    apply Nat.leb_nle in Ha; apply Nat.leb_nle in Hb; apply Nat.leb_le in Hd.
    apply Nat.leb_le in He; apply Nat.leb_nle in Hf.
    destruct c; [ apply Nat.ltb_lt in Hc; flia Ha Hb Hc Hd He Hf | ].
    cbn in He.
    apply Nat.ltb_nlt in Hc; flia Ha Hb Hc Hd He Hf.
  } {
    apply Nat.leb_nle in Ha; apply Nat.leb_nle in Hb; apply Nat.leb_le in Hd.
    apply Nat.leb_nle in He; apply Nat.leb_le in Hf.
    destruct c; [ apply Nat.ltb_lt in Hc; flia Ha Hb Hc Hd He Hf | ].
    apply Nat.ltb_nlt in Hc; flia Ha Hb Hc Hd He Hf.
  } {
    apply Nat.leb_nle in Ha; apply Nat.leb_nle in Hb; apply Nat.leb_nle in Hd.
    apply Nat.leb_le in He; apply Nat.leb_le in Hf.
    destruct c; [ apply Nat.ltb_lt in Hc; flia Ha Hb Hc Hd He Hf | ].
    apply Nat.ltb_nlt in Hc; flia Ha Hb Hc Hd He Hf.
  } {
    apply Nat.leb_nle in Ha; apply Nat.leb_nle in Hb; apply Nat.leb_nle in Hd.
    apply Nat.leb_le in He; apply Nat.leb_nle in Hf.
    destruct c; [ apply Nat.ltb_lt in Hc; flia Ha Hb Hc Hd He Hf | ].
    apply Nat.ltb_nlt in Hc; flia Ha Hb Hc Hd He Hf.
  } {
    apply Nat.leb_nle in Ha; apply Nat.leb_nle in Hb; apply Nat.leb_nle in Hd.
    apply Nat.leb_nle in He; apply Nat.leb_le in Hf.
    destruct c; [ apply Nat.ltb_lt in Hc; flia Ha Hb Hc Hd He Hf | ].
    apply Nat.ltb_nlt in Hc; flia Ha Hb Hc Hd He Hf.
  }
} {
  do 2 rewrite <- Nat.add_assoc; f_equal.
  rewrite Nat.add_comm.
  unfold δ_lt.
  remember (l <=? j') as a eqn:Ha.
  remember (j <=? j' + Nat.b2n a) as b eqn:Hb.
  remember (j <? l) as c eqn:Hc.
  remember (l <? j) as d eqn:Hd.
  remember (j - Nat.b2n d <=? j') as e eqn:He.
  remember (l + Nat.b2n c <=? j' + Nat.b2n e) as f eqn:Hf.
  move b before a; move c before b; move d before c; move e before d.
  move f before e.
  symmetry in Ha, Hb, Hc, Hd, He, Hf.
  destruct a, b, d, e, f; cbn; try easy; exfalso. {
    apply Nat.leb_le in Ha; apply Nat.leb_le in Hb; apply Nat.leb_le in Hd.
    apply Nat.leb_le in He; apply Nat.leb_nle in Hf.
    destruct c; [ apply Nat.ltb_lt in Hc; flia Ha Hb Hc Hd He Hf | ].
    cbn in He, Hf.
    apply Nat.ltb_nlt in Hc; flia Ha Hb Hc Hd He Hf.
  } {
    apply Nat.leb_le in Ha; apply Nat.leb_le in Hb; apply Nat.leb_le in Hd.
    apply Nat.leb_nle in He; apply Nat.leb_le in Hf.
    destruct c; [ apply Nat.ltb_lt in Hc; flia Ha Hb Hc Hd He Hf | ].
    apply Nat.ltb_nlt in Hc; flia Ha Hb Hc Hd He Hf.
  } {
    apply Nat.leb_le in Ha; apply Nat.leb_le in Hb; apply Nat.leb_le in Hd.
    apply Nat.leb_nle in He; apply Nat.leb_nle in Hf.
    destruct c; [ apply Nat.ltb_lt in Hc; flia Ha Hb Hc Hd He Hf | ].
    apply Nat.ltb_nlt in Hc; flia Ha Hb Hc Hd He Hf.
  } {
    apply Nat.leb_le in Ha; apply Nat.leb_le in Hb; apply Nat.leb_nle in Hd.
    apply Nat.leb_le in He; apply Nat.leb_nle in Hf.
    destruct c; [ apply Nat.ltb_lt in Hc; flia Ha Hb Hc Hd He Hf | ].
    cbn in Hf.
    apply Nat.ltb_nlt in Hc; flia Ha Hb Hc Hd He Hf.
  } {
    apply Nat.leb_le in Ha; apply Nat.leb_le in Hb; apply Nat.leb_nle in Hd.
    apply Nat.leb_nle in He; apply Nat.leb_le in Hf.
    destruct c; [ apply Nat.ltb_lt in Hc; flia Ha Hb Hc Hd He Hf | ].
    apply Nat.ltb_nlt in Hc; flia Ha Hb Hc Hd He Hf.
  } {
    apply Nat.leb_le in Ha; apply Nat.leb_le in Hb; apply Nat.leb_nle in Hd.
    apply Nat.leb_nle in He; apply Nat.leb_nle in Hf.
    destruct c; [ apply Nat.ltb_lt in Hc; flia Ha Hb Hc Hd He Hf | ].
    apply Nat.ltb_nlt in Hc; flia Ha Hb Hc Hd He Hf.
  } {
    apply Nat.leb_le in Ha; apply Nat.leb_nle in Hb; apply Nat.leb_le in Hd.
    apply Nat.leb_le in He; apply Nat.leb_le in Hf.
    destruct c; [ apply Nat.ltb_lt in Hc; flia Ha Hb Hc Hd He Hf | ].
    apply Nat.ltb_nlt in Hc; flia Ha Hb Hc Hd He Hf.
  } {
    apply Nat.leb_le in Ha; apply Nat.leb_nle in Hb; apply Nat.leb_le in Hd.
    apply Nat.leb_nle in He; apply Nat.leb_nle in Hf.
    destruct c; [ apply Nat.ltb_lt in Hc; flia Ha Hb Hc Hd He Hf | ].
    apply Nat.ltb_nlt in Hc; cbn in Hc; flia Ha Hb Hc Hd He Hf.
  } {
    apply Nat.leb_le in Ha; apply Nat.leb_nle in Hb; apply Nat.leb_nle in Hd.
    apply Nat.leb_le in He; apply Nat.leb_le in Hf.
    destruct c; [ apply Nat.ltb_lt in Hc; flia Ha Hb Hc Hd He Hf | ].
    apply Nat.ltb_nlt in Hc; flia Ha Hb Hc Hd He Hf.
  } {
    apply Nat.leb_le in Ha; apply Nat.leb_nle in Hb; apply Nat.leb_nle in Hd.
    apply Nat.leb_nle in He; apply Nat.leb_nle in Hf.
    destruct c; [ apply Nat.ltb_lt in Hc; flia Ha Hb Hc Hd He Hf | ].
    apply Nat.ltb_nlt in Hc; flia Ha Hb Hc Hd He Hf.
  } {
    apply Nat.leb_nle in Ha; apply Nat.leb_le in Hb; apply Nat.leb_le in Hd.
    apply Nat.leb_le in He; apply Nat.leb_le in Hf.
    destruct c; [ apply Nat.ltb_lt in Hc; flia Ha Hb Hc Hd He Hf | ].
    cbn in He.
    apply Nat.ltb_nlt in Hc; flia Ha Hb Hc Hd He Hf.
  } {
    apply Nat.leb_nle in Ha; apply Nat.leb_le in Hb; apply Nat.leb_le in Hd.
    apply Nat.leb_nle in He; apply Nat.leb_nle in Hf.
    destruct c; [ apply Nat.ltb_lt in Hc; flia Ha Hb Hc Hd He Hf | ].
    cbn in Hb.
    apply Nat.ltb_nlt in Hc; flia Ha Hb Hc Hd He Hf.
  } {
    apply Nat.leb_nle in Ha; apply Nat.leb_le in Hb; apply Nat.leb_nle in Hd.
    apply Nat.leb_le in He; apply Nat.leb_le in Hf.
    destruct c; [ apply Nat.ltb_lt in Hc; flia Ha Hb Hc Hd He Hf | ].
    cbn in Hb.
    apply Nat.ltb_nlt in Hc; flia Ha Hb Hc Hd He Hf.
  } {
    apply Nat.leb_nle in Ha; apply Nat.leb_le in Hb; apply Nat.leb_nle in Hd.
    apply Nat.leb_nle in He; apply Nat.leb_nle in Hf.
    destruct c; [ apply Nat.ltb_lt in Hc; flia Ha Hb Hc Hd He Hf | ].
    apply Nat.ltb_nlt in Hc; flia Ha Hb Hc Hd He Hf.
  } {
    apply Nat.leb_nle in Ha; apply Nat.leb_nle in Hb; apply Nat.leb_le in Hd.
    apply Nat.leb_le in He; apply Nat.leb_le in Hf.
    destruct c; [ apply Nat.ltb_lt in Hc; flia Ha Hb Hc Hd He Hf | ].
    cbn in He.
    apply Nat.ltb_nlt in Hc; flia Ha Hb Hc Hd He Hf.
  } {
    apply Nat.leb_nle in Ha; apply Nat.leb_nle in Hb; apply Nat.leb_le in Hd.
    apply Nat.leb_le in He; apply Nat.leb_nle in Hf.
    destruct c; [ apply Nat.ltb_lt in Hc; flia Ha Hb Hc Hd He Hf | ].
    cbn in He.
    apply Nat.ltb_nlt in Hc; flia Ha Hb Hc Hd He Hf.
  } {
    apply Nat.leb_nle in Ha; apply Nat.leb_nle in Hb; apply Nat.leb_le in Hd.
    apply Nat.leb_nle in He; apply Nat.leb_le in Hf.
    destruct c; [ apply Nat.ltb_lt in Hc; flia Ha Hb Hc Hd He Hf | ].
    apply Nat.ltb_nlt in Hc; flia Ha Hb Hc Hd He Hf.
  } {
    apply Nat.leb_nle in Ha; apply Nat.leb_nle in Hb; apply Nat.leb_nle in Hd.
    apply Nat.leb_le in He; apply Nat.leb_le in Hf.
    destruct c; [ apply Nat.ltb_lt in Hc; flia Ha Hb Hc Hd He Hf | ].
    apply Nat.ltb_nlt in Hc; flia Ha Hb Hc Hd He Hf.
  } {
    apply Nat.leb_nle in Ha; apply Nat.leb_nle in Hb; apply Nat.leb_nle in Hd.
    apply Nat.leb_le in He; apply Nat.leb_nle in Hf.
    destruct c; [ apply Nat.ltb_lt in Hc; flia Ha Hb Hc Hd He Hf | ].
    apply Nat.ltb_nlt in Hc; flia Ha Hb Hc Hd He Hf.
  } {
    apply Nat.leb_nle in Ha; apply Nat.leb_nle in Hb; apply Nat.leb_nle in Hd.
    apply Nat.leb_nle in He; apply Nat.leb_le in Hf.
    destruct c; [ apply Nat.ltb_lt in Hc; flia Ha Hb Hc Hd He Hf | ].
    apply Nat.ltb_nlt in Hc; flia Ha Hb Hc Hd He Hf.
  }
}
Qed.

Theorem glop1 : ∀ n (A : matrix n n T) i j,
  subm (subm A i j) 0 0 = subm (subm A 0 0) (i - 1) (j - 1).
Proof.
intros.
rewrite subm_subm_swap.
unfold δ_lt.
now destruct i, j.
Qed.

Definition swap_in_permut n i j k := vect_swap_elem (canon_permut n k) i j.

(* comatrix *)

Definition comatrix {n} (M : matrix n n T) : matrix n n T :=
  {| mat_el i j := (minus_one_pow (i + j) * determinant (subm M i j))%F |}.

Theorem subm_mat_swap_rows_0_1 : ∀ n (M : matrix n n T) r,
  subm (mat_swap_rows 0 1 M) 0 r = subm M 1 r.
Proof.
intros.
apply matrix_eq.
intros i j Hi Hj; cbn.
destruct (Nat.eq_dec (i + 1) 0) as [H| H]; [ flia H | clear H ].
destruct (Nat.eq_dec (i + 1) 1) as [H| H]. {
  now replace i with 0 by flia H.
}
now destruct i.
Qed.

(* Laplace formulas *)

Theorem laplace_formula_on_rows :
  rngl_is_comm = true →
  rngl_has_opp = true →
  rngl_has_inv = true →
  rngl_is_integral = true →
  rngl_has_1_neq_0 = true →
  rngl_has_dec_eq = true →
  rngl_characteristic = 0 →
  ∀ n (M : matrix n n T) i,
  n ≠ 0
  → i < n
  → determinant M = (Σ (j = 0, n - 1), mat_el M i j * mat_el (comatrix M) i j)%F.
Proof.
(*
intros Hic Hop Hin Hit H10 Hde Hch * Hnz Hlin.
destruct (Nat.eq_dec i 0) as [Hiz| Hiz]. {
  subst i.
  unfold determinant.
  destruct n; [ easy | cbn ].
  symmetry.
  rewrite Nat.sub_0_r at 1.
  apply rngl_summation_eq_compat.
  intros j Hj.
  rewrite rngl_mul_comm; [ | easy ].
  rewrite rngl_mul_mul_swap; [ | easy ].
  f_equal; f_equal.
  apply Nat.sub_0_r.
}
destruct (le_dec n 1) as [Hn1| Hn1]. {
  destruct n; [ easy | ].
  destruct n; [ flia Hlin Hiz | flia Hn1 ].
}
apply Nat.nle_gt in Hn1.
unfold comatrix; symmetry; cbn.
destruct (Nat.eq_dec i (n - 1)) as [Hin1| Hin1]. {
  unfold comatrix; symmetry; cbn.
  destruct n; [ easy | clear Hnz; cbn ].
  rewrite Nat.sub_succ, Nat.sub_0_r in Hin1; subst i.
...
erewrite rngl_summation_eq_compat. 2: {
  intros j (_, Hj).
  specialize (determinant_alternating Hic Hop Hin Hit H10 Hde Hch) as H1.
  apply Nat.neq_0_lt_0 in Hnz.
  specialize (H1 _ (subm M i j) i 0 Hiz).
...
  assert (0 < n - 1) by flia Hn1.
...
  specialize (H1 _ M i 0 Hiz Hlin Hnz).
  apply (f_equal rngl_opp) in H1.
  rewrite rngl_opp_involutive in H1; [ | easy ].
  rewrite <- H1.
unfold determinant.
destruct n; [ easy | clear Hnz Hiz ].
cbn - [ mat_swap_rows ].
rewrite Nat.sub_0_r at 1.
...
*)
intros Hic Hop Hin Hit H10 Hde Hch * Hnz Hlin.
destruct (Nat.eq_dec i 0) as [Hiz| Hiz]. {
  subst i.
  unfold determinant.
  destruct n; [ easy | cbn ].
  symmetry.
  rewrite Nat.sub_0_r at 1.
  apply rngl_summation_eq_compat.
  intros j Hj.
  rewrite rngl_mul_comm; [ | easy ].
  rewrite rngl_mul_mul_swap; [ | easy ].
  f_equal; f_equal.
  apply Nat.sub_0_r.
}
destruct n; [ easy | clear Hnz ].
replace (S n - 1) with n by flia.
specialize (determinant_alternating Hic Hop Hin Hit H10 Hde Hch) as H1.
specialize (H1 (S n) M 0 i).
assert (H : 0 ≠ i) by flia Hiz.
specialize (H1 H); clear H.
specialize (H1 (Nat.lt_0_succ _) Hlin).
apply (f_equal rngl_opp) in H1.
rewrite rngl_opp_involutive in H1; [ | easy ].
symmetry in H1.
unfold comatrix.
cbn - [ determinant ].
erewrite rngl_summation_eq_compat. 2: {
  intros j Hj.
  rewrite rngl_mul_comm; [ | easy ].
  rewrite rngl_mul_mul_swap; [ | easy ].
  easy.
}
cbn - [ determinant ].
(**)
rewrite H1; cbn.
rewrite rngl_opp_summation; [ | easy | easy ].
unfold determinant.
...
destruct (Nat.eq_dec i n) as [Hein| Hein]. {
  subst i; clear Hlin.
...
erewrite rngl_summation_eq_compat. 2: {
  intros j (_, Hj).
  specialize (determinant_alternating Hic Hop Hin Hit H10 Hde Hch) as H1.
  specialize (H1 _ (subm M 0 j) 0 i).
  assert (H : 0 ≠ i) by flia Hiz.
  specialize (H1 H); clear H.
  rewrite Nat.sub_succ, Nat.sub_0_r in H1 at 1 2.
...
  assert (H : 0 < S n - 1) by flia Hlin.
  apply Nat.neq_0_lt_0 in Hnz.
specialize (H1 _ M i 0 Hiz Hlin Hnz).
apply (f_equal rngl_opp) in H1.
rewrite rngl_opp_involutive in H1; [ | easy ].
rewrite <- H1; cbn.
unfold determinant.
destruct n; [ easy | clear Hnz Hiz ].
cbn - [ mat_swap_rows ].
rewrite Nat.sub_0_r at 1.
...
intros Hic Hop Hin Hit H10 Hde Hch * Hnz Hlin.
unfold comatrix; cbn.
erewrite rngl_summation_eq_compat. 2: {
  intros j Hj.
  rewrite rngl_mul_comm; [ | easy ].
  rewrite rngl_mul_mul_swap; [ | easy ].
  easy.
}
destruct n; [ easy | clear Hnz ].
...
cbn.
cbn - [ determinant ].
unfold determinant at 1.
cbn - [ determinant ].
...
intros Hic Hop Hin Hit H10 Hde Hch * Hnz Hlin.
unfold determinant.
destruct n; [ easy | clear Hnz ].
rewrite Nat.sub_succ, Nat.sub_0_r.
symmetry.
erewrite rngl_summation_eq_compat. 2: {
  intros j Hj.
  rewrite rngl_mul_comm; [ | easy ].
  rewrite rngl_mul_mul_swap; [ | easy ].
  easy.
}
cbn.
destruct i. {
  apply rngl_summation_eq_compat.
  intros i (_, Hi).
  rewrite Nat.add_0_l.
  f_equal; f_equal.
  apply Nat.sub_0_r.
}
destruct i. {
  destruct (Nat.eq_dec n 0) as [Hnz| Hnz]; [ flia Hlin Hnz | ].
  specialize (determinant_alternating Hic Hop Hin Hit H10 Hde Hch) as H1.
  specialize (H1 _ M 0 1 (Nat.neq_0_succ _) (Nat.lt_0_succ _) Hlin).
  cbn in H1.
  apply (f_equal rngl_opp) in H1.
  rewrite rngl_opp_involutive in H1; [ | easy ].
  rewrite <- H1.
  rewrite rngl_opp_summation; [ | easy | easy ].
  apply rngl_summation_eq_compat.
  intros i (_, Hi).
  rewrite <- rngl_mul_opp_l; [ | easy ].
  rewrite <- rngl_mul_opp_l; [ | easy ].
  f_equal. {
    f_equal; cbn.
    now apply minus_one_pow_succ.
  }
  f_equal; [ | apply Nat.sub_0_r ].
  symmetry; apply subm_mat_swap_rows_0_1.
}
destruct i. {
  destruct (Nat.eq_dec n 0) as [Hnz| Hnz]; [ flia Hlin Hnz | ].
  specialize (determinant_alternating Hic Hop Hin Hit H10 Hde Hch) as H1.
  specialize (H1 _ M 0 2 (Nat.neq_0_succ _) (Nat.lt_0_succ _) Hlin).
  cbn in H1.
  apply (f_equal rngl_opp) in H1.
  rewrite rngl_opp_involutive in H1; [ | easy ].
  rewrite <- H1; clear H1.
  rewrite rngl_opp_summation; [ | easy | easy ].
  erewrite rngl_summation_eq_compat. 2: {
    intros i (_, Hi); cbn.
    rewrite minus_one_pow_succ; [ | easy | easy ].
    rewrite minus_one_pow_succ; [ | easy | easy ].
    rewrite rngl_opp_involutive; [ | easy ].
    easy.
  }
  cbn; symmetry.
  erewrite rngl_summation_eq_compat. 2: {
    intros i (_, Hi); cbn.
    rewrite <- rngl_mul_opp_l; [ | easy ].
    rewrite <- rngl_mul_opp_l; [ | easy ].
    easy.
  }
  cbn; symmetry.
  rewrite (rngl_summation_split _ 2); [ symmetry | flia Hlin ].
  rewrite (rngl_summation_split _ 2); [ symmetry | flia Hlin ].
  rewrite rngl_summation_split_last; [ symmetry | flia ].
  rewrite rngl_summation_split_last; [ symmetry | flia ].
  cbn.
  rewrite rngl_mul_1_l.
  destruct n; [ easy | ].
  destruct n; [ flia Hlin | clear Hnz Hlin ].
  destruct n. {
    f_equal; f_equal. 2: {
      rewrite rngl_mul_opp_l; [ | easy ].
      rewrite rngl_mul_1_l.
      rewrite rngl_mul_opp_l; [ | easy ].
      rewrite <- rngl_mul_opp_r; [ | easy ].
      f_equal; cbn.
      unfold iter_seq, iter_list; cbn.
      do 6 rewrite rngl_add_0_l.
      do 4 rewrite rngl_mul_1_l.
      do 4 rewrite rngl_mul_1_r.
      rewrite rngl_opp_add_distr; [ | easy ].
      rewrite <- rngl_mul_opp_l; [ | easy ].
      rewrite <- rngl_mul_opp_l; [ | easy ].
      rewrite rngl_opp_involutive; [ | easy ].
      rewrite rngl_mul_1_l.
      rewrite rngl_mul_comm; [ | easy ].
      rewrite rngl_mul_opp_l; [ | easy ].
      rewrite rngl_mul_1_l.
      rewrite rngl_mul_opp_l; [ | easy ].
      rewrite fold_rngl_sub; [ | easy ].
      f_equal.
      now apply rngl_mul_comm.
    }
    cbn.
    unfold iter_seq, iter_list; cbn.
    do 12 rewrite rngl_add_0_l.
    do 7 rewrite rngl_mul_1_l.
    do 6 rewrite rngl_mul_1_r.
    do 14 (rewrite rngl_mul_opp_l; [ | easy ]).
    do 4 rewrite rngl_mul_1_l.
    do 4 rewrite rngl_mul_add_distr_l.
    do 4 (rewrite rngl_mul_opp_r; [ | easy ]).
    do 2 (rewrite rngl_opp_add_distr; [ | easy ]).
    do 8 rewrite rngl_mul_assoc.
    do 3 (rewrite rngl_opp_involutive; [ | easy ]).
    unfold rngl_sub; rewrite Hop.
    do 2 rewrite rngl_add_assoc.
    rewrite rngl_mul_mul_swap; [ | easy ].
    do 4 rewrite <- rngl_add_assoc.
    f_equal; rewrite rngl_mul_mul_swap; [ | easy ].
    f_equal; rewrite rngl_mul_mul_swap; [ | easy ].
    f_equal; rewrite rngl_mul_mul_swap; [ | easy ].
    easy.
  }
...
Check determinant_alternating.
...
*)

Theorem mat_comat_mul :
  rngl_is_comm = true →
  rngl_has_opp = true →
  rngl_has_inv = true →
  rngl_is_integral = true →
  rngl_has_1_neq_0 = true →
  rngl_has_dec_eq = true →
  rngl_characteristic = 0 →
  ∀ n (M : matrix n n T),
  (M * (comatrix M)⁺ = determinant M × mI n)%M.
Proof.
intros Hic Hop Hin Hit H10 Hde Hch *.
...
*)

End a.

Arguments det_loop {T ro} {n}%nat M%M i%nat.
Arguments determinant {T ro n} M%M.
Arguments subm {T m n} M%M i%nat j%nat.

Arguments determinant {T ro} {n%nat} M%M.
Arguments det_loop {T ro} {n%nat} M%M i%nat.
Arguments det_from_row {T}%type {ro} {n}%nat M%M i%nat.
Arguments det_from_col {T}%type {ro} {n}%nat M%M j%nat.
Arguments comatrix {T}%type {ro} {n}%nat M%M.
