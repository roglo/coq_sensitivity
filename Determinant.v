Set Nested Proofs Allowed.
Set Implicit Arguments.

Require Import Utf8 Arith Bool.
Import List List.ListNotations.

Require Import Misc RingLike Matrix.
Require Import RLsummation RLproduct.
Import matrix_Notations.

Section a.

Context {T : Type}.
Context (ro : ring_like_op T).
Context (rp : ring_like_prop T).

(* determinant *)

Fixpoint det_loop {n} (M : matrix n n T) i :=
  match i with
  | 0 => 1%F
  | S i' =>
      (Σ (j = 0, i'),
       minus_one_pow j * mat_el M 0 j * det_loop (subm M 0 j) i')%F
  end.

Definition determinant {n} (M : matrix n n T) := det_loop M n.

(* the following versions of computing the determinant should
   (to be proven) be equivalent; perhaps could help for proving
   Cramer's rule of resolving equations *)

Definition det_from_row {n} (M : matrix n n T) i :=
  (minus_one_pow i *
   Σ (j = 0, n - 1),
     minus_one_pow j * mat_el M i j * determinant (subm M i j))%F.

Definition det_from_col {n} (M : matrix n n T) j :=
  (minus_one_pow j *
   Σ (i = 0, n - 1),
     minus_one_pow i * mat_el M i j * determinant (subm M i j))%F.

(* Alternative version of the determinant: sum of product of the
   factors a_{i,σ(i)} where σ goes through all permutations of
   the naturals of the interval [0, n-1].
   The permutations generated are in the same order as the
   terms generated by the determinant defined by induction on
   the size of the matrix.
     The order happens to be the canonical (alphabetical) order.
   Example for n=3
     = [[0; 1; 2]; [0; 2; 1]; [1; 0; 2]; [1; 2; 0]; [2; 0; 1]; [2; 1; 0]]
   Having the same terms order, the proof of equality of both definitions
   of both determinants is easy.

   The permutations are built this way. The k-th permutation is a
   vector of size n where
   - the first value is k/fact(n-1)
   - the rest is the (k mod fact(n-1))-th permutation of n-1 values
     (from 0 to n-2) where
     * all values less than the first value (k/fact(n-1)) are unchanged
     * all values greater or equal to it are increased by 1
   Example. For n=4 and k=0
   - first value: 0
   - rest: shift of 0;1;2 by 1, i.e. 1;2;3
   Result : 0;1;2;3
   Other example. For n=4 and k=13
   - first value: 13/3! = 13/6 = 2
   - rest: k' = 13 mod 3! = 13 mod 6 = 1 for n'=3, resulting 0;2;1
     0 and 1 are not shifted (both < 2), 2 is shifted, resulting 0;3;1
     final result: 2;0;3;1
  *)

Definition canon_permut_fun {n} (σ_n : nat → vector n nat) k j :=
  match j with
  | 0 => k / fact n
  | S j' =>
      vect_el (σ_n (k mod fact n)) j' +
      Nat.b2n (k / fact n <=? vect_el (σ_n (k mod fact n)) j')
  end.

Fixpoint canon_permut n k : vector n nat :=
  match n with
  | 0 => mk_vect 0 (λ _, 0)
  | S n' => mk_vect (S n') (canon_permut_fun (canon_permut n') k)
  end.

Fixpoint canon_permut_inv n k (j : nat) :=
  match n with
  | 0 => 0
  | S n' =>
      if lt_dec j (k / fact n') then
        S (canon_permut_inv n' (k mod fact n') j)
      else if lt_dec (k / fact n') j then
        S (canon_permut_inv n' (k mod fact n') (j - 1))
      else 0
  end.

(*
Compute (map (λ i, list_of_vect (permut 3 i)) (seq 0 (fact 3))).
Compute list_of_vect (permut 3 4).
Compute permut_inv 3 4 0.
Compute permut_inv 3 4 1.
Compute permut_inv 3 4 2.
Compute list_of_vect (permut 4 12).
Compute permut_inv 4 12 0.
Compute permut_inv 4 12 1.
Compute permut_inv 4 12 2.
Compute permut_inv 4 12 3.

Compute vect_el (permut 3 4) (permut_inv 3 4 1).
Compute permut_inv 3 4 (vect_el (permut 3 4) 1).
*)

Theorem canon_permut_inv_upper_bound : ∀ n k j,
  k < fact n
  → j < n
  → canon_permut_inv n k j < n.
Proof.
intros * Hkn Hjn.
revert k j Hkn Hjn.
induction n; intros; [ easy | ].
cbn.
destruct (lt_dec j (k / fact n)) as [Hjkn| Hjkn]. {
  apply -> Nat.succ_lt_mono.
  destruct n. {
    cbn in Hkn.
    apply Nat.lt_1_r in Hkn; subst k.
    now cbn in Hjkn.
  }
  destruct (Nat.eq_dec j (S n)) as [Hjsn| Hjsn]. {
    subst j.
    clear Hjn.
    exfalso; apply Nat.nle_gt in Hjkn; apply Hjkn; clear Hjkn.
    rewrite Nat_fact_succ in Hkn.
    rewrite Nat.mul_comm in Hkn.
    apply Nat.lt_succ_r.
    apply Nat.div_lt_upper_bound; [ | easy ].
    apply fact_neq_0.
  } {
    apply IHn; [ | flia Hjn Hjsn ].
    apply Nat.mod_upper_bound, fact_neq_0.
  }
} {
  apply Nat.nlt_ge in Hjkn.
  destruct (lt_dec (k / fact n) j) as [Hknj| Hknj]; [ | flia ].
  apply -> Nat.succ_lt_mono.
  destruct n. {
    now apply Nat.lt_1_r in Hjn; subst j.
  }
  apply IHn; [ | flia Hjn Hknj ].
  apply Nat.mod_upper_bound, fact_neq_0.
}
Qed.

Theorem canon_permut_permut_inv : ∀ n k j,
  j < n
  → k < fact n
  → vect_el (canon_permut n k) (canon_permut_inv n k j) = j.
Proof.
intros * Hjn Hkn.
revert j k Hjn Hkn.
induction n; intros; [ easy | ].
cbn.
destruct (lt_dec j (k / fact n)) as [Hjkn| Hjkn]. {
  cbn.
  destruct n. {
    rewrite Nat.div_1_r in Hjkn; cbn in Hkn.
    flia Hkn Hjkn.
  }
  destruct (lt_dec k (fact (S n))) as [Hksn| Hksn]. {
    now rewrite Nat.div_small in Hjkn.
  }
  apply Nat.nlt_ge in Hksn.
  destruct (Nat.eq_dec j (S n)) as [Hjsn| Hjsn]. {
    subst j.
    clear Hjn.
    exfalso; apply Nat.nle_gt in Hjkn; apply Hjkn; clear Hjkn.
    rewrite Nat_fact_succ in Hkn.
    rewrite Nat.mul_comm in Hkn.
    apply Nat.lt_succ_r.
    apply Nat.div_lt_upper_bound; [ | easy ].
    apply fact_neq_0.
  }
  rewrite IHn; [ | flia Hjn Hjsn | ]. 2: {
    apply Nat.mod_upper_bound, fact_neq_0.
  }
  remember (k / fact (S n) <=? j) as b eqn:Hb.
  symmetry in Hb.
  destruct b; [ exfalso | apply Nat.add_0_r ].
  apply Nat.leb_le in Hb.
  flia Hjkn Hb.
} {
  apply Nat.nlt_ge in Hjkn.
  destruct (lt_dec (k / fact n) j) as [Hkj| Hkj]. 2: {
    apply Nat.nlt_ge in Hkj; cbn.
    now apply Nat.le_antisymm.
  }
  clear Hjkn.
  destruct j; [ easy | ].
  rewrite Nat.sub_succ, Nat.sub_0_r.
  cbn.
  destruct n; [ flia Hjn | ].
  apply Nat.succ_lt_mono in Hjn.
  rewrite IHn; [ | easy | ]. 2: {
    apply Nat.mod_upper_bound, fact_neq_0.
  }
  remember (k / fact (S n) <=? j) as b eqn:Hb.
  symmetry in Hb.
  destruct b; [ apply Nat.add_1_r | exfalso ].
  apply Nat.leb_nle in Hb.
  now apply Nat.succ_le_mono in Hkj.
}
Qed.

Theorem canon_permut_inv_permut : ∀ n k i,
  i < n
  → k < fact n
  → canon_permut_inv n k (vect_el (canon_permut n k) i) = i.
Proof.
intros * Hi Hkn.
revert k i Hi Hkn.
induction n; intros; [ flia Hi | ].
destruct i. {
  clear Hi; cbn.
  remember (k / fact n) as p eqn:Hp.
  destruct (lt_dec p p) as [H| H]; [ flia H | easy ].
}
apply Nat.succ_lt_mono in Hi.
cbn.
remember (k / fact n) as p eqn:Hp.
remember (vect_el (canon_permut n (k mod fact n)) i) as q eqn:Hq.
move q before p.
remember (p <=? q) as b eqn:Hb; symmetry in Hb.
destruct b. {
  apply Nat.leb_le in Hb; cbn.
  destruct (lt_dec (q + 1) p) as [Hpq| Hqp]; [ flia Hb Hpq | ].
  apply Nat.nlt_ge in Hqp.
  destruct (lt_dec p (q + 1)) as [Hpq| Hpq]; [ | flia Hb Hpq ].
  clear Hpq Hqp.
  f_equal.
  rewrite Nat.add_sub.
  rewrite Hq.
  apply IHn; [ easy | ].
  apply Nat.mod_upper_bound, fact_neq_0.
} {
  apply Nat.leb_gt in Hb; cbn.
  rewrite Nat.add_0_r.
  destruct (lt_dec q p) as [H| H]; [ clear H | flia Hb H ].
  f_equal.
  rewrite Hq.
  apply IHn; [ easy | ].
  apply Nat.mod_upper_bound, fact_neq_0.
}
Qed.

Theorem canon_permut_surjective : ∀ n k j,
  k < fact n
  → j < n
  → ∃ i : nat, i < n ∧ vect_el (canon_permut n k) i = j.
Proof.
intros * Hkn Hjn.
exists (canon_permut_inv n k j).
destruct n; [ easy | ].
split. {
  cbn.
  destruct (lt_dec j (k / fact n)) as [Hjk| Hjk]. {
    apply -> Nat.succ_lt_mono.
    destruct n. {
      now apply Nat.lt_1_r in Hkn; subst k.
    }
    destruct (Nat.eq_dec j (S n)) as [Hjsn| Hjsn]. {
      subst j; clear Hjn.
      apply Nat.nle_gt in Hjk.
      exfalso; apply Hjk; clear Hjk.
      rewrite Nat_fact_succ in Hkn.
      rewrite Nat.mul_comm in Hkn.
      apply Nat.lt_succ_r.
      apply Nat.div_lt_upper_bound; [ | easy ].
      apply fact_neq_0.
    }
    apply canon_permut_inv_upper_bound; [ | flia Hjn Hjsn ].
    apply Nat.mod_upper_bound, fact_neq_0.
  } {
    apply Nat.nlt_ge in Hjk.
    destruct (lt_dec (k / fact n) j) as [Hkj| Hkj]; [ | flia ].
    apply -> Nat.succ_lt_mono.
    destruct n. {
      apply Nat.lt_1_r in Hkn; subst k.
      flia Hjn Hkj.
    }
    apply canon_permut_inv_upper_bound; [ | flia Hjn Hkj ].
    apply Nat.mod_upper_bound, fact_neq_0.
  }
}
now apply canon_permut_permut_inv.
Qed.

Theorem canon_permut_injective : ∀ n k i j,
  k < fact n
  → i < n
  → j < n
  → vect_el (canon_permut n k) i = vect_el (canon_permut n k) j
  → i = j.
Proof.
intros * Hk Hi Hj Hij.
assert (Hnz : n ≠ 0) by flia Hi.
rewrite <- canon_permut_inv_permut with (n := n) (k := k); [ | easy | easy ].
symmetry.
rewrite <- canon_permut_inv_permut with (n := n) (k := k); [ | easy | easy ].
now f_equal.
Qed.

(* signature of the k-th permutation of "canon_permut" above *)

Fixpoint ε_canon_permut n k :=
  match n with
  | 0 => 1%F
  | S n' => (minus_one_pow (k / fact n') * ε_canon_permut n' (k mod fact n'))%F
  end.

(* signature of a permutation *)

(*
Definition sgn_diff a b := if lt_dec a b then (- 1)%F else 1%F.

Definition ε {n} (p : vector n nat) :=
  (Π (i = 1, n), Π (j = i + 1, n),
   sgn_diff (vect_el p (j - 1)) (vect_el p (i - 1)))%F.
*)

(*
Definition ε {n} (p : vector n nat) :=
  ((Π (i = 1, n), Π (j = i + 1, n),
    (rngl_of_nat (vect_el p (j - 1)) - rngl_of_nat (vect_el p (i - 1)))) /
   (Π (i = 1, n), Π (j = i + 1, n),
    (rngl_of_nat j - rngl_of_nat i)))%F.
*)

Definition δ i j u v := if lt_dec i j then (rngl_of_nat v - rngl_of_nat u)%F else 1%F.
Definition ip {n} (p : vector n nat) i := rngl_of_nat (vect_el p i).

Definition ε {n} (p : vector n nat) :=
  ((Π (i = 1, n), Π (j = i + 1, n), (ip p (j - 1) - ip p (i - 1))) /
   (Π (i = 1, n), Π (j = i + 1, n), rngl_of_nat (j - i)))%F.

Definition ε' {n} (p : vector n nat) :=
  ((Π (i = 1, n), Π (j = 1, n), δ i j (vect_el p (i - 1)) (vect_el p (j - 1))) /
   (Π (i = 1, n), Π (j = 1, n), δ i j i j))%F.

(* signature by counting the number of transpositions *)

Fixpoint insert x list :=
  match list with
  | [] => ([x], false)
  | y :: l =>
      if lt_dec x y then (x :: list, false)
      else
        let '(l', odd) := insert x l in
        (y :: l', negb odd)
  end.

Fixpoint insertion_sort list :=
  match list with
  | [] => (list, false)
  | x :: l =>
      let (l', odd') := insertion_sort l in
      let '(l'', odd'') := insert x l' in
      (l'', xorb odd' odd'')
  end.

(*
Compute let n := 5 in (map (λ k, insertion_sort (list_of_vect (canon_permut n k))) (seq 0 (fact n))).
*)

Definition ε'' {n} (p : vector n nat) :=
  if snd (insertion_sort (list_of_vect p)) then (-1)%F else 1%F.

(*
End a.
Require Import Zrl ZArith.
Compute (ε_canon_permut Z_ring_like_op 2 1).
Compute (ε Z_ring_like_op (canon_permut 2 1)).
Compute (ε' Z_ring_like_op (canon_permut 2 1)).
Compute (ε'' Z_ring_like_op (canon_permut 2 1)).
Compute (list_of_vect (canon_permut 2 1)).
Compute (map (λ k, (ε_canon_permut Z_ring_like_op 4 k)) (seq 0 (fact 4))).
Compute (map (λ k, (ε Z_ring_like_op (canon_permut 4 k))) (seq 0 (fact 4))).
Compute (map (λ k, (ε' Z_ring_like_op (canon_permut 4 k))) (seq 0 (fact 4))).
Compute (map (λ k, (ε'' Z_ring_like_op (canon_permut 4 k))) (seq 0 (fact 4))).
Compute let ro := Z_ring_like_op in let n := 4  in
  (Π (i = 1, n), (Π (j = i + 1, n), (rngl_of_nat j - rngl_of_nat i)))%F.
Compute let ro := Z_ring_like_op in let n := 4  in
  (Π (i = 1, n), (Π (j = i + 1, n), (ip _ (permut n 13) (j - 1) - ip _ (permut n 13) (i - 1))))%F.

Compute let n := 4 in let σ₁ := permut n 13 in let σ₂ := permut n 4 in
       (Π (i = 1, n),
        (Π (j = i + 1, n),
         (rngl_of_nat (vect_el σ₁ (vect_el σ₂ (j - 1))) - rngl_of_nat (vect_el σ₁ (vect_el σ₂ (i - 1))))))%F.
Compute let n := 4 in let σ₁ := permut n 13 in let σ₂ := permut n 4 in
  (Π (i = 1, n), (Π (j = i + 1, n), (rngl_of_nat j - rngl_of_nat i)))%F.

Compute let n := 4 in let σ₁ := permut n 13 in let σ₂ := permut n 4 in
  (Π (i = 1, n), (Π (j = i + 1, n), (ip _ σ₁ (j - 1) - ip _ σ₁ (i - 1))))%F.
Compute let n := 4 in let σ₁ := permut n 13 in let σ₂ := permut n 4 in
  (Π (i = 1, n), (Π (j = i + 1, n), (ip _ σ₂ (j - 1) - ip _ σ₂ (i - 1))))%F.
...
  Hx : x =
       (Π (i = 1, n),
        (Π (j = i + 1, n),
         (rngl_of_nat (vect_el σ₁ (vect_el σ₂ (j - 1))) - rngl_of_nat (vect_el σ₁ (vect_el σ₂ (i - 1))))))%F
  Hy : y = (Π (i = 1, n), (Π (j = i + 1, n), (rngl_of_nat j - rngl_of_nat i)))%F
  Hz : z = (Π (i = 1, n), (Π (j = i + 1, n), (ip σ₁ (j - 1) - ip σ₁ (i - 1))))%F
  Ht : t = (Π (i = 1, n), (Π (j = i + 1, n), (ip σ₂ (j - 1) - ip σ₂ (i - 1))))%F
  (x * y)%F = (z * t)%F
*)

(*
Theorem sgn_diff_diag : ∀ i, sgn_diff i i = 1%F.
Proof.
intros.
unfold sgn_diff.
destruct (lt_dec i i) as [H| H]; [ flia H | easy ].
Qed.

Theorem sgn_diff_add_mono_l : ∀ a b c,
  sgn_diff (a + b) (a + c) = sgn_diff b c.
Proof.
intros.
unfold sgn_diff.
destruct (lt_dec (a + b) (a + c)) as [Habc| Habc]. {
  destruct (lt_dec b c) as [Hbc| Hbc]; [ easy | ].
  exfalso; apply Hbc; clear Hbc.
  now apply Nat.add_lt_mono_l in Habc.
}
destruct (lt_dec b c) as [Hbc| Hbc]; [ | easy ].
exfalso; apply Habc; clear Habc.
now apply Nat.add_lt_mono_l.
Qed.

Theorem sgn_diff_add_mono_r : ∀ a b c,
  sgn_diff (a + c) (b + c) = sgn_diff a b.
Proof.
intros.
setoid_rewrite Nat.add_comm.
apply sgn_diff_add_mono_l.
Qed.
*)

(*
Theorem sgn_diff_add_mono_r_small : ∀ a b c d,
  a ≠ b
  → c ≤ 1
  → d ≤ 1
  → sgn_diff (a + c) (b + d) = sgn_diff a b.
Proof.
intros * Hab Hc Hd.
unfold sgn_diff.
destruct (lt_dec (a + c) (b + d)) as [Habcd| Habcd]. {
  destruct (lt_dec a b) as [Hlab| Hlab]; [ easy | exfalso ].
  apply Hlab; clear Hlab.
  destruct c. {
    destruct d; [ flia Habcd | ].
    destruct d; [ | flia Hd ].
    flia Hab Habcd.
  }
  destruct c; [ | flia Hc ].
  destruct d; [ flia Hab Habcd | ].
  destruct d; [ | flia Hd ].
  flia Habcd.
}
destruct (lt_dec a b) as [Hlab| Hlab]; [ exfalso | easy ].
apply Habcd; clear Habcd.
destruct c; [ flia Hlab | ].
destruct c; [ | flia Hc ].
destruct d. {
  rewrite Nat.add_0_r.
...
*)

(* equality ε on permut and ε_permut *)

Theorem ε_canon_permut_ε_canon_permut :
  rngl_has_inv = true ∨ rngl_has_no_inv_but_div = true →
  rngl_has_1_neq_0 = true →
  ∀ n k, k < fact n → ε (canon_permut n k) = ε_canon_permut n k.
Proof.
intros Hin H10 * Hkn.
unfold ε.
revert k Hkn.
induction n; intros. {
  apply rngl_mul_inv_r; [ easy | cbn ].
  specialize rngl_opt_1_neq_0 as rngl_1_neq_0.
  now rewrite H10 in rngl_1_neq_0.
}
cbn - [ iter_seq ].
Abort. (*
(**)
rewrite rngl_product_split_first; [ | easy | flia ].
cbn - [ iter_seq ].
rewrite rngl_product_succ_succ.
erewrite rngl_product_eq_compat. 2: {
  intros i Hi.
  now rewrite Nat.sub_succ, Nat.sub_0_r.
}
erewrite (rngl_product_eq_compat _ _ _ 2). 2: {
  intros i Hi.
  erewrite rngl_product_eq_compat. 2: {
    intros j Hj.
    replace (i - 1) with (S (i - 2)) by flia Hi.
    replace (j - 1) with (S (j - 2)) by flia Hj Hi.
    now cbn.
  }
  easy.
}
cbn - [ iter_seq ].
...
intros * Hkn.
unfold ε.
revert k Hkn.
induction n; intros; [ easy | ].
cbn - [ iter_seq ].
(**)
rewrite rngl_product_split_first; [ | easy | flia ].
cbn - [ iter_seq ].
rewrite rngl_product_succ_succ.
erewrite rngl_product_eq_compat. 2: {
  intros i Hi.
  now rewrite Nat.sub_succ, Nat.sub_0_r.
}
erewrite (rngl_product_eq_compat _ _ _ 2). 2: {
  intros i Hi.
  erewrite rngl_product_eq_compat. 2: {
    intros j Hj.
    replace (i - 1) with (S (i - 2)) by flia Hi.
    replace (j - 1) with (S (j - 2)) by flia Hj Hi.
    now cbn.
  }
  easy.
}
cbn - [ iter_seq ].
(**)
rewrite rngl_product_succ_succ.
remember (Π (i = _, _), _)%F as x eqn:Hx.
erewrite rngl_product_eq_compat. 2: {
  intros i Hi.
  rewrite Nat.add_succ_l.
  erewrite rngl_product_succ_succ.
  erewrite rngl_product_eq_compat. 2: {
    intros j Hj.
    do 2 rewrite Nat.sub_succ.
    easy.
  }
  cbn - [ iter_seq ].
  easy.
}
cbn - [ iter_seq ].
subst x.
rename Hkn into Hksn.
destruct (lt_dec k (fact n)) as [Hkn| Hkn]. {
  rewrite Nat.div_small; [ | easy ].
  rewrite Nat.mod_small; [ | easy ].
  cbn - [ iter_seq ].
  rewrite all_1_rngl_product_1; [ | easy | easy ].
  do 2 rewrite rngl_mul_1_l.
  erewrite rngl_product_eq_compat. 2: {
    intros i Hi.
    erewrite rngl_product_eq_compat. 2: {
      intros j Hj.
      now rewrite sgn_diff_add_mono_r.
    }
    easy.
  }
  cbn - [ iter_seq ].
  now apply IHn.
}
apply Nat.nlt_ge in Hkn.
destruct (lt_dec k (2 * fact n)) as [Hk2n| Hk2n]. {
  rewrite (Nat_div_less_small 1); [ | now rewrite Nat.mul_1_l ].
  rewrite (Nat_mod_less_small 1); [ | now rewrite Nat.mul_1_l ].
  rewrite Nat.mul_1_l.
  cbn - [ iter_seq "<=?" ].
  f_equal. {
    unfold sgn_diff.
    replace (permut_fun (permut n) k) with (vect_el (permut (S n) k)) by easy.
    rewrite (rngl_product_split _ (permut_inv (S n) k 0)). 2: {
      split; [ flia | ].
      apply permut_inv_upper_bound; [ easy | flia ].
    }
    rewrite rngl_product_split_last. 2: {
      cbn.
      rewrite (Nat_div_less_small 1); [ | now rewrite Nat.mul_1_l ].
      cbn; flia.
    }
    rewrite all_1_rngl_product_1; [ | easy | ]. 2: {
      intros i Hi.
      destruct (lt_dec (vect_el (permut (S n) k) (i - 1)) 1) as [Hni| Hni].
      2: easy.
      exfalso.
      apply Nat.lt_1_r in Hni.
      cbn in Hi.
      rewrite (Nat_div_less_small 1) in Hi; [ | now rewrite Nat.mul_1_l ].
      rewrite (Nat_mod_less_small 1) in Hi; [ | now rewrite Nat.mul_1_l ].
      cbn in Hi.
      rewrite Nat.add_0_r in Hi.
      specialize (@permut_inv_permut (S n) k (i - 1)) as H1.
      assert (H : i - 1 < S n). {
        specialize (@permut_inv_upper_bound n (k - fact n) 0) as H2.
        assert (H : k - fact n < fact n) by (cbn in Hk2n; flia Hk2n).
        specialize (H2 H); clear H.
        assert (H : 0 < n). {
          destruct n; [ | flia ].
          cbn in Hksn, Hkn; flia Hksn Hkn.
        }
        specialize (H2 H); clear H.
        flia Hi H2.
      }
      specialize (H1 H Hksn); clear H.
      rewrite Hni in H1.
      cbn in H1.
      rewrite (Nat_div_less_small 1) in H1; [ | now rewrite Nat.mul_1_l ].
      rewrite (Nat_mod_less_small 1) in H1; [ | now rewrite Nat.mul_1_l ].
      rewrite Nat.mul_1_l in H1.
      cbn in H1.
      flia Hi H1.
    }
    rewrite rngl_mul_1_l.
    rewrite all_1_rngl_product_1; [ | easy | ]. 2: {
      intros i Hi.
      destruct (lt_dec (vect_el (permut (S n) k) i) 1) as [Hni| Hni].
      2: easy.
      exfalso.
      apply Nat.lt_1_r in Hni.
      cbn in Hi.
      rewrite (Nat_div_less_small 1) in Hi; [ | now rewrite Nat.mul_1_l ].
      rewrite (Nat_mod_less_small 1) in Hi; [ | now rewrite Nat.mul_1_l ].
      cbn in Hi.
      rewrite Nat.add_0_r in Hi.
      specialize (@permut_inv_permut (S n) k i) as H1.
      assert (H : i < S n). {
        specialize (@permut_inv_upper_bound n (k - fact n) 0) as H2.
        assert (H : k - fact n < fact n) by (cbn in Hk2n; flia Hk2n).
        specialize (H2 H); clear H.
        assert (H : 0 < n). {
          destruct n; [ | flia ].
          cbn in Hksn, Hkn; flia Hksn Hkn.
        }
        specialize (H2 H); clear H.
        flia Hi H2.
      }
      specialize (H1 H Hksn); clear H.
      rewrite Hni in H1.
      cbn in H1.
      rewrite (Nat_div_less_small 1) in H1; [ | now rewrite Nat.mul_1_l ].
      rewrite (Nat_mod_less_small 1) in H1; [ | now rewrite Nat.mul_1_l ].
      rewrite Nat.mul_1_l in H1.
      cbn in H1.
      flia Hi H1.
    }
    rewrite permut_permut_inv; [ | flia | easy ].
    cbn; apply rngl_mul_1_r.
  }
  rewrite <- IHn; [ | cbn in Hk2n; flia Hk2n ].
  apply rngl_product_eq_compat.
  intros i Hi.
  apply rngl_product_eq_compat.
  intros j Hj.
  (* chuis pas sûr *)
  (* trop compliqué ; en plus, c'est juste *un* cas *)
Abort.
*)

(* definition of determinant by sum of products involving all
   permutations *)

Definition determinant' n (M : matrix n n T) :=
  (Σ (k = 0, fact n - 1), ε_canon_permut n k *
   Π (i = 1, n), mat_el M (i - 1) (vect_el (canon_permut n k) (i - 1)%nat))%F.

(* Proof that both definitions of determinants are equal *)

Theorem det_is_det_by_canon_permut :
  rngl_is_comm = true →
  ∀ n (M : matrix n n T), determinant M = determinant' M.
Proof.
intros Hic *.
unfold determinant, determinant'.
destruct n; intros. {
  cbn; rewrite rngl_add_0_l.
  symmetry; apply rngl_mul_1_l.
}
erewrite rngl_summation_eq_compat. 2: {
  intros i Hi.
  rewrite rngl_product_succ_succ.
  erewrite rngl_product_eq_compat. 2: {
    intros j Hj.
    now rewrite Nat.sub_succ, Nat.sub_0_r.
  }
  easy.
}
cbn - [ iter_seq fact det_loop canon_permut ε ].
revert M.
induction n; intros. {
  cbn.
  do 3 rewrite rngl_mul_1_l.
  now rewrite rngl_mul_1_r.
}
remember (S n) as sn.
cbn - [ fact iter_seq "mod" "/" ]; subst sn.
erewrite rngl_summation_eq_compat. 2: {
  intros i Hi.
  now rewrite IHn.
}
cbn - [ fact iter_seq "mod" "/" canon_permut ].
erewrite rngl_summation_eq_compat. 2: {
  intros i Hi.
  now rewrite rngl_mul_summation_distr_l.
}
cbn - [ fact iter_seq "mod" "/" canon_permut ].
rewrite rngl_summation_summation_distr; [ | easy ].
rewrite <- Nat.sub_succ_l; [ | apply lt_O_fact ].
rewrite Nat.sub_succ, Nat.sub_0_r.
rewrite <- Nat_fact_succ.
symmetry.
erewrite rngl_summation_eq_compat. 2: {
  intros i Hi.
  rewrite rngl_product_split_first; [ | easy | flia ].
  rewrite rngl_product_succ_succ.
  easy.
}
cbn - [ fact iter_seq "mod" "/" canon_permut ].
symmetry.
apply rngl_summation_eq_compat.
intros i Hi.
do 3 rewrite rngl_mul_assoc.
f_equal. 2: {
  apply rngl_product_eq_compat.
  intros j Hj.
  now rewrite Nat.add_1_r.
}
rewrite rngl_mul_mul_swap; [ | easy ].
rewrite <- rngl_mul_assoc.
rewrite rngl_mul_mul_swap; [ | easy ].
f_equal.
rewrite rngl_mul_assoc.
rewrite rngl_mul_mul_swap; [ | easy ].
now rewrite rngl_mul_assoc.
Qed.

(* multilinearity *)

Theorem determinant_multilinear :
  rngl_is_comm = true
  → ∀ n (M : matrix n n T) i a b U V,
    i < n
    → determinant (mat_repl_vect i M (a × U + b × V)%V) =
         (a * determinant (mat_repl_vect i M U) +
          b * determinant (mat_repl_vect i M V))%F.
Proof.
intros Hic * Hi.
rewrite det_is_det_by_canon_permut; [ | easy ].
rewrite det_is_det_by_canon_permut; [ | easy ].
rewrite det_is_det_by_canon_permut; [ | easy ].
unfold determinant'.
erewrite rngl_summation_eq_compat. 2: {
  intros k Hk.
  erewrite rngl_product_eq_compat. 2: {
    intros j Hj.
    now cbn.
  }
  easy.
}
cbn - [ iter_seq ].
specialize rngl_opt_mul_comm as rngl_mul_comm.
rewrite Hic in rngl_mul_comm.
rewrite rngl_mul_summation_distr_l.
rewrite rngl_mul_summation_distr_l.
symmetry.
erewrite rngl_summation_eq_compat. 2: {
  intros k Hk.
  rewrite rngl_mul_assoc.
  now rewrite (rngl_mul_comm a).
}
rewrite rngl_add_comm.
erewrite rngl_summation_eq_compat. 2: {
  intros k Hk.
  rewrite rngl_mul_assoc.
  now rewrite (rngl_mul_comm b).
}
rewrite rngl_add_comm.
rewrite <- rngl_summation_add_distr; [ | easy ].
apply rngl_summation_eq_compat.
intros k Hk.
do 2 rewrite <- rngl_mul_assoc.
rewrite <- rngl_mul_add_distr_l.
f_equal.
assert (Hkn : k < fact n). {
  specialize (fact_neq_0 n) as Hnz.
  flia Hk Hnz.
}
specialize (canon_permut_surjective Hkn Hi) as Hp.
destruct Hp as (p & Hp & Hpp).
rewrite (rngl_product_split _ (p + 1)); [ | flia Hp ].
rewrite rngl_product_split_last; [ | flia ].
erewrite rngl_product_eq_compat. 2: {
  intros j Hj.
  replace (j - 1 - 1) with (j - 2) by flia.
  destruct (Nat.eq_dec (vect_el (canon_permut n k) (j - 2)) i) as [Hpj| Hpj]. {
    exfalso.
    rewrite <- Hpp in Hpj.
    apply canon_permut_injective in Hpj; [ | easy | flia Hp Hj | easy ].
    flia Hj Hpj.
  }
  easy.
}
rewrite (rngl_mul_comm (iter_seq _ _ _ _)).
rewrite rngl_add_comm.
rewrite (rngl_product_split _ (p + 1)); [ | flia Hp ].
rewrite rngl_product_split_last; [ | flia ].
erewrite rngl_product_eq_compat. 2: {
  intros j Hj.
  replace (j - 1 - 1) with (j - 2) by flia.
  destruct (Nat.eq_dec (vect_el (canon_permut n k) (j - 2)) i) as [Hpj| Hpj]. {
    exfalso.
    rewrite <- Hpp in Hpj.
    apply canon_permut_injective in Hpj; [ | easy | flia Hp Hj | easy ].
    flia Hj Hpj.
  }
  easy.
}
rewrite (rngl_mul_comm (iter_seq _ _ _ _)).
rewrite rngl_add_comm.
symmetry.
rewrite (rngl_product_split _ (p + 1)); [ | flia Hp ].
rewrite rngl_product_split_last; [ | flia ].
erewrite rngl_product_eq_compat. 2: {
  intros j Hj.
  replace (j - 1 - 1) with (j - 2) by flia.
  destruct (Nat.eq_dec (vect_el (canon_permut n k) (j - 2)) i) as [Hpj| Hpj]. {
    exfalso.
    rewrite <- Hpp in Hpj.
    apply canon_permut_injective in Hpj; [ | easy | flia Hp Hj | easy ].
    flia Hj Hpj.
  }
  easy.
}
rewrite (rngl_mul_comm (iter_seq _ _ _ _)).
rewrite Nat.add_sub.
rewrite Hpp.
destruct (Nat.eq_dec i i) as [H| H]; [ clear H | easy ].
do 4 rewrite rngl_mul_assoc.
remember
  (Π (i0 = 2, p + 1),
   mat_el M (i0 - 2) (vect_el (canon_permut n k) (i0 - 2)%nat))%F
  as q eqn:Hq.
rewrite (rngl_mul_mul_swap Hic _ _ q).
do 3 rewrite (rngl_mul_comm _ q).
do 5 rewrite <- rngl_mul_assoc.
rewrite <- rngl_mul_add_distr_l.
f_equal.
clear q Hq.
erewrite rngl_product_eq_compat. 2: {
  intros j Hj.
  destruct (Nat.eq_dec (vect_el (canon_permut n k) (j - 1)) i) as [Hpj| Hpj]. {
    rewrite <- Hpp in Hpj.
    apply canon_permut_injective in Hpj; [ | easy | flia Hp Hj | easy ].
    flia Hj Hpj.
  }
  easy.
}
symmetry.
erewrite rngl_product_eq_compat. 2: {
  intros j Hj.
  destruct (Nat.eq_dec (vect_el (canon_permut n k) (j - 1)) i) as [Hpj| Hpj]. {
    rewrite <- Hpp in Hpj.
    apply canon_permut_injective in Hpj; [ | easy | flia Hp Hj | easy ].
    flia Hj Hpj.
  }
  easy.
}
rewrite rngl_add_comm.
erewrite rngl_product_eq_compat. 2: {
  intros j Hj.
  destruct (Nat.eq_dec (vect_el (canon_permut n k) (j - 1)) i) as [Hpj| Hpj]. {
    rewrite <- Hpp in Hpj.
    apply canon_permut_injective in Hpj; [ | easy | flia Hp Hj | easy ].
    flia Hj Hpj.
  }
  easy.
}
cbn - [ iter_seq ].
rewrite rngl_add_comm.
do 2 rewrite rngl_mul_assoc.
now rewrite <- rngl_mul_add_distr_r.
Qed.

(* compute the rank of a given permutation *)

Definition nat_of_canon_permut_sub_vect n (v : vector n nat) n' :=
  let d := vect_el v 0 in
  mk_vect n' (λ i, vect_el v (S i) - Nat.b2n (d <? vect_el v (S i))).

Fixpoint nat_of_canon_permut n (v : vector n nat) : nat :=
  match n with
  | 0 => 0
  | S n' =>
      let d := vect_el v 0 in
      d * fact n' +
      nat_of_canon_permut (nat_of_canon_permut_sub_vect v n')
  end.

(*
Theorem glop : ∀ n (v : vector n nat),
  (∀ i, i < S n → vect_el v i < n)
  → (∀ i j, i < n → j < n → vect_el v i ≠ vect_el v j)
  → nat_of_permut v < fact n.
Proof.
intros * Hvn Hn.
revert v Hvn Hn.
induction n; intros; [ cbn; flia | ].
cbn - [ fact "<?" ].
Print nat_of_permut_sub_vect.
...
specialize (IHn (nat_of_permut_sub_vect v (S n))) as H1.
...
*)

Theorem Nat_b2n_upper_bound : ∀ b, Nat.b2n b ≤ 1.
Proof.
intros; destruct b; cbn; flia.
Qed.

Theorem vect_el_nat_of_canon_permut_ub : ∀ n (v : vector (S n) nat) i,
  (∀ i, i < S n → vect_el v i < S n)
  → (∀ i j, i < S n → j < S n → i ≠ j → vect_el v i ≠ vect_el v j)
  → i < n
  → vect_el (nat_of_canon_permut_sub_vect v n) i < n.
Proof.
intros * Hvn Hn Hin.
destruct n; [ easy | ].
cbn - [ "<?" ].
remember (vect_el v 0 <? vect_el v (S i)) as b eqn:Hb.
symmetry in Hb.
specialize (Hvn (S i)) as H1.
specialize (Hn 0 (S i) (Nat.lt_0_succ _)) as H2.
assert (H : S i < S (S n)) by flia Hin.
specialize (H1 H); specialize (H2 H); clear H.
destruct b; cbn; [ flia H1 | ].
rewrite Nat.sub_0_r.
apply Nat.ltb_ge in Hb.
destruct (Nat.eq_dec (vect_el v (S i)) (S n)) as [Hvi| Hvi]; [ | flia H1 Hvi ].
specialize (Hvn 0 (Nat.lt_0_succ _)) as H3.
flia Hb H1 H2 H3 Hvi.
Qed.

Theorem vect_el_nat_of_canon_permut_diff : ∀ n (v : vector (S n) nat) i j,
  (∀ i, i < S n → vect_el v i < S n)
  → (∀ i j, i < S n → j < S n → i ≠ j → vect_el v i ≠ vect_el v j)
  → i < n
  → j < n
  → i ≠ j
  → vect_el (nat_of_canon_permut_sub_vect v n) i ≠
    vect_el (nat_of_canon_permut_sub_vect v n) j.
Proof.
intros * Hvn Hn Hin Hjn Hij.
destruct n; [ easy | ].
cbn - [ "<?" ].
remember (vect_el v 0 <? vect_el v (S i)) as bi eqn:Hbi.
remember (vect_el v 0 <? vect_el v (S j)) as bj eqn:Hbj.
symmetry in Hbi, Hbj.
move bj before bi.
destruct bi; cbn. {
  apply Nat.ltb_lt in Hbi.
  destruct bj; cbn. {
    apply Nat.ltb_lt in Hbj.
    apply Nat.succ_lt_mono in Hin.
    apply Nat.succ_lt_mono in Hjn.
    specialize (Hn (S i) (S j) Hin Hjn) as Hs.
    assert (H : S i ≠ S j) by flia Hij.
    specialize (Hs H); clear H.
    flia Hbi Hbj Hs.
  } {
    apply Nat.ltb_ge in Hbj.
    apply Nat.succ_lt_mono in Hjn.
    specialize (Hn 0 (S j) (Nat.lt_0_succ _) Hjn) as H1.
    flia Hbi Hbj H1.
  }
} {
  apply Nat.ltb_ge in Hbi.
  destruct bj; cbn. {
    apply Nat.ltb_lt in Hbj.
    apply Nat.succ_lt_mono in Hin.
    specialize (Hn 0 (S i) (Nat.lt_0_succ _) Hin) as H1.
    flia Hbi Hbj H1.
  } {
    apply Nat.ltb_ge in Hbj.
    apply Nat.succ_lt_mono in Hin.
    apply Nat.succ_lt_mono in Hjn.
    specialize (Hn (S i) (S j) Hin Hjn) as Hs.
    assert (H : S i ≠ S j) by flia Hij.
    specialize (Hs H); clear H.
    flia Hbi Hbj Hs.
  }
}
Qed.

Theorem nat_of_canon_permut_upper_bound : ∀ n (v : vector n nat),
  (∀ i, i < n → vect_el v i < n)
  → (∀ i j, i < n → j < n → i ≠ j → vect_el v i ≠ vect_el v j)
  → nat_of_canon_permut v < fact n.
Proof.
intros * Hvn Hn.
revert v Hvn Hn.
induction n; intros; [ cbn; flia | ].
cbn.
rewrite Nat.add_comm.
apply Nat.add_lt_le_mono. {
  apply IHn. {
    intros i Hi.
    now apply vect_el_nat_of_canon_permut_ub.
  } {
    intros i j Hi Hj.
    now apply vect_el_nat_of_canon_permut_diff.
  }
}
apply Nat.mul_le_mono_r.
specialize (Hvn 0 (Nat.lt_0_succ _)).
flia Hvn.
Qed.

Theorem nat_of_canon_permut_permut : ∀ n k,
  k < fact n
  → nat_of_canon_permut (canon_permut n k) = k.
Proof.
intros * Hkn.
revert k Hkn.
induction n; intros; [ now apply Nat.lt_1_r in Hkn | cbn ].
specialize (Nat.div_mod k (fact n) (fact_neq_0 _)) as H1.
rewrite Nat.mul_comm in H1.
replace (k / fact n * fact n) with (k - k mod fact n) by flia H1.
rewrite <- Nat.add_sub_swap; [ | apply Nat.mod_le, fact_neq_0 ].
apply Nat.add_sub_eq_r; f_equal.
clear H1.
rewrite <- (IHn (k mod fact n)) at 1. 2: {
  apply Nat.mod_upper_bound, fact_neq_0.
}
f_equal.
apply vector_eq.
intros i Hi; cbn.
symmetry.
apply Nat.add_sub_eq_r.
f_equal.
remember (Nat.b2n (_ <=? _)) as b eqn:Hb.
rewrite Nat.add_comm.
symmetry in Hb.
destruct b. 2: {
  cbn.
  destruct b; [ easy | exfalso ].
  unfold Nat.b2n in Hb.
  destruct (k / fact n <=? _); flia Hb.
}
cbn.
remember (vect_el (canon_permut n _) i) as x eqn:Hx.
symmetry in Hx.
destruct x; [ easy | ].
unfold Nat.b2n in Hb |-*.
remember (k / fact n) as y eqn:Hy; symmetry in Hy.
remember (y <=? S x) as c eqn:Hc; symmetry in Hc.
destruct c; [ easy | clear Hb ].
apply Nat.leb_gt in Hc.
remember (y <=? x) as b eqn:Hb.
symmetry in Hb.
destruct b; [ | easy ].
apply Nat.leb_le in Hb.
flia Hb Hc.
Qed.

Theorem permut_nat_of_canon_permut : ∀ n v,
  (∀ i, i < n → vect_el v i < n)
  → (∀ i j, i < n → j < n → i ≠ j → vect_el v i ≠ vect_el v j)
  → canon_permut n (nat_of_canon_permut v) = v.
Proof.
intros * Hvn Hn.
revert v Hvn Hn.
induction n; intros; [ now apply vector_eq | ].
apply vector_eq.
intros j Hj; cbn.
destruct j. {
  cbn; clear Hj.
  rewrite Nat.div_add_l; [ | apply fact_neq_0 ].
  rewrite <- Nat.add_0_r; f_equal.
  apply Nat.div_small.
  apply nat_of_canon_permut_upper_bound. {
    intros i Hi.
    now apply vect_el_nat_of_canon_permut_ub.
  } {
    intros i j Hi Hj.
    now apply vect_el_nat_of_canon_permut_diff.
  }
}
cbn.
remember (nat_of_canon_permut (nat_of_canon_permut_sub_vect v n)) as k eqn:Hk.
symmetry in Hk.
rewrite Nat.div_add_l; [ | apply fact_neq_0 ].
rewrite Nat_mod_add_l_mul_r; [ | apply fact_neq_0 ].
assert (Hkn : k < fact n). {
  rewrite <- Hk.
  apply nat_of_canon_permut_upper_bound. {
    intros i Hi.
    now apply vect_el_nat_of_canon_permut_ub.
  } {
    intros i m Hi Hm.
    now apply vect_el_nat_of_canon_permut_diff.
  }
}
rewrite Nat.div_small; [ | easy ].
rewrite Nat.mod_small; [ | easy ].
rewrite Nat.add_0_r.
remember (vect_el v 0 <=? vect_el (canon_permut n k) j) as b eqn:Hb.
symmetry in Hb.
assert (H1 : ∀ i, i < n → vect_el (nat_of_canon_permut_sub_vect v n) i < n). {
  intros i Hi.
  now apply vect_el_nat_of_canon_permut_ub.
}
assert
(H2 : ∀ i j : nat,
    i < n
    → j < n
    → i ≠ j
    → vect_el (nat_of_canon_permut_sub_vect v n) i ≠
      vect_el (nat_of_canon_permut_sub_vect v n) j). {
  intros i m Hi Hm Him.
  now apply vect_el_nat_of_canon_permut_diff.
}
destruct b. {
  apply Nat.leb_le in Hb; cbn.
  rewrite <- Hk in Hb |-*.
  rewrite IHn in Hb |-*; [ | easy | easy | easy | easy ].
  cbn - [ "<?" ] in Hb |-*.
  remember (vect_el v 0 <? vect_el v (S j)) as b1 eqn:Hb1.
  symmetry in Hb1.
  destruct b1. {
    apply Nat.ltb_lt in Hb1; cbn.
    apply Nat.sub_add; flia Hb1.
  } {
    apply Nat.ltb_ge in Hb1; exfalso.
    cbn in Hb.
    rewrite Nat.sub_0_r in Hb.
    apply (Hn 0 (S j) (Nat.lt_0_succ _) Hj); [ easy | ].
    now apply Nat.le_antisymm.
  }
} {
  apply Nat.leb_gt in Hb; cbn.
  rewrite Nat.add_0_r.
  rewrite <- Hk in Hb |-*.
(**)
  remember (vect_el v 0 <? vect_el v (S j)) as b1 eqn:Hb1.
  symmetry in Hb1.
  destruct b1. {
    rewrite IHn in Hb; [ | easy | easy ].
    cbn - [ "<?" ] in Hb.
    rewrite Hb1 in Hb; cbn in Hb.
    apply Nat.ltb_lt in Hb1.
    flia Hb1 Hb.
  } {
    rewrite IHn; [ | easy | easy ].
    cbn - [ "<?" ].
    rewrite Hb1; cbn.
    apply Nat.sub_0_r.
  }
}
Qed.

(* list of terms in determinant' (determinant by sum of products of
   permutations *)

Definition determinant'_list {n} (M : matrix n n T) :=
  map (λ k,
    (ε_canon_permut n k *
     Π (i = 1, n), mat_el M (i - 1) (vect_el (canon_permut n k) (i - 1)%nat))%F)
    (seq 0 (fact n)).

Theorem determinant'_by_list : ∀ n (M : matrix n n T),
  determinant' M = (Σ (k = 0, fact n - 1), nth k (determinant'_list M) 0)%F.
Proof.
intros.
unfold determinant', determinant'_list.
apply rngl_summation_eq_compat; intros k Hk.
assert (Hkn : k < fact n). {
  specialize (fact_neq_0 n) as Hn.
  flia Hk Hn.
}
rewrite List_map_nth_in with (a := 0); [ | now rewrite seq_length ].
rewrite seq_nth; [ | easy ].
now rewrite Nat.add_0_l.
Qed.

Import Permutation.

Theorem rngl_summation_permut : ∀ n l1 l2,
  Permutation l1 l2
  → length l1 = n
  → length l2 = n
  → (Σ (i = 0, n - 1), nth i l1 0 = Σ (i = 0, n - 1), nth i l2 0)%F.
Proof.
intros * Hl H1 H2.
destruct n. {
  apply length_zero_iff_nil in H1.
  apply length_zero_iff_nil in H2.
  now subst l1 l2.
}
rewrite Nat.sub_succ, Nat.sub_0_r.
revert n H1 H2.
induction Hl; intros; [ easy | | | ]. {
  cbn in H1, H2.
  apply Nat.succ_inj in H1.
  apply Nat.succ_inj in H2.
  rewrite rngl_summation_split_first; [ symmetry | easy | flia ].
  rewrite rngl_summation_split_first; [ symmetry | easy | flia ].
  destruct n; [ easy | ].
  do 2 rewrite rngl_summation_succ_succ.
  now rewrite IHHl.
} {
  destruct n; [ easy | ].
  cbn in H1, H2.
  do 2 apply Nat.succ_inj in H1.
  do 2 apply Nat.succ_inj in H2.
  rewrite rngl_summation_split_first; [ symmetry | easy | flia ].
  rewrite rngl_summation_split_first; [ symmetry | easy | flia ].
  rewrite rngl_summation_split_first; [ symmetry | easy | flia ].
  rewrite rngl_summation_split_first; [ symmetry | easy | flia ].
  do 2 rewrite rngl_add_assoc.
  do 2 rewrite rngl_summation_succ_succ.
  f_equal; [ apply rngl_add_comm | ].
  apply rngl_summation_eq_compat.
  intros i Hi; cbn.
  destruct i; [ flia Hi | easy ].
} {
  specialize (Permutation_length Hl2) as H3.
  rewrite H2 in H3.
  rewrite IHHl1; [ | easy | easy ].
  now rewrite IHHl2.
}
Qed.

Theorem det_is_det_by_any_permut :
  rngl_is_comm = true
  → ∀ n (M : matrix n n T) l,
  Permutation l (determinant'_list M)
  → determinant M = (Σ (k = 0, fact n - 1), nth k l 0)%F.
Proof.
intros Hic * Hl.
rewrite det_is_det_by_canon_permut; [ | easy ].
rewrite determinant'_by_list.
apply rngl_summation_permut; [ now symmetry | | ]. {
  unfold determinant'_list.
  now rewrite map_length, seq_length.
} {
  apply Permutation_length in Hl.
  unfold determinant'_list in Hl.
  now rewrite map_length, seq_length in Hl.
}
Qed.

(* order of permutations where ranks p & q are swapped with the
   last two numbers, allowing consecutive permutations
   to have the p-th and the q-th numbers swapped; perhaps
   useful to prove aternativity, if I can do it.
   we have: permut_swap_last (n-2) (n-1) n k = permut n k *)

(*
Compute list_of_vect (permut 4 13).
     = [2; 0; 3; 1]
*)

Definition swap_nat i j k :=
  if Nat.eq_dec k i then j
  else if Nat.eq_dec k j then i
  else k.

Definition vect_swap_elem n (v : vector n nat) i j :=
  mk_vect n (λ k, vect_el v (swap_nat i j k)).

(* i such that vect_el (permut n k) i = j *)

Definition canon_permut_swap_with_0 p n k :=
  vect_swap_elem (canon_permut n k) 0 p.

(*
Compute (map (λ i, list_of_vect (permut_swap_with_0 0 3 i)) (seq 0 (fact 3))).
Compute (map (λ i, list_of_vect (permut_swap_with_0 1 3 i)) (seq 0 (fact 3))).
Compute (map (λ i, list_of_vect (permut_swap_with_0 2 3 i)) (seq 0 (fact 3))).
*)

(* k' such that permut_swap_with_0 p n k = permut n k' *)

Definition canon_permut_nth_of_swap_with_0 (p n k : nat) :=
  nat_of_canon_permut (canon_permut_swap_with_0 p n k).

Definition canon_permut_swap_last (p q : nat) n k :=
  vect_swap_elem (vect_swap_elem (canon_permut n k) p (n - 2)) q (n - 1).

(* yet another definition of determinant *)

Definition determinant'' p q n (M : matrix n n T) :=
  (Σ (k = 0, fact n - 1), ε_canon_permut n k *
   Π (i = 1, n),
   mat_el M (i - 1) (vect_el (canon_permut_swap_last p q n k) (i - 1)%nat))%F.

Definition determinant''_list p q {n} (M : matrix n n T) :=
  map (λ k,
    (ε_canon_permut n k *
     Π (i = 1, n),
     mat_el M (i - 1) (vect_el (canon_permut_swap_last p q n k) (i - 1)%nat))%F)
    (seq 0 (fact n)).

Theorem determinant''_by_list : ∀ n p q (M : matrix n n T),
  determinant'' p q M =
    (Σ (k = 0, fact n - 1), nth k (determinant''_list p q M) 0)%F.
Proof.
intros.
unfold determinant'', determinant''_list.
apply rngl_summation_eq_compat; intros k Hk.
assert (Hkn : k < fact n). {
  specialize (fact_neq_0 n) as Hn.
  flia Hk Hn.
}
rewrite List_map_nth_in with (a := 0); [ | now rewrite seq_length ].
rewrite seq_nth; [ | easy ].
now rewrite Nat.add_0_l.
Qed.

Theorem vect_el_canon_permut_ub : ∀ n k i,
  k < fact n
  → i < n
  → vect_el (canon_permut n k) i < n.
Proof.
intros * Hkn Hin.
revert k i Hkn Hin.
induction n; intros; [ easy | cbn ].
unfold canon_permut_fun.
destruct i. {
  rewrite Nat_fact_succ, Nat.mul_comm in Hkn.
  apply Nat.div_lt_upper_bound; [ | easy ].
  apply fact_neq_0.
}
apply Nat.succ_lt_mono in Hin.
remember (k / fact n <=? vect_el (canon_permut n (k mod fact n)) i) as b eqn:Hb.
symmetry in Hb.
destruct b. {
  cbn; rewrite Nat.add_1_r.
  apply -> Nat.succ_lt_mono.
  apply IHn; [ | easy ].
  apply Nat.mod_upper_bound, fact_neq_0.
}
cbn; rewrite Nat.add_0_r.
apply Nat.leb_gt in Hb.
etransitivity; [ apply Hb | ].
rewrite Nat_fact_succ, Nat.mul_comm in Hkn.
apply Nat.div_lt_upper_bound; [ | easy ].
apply fact_neq_0.
Qed.

Theorem swap_nat_swap_nat : ∀ n p q j k,
  p < q < n
  → j < n
  → k < n
  → j ≠ k
  → swap_nat p (n - 2) (swap_nat q (n - 1) j) ≠
    swap_nat p (n - 2) (swap_nat q (n - 1) k).
Proof.
intros * (Hpq, Hqn) Hjn Hkn Hjk Hjke.
unfold swap_nat in Hjke.
destruct (Nat.eq_dec j q) as [H1| H1]. {
  subst j.
  destruct (Nat.eq_dec k q) as [H1| H1]; [ now subst k | ].
  clear H1.
  destruct (Nat.eq_dec (n - 1) p) as [H1| H1]. {
    subst p; flia Hpq Hqn.
  }
  destruct (Nat.eq_dec (n - 1) (n - 2)) as [H2| H2]. {
    destruct n; [ easy | ].
    destruct n; [ | flia H2 ].
    apply Nat.lt_1_r in Hqn; subst q.
    now apply Nat.lt_1_r in Hkn; subst k.
  }
  destruct (Nat.eq_dec k (n - 1)) as [H3| H3]. {
    subst k.
    destruct (Nat.eq_dec q p) as [H4| H4]; [ now subst q | ].
    destruct (Nat.eq_dec q (n - 2)) as [H5| H5]; [ now subst p | ].
    now subst q.
  }
  destruct (Nat.eq_dec k p) as [H4| H4]; [ easy | ].
  destruct (Nat.eq_dec k (n - 2)) as [H5| H5]; [ now subst p | ].
  now subst k.
} {
  destruct (Nat.eq_dec k q) as [H2| H2]. {
    subst k; clear Hkn H1.
    destruct (Nat.eq_dec j (n - 1)) as [H1| H1]. {
      subst j.
      destruct (Nat.eq_dec q p) as [H| H]; [ subst q; flia Hpq | ].
      clear H Hjn.
      destruct (Nat.eq_dec (n - 1) p) as [H1| H1]. {
        subst p; flia Hpq Hqn.
      }
      destruct (Nat.eq_dec q (n - 1)) as [H| H]; [ now subst q | ].
      clear H.
      destruct (Nat.eq_dec q (n - 2)) as [H2| H2]. {
        subst q.
        destruct (Nat.eq_dec (n - 1) (n - 2)) as [H| H]. {
          destruct n; [ easy | ].
          destruct n; [ | flia H ].
          flia Hpq.
        }
        now symmetry in Hjke.
      }
      destruct (Nat.eq_dec (n - 1) (n - 2)) as [H3| H3]. {
        subst q; flia Hpq.
      }
      now symmetry in Hjke.
    }
    destruct (Nat.eq_dec j p) as [H2| H2]. {
      subst j.
      destruct (Nat.eq_dec (n - 1) p) as [H3| H3]; [ now subst p | ].
      destruct (Nat.eq_dec (n - 1) (n - 2)) as [H2| H2]; [ now subst p | ].
      destruct n; [ easy | ].
      destruct n; [ flia H2 | flia Hjke ].
    }
    destruct (Nat.eq_dec j (n - 2)) as [H3| H3]. {
      subst j.
      destruct (Nat.eq_dec (n - 1) p) as [H3| H3]. {
        now subst p; symmetry in Hjke.
      }
      destruct (Nat.eq_dec (n - 1) (n - 2)) as [H4| H4]; [ | now subst p ].
      destruct n; [ easy | ].
      destruct n; [ easy | flia H4 ].
    }
    destruct (Nat.eq_dec (n - 1) p) as [H4| H4]; [ now subst j | ].
    destruct (Nat.eq_dec (n - 1) (n - 2)) as [H5| H5]; [ now subst j | easy ].
  }
  destruct (Nat.eq_dec j (n - 1)) as [H3| H3]. {
    subst j.
    destruct (Nat.eq_dec q p) as [H| H]; [ subst q; flia Hpq | clear H ].
    destruct (Nat.eq_dec k (n - 1)) as [H| H]; [ now subst k | clear H ].
    destruct (Nat.eq_dec q (n - 2)) as [H3| H3]. {
      subst q.
      destruct (Nat.eq_dec k p) as [H3| H3]; [ now subst k p | ].
      now destruct (Nat.eq_dec k (n - 2)); subst k.
    }
    destruct (Nat.eq_dec k p) as [H4| H4]; [ now subst k | ].
    destruct (Nat.eq_dec k (n - 2)) as [H5| H5]; [ subst k q; flia Hpq  | ].
    now subst k.
  }
  destruct (Nat.eq_dec k (n - 1)) as [H4| H4]; [ subst k | ]. {
    destruct (Nat.eq_dec j p) as [H4| H4]; [ subst j | ]. {
      destruct (Nat.eq_dec q p) as [H5| H5]; [ now subst q | ].
      now destruct (Nat.eq_dec q (n - 2)); subst q.
    }
    destruct (Nat.eq_dec q p) as [H5| H5]; [ subst q; flia Hpq | ].
    destruct (Nat.eq_dec j (n - 2)) as [H6| H6]; [ subst j | ]. {
      now destruct (Nat.eq_dec q (n - 2)); subst q.
    }
    now destruct (Nat.eq_dec q (n - 2)); subst q.
  }
  destruct (Nat.eq_dec j p) as [H5| H5]; [ subst j | ]. {
    destruct (Nat.eq_dec k p) as [H5| H5]; [ now subst k | ].
    destruct (Nat.eq_dec k (n - 2)) as [H6| H6]; [ now subst k | ].
    now subst k.
  }
  destruct (Nat.eq_dec k p) as [H6| H6]; [ subst k | ]. {
    destruct (Nat.eq_dec j (n - 2)) as [H6| H6]; [ now subst p | easy ].
  }
  destruct (Nat.eq_dec j (n - 2)) as [H7| H7]; [ subst j | ]. {
    now destruct (Nat.eq_dec k (n - 2)); subst k.
  }
  now destruct (Nat.eq_dec k (n - 2)); subst k.
}
Qed.

Theorem swap_nat_lt : ∀ i j k n,
  i < n
  → j < n
  → k < n
  → swap_nat i j k < n.
Proof.
intros * Hi Hj Hk.
unfold swap_nat.
destruct (Nat.eq_dec k i); [ easy | ].
now destruct (Nat.eq_dec k j).
Qed.

(*
End a.
Require Import Zrl.
Require Import ZArith.
Compute (map (λ i, list_of_vect (permut 3 i)) (seq 0 (fact 3))).
Compute (map (λ i, minus_one_pow (vect_el (permut 3 i) 2)) (seq 0 (fact 3))).
Compute (map (λ i, minus_one_pow (vect_el (permut 4 i) 3)) (seq 0 (fact 4))).
Compute @signature _ Z_ring_like_op 4 0.
Compute @signature _ Z_ring_like_op 4 (nat_of_permut (permut_swap_last 0 1 4 0)).
*)

Theorem vect_swap_elem_same : ∀ n (v : vector n nat) i,
  vect_swap_elem v i i = v.
Proof.
intros.
apply vector_eq; cbn.
intros j Hj.
unfold swap_nat.
destruct (Nat.eq_dec j i); [ now subst i | easy ].
Qed.

Definition permut_comp {n} (σ₁ σ₂ : vector n nat) :=
  mk_vect n (λ i, vect_el σ₁ (vect_el σ₂ i)).

Notation "σ₁ ° σ₂" := (permut_comp σ₁ σ₂) (at level 40).

(* https://fr.wikipedia.org/wiki/Signature_d%27une_permutation#Une_transposition_est_impaire *)

(*
Theorem pouet :
  rngl_is_comm = true →
  ∀ n (σ₁ σ₂ : vector n nat),
  (ε (σ₁ ° σ₂) * ε σ₂)%F = ε σ₁.
Proof.
intros Hic *.
unfold ε.
rewrite <- (rngl_product_mul_distr _ Hic).
erewrite rngl_product_eq_compat. 2: {
  intros i Hi.
  now rewrite <- (rngl_product_mul_distr _ Hic).
}
cbn - [ iter_seq ].
(*
replace (Π (i = _, _), Π (j = _, _), _)%F with
  (Π (i = 1, n),
   (Π (j = 1, n),
    (sgn_diff (vect_el σ₁ (vect_el σ₂ (j - 1)))
       (vect_el σ₁ (vect_el σ₂ (i - 1))) *
     sgn_diff (vect_el σ₂ (j - 1)) (vect_el σ₂ (i - 1)))))%F. 2: {
  apply rngl_product_eq_compat.
  intros i Hi.
  erewrite (rngl_product_split _ i); [ | flia Hi ].
  rewrite <- rngl_mul_1_l.
  f_equal.
...
*)
replace (Π (i = _, _), Π (j = _, _), _)%F with
  (Π (k = 1, n), Π (l = k + 1, n),
   (sgn_diff (vect_el σ₁ k) (vect_el σ₁ l) * sgn_diff k l))%F. 2: {
...
(*
replace (Π (i = _, _), Π (j = _, _), _)%F with
  (Π (k = 1, n), Π (l = 1, n),
   (sgn_diff (vect_el σ₁ k) (vect_el σ₁ l) * sgn_diff k l))%F. 2: {
...
(**)
erewrite rngl_product_eq_compat. 2: {
  intros i Hi.
  erewrite rngl_product_eq_compat. 2: {
    intros j Hj.
    remember (vect_el σ₂ (i - 1)) as l eqn:Hl.
    remember (vect_el σ₂ (j - 1)) as k eqn:Hk.
(* i varies from 1 to n
   j varies from i+1 to n
   ⇒
   k varies from vect_el σ₂ i to vect_el σ₂ n-1
   l varies from vect_el σ₂ 0 to vect_el σ₂ n-1
*)
...
  Hl : l = vect_el σ₂ (i - 1)
  k : nat
  Hk : k = vect_el σ₂ (j - 1)
  ============================
  (sgn_diff (vect_el σ₁ k) (vect_el σ₁ l) * sgn_diff k l)%F = ?h0 j
...

apply rngl_product_eq_compat.
intros j Hj.
...
*)
*)

Theorem rngl_product_change_var : ∀ b e f g h,
  (∀ i, b ≤ i ≤ e → g (h i) = i)
  → (Π (i = b, e), f i = Π (i ∈ map h (seq b (S e - b))), f (g i))%F.
Proof.
intros * Hgh.
unfold iter_seq, iter_list.
rewrite List_fold_left_map.
apply List_fold_left_ext_in.
intros i c Hi.
f_equal; f_equal; symmetry.
apply Hgh.
apply in_seq in Hi.
flia Hi.
Qed.

Definition is_permut {n} (σ : vector n nat) :=
  (∀ i, i < n → vect_el σ i < n) ∧
  (∀ i j, i < n → j < n → vect_el σ i = vect_el σ j → i = j).

Fixpoint permut_find n (σ : vector n nat) i j :=
  match i with
  | 0 => 42
  | S i' => if Nat.eq_dec (vect_el σ i') j then i' else permut_find σ i' j
  end.

Definition permut_inv n (σ : vector n nat) := mk_vect n (permut_find σ n).

Fixpoint fun_find (f : nat → nat) n i :=
  match n with
  | 0 => 42
  | S n' => if Nat.eq_dec (f n') i then n' else fun_find f n' i
  end.

Theorem permut_list_find : ∀ n (σ : vector n nat) i j,
  permut_find σ i j = fun_find (vect_el σ) i j.
Proof.
intros.
induction i; [ easy | cbn ].
destruct (Nat.eq_dec (vect_el σ i) j) as [Hij| Hij]; [ easy | ].
apply IHi.
Qed.

(*
Compute let n := 4 in let k := 3 in (list_of_vect (canon_permut n k), list_of_vect (permut_inv (canon_permut n k))).
Compute let n := 4 in map (λ k, list_of_vect (permut_inv (canon_permut n k))) (seq 0 (fact n)).
*)

Theorem fun_find_prop : ∀ f n i,
  (∀ i j, i < n → j < n → f i = f j → i = j)
  → i < n
  → fun_find f n (f i) = i.
Proof.
intros * Hp2 Hin.
revert i Hin.
induction n; intros; [ easy | cbn ].
destruct (Nat.eq_dec (f n) (f i)) as [Hfni| Hfni]. {
  apply Hp2; [ flia | easy | easy ].
}
rename Hin into Hisn.
assert (Hin : i < n). {
  destruct (Nat.eq_dec n i) as [H| H]; [ now subst n | ].
  flia Hisn H.
}
clear Hisn.
apply IHn; [ | easy ].
intros j k Hj Hk Hjk.
apply Hp2; [ flia Hj | flia Hk | easy ].
Qed.

Theorem permut_inv_permut_prop : ∀ n (σ : vector n nat) i,
  is_permut σ
  → i < n
  → vect_el (permut_inv σ) (vect_el σ i) = i.
Proof.
intros * (_, Hp2) Hin; cbn.
rewrite permut_list_find.
now apply fun_find_prop.
Qed.

(*
Theorem glop : ∀ f i k n,
  (∀ i, i < n → f i < n)
  → (∀ i j, i < n → j < n → f i = f j → i = j)
  → i < n ≤ k
  → f (fun_find f k i) = i.
Proof.
intros * Hfi Hff (Hin, Hnk).
revert f n Hfi Hff i Hin Hnk.
induction k; intros; [ flia Hin Hnk | cbn ].
destruct (Nat.eq_dec (f k) i) as [Hki| Hki]; [ easy | ].
destruct (Nat.eq_dec n (S k)) as [Hnsk| Hnks]. 2: {
  apply IHk with (n := n); [ easy | easy | easy | ].
  flia Hnk Hnks.
}
clear Hnk; subst n.
destruct (Nat.eq_dec (f k) k) as [Hfkk| Hfkk]. {
  apply IHk with (n := k); [ | | | easy ]. 3: {
    flia Hin Hki Hfkk.
  } {
    intros j Hj.
    specialize (Hfi j) as H1.
    assert (H : j < S k) by flia Hj.
    specialize (H1 H); clear H.
    destruct (Nat.eq_dec (f j) k) as [Hfjk| Hfjk]. {
      rewrite <- Hfkk in Hfjk.
      apply Hff in Hfjk; [ flia Hj Hfjk | flia Hj | flia ].
    }
    specialize (Hfi j) as H2.
    assert (H : j < S k) by flia Hj.
    specialize (H2 H); clear H.
    flia Hfjk H2.
  } {
    intros m n Hm Hn Hmn.
    apply Hff; [ flia Hm | flia Hn | easy ].
  }
}
destruct (Nat.eq_dec i k) as [Hik| Hik]. {
  subst i; clear Hin Hki.
  clear IHk.
...
  clear - Hfi Hfkk.
  induction k. {
    specialize (Hfi 0 Nat.lt_0_1) as H1.
    flia Hfkk H1.
  }
  cbn.
  destruct (Nat.eq_dec (f k) (S k)) as [Hfksk| Hfksk]; [ easy | ].
...
apply IHk with (n := k); try easy.
...
  eapply lt_le_trans; [ apply Hin | ].
  apply -> Nat.succ_le_mono.
  specialize (
...
specialize (Hfi k (Nat.lt_succ_diag_r _)) as H1.
...
destruct (Nat.eq_dec i k) as [Hik| Hik]. 2: {
  apply IHk with (n := k); [ | | flia Hik Hin | easy ]. {
    intros j Hj.
...
    destruct j. {
      destruct k; [ easy | ].
      clear Hj.
apply IHk with (
...
destruct n; [ flia Hik | ].
apply Nat.succ_le_mono in Hkn.
destruct i. {
  clear IHk.
  clear Hik.
  revert n Hfi Hff Hkn.
  induction k; intros. {
    exfalso.
    apply Nat.le_0_r in Hkn; subst n.
    specialize (Hfi 0 Nat.lt_0_1).
    flia Hfi Hki.
  }
  cbn.
  destruct (Nat.eq_dec (f k) 0) as [H1| H1]; [ easy | ].
  destruct n. {
apply IHk with (n := n).
destruct i. {
  destruct k. {
    cbn.
...
apply IHk with (n := n); [ easy | easy | | flia Hkn ].
...
*)

Theorem pigeonhole_exist : ∀ a b f,
  b < a
  → (∀ x, x < a → f x < b)
  → ∃ x x', x < a ∧ x' < a ∧ x ≠ x' ∧ f x = f x'.
Proof.
intros * Hba Hf.
(* to be copied from my github coq_euler_prod_form *)
Admitted.

Theorem glop : ∀ f i n,
  (∀ i, i < n → f i < n)
  → (∀ i j, i < n → j < n → f i = f j → i = j)
  → i < n
  → f (fun_find f n i) = i.
Proof.
intros * Hp1 Hp2 Hin.
destruct n; [ easy | cbn ].
destruct (Nat.eq_dec (f n) i) as [Hfi0| Hfi0]; [ easy | ].
(**)
specialize (@pigeonhole_exist (S n) n) as H1.
...
specialize (H1 (λ j, if lt_dec i j then f j else f (j + 1))).
specialize (H1 (Nat.lt_succ_diag_r _)).
cbn in H1.
assert (∀ j, j < S n → (if lt_dec i j then f j else f (j + 1)) < n). {
  intros j Hj.
  destruct (lt_dec i j) as [Hij| Hij]. {
    specialize (Hp1 _ Hj) as H3.
...
specialize (Hp1 0 (Nat.lt_0_succ _)) as H0.
remember (f 0) as i0 eqn:Hi0; symmetry in Hi0.
move i0 before i.
move H0 before Hin.
destruct n; [ exfalso | cbn ]. {
  rewrite Hi0 in Hfi0.
  flia Hin Hfi0 H0.
}
rename Hfi0 into Hfi1.
destruct (Nat.eq_dec (f n) i) as [Hfi0| Hfi0]; [ easy | ].
specialize (Hp1 1) as H1.
assert (H : 1 < S (S n)) by flia.
specialize (H1 H); clear H.
remember (f 1) as i1 eqn:Hi1; symmetry in Hi1.
move i1 before i0.
move H1 before H0.
move Hfi0 before Hfi1.
destruct n; [ exfalso | cbn ]. {
  rewrite Hi0 in Hfi0.
  rewrite Hi1 in Hfi1.
  destruct i0. {
    destruct i1. {
      enough (0 = 1); [ easy | ].
      apply Hp2; [ easy | flia | congruence ].
    }
    destruct i1; [ | flia H1 ].
    flia Hin Hfi0 Hfi1.
  }
  destruct i0; [ | flia H0 ].
  destruct i1; [ flia Hin Hfi0 Hfi1 | ].
  destruct i1; [ | flia H1 ].
  enough (0 = 1); [ easy | ].
  apply Hp2; [ flia | flia | congruence ].
}
rename Hfi1 into Hfi2.
rename Hfi0 into Hfi1.
destruct (Nat.eq_dec (f n) i) as [Hfi0| Hfi0]; [ easy | ].
specialize (Hp1 2) as H2.
assert (H : 2 < S (S (S n))) by flia.
specialize (H2 H); clear H.
remember (f 2) as i2 eqn:Hi2; symmetry in Hi2.
move i2 before i1.
move H2 before H1.
move Hfi0 before Hfi1.
destruct n; [ exfalso | cbn ]. {
  rewrite Hi0 in Hfi0.
  rewrite Hi1 in Hfi1.
  rewrite Hi2 in Hfi2.
  destruct i0. {
    destruct i1. {
      enough (0 = 1); [ easy | ].
      apply Hp2; [ easy | flia | congruence ].
    }
    destruct i1. {
      destruct i2. {
        enough (0 = 2); [ easy | ].
        apply Hp2; [ easy | flia | congruence ].
      }
      destruct i2. {
        enough (1 = 2); [ easy | ].
        apply Hp2; [ easy | flia | congruence ].
      }
      destruct i2; [ | flia H2 ].
      flia Hin Hfi0 Hfi1 Hfi2.
    }
    destruct i1; [ | flia H1 ].
    destruct i2. {
      enough (0 = 2); [ easy | ].
      apply Hp2; [ easy | flia | congruence ].
    }
    destruct i2; [ flia Hin Hfi0 Hfi1 Hfi2 | ].
    destruct i2; [ | flia H2 ].
    enough (1 = 2); [ easy | ].
    apply Hp2; [ flia | flia | congruence ].
  }
  destruct i0. {
    destruct i1. {
      destruct i2. {
        enough (1 = 2); [ easy | ].
        apply Hp2; [ flia | flia | congruence ].
      }
      destruct i2. {
        enough (0 = 2); [ easy | ].
        apply Hp2; [ flia | flia | congruence ].
      }
      destruct i2; [ | flia H2 ].
      flia Hin Hfi0 Hfi1 Hfi2.
    }
    destruct i1. {
      enough (0 = 1); [ easy | ].
      apply Hp2; [ flia | flia | congruence ].
    }
    destruct i1; [ | flia H1 ].
    destruct i2; [ flia Hin Hfi0 Hfi1 Hfi2 | ].
    destruct i2. {
      enough (0 = 2); [ easy | ].
      apply Hp2; [ flia | flia | congruence ].
    }
    destruct i2; [ | flia H2 ].
    enough (1 = 2); [ easy | ].
    apply Hp2; [ flia | flia | congruence ].
  }
  destruct i0; [ | flia H0 ].
  destruct i1. {
    destruct i2. {
      enough (1 = 2); [ easy | ].
      apply Hp2; [ flia | flia | congruence ].
    }
    destruct i2; [ flia Hin Hfi0 Hfi1 Hfi2 | ].
    destruct i2; [ | flia H2 ].
    enough (0 = 2); [ easy | ].
    apply Hp2; [ flia | flia | congruence ].
  }
  destruct i1. {
    destruct i2; [ flia Hin Hfi0 Hfi1 Hfi2 | ].
    destruct i2. {
      enough (1 = 2); [ easy | ].
      apply Hp2; [ flia | flia | congruence ].
    }
    destruct i2; [ | flia H2 ].
    enough (0 = 2); [ easy | ].
    apply Hp2; [ flia | flia | congruence ].
  }
  destruct i1; [ | flia H1 ].
  enough (0 = 1); [ easy | ].
  apply Hp2; [ flia | flia | congruence ].
}
rename Hfi2 into Hfi3.
rename Hfi1 into Hfi2.
rename Hfi0 into Hfi1.
destruct (Nat.eq_dec (f n) i) as [Hfi0| Hfi0]; [ easy | ].
specialize (Hp1 3) as H3.
assert (H : 3 < S (S (S (S n)))) by flia.
specialize (H3 H); clear H.
remember (f 3) as i3 eqn:Hi3; symmetry in Hi3.
move i3 before i2.
move H3 before H2.
move Hfi0 before Hfi1.
remember 3 as k eqn:Hk.
assert (Hfn : ∀ j, j ≤ k → f (n + j) ≠ i). {
  intros j Hjk.
  subst k.
  rewrite Nat.add_comm.
  destruct j; [ easy | ].
  destruct j; [ easy | ].
  destruct j; [ easy | ].
  destruct j; [ easy | ].
  flia Hjk.
}
clear Hfi0 Hfi1 Hfi2 Hfi3.
assert (Hi : i ≤ n + k) by flia Hin Hk.
clear Hin.
assert (H : ∀ i, i ≤ n + k → f i ≤ n + k). {
  intros j Hj.
  specialize (Hp1 j).
  assert (H : j < S (S (S (S n)))) by flia Hj Hk.
  specialize (Hp1 H); clear H.
  flia Hk Hp1.
}
clear Hp1; rename H into Hp1.
assert (H : ∀ i j, i ≤ n + k → j ≤ n + k → f i = f j → i = j). {
  intros a b Ha Hb Hab.
  apply Hp2; [ flia Hk Ha | flia Hk Hb | easy ].
}
clear Hp2; rename H into Hp2.
clear - Hfn Hi Hp1 Hp2.
revert i k Hfn Hi Hp1 Hp2.
induction n; intros; [ exfalso | cbn ]. {
  cbn in Hfn, Hi, Hp1, Hp2.
...
  revert i Hfn Hi.
  induction k; intros. {
    apply Nat.le_0_r in Hi; subst i.
    specialize (Hp1 0 (le_refl _)) as H1.
    specialize (Hfn 0 (le_refl _)) as H2.
    now apply Nat.le_0_r in H1.
  }
...
  destruct (Nat.eq_dec i (S k)) as [Hisk| Hisk]. {
    subst i; clear Hi.
    apply IHk with (i := k); [ | | | easy ]. {
      intros i Hik.
      assert (H : i ≤ S k) by flia Hik.
      specialize (Hp1 i H) as H1.
      specialize (Hfn i H) as H2; clear H.
      flia H1 H2.
    } {
      intros i j Hi Hj Hij.
      apply Hp2; [ flia Hi | flia Hj | easy ].
    } {
      intros j Hj.
...
      assert (H : j ≤ S k) by flia Hj.
      specialize (Hp1 j H) as H1.
      specialize (Hfn j H) as H2; clear H.
      assert (H3 : f j ≤ k) by flia H1 H2.
...
revert i n Hi Hfn Hp1 Hp2.
induction k; intros; cbn. {
  specialize (Hfn 0 (le_refl _)).
  rewrite Nat.add_0_r in Hp1, Hp2, Hi, Hfn.
  revert i Hi Hfn.
  induction n; intros; [ exfalso | cbn ]. {
    apply Nat.le_0_r in Hi; subst i.
    specialize (Hp1 0 (le_refl _)).
    now apply Nat.le_0_r in Hp1.
  }
  destruct (Nat.eq_dec (f n) i) as [Hfni'| Hfni']; [ easy | ].
  destruct n; [ exfalso | cbn ]. {
...
  }
  destruct (Nat.eq_dec (f n) i) as [Hfni| Hfni]; [ easy | ].
...

  destruct (Nat.eq_dec i (S n)) as [Hisn| Hisn]. {
    subst i; clear Hi.
    clear IHn.
    induction n; [ exfalso | cbn ]. {
      specialize (Hp1 0 Nat.le_0_1) as H1.
      specialize (Hp1 1 (le_refl _)) as H2.
      enough (H : 0 = 1); [ easy | ].
      apply Hp2; [ flia | flia | ].
      flia Hfni' Hfn H1 H2.
    }
    destruct (Nat.eq_dec (f n) (S (S n))) as [Hfns| Hfns]; [ easy | ].
...
  apply IHn; [ | | | easy ].
...
destruct n; [ exfalso | cbn ]. {
  cbn in Hfn.
  remember (f 0) as i0 eqn:Hi0; symmetry in Hi0.
  specialize (Hfn 0 (Nat.le_0_l _)) as H0.
  destruct H0 as (H0, Hf0).
  specialize (Hfn 1) as H1.
  assert (H : 1 ≤ k) by flia Hk.
  specialize (H1 H); clear H.
  destruct H1 as (H1, Hf1).
  destruct i0. {
...

Theorem permut_permut_inv_prop : ∀ n (σ : vector n nat) i,
  is_permut σ
  → i < n
  → vect_el σ (vect_el (permut_inv σ) i) = i.
Proof.
intros * (Hp1, Hp2) Hin; cbn.
rewrite permut_list_find.
remember (vect_el σ) as f eqn:Hf.
clear σ Hf.
Print fun_find.
...
(*
revert f Hp1 i Hin.
induction n; intros; [ easy | cbn ].
destruct (Nat.eq_dec (f n) i) as [Hni| Hni]; [ easy | ].
rename Hin into Hisn.
destruct n; [ exfalso | ]. {
  apply Nat.lt_1_r in Hisn; subst i.
  specialize (Hp1 0 Nat.lt_0_1).
  flia Hp1 Hni.
}
cbn.
destruct (Nat.eq_dec (f n) i) as [Hfni| Hfni]; [ easy | ].
specialize (IHn (λ i, f i - 1)).
cbn - [ fun_find ] in IHn.
assert (H : ∀ i : nat, i < S n → f i - 1 < S n). {
  intros j Hj.
  specialize (Hp1 j).
  assert (H : j < S (S n)) by flia Hj.
  specialize (Hp1 H); clear H.
  flia Hp1.
}
specialize (IHn H); clear H.
assert (H : ∀ i j : nat, i < S n → j < S n → f i - 1 = f j - 1 → i = j). {
  intros j k Hj Hk Hjk.
...
  apply Hp2; [ flia Hj | flia Hk | ].
...
  specialize (Hp1 (S j)).
  assert (H : S j < S (S n)) by flia Hj.
  specialize (Hp1 H); clear H.
...
cbn in IHn.
...
*)
assert (Hsurj : ∀ i, i < n → ∃ j, j < n ∧ f j = i). {
  clear i Hin.
  intros i Hi.
(*
  destruct n; [ easy | ].
  destruct n. {
    exists 0.
    split; [ flia | ].
    specialize (Hp1 _ Hi).
    apply Nat.lt_1_r in Hp1.
    apply Nat.lt_1_r in Hi.
    now subst i.
  }
  destruct n. {
    specialize (Hp1 _ Hi) as H1.
    assert (H2 : ∀ j, j < 2 → f i = f j → i = j). {
      now intros; apply Hp2.
    }
    remember (f 0) as k eqn:Hk; symmetry in Hk.
    remember (f 1) as l eqn:Hl; symmetry in Hl.
    move l before k.
    destruct i. {
      destruct k. {
        exists 0.
        split; [ flia | easy ].
      }
      destruct k; [ | flia H1 Hk ].
      exists 1.
      split; [ flia | ].
      destruct l; [ easy | exfalso ].
      destruct l. 2: {
        specialize (Hp1 1 (Nat.lt_1_2)).
        flia Hp1 Hl.
      }
      specialize (H2 _ Nat.lt_1_2).
      rewrite Hk, Hl in H2.
      now specialize (H2 eq_refl).
    }
    destruct i; [ | flia Hi ].
    destruct k. {
      exists 1.
      split; [ flia | ].
      destruct l. {
        specialize (Hp2 0 1 Nat.lt_0_2 Nat.lt_1_2).
        rewrite Hk, Hl in Hp2.
        now specialize (Hp2 eq_refl).
      }
      destruct l; [ easy | ].
      specialize (Hp1 1 Nat.lt_1_2).
      flia Hp1 Hl.
    }
    destruct k. 2: {
      specialize (Hp1 0 Nat.lt_0_2).
      flia Hp1 Hk.
    }
    exists 0.
    split; [ flia | easy ].
  }
...
*)
...
  revert f Hp1 Hp2 i Hi.
  induction n; intros; [ easy | ].
...
  Hp1 : ∀ i : nat, i < S n → f i < S n
  Hp2 : ∀ i j : nat, i < S n → j < S n → f i = f j → i = j
  IHn : (∀ i : nat, i < n → f i < n)
        → (∀ i j : nat, i < n → j < n → f i = f j → i = j) → ∀ i : nat, i < n → ∃ j : nat, f j = i
  i : nat
  Hi : i < S n
  ============================
  f (fun_find f n i) = i
...
(**)
revert f i Hin Hp1 Hp2.
induction n; intros; [ easy | cbn ].
destruct (Nat.eq_dec (f n) i) as [Hni| Hni]; [ easy | ].
rename Hin into Hisn.
specialize (IHn (λ i, i - 1)) as H1.
cbn in H1.
...
destruct (Nat.eq_dec i n) as [Hin| Hin]. {
  subst i; clear Hisn.
...
  assert (H1 : f n < n). {
    specialize (Hp1 n (Nat.lt_succ_diag_r _)) as H1.
    flia Hni H1.
  }
  clear Hni; rename H1 into Hfnn.
...
}
apply IHn; [ | | flia Hisn Hin ]. {
  intros j Hj.
  destruct (Nat.eq_dec (f j) n) as [Hfjn| Hfjn]. {
...
  clear IHn.
  induction n; [ easy | cbn ].
  destruct (Nat.eq_dec (f n) (S n)) as [Hfnsn| Hfnsn]; [ easy | ].
...
destruct i. {
  clear Hin.
...
induction n; [ easy | cbn ].
destruct (Nat.eq_dec (f n) i) as [Hni| Hni]; [ easy | ].
...
revert i Hin.
induction n; intros; [ easy | cbn ].
destruct (Nat.eq_dec (f n) i) as [Hni| Hni]; [ easy | ].
...
destruct (Nat.eq_dec i n) as [Hin'| Hin']. {
  subst i.
  clear Hin.
  destruct n. {
    specialize (Hp1 0 Nat.lt_0_1).
    flia Hp1 Hni.
  }
  cbn.
  destruct (Nat.eq_dec (f n) (S n)) as [H1| H1]; [ easy | ].
...
intros * (Hp1, Hp2) Hin; cbn.
rewrite permut_fun_find.
remember (vect_el σ) as f eqn:Hf.
clear σ Hf.
destruct n; [ easy | cbn ].
destruct (Nat.eq_dec (f n) i) as [Hni| Hni]; [ easy | ].
destruct n. {
  specialize (Hp1 _ Hin) as H1; cbn.
  apply Nat.lt_1_r in Hin.
  apply Nat.lt_1_r in H1.
  now subst i.
}
cbn.
destruct (Nat.eq_dec (f n) i) as [Hsni| Hsni]; [ easy | ].
destruct n. {
  specialize (Hp1 _ Hin) as H1; cbn.
  specialize (Hp1 1 (Nat.lt_succ_diag_r _)) as H2.
  specialize (Hp2 0 1 (Nat.lt_0_succ _) (Nat.lt_succ_diag_r _)) as H3.
  destruct i. {
    remember (f 0) as x eqn:Hx; symmetry in Hx.
    destruct x; [ easy | exfalso ].
    destruct x; [ | flia H1 ].
    flia Hni Hx H2 H3.
  }
  destruct i; [ | flia Hin ].
  remember (f 0) as x eqn:Hx; symmetry in Hx.
  destruct x; [ flia Hni H1 H3 | ].
  destruct x; [ easy | exfalso ].
  specialize (Hp1 0 (Nat.lt_0_succ _)) as H4.
  flia Hx H4.
}
...
revert i Hin.
induction n; intros; [ easy | cbn ].
destruct (Nat.eq_dec (f n) i) as [Hni| Hni]; [ easy | ].
destruct i. {

  destruct n. {
    cbn.
    specialize (Hp1 0 Nat.lt_0_1).
    now apply Nat.lt_1_r in Hp1.
  }
  cbn.
  destruct (Nat.eq_dec (f n) 0) as [Hnz| Hnz]; [ easy | ].
  apply IHn.
...
apply IHn.
...
intros * Hperm Hin; cbn.
induction i; intros; cbn. {
  destruct n; [ easy | ].
  cbn.
...
; [ easy | cbn ].
destruct (Nat.eq_dec (vect_el σ n) i) as [Hni| Hni]; [ easy | ].
...

Theorem permut_has_invert : ∀ n (σ : vector n nat),
  is_permut σ
  → ∃ σ' : vector n nat,
     is_permut σ' ∧ ∀ i, i < n → vect_el σ (vect_el σ' i) = i.
Proof.
intros * Hperm.
destruct Hperm as (Hp1, Hp2).
exists (permut_inv σ).

split. {
...

Theorem signature_comp :
  rngl_has_opp = true →
  rngl_has_inv = true →
  rngl_is_comm = true →
  rngl_has_1_neq_0 = true →
  rngl_is_integral = true →
  rngl_characteristic = 0 →
  ∀ n (σ₁ σ₂ : vector n nat),
  is_permut σ₂
  → ε' (σ₁ ° σ₂) = (ε' σ₁ * ε' σ₂)%F.
Proof.
intros Hop Hin Hic H10 Hit Hch * Hperm.
unfold ε'.
cbn - [ iter_seq ].
remember (Π (i = _, _), _)%F as x eqn:Hx in |-*.
remember (Π (i = _, _), _)%F as y eqn:Hy in |-*.
remember (Π (i = _, _), _)%F as z eqn:Hz in |-*.
remember (Π (i = _, _), _)%F as t eqn:Ht in |-*.
move y before x; move z before y; move t before z.
unfold rngl_div.
rewrite Hin.
rewrite rngl_mul_assoc; f_equal.
(**)
specialize rngl_opt_1_neq_0 as rngl_1_neq_0.
rewrite H10 in rngl_1_neq_0.
specialize rngl_opt_mul_inv_l as rngl_mul_inv_l.
rewrite Hin in rngl_mul_inv_l.
specialize rngl_opt_mul_comm as rngl_mul_comm.
rewrite Hic in rngl_mul_comm.
assert (Htz : t ≠ 0%F). {
  intros Hij; rewrite Ht in Hij.
  clear x z t Hx Hy Hz Ht.
  clear σ₁.
  specialize @rngl_product_opt_integral as rngl_product_integral.
  specialize (rngl_product_integral T ro rp Hit H10).
  apply rngl_product_integral in Hij.
  destruct Hij as (i & Hi & Hij).
  apply rngl_product_integral in Hij.
  destruct Hij as (j & Hj & Hij).
  unfold δ in Hij.
  destruct (lt_dec i j) as [Hlij| Hlij]; [ | easy ].
  apply rngl_sub_move_0_r in Hij; [ | easy ].
  apply rngl_of_nat_inj in Hij; [ | easy ].
  destruct Hperm as (Hp1, Hp2).
  specialize (Hp2 (j - 1) (i - 1)) as H1.
  assert (H : j - 1 < n) by flia Hj.
  specialize (H1 H); clear H.
  assert (H : i - 1 < n) by flia Hi.
  now specialize (H1 H); clear H.
}
apply rngl_mul_reg_r with (c := (¹/ t)%F); [ now left | | ]. {
  specialize (rngl_mul_inv_l t Htz) as H1.
  intros H; rewrite H, rngl_mul_0_l in H1.
  now symmetry in H1.
}
rewrite <- rngl_mul_assoc.
rewrite (rngl_mul_comm t), rngl_mul_inv_l; [ | easy ].
rewrite rngl_mul_1_r.
subst y t.
rewrite rngl_inv_product; [ | easy | easy | easy | easy | ]. 2: {
  intros i Hi Hij.
  specialize @rngl_product_opt_integral as rngl_product_integral.
  specialize (rngl_product_integral T ro rp Hit H10).
  apply rngl_product_integral in Hij.
  destruct Hij as (j & Hj & Hij).
  unfold δ in Hij.
  destruct (lt_dec i j) as [Hlij| Hlij]; [ | easy ].
  apply rngl_sub_move_0_r in Hij; [ | easy ].
  apply rngl_of_nat_inj in Hij; [ | easy ].
  destruct Hperm as (Hp1, Hp2).
  specialize (Hp2 (j - 1) (i - 1)) as H1.
  assert (H : j - 1 < n) by flia Hj.
  specialize (H1 H); clear H.
  assert (H : i - 1 < n) by flia Hi.
  now specialize (H1 H); clear H.
}
rewrite rngl_inv_product; [ | easy | easy | easy | easy | ]. 2: {
  intros i Hi Hij.
  specialize @rngl_product_opt_integral as rngl_product_integral.
  specialize (rngl_product_integral T ro rp Hit H10).
  apply rngl_product_integral in Hij.
  destruct Hij as (j & Hj & Hij).
  unfold δ in Hij.
  destruct (lt_dec i j) as [Hlij| Hlij]; [ | easy ].
  apply rngl_sub_move_0_r in Hij; [ | easy ].
  apply rngl_of_nat_inj in Hij; [ | easy ].
  flia Hlij Hij.
}
subst x z.
erewrite <- rngl_product_mul_distr; [ | easy ].
erewrite <- rngl_product_mul_distr; [ | easy ].
erewrite rngl_product_eq_compat. 2: {
  intros i Hi.
  rewrite rngl_inv_product; [ | easy | easy | easy | easy | ]. 2: {
    intros j Hj Hij.
    unfold δ in Hij.
    destruct (lt_dec i j) as [Hlij| Hlij]; [ | easy ].
    apply rngl_sub_move_0_r in Hij; [ | easy ].
    apply rngl_of_nat_inj in Hij; [ | easy ].
    destruct Hperm as (Hp1, Hp2).
    specialize (Hp2 (j - 1) (i - 1)) as H1.
    assert (H : j - 1 < n) by flia Hj.
    specialize (H1 H); clear H.
    assert (H : i - 1 < n) by flia Hi.
    now specialize (H1 H); clear H.
  }
  erewrite <- rngl_product_mul_distr; [ | easy ].
  easy.
}
symmetry.
erewrite rngl_product_eq_compat. 2: {
  intros i Hi.
  rewrite rngl_inv_product; [ | easy | easy | easy | easy | ]. 2: {
    intros j Hj Hij.
    unfold δ in Hij.
    destruct (lt_dec i j) as [Hlij| Hlij]; [ | easy ].
    apply rngl_sub_move_0_r in Hij; [ | easy ].
    apply rngl_of_nat_inj in Hij; [ | easy ].
    flia Hlij Hij.
  }
  erewrite <- rngl_product_mul_distr; [ | easy ].
  easy.
}
symmetry.
(* changement of variable *)
...
specialize (permut_has_invert Hperm) as H1.
destruct H1 as (σ'₂ & Hperm' & Hσ'₂).
rewrite rngl_product_change_var with (g := vect_el σ₂) (h := vect_el σ'₂).
unfold is_permut in Hperm.
...
symmetry.
rewrite <- glop with (g := vect_el σ₂).
apply rngl_product_eq_compat.
intros i Hi.
apply rngl_product_eq_compat.
intros j Hj.
move j before i.
...
rewrite rngl_mul_mul_swap; [ | easy ].
specialize rngl_opt_1_neq_0 as rngl_1_neq_0.
rewrite H10 in rngl_1_neq_0.
assert (Hyz : y ≠ 0%F). {
  intros Hij; rewrite Hy in Hij.
  clear x z t Hx Hy Hz Ht.
  clear σ₁ σ₂ Hperm.
  specialize @rngl_product_opt_integral as rngl_product_integral.
  specialize (rngl_product_integral T ro rp Hit H10).
  apply rngl_product_integral in Hij.
  destruct Hij as (i & Hi & Hij).
  apply rngl_product_integral in Hij.
  destruct Hij as (j & Hj & Hij).
  unfold δ in Hij.
  destruct (lt_dec i j) as [Hlij| Hlij]; [ | easy ].
  apply rngl_sub_move_0_r in Hij; [ | easy ].
  apply rngl_of_nat_inj in Hij; [ | easy ].
  flia Hlij Hij.
}
assert (Htz : t ≠ 0%F). {
  intros Hij; rewrite Ht in Hij.
  clear x z t Hx Hy Hz Ht.
  clear σ₁.
  specialize @rngl_product_opt_integral as rngl_product_integral.
  specialize (rngl_product_integral T ro rp Hit H10).
  apply rngl_product_integral in Hij.
  destruct Hij as (i & Hi & Hij).
  apply rngl_product_integral in Hij.
  destruct Hij as (j & Hj & Hij).
  unfold δ in Hij.
  destruct (lt_dec i j) as [Hlij| Hlij]; [ | easy ].
  apply rngl_sub_move_0_r in Hij; [ | easy ].
  apply rngl_of_nat_inj in Hij; [ | easy ].
  destruct Hperm as (Hp1, Hp2).
  specialize (Hp2 (j - 1) (i - 1)) as H1.
  assert (H : j - 1 < n) by flia Hj.
  specialize (H1 H); clear H.
  assert (H : i - 1 < n) by flia Hi.
  now specialize (H1 H); clear H.
}
apply rngl_mul_reg_r with (c := y); [ now left | easy | ].
rewrite <- rngl_mul_assoc.
specialize rngl_opt_mul_inv_l as rngl_mul_inv_l.
rewrite Hin in rngl_mul_inv_l.
rewrite rngl_mul_inv_l; [ | easy ].
rewrite rngl_mul_1_r.
unfold δ in Hx, Hy, Hz, Ht.
(* according to wikipedia (fr), we should have x/t = z/y, because
   z/y is x/t with a changt or variable j→σ₂(j) (something like
   that, but I must prove it *)
...
(*
Abort.
End a.
About δ.
Arguments δ {T}%type {ro} (i j u v)%nat.
Require Import Zrl ZArith.
Open Scope Z_scope.
Compute let n := 4%nat in
  map
    (λ k, let σ₂ := canon_permut n k in let σ₁ := canon_permut n 8 in let ro := Z_ring_like_op in
     ((Π (i = 1, n), (Π (j = 1, n), δ i j (vect_el σ₁ (vect_el σ₂ (i - 1))) (vect_el σ₁ (vect_el σ₂ (j - 1)))))%F,
      (Π (i = 1, n), (Π (j = 1, n), δ i j i j))%F,
      (Π (i = 1, n), (Π (j = 1, n), δ i j (vect_el σ₁ (i - 1)) (vect_el σ₁ (j - 1))))%F,
      (Π (i = 1, n), (Π (j = 1, n), δ i j (vect_el σ₂ (i - 1)) (vect_el σ₂ (j - 1))))%F))
    (seq 0 (fact n)).
Compute let n := 4%nat in
  map
    (λ k, let σ₂ := canon_permut n k in let σ₁ := canon_permut n 5 in let ro := Z_ring_like_op in
     ((Π (i = 1, n), (Π (j = 1, n), δ i j (vect_el σ₁ (vect_el σ₂ (i - 1))) (vect_el σ₁ (vect_el σ₂ (j - 1)))))%F,
      (Π (i = 1, n), (Π (j = 1, n), δ i j i j))%F,
      (Π (i = 1, n), (Π (j = 1, n), δ i j (vect_el σ₁ (i - 1)) (vect_el σ₁ (j - 1))))%F,
      (Π (i = 1, n), (Π (j = 1, n), δ i j (vect_el σ₂ (i - 1)) (vect_el σ₂ (j - 1))))%F))
    (seq 0 (fact n)).
*)
...
enough (H : (x / t = z / y)%F). {
  assert (H' : (x / t * t = z / y * t)%F) by now rewrite H.
  unfold rngl_div in H'.
  rewrite Hin in H'.
  rewrite <- rngl_mul_assoc in H'.
  rewrite rngl_mul_inv_l in H'; [ | easy ].
  rewrite rngl_mul_1_r in H'.
  rewrite H'.
  rewrite rngl_mul_mul_swap; [ | easy ].
  f_equal.
  rewrite <- rngl_mul_assoc.
  rewrite rngl_mul_inv_l; [ | easy ].
  apply rngl_mul_1_r.
}
unfold rngl_div.
rewrite Hin.
subst x t.
Search (- Σ (_ = _, _), _)%F.
Search (¹/ Π (_ = _, _), _)%F.
...
*)

Theorem glop : ∀ p q n k k',
  p < q < n
  → k' = nat_of_canon_permut (vect_swap_elem (canon_permut n k) p q)
  → ε (canon_permut n k') = (- ε (canon_permut n k))%F.
Proof.
intros * Hpqn Hk'.
unfold ε.
revert p q k k' Hpqn Hk'.
induction n; intros; [ easy | ].
rewrite (rngl_product_split _ (S p)); [ | flia Hpqn ].
rewrite rngl_product_split_last; [ | flia ].
rewrite rngl_product_succ_succ.
erewrite rngl_product_eq_compat. 2: {
  intros i Hi.
  rewrite Nat.sub_add; [ | flia Hi ].
  rewrite rngl_product_succ_succ.
  rewrite Nat.sub_succ, Nat.sub_0_r.
  erewrite rngl_product_eq_compat. 2: {
    intros j Hj.
    now rewrite Nat.sub_succ, Nat.sub_0_r.
  }
  easy.
}
cbn - [ iter_seq canon_permut ].
rewrite rngl_product_succ_succ.
erewrite (rngl_product_eq_compat _ _ _ (p + 1)). 2: {
  intros i Hi.
  rewrite Nat.sub_succ, Nat.sub_0_r.
  now rewrite Nat.sub_0_r.
}
cbn - [ iter_seq canon_permut ].
(* hyper compliqué, même sur le papier ; faudrait trouver un
   raccourci, trouver des propriétés de ε, de vect_swap_elem,
   que sais-je... *)
(* voir https://fr.wikipedia.org/wiki/Signature_d%27une_permutation#Une_transposition_est_impaire et essayer de l'implémenter *)
Abort. (*
...
destruct (Nat.eq_dec p 0) as [Hpz| Hpz]. {
  subst p.
  rewrite rngl_product_empty; [ | flia ].
  rewrite rngl_mul_1_l, Nat.add_0_l.
  destruct (lt_dec q 2) as [Hq2| Hq2]. {
    destruct q; [ flia Hpqn | ].
    destruct q; [ | flia Hq2 ].
...
*)

Theorem glop : ∀ p q n k k',
  p < q < n
  → k' = nat_of_canon_permut (vect_swap_elem (canon_permut n k) p q)
  → ε_canon_permut n k' = (- ε_canon_permut n k)%F.
Proof.
intros * Hpqn Hk'.
revert p q k k' Hpqn Hk'.
induction n; intros; [ easy | ].
cbn - [ nat_of_canon_permut canon_permut ].
(* nothing can be said about "minus_one_pow (k' / fact n)" and
   "minus_one_pow (k / fact n)": they can be equal or not;
   difficult to predict (I tested examples) *)
Abort.

Theorem signature_swap :
  rngl_has_opp = true →
  ∀ n p q k,
  p < q < n
  → k < fact n
  → ε_canon_permut n
       (nat_of_canon_permut (vect_swap_elem (canon_permut n k) p q)) =
     (- ε_canon_permut n k)%F.
Proof.
intros Hop * (Hpq, Hqn) Hk.
unfold ε_canon_permut.
Abort. (*
intros Hop * (Hpq, Hqn) Hk.
revert k Hk.
induction n; intros; [ easy | cbn ].
rewrite Nat.div_add_l; [ | apply fact_neq_0 ].
rewrite Nat_mod_add_l_mul_r; [ | apply fact_neq_0 ].
rewrite <- rngl_mul_opp_r; [ | easy ].
f_equal. 2: {
  rename Hqn into Hqsn.
  destruct (Nat.eq_dec q n) as [Hqn| Hqn]. {
    subst q; clear Hqsn IHn.
    destruct n; [ easy | ].
    cbn - [ nat_of_permut vect_swap_elem permut_fun permut fact ].
Print permut_fun.
...
*)

Theorem determinant'_determinant''_permut :
  rngl_is_comm = true →
  rngl_has_opp = true →
  ∀ n p q (M : matrix n n T),
  p < q < n
  → Permutation (determinant'_list M) (determinant''_list p q M).
Proof.
intros Hic Hop * (Hpq, Hqn).
symmetry.
unfold determinant'_list, determinant''_list.
apply NoDup_Permutation_bis; cycle 1. {
  now do 2 rewrite map_length.
} {
  intros x.
  rewrite in_map_iff.
  intros (y & Hx & Hy); subst x.
  rewrite in_seq in Hy; cbn in Hy.
  destruct Hy as (_, Hy).
  apply in_map_iff.
(**)
  remember
    (nat_of_canon_permut
       (if Nat.eq_dec q (n - 1) then
          vect_swap_elem (canon_permut n y) p (n - 2)
        else
          canon_permut_swap_last p q n y)) as x eqn:Hx.
  move x after y.
  exists x.
  split. {
    destruct (Nat.eq_dec q (n - 1)) as [Hqn1| Hqn1]. {
      subst q; clear Hqn.
      destruct (Nat.eq_dec p (n - 2)) as [Hpn2| Hpn2]. {
        subst p; clear Hpq.
        rewrite vect_swap_elem_same in Hx.
        rewrite nat_of_canon_permut_permut in Hx; [ subst x | easy ].
        f_equal.
        unfold canon_permut_swap_last.
        now do 2 rewrite vect_swap_elem_same.
      }
      assert (Hp : p < n - 2) by flia Hpq Hpn2.
      clear Hpq Hpn2.
      replace (ε_canon_permut n x) with (- ε_canon_permut n y)%F. 2: {
        subst x; cbn; clear M; symmetry.
        rename y into k; rename Hy into Hk.
Abort. (*
...
        apply ε_permut_swap.
Print nat_of_permut.
...
        revert p y Hy Hp.
        induction n; intros; [ easy | cbn ].
        rewrite Nat.div_add_l; [ | apply fact_neq_0 ].
        rewrite Nat_mod_add_l_mul_r; [ | apply fact_neq_0 ].
        rewrite <- rngl_mul_opp_r; [ | easy ].
        rewrite Nat.sub_succ in Hp.
        destruct p. {
          cbn; clear IHn.
          rewrite minus_one_pow_add_r; [ | easy | easy ].
          replace (permut_fun (permut n) y) with (vect_el (permut (S n) y))
            by easy.
          unfold vect_swap_elem.
          cbn - [ permut ].
          destruct y. {
            rewrite Nat.div_0_l; [ | apply fact_neq_0 ].
            rewrite Nat.mod_0_l; [ | apply fact_neq_0 ].
            cbn; rewrite rngl_mul_1_l.
...
        destruct n; [ easy | ].
        destruct n; [ easy | ].
        destruct n; [ easy | ].
        destruct n. {
          destruct p; [ | flia Hp ].
          cbn - [ "/" "mod" ].
          rewrite Nat.add_0_l, Nat.add_0_r.
          do 4 rewrite Nat.div_1_r.
          do 2 rewrite Nat.mul_1_r.
          do 2 rewrite Nat.mod_1_r.
          cbn - [ "/" "mod" ].
          destruct y; [ now cbn; repeat rewrite rngl_mul_1_r | ].
          destruct y. {
            cbn; repeat rewrite rngl_mul_1_r.
            rewrite rngl_mul_opp_r; [ | easy ].
            rewrite rngl_mul_1_r.
            now apply rngl_opp_involutive.
          }
          destruct y. {
            cbn; repeat rewrite rngl_mul_1_r.
            now apply rngl_opp_involutive.
          }
          destruct y. {
            cbn; repeat rewrite rngl_mul_1_r.
            rewrite rngl_mul_opp_r; [ | easy ].
            rewrite rngl_mul_1_l, rngl_mul_1_r.
            now apply rngl_opp_involutive.
          }
          destruct y. {
            cbn; repeat rewrite rngl_mul_1_r.
            rewrite rngl_mul_opp_r; [ | easy ].
            now rewrite rngl_mul_1_r.
          }
          destruct y. {
            cbn; repeat rewrite rngl_mul_1_r.
            rewrite rngl_mul_opp_r; [ | easy ].
            rewrite rngl_mul_opp_r; [ | easy ].
            rewrite rngl_mul_opp_l; [ | easy ].
            easy.
          }
          cbn in Hy; flia Hy.
        }
        destruct n. {
...
      replace (ε_permut n x) with (- ε_permut n y)%F. 2: {
        subst x; cbn.
        destruct n; [ easy | ].
        cbn.
        destruct n; [ easy | ].
        destruct n. {
          apply Nat.lt_1_r in Hpq; subst p.
          cbn - [ "/" ].
          rewrite Nat.add_0_r, Nat.add_0_l.
          do 3 rewrite Nat.div_1_r.
          do 2 rewrite Nat.mul_1_r; cbn.
          do 3 rewrite rngl_mul_1_r.
          destruct y. {
            cbn.
            (* ah merde *)
...
      unfold permut_swap_last.
      remember (vect_swap_elem (permut n y) p (n - 2)) as v eqn:Hv.
      unfold vect_swap_elem.
      cbn - [ iter_seq ]; symmetry.
      erewrite rngl_product_eq_compat; [ | easy | ]. 2: {
        intros i Hi.
        replace (swap_nat (n - 1) (n - 1) (i - 1)) with (i - 1). 2: {
          unfold swap_nat.
          now destruct (Nat.eq_dec (i - 1) (n - 1)).
        }
        easy.
      }
      cbn - [ iter_seq ]; symmetry.
      f_equal. {
        subst v; cbn.
        revert p y Hpq Hy.
        induction n; intros; [ easy | ].
        rewrite Nat.sub_succ, Nat.sub_0_r in Hpq.
        rewrite Nat.sub_succ; cbn.
        rewrite Nat.div_add_l; [ | apply fact_neq_0 ].
        rewrite Nat_mod_add_l_mul_r; [ | apply fact_neq_0 ].
        rewrite Nat.add_comm.
        rewrite minus_one_pow_add_r; [ | easy | easy ].
        rewrite rngl_mul_mul_swap; [ | easy ].
        replace {| vect_el := permut_fun (permut n) y |} with
          (permut (S n) y) by easy.
        replace (permut_fun (permut n) y) with (vect_el (permut (S n) y))
          by easy.
        remember
          (nat_of_permut
             (nat_of_permut_sub_vect
                (vect_swap_elem (permut (S n) y) p (n - 1)) n))
          as x eqn:Hx.
        move x after y; move Hx after Hy.
Print nat_of_permut.
Print ε_permut.
...
  IHn : matrix n n T
        → ∀ p y : nat,
            p < n - 1
            → y < fact n → ε_permut n (nat_of_permut (vect_swap_elem (permut n y) p (n - 2))) = ε_permut n y
  p, x, y : nat
  Hpq : p < n
  Hx : x = nat_of_permut (nat_of_permut_sub_vect (vect_swap_elem (permut (S n) y) p (n - 1)) n)
  Hy : y < fact (S n)
  ============================
  (minus_one_pow (x / fact n) * ε_permut n (x mod fact n) *
   minus_one_pow (vect_el (permut (S n) y) (swap_nat p (n - 1) 0)))%F =
  (minus_one_pow (y / fact n) * ε_permut n (y mod fact n))%F
...
  destruct (lt_dec q (n - 1)) as [Hqn1| Hqn1]. {
    exists (nat_of_permut (permut_swap_last p q n y)).
    split. {
      f_equal. 2: {
        apply rngl_product_eq_compat; [ easy | ].
        intros i Hi.
        f_equal.
        rewrite permut_nat_of_permut; [ easy | | ]. {
          intros j Hj.
          unfold permut_swap_last.
          unfold vect_swap_elem; cbn.
          unfold swap_nat.
          apply vect_el_permut_ub; [ easy | ].
          destruct (Nat.eq_dec j q) as [Hjq| Hjq]. {
            destruct (Nat.eq_dec (n - 1) p) as [Hnp| Hnp]; [ flia Hj | ].
            destruct (Nat.eq_dec (n - 1) (n - 2)) as [Hnn| Hnn]. {
              flia Hpq Hjq Hj.
            }
            flia Hj.
          }
          destruct (Nat.eq_dec j (n - 1)) as [Hjn| Hjn]. {
            destruct (Nat.eq_dec q p) as [Hqp| Hqp]; [ flia Hqp Hpq | ].
            destruct (Nat.eq_dec q (n - 2)) as [H| H]; [ flia Hpq H | easy ].
          }
          destruct (Nat.eq_dec j p) as [Hjp| Hjp]; [ flia Hj | ].
          destruct (Nat.eq_dec j (n - 2)) as [H| H]; [ flia Hpq Hqn | easy ].
        } {
          intros j k Hj Hk Hjk.
          move i before y; move j before i; move k before j.
          unfold permut_swap_last.
          unfold vect_swap_elem; cbn.
          intros Hjke.
          apply permut_injective in Hjke; [ | easy | | ]. {
            revert Hjke.
            now apply swap_nat_swap_nat.
          } {
            apply swap_nat_lt; [ flia Hpq Hqn | flia Hj | ].
            apply swap_nat_lt; [ easy | | easy ].
            flia Hpq Hqn.
          } {
            apply swap_nat_lt; [ flia Hpq Hqn | flia Hj | ].
            apply swap_nat_lt; [ easy | | easy ].
            flia Hpq Hqn.
          }
        }
      }
      clear Hqn.
      revert p q y Hpq Hqn1 Hy.
      induction n; intros; [ easy | ].
      cbn.
      rewrite Nat.sub_0_r.
...
destruct n; [ easy | ].
cbn.
Search (permut_fun _ _ _ ≠ _).
Search (vect_el _ _ = vect_el _ _).
apply vect_el_nat_of_permut_diff.
...
unfold permut_swap_last.
...
}
apply FinFun.Injective_map_NoDup; [ | apply seq_NoDup ].
unfold FinFun.Injective.
intros x y Hxy.
(* pas gagné *)
...
*)

(* yet another proof that it is equal to determinant *)

Theorem det_is_det_by_permut'' :
  rngl_is_comm = true →
  ∀ n (M : matrix n n T) p q, determinant M = determinant'' p q M.
Proof.
intros Hic *.
rewrite det_is_det_by_canon_permut; [ | easy ].
rewrite determinant'_by_list.
rewrite determinant''_by_list.
apply rngl_summation_permut; cycle 1. {
  unfold determinant'_list.
  now rewrite map_length, seq_length.
} {
  unfold determinant''_list.
  now rewrite map_length, seq_length.
}
Abort.

(* *)

Definition mat_mul_row_by_scal n k (M : matrix n n T) s :=
  mk_mat n n
    (λ i j,
     if Nat.eq_dec i k then (s * mat_el M i j)%F else mat_el M i j).

Definition mat_swap_rows n (M : matrix n n T) i1 i2 :=
  mk_mat n n
    (λ i j,
     if Nat.eq_dec i i1 then mat_el M i2 j
     else if Nat.eq_dec i i2 then mat_el M i1 j
     else mat_el M i j).

Definition mat_add_row_mul_scal_row n (M : matrix n n T) i1 v i2 :=
  mk_mat n n
    (λ i j,
     if Nat.eq_dec i i1 then (mat_el M i1 j + v * mat_el M i2 j)%F
     else mat_el M i j).

(* If we multiply a row (column) of A by a number, the determinant of
   A will be multiplied by the same number. *)
(* https://math.vanderbilt.edu/sapirmv/msapir/proofdet1.html
   point 1 *)

(* Well, since my definition of the discriminant only covers the
   row 0, we can prove that only when i=0; this will able us to
   prove next theorems, swapping rows by going via row 0 *)

Theorem det_mul_row_0_by_scal :
  rngl_is_comm = true →
  ∀ n (A : matrix n n T) v,
  n ≠ 0
  → determinant (mat_mul_row_by_scal 0 A v) = (v * determinant A)%F.
Proof.
intros Hic * Hnz.
unfold determinant; cbn.
destruct n; [ easy | clear Hnz ].
cbn - [ iter_seq ].
rewrite rngl_mul_summation_distr_l.
apply rngl_summation_eq_compat.
intros j Hj.
specialize rngl_opt_mul_comm as rngl_mul_comm.
rewrite Hic in rngl_mul_comm.
rewrite (rngl_mul_comm (minus_one_pow j)).
do 2 rewrite <- rngl_mul_assoc.
f_equal.
rewrite (rngl_mul_comm (mat_el A 0 j)).
do 2 rewrite <- rngl_mul_assoc.
f_equal.
rewrite rngl_mul_comm; f_equal.
f_equal.
apply matrix_eq; cbn.
rename j into k; rename Hj into Hk.
intros i j Hi Hj.
destruct (Nat.eq_dec (i + 1) 0) as [H| H]; [ flia H | easy ].
Qed.

(* If the i-th row (column) in A is a sum of the i-th row (column) of
   a matrix B and the i-th row (column) of a matrix C and all other
   rows in B and C are equal to the corresponding rows in A (that is B
   and C differ from A by one row only), then det(A)=det(B)+det(C). *)
(* https://math.vanderbilt.edu/sapirmv/msapir/proofdet1.html
   point 2 *)

(* Well, since my definition of the discriminant only covers the
   row 0, we can prove that only when i=0; this will able us to
   prove the next theorem, swapping rows by going via row 0 *)

Theorem det_sum_row_row : ∀ n (A B C : matrix n n T),
  n ≠ 0
  → (∀ j, mat_el A 0 j = (mat_el B 0 j + mat_el C 0 j)%F)
  → (∀ i j, i ≠ 0 → mat_el B i j = mat_el A i j)
  → (∀ i j, i ≠ 0 → mat_el C i j = mat_el A i j)
  → determinant A = (determinant B + determinant C)%F.
Proof.
intros * Hnz Hbc Hb Hc.
unfold determinant.
destruct n; [ easy | clear Hnz ].
cbn - [ iter_seq ].
assert (Hab : ∀ j, subm A 0 j = subm B 0 j). {
  intros.
  apply matrix_eq; cbn.
  intros i j' Hi Hj'.
  destruct (lt_dec j' j); symmetry; apply Hb; flia.
}
assert (Hac : ∀ j, subm A 0 j = subm C 0 j). {
  intros.
  apply matrix_eq; cbn.
  intros i j' Hi Hj'.
  destruct (lt_dec j' j); symmetry; apply Hc; flia.
}
erewrite rngl_summation_eq_compat. 2: {
  intros j Hj.
  rewrite Hbc.
  rewrite rngl_mul_add_distr_l.
  rewrite rngl_mul_add_distr_r.
  rewrite Hab at 1.
  rewrite Hac at 1.
  easy.
}
cbn - [ iter_seq ].
now apply rngl_summation_add_distr.
Qed.

(* If two rows (columns) in A are equal then det(A)=0. *)
(* https://math.vanderbilt.edu/sapirmv/msapir/proofdet1.html
   point 3 *)
(* doing it only when the first row is 0; can be generalized later *)

Definition δ_lt i k := Nat.b2n (i <? k).

Theorem subm_subm_swap : ∀ n (A : matrix n n T) i j k l,
  subm (subm A i j) k l =
  subm (subm A (k + δ_lt i k) (l + δ_lt j l)) (i - δ_lt k i) (j - δ_lt l j).
Proof.
intros.
apply matrix_eq; cbn.
intros i' j' Hi' Hj'.
f_equal. {
  do 2 rewrite <- Nat.add_assoc; f_equal.
  rewrite Nat.add_comm.
  unfold δ_lt.
  remember (k <=? i') as a eqn:Ha.
  remember (i <=? i' + Nat.b2n a) as b eqn:Hb.
  remember (i <? k) as c eqn:Hc.
  remember (k <? i) as d eqn:Hd.
  remember (i - Nat.b2n d <=? i') as e eqn:He.
  remember (k + Nat.b2n c <=? i' + Nat.b2n e) as f eqn:Hf.
  move b before a; move c before b; move d before c; move e before d.
  move f before e.
  symmetry in Ha, Hb, Hc, Hd, He, Hf.
  destruct a, b, d, e, f; cbn; try easy; exfalso. {
    apply Nat.leb_le in Ha; apply Nat.leb_le in Hb; apply Nat.leb_le in Hd.
    apply Nat.leb_le in He; apply Nat.leb_nle in Hf.
    destruct c; [ apply Nat.ltb_lt in Hc; flia Ha Hb Hc Hd He Hf | ].
    cbn in Hf.
    apply Nat.ltb_nlt in Hc; flia Ha Hb Hc Hd He Hf.
  } {
    apply Nat.leb_le in Ha; apply Nat.leb_le in Hb; apply Nat.leb_le in Hd.
    apply Nat.leb_nle in He; apply Nat.leb_le in Hf.
    destruct c; [ apply Nat.ltb_lt in Hc; flia Ha Hb Hc Hd He Hf | ].
    apply Nat.ltb_nlt in Hc; flia Ha Hb Hc Hd He Hf.
  } {
    apply Nat.leb_le in Ha; apply Nat.leb_le in Hb; apply Nat.leb_le in Hd.
    apply Nat.leb_nle in He; apply Nat.leb_nle in Hf.
    destruct c; [ apply Nat.ltb_lt in Hc; flia Ha Hb Hc Hd He Hf | ].
    apply Nat.ltb_nlt in Hc; flia Ha Hb Hc Hd He Hf.
  } {
    apply Nat.leb_le in Ha; apply Nat.leb_le in Hb; apply Nat.leb_nle in Hd.
    apply Nat.leb_le in He; apply Nat.leb_nle in Hf.
    destruct c; [ apply Nat.ltb_lt in Hc; flia Ha Hb Hc Hd He Hf | ].
    cbn in Hf.
    apply Nat.ltb_nlt in Hc; flia Ha Hb Hc Hd He Hf.
  } {
    apply Nat.leb_le in Ha; apply Nat.leb_le in Hb; apply Nat.leb_nle in Hd.
    apply Nat.leb_nle in He; apply Nat.leb_le in Hf.
    destruct c; [ apply Nat.ltb_lt in Hc; flia Ha Hb Hc Hd He Hf | ].
    apply Nat.ltb_nlt in Hc; flia Ha Hb Hc Hd He Hf.
  } {
    apply Nat.leb_le in Ha; apply Nat.leb_le in Hb; apply Nat.leb_nle in Hd.
    apply Nat.leb_nle in He; apply Nat.leb_nle in Hf.
    destruct c; [ apply Nat.ltb_lt in Hc; flia Ha Hb Hc Hd He Hf | ].
    apply Nat.ltb_nlt in Hc; flia Ha Hb Hc Hd He Hf.
  } {
    apply Nat.leb_le in Ha; apply Nat.leb_nle in Hb; apply Nat.leb_le in Hd.
    apply Nat.leb_le in He; apply Nat.leb_le in Hf.
    destruct c; [ apply Nat.ltb_lt in Hc; flia Ha Hb Hc Hd He Hf | ].
    apply Nat.ltb_nlt in Hc; flia Ha Hb Hc Hd He Hf.
  } {
    apply Nat.leb_le in Ha; apply Nat.leb_nle in Hb; apply Nat.leb_le in Hd.
    apply Nat.leb_nle in He; apply Nat.leb_nle in Hf.
    destruct c; [ apply Nat.ltb_lt in Hc; flia Ha Hb Hc Hd He Hf | ].
    apply Nat.ltb_nlt in Hc; flia Ha Hb Hc Hd He Hf.
  } {
    apply Nat.leb_le in Ha; apply Nat.leb_nle in Hb; apply Nat.leb_nle in Hd.
    apply Nat.leb_le in He; apply Nat.leb_le in Hf.
    destruct c; [ apply Nat.ltb_lt in Hc; flia Ha Hb Hc Hd He Hf | ].
    apply Nat.ltb_nlt in Hc; flia Ha Hb Hc Hd He Hf.
  } {
    apply Nat.leb_le in Ha; apply Nat.leb_nle in Hb; apply Nat.leb_nle in Hd.
    apply Nat.leb_nle in He; apply Nat.leb_nle in Hf.
    destruct c; [ apply Nat.ltb_lt in Hc; flia Ha Hb Hc Hd He Hf | ].
    apply Nat.ltb_nlt in Hc; flia Ha Hb Hc Hd He Hf.
  } {
    apply Nat.leb_nle in Ha; apply Nat.leb_le in Hb; apply Nat.leb_le in Hd.
    apply Nat.leb_le in He; apply Nat.leb_le in Hf.
    destruct c; [ apply Nat.ltb_lt in Hc; flia Ha Hb Hc Hd He Hf | ].
    cbn in He.
    apply Nat.ltb_nlt in Hc; flia Ha Hb Hc Hd He Hf.
  } {
    apply Nat.leb_nle in Ha; apply Nat.leb_le in Hb; apply Nat.leb_le in Hd.
    apply Nat.leb_nle in He; apply Nat.leb_nle in Hf.
    destruct c; [ apply Nat.ltb_lt in Hc; flia Ha Hb Hc Hd He Hf | ].
    cbn in Hb.
    apply Nat.ltb_nlt in Hc; flia Ha Hb Hc Hd He Hf.
  } {
    apply Nat.leb_nle in Ha; apply Nat.leb_le in Hb; apply Nat.leb_nle in Hd.
    apply Nat.leb_le in He; apply Nat.leb_le in Hf.
    destruct c; [ apply Nat.ltb_lt in Hc; flia Ha Hb Hc Hd He Hf | ].
    cbn in Hb.
    apply Nat.ltb_nlt in Hc; flia Ha Hb Hc Hd He Hf.
  } {
    apply Nat.leb_nle in Ha; apply Nat.leb_le in Hb; apply Nat.leb_nle in Hd.
    apply Nat.leb_nle in He; apply Nat.leb_nle in Hf.
    destruct c; [ apply Nat.ltb_lt in Hc; flia Ha Hb Hc Hd He Hf | ].
    apply Nat.ltb_nlt in Hc; flia Ha Hb Hc Hd He Hf.
  } {
    apply Nat.leb_nle in Ha; apply Nat.leb_nle in Hb; apply Nat.leb_le in Hd.
    apply Nat.leb_le in He; apply Nat.leb_le in Hf.
    destruct c; [ apply Nat.ltb_lt in Hc; flia Ha Hb Hc Hd He Hf | ].
    cbn in He.
    apply Nat.ltb_nlt in Hc; flia Ha Hb Hc Hd He Hf.
  } {
    apply Nat.leb_nle in Ha; apply Nat.leb_nle in Hb; apply Nat.leb_le in Hd.
    apply Nat.leb_le in He; apply Nat.leb_nle in Hf.
    destruct c; [ apply Nat.ltb_lt in Hc; flia Ha Hb Hc Hd He Hf | ].
    cbn in He.
    apply Nat.ltb_nlt in Hc; flia Ha Hb Hc Hd He Hf.
  } {
    apply Nat.leb_nle in Ha; apply Nat.leb_nle in Hb; apply Nat.leb_le in Hd.
    apply Nat.leb_nle in He; apply Nat.leb_le in Hf.
    destruct c; [ apply Nat.ltb_lt in Hc; flia Ha Hb Hc Hd He Hf | ].
    apply Nat.ltb_nlt in Hc; flia Ha Hb Hc Hd He Hf.
  } {
    apply Nat.leb_nle in Ha; apply Nat.leb_nle in Hb; apply Nat.leb_nle in Hd.
    apply Nat.leb_le in He; apply Nat.leb_le in Hf.
    destruct c; [ apply Nat.ltb_lt in Hc; flia Ha Hb Hc Hd He Hf | ].
    apply Nat.ltb_nlt in Hc; flia Ha Hb Hc Hd He Hf.
  } {
    apply Nat.leb_nle in Ha; apply Nat.leb_nle in Hb; apply Nat.leb_nle in Hd.
    apply Nat.leb_le in He; apply Nat.leb_nle in Hf.
    destruct c; [ apply Nat.ltb_lt in Hc; flia Ha Hb Hc Hd He Hf | ].
    apply Nat.ltb_nlt in Hc; flia Ha Hb Hc Hd He Hf.
  } {
    apply Nat.leb_nle in Ha; apply Nat.leb_nle in Hb; apply Nat.leb_nle in Hd.
    apply Nat.leb_nle in He; apply Nat.leb_le in Hf.
    destruct c; [ apply Nat.ltb_lt in Hc; flia Ha Hb Hc Hd He Hf | ].
    apply Nat.ltb_nlt in Hc; flia Ha Hb Hc Hd He Hf.
  }
} {
  do 2 rewrite <- Nat.add_assoc; f_equal.
  rewrite Nat.add_comm.
  unfold δ_lt.
  remember (l <=? j') as a eqn:Ha.
  remember (j <=? j' + Nat.b2n a) as b eqn:Hb.
  remember (j <? l) as c eqn:Hc.
  remember (l <? j) as d eqn:Hd.
  remember (j - Nat.b2n d <=? j') as e eqn:He.
  remember (l + Nat.b2n c <=? j' + Nat.b2n e) as f eqn:Hf.
  move b before a; move c before b; move d before c; move e before d.
  move f before e.
  symmetry in Ha, Hb, Hc, Hd, He, Hf.
  destruct a, b, d, e, f; cbn; try easy; exfalso. {
    apply Nat.leb_le in Ha; apply Nat.leb_le in Hb; apply Nat.leb_le in Hd.
    apply Nat.leb_le in He; apply Nat.leb_nle in Hf.
    destruct c; [ apply Nat.ltb_lt in Hc; flia Ha Hb Hc Hd He Hf | ].
    cbn in He, Hf.
    apply Nat.ltb_nlt in Hc; flia Ha Hb Hc Hd He Hf.
  } {
    apply Nat.leb_le in Ha; apply Nat.leb_le in Hb; apply Nat.leb_le in Hd.
    apply Nat.leb_nle in He; apply Nat.leb_le in Hf.
    destruct c; [ apply Nat.ltb_lt in Hc; flia Ha Hb Hc Hd He Hf | ].
    apply Nat.ltb_nlt in Hc; flia Ha Hb Hc Hd He Hf.
  } {
    apply Nat.leb_le in Ha; apply Nat.leb_le in Hb; apply Nat.leb_le in Hd.
    apply Nat.leb_nle in He; apply Nat.leb_nle in Hf.
    destruct c; [ apply Nat.ltb_lt in Hc; flia Ha Hb Hc Hd He Hf | ].
    apply Nat.ltb_nlt in Hc; flia Ha Hb Hc Hd He Hf.
  } {
    apply Nat.leb_le in Ha; apply Nat.leb_le in Hb; apply Nat.leb_nle in Hd.
    apply Nat.leb_le in He; apply Nat.leb_nle in Hf.
    destruct c; [ apply Nat.ltb_lt in Hc; flia Ha Hb Hc Hd He Hf | ].
    cbn in Hf.
    apply Nat.ltb_nlt in Hc; flia Ha Hb Hc Hd He Hf.
  } {
    apply Nat.leb_le in Ha; apply Nat.leb_le in Hb; apply Nat.leb_nle in Hd.
    apply Nat.leb_nle in He; apply Nat.leb_le in Hf.
    destruct c; [ apply Nat.ltb_lt in Hc; flia Ha Hb Hc Hd He Hf | ].
    apply Nat.ltb_nlt in Hc; flia Ha Hb Hc Hd He Hf.
  } {
    apply Nat.leb_le in Ha; apply Nat.leb_le in Hb; apply Nat.leb_nle in Hd.
    apply Nat.leb_nle in He; apply Nat.leb_nle in Hf.
    destruct c; [ apply Nat.ltb_lt in Hc; flia Ha Hb Hc Hd He Hf | ].
    apply Nat.ltb_nlt in Hc; flia Ha Hb Hc Hd He Hf.
  } {
    apply Nat.leb_le in Ha; apply Nat.leb_nle in Hb; apply Nat.leb_le in Hd.
    apply Nat.leb_le in He; apply Nat.leb_le in Hf.
    destruct c; [ apply Nat.ltb_lt in Hc; flia Ha Hb Hc Hd He Hf | ].
    apply Nat.ltb_nlt in Hc; flia Ha Hb Hc Hd He Hf.
  } {
    apply Nat.leb_le in Ha; apply Nat.leb_nle in Hb; apply Nat.leb_le in Hd.
    apply Nat.leb_nle in He; apply Nat.leb_nle in Hf.
    destruct c; [ apply Nat.ltb_lt in Hc; flia Ha Hb Hc Hd He Hf | ].
    apply Nat.ltb_nlt in Hc; cbn in Hc; flia Ha Hb Hc Hd He Hf.
  } {
    apply Nat.leb_le in Ha; apply Nat.leb_nle in Hb; apply Nat.leb_nle in Hd.
    apply Nat.leb_le in He; apply Nat.leb_le in Hf.
    destruct c; [ apply Nat.ltb_lt in Hc; flia Ha Hb Hc Hd He Hf | ].
    apply Nat.ltb_nlt in Hc; flia Ha Hb Hc Hd He Hf.
  } {
    apply Nat.leb_le in Ha; apply Nat.leb_nle in Hb; apply Nat.leb_nle in Hd.
    apply Nat.leb_nle in He; apply Nat.leb_nle in Hf.
    destruct c; [ apply Nat.ltb_lt in Hc; flia Ha Hb Hc Hd He Hf | ].
    apply Nat.ltb_nlt in Hc; flia Ha Hb Hc Hd He Hf.
  } {
    apply Nat.leb_nle in Ha; apply Nat.leb_le in Hb; apply Nat.leb_le in Hd.
    apply Nat.leb_le in He; apply Nat.leb_le in Hf.
    destruct c; [ apply Nat.ltb_lt in Hc; flia Ha Hb Hc Hd He Hf | ].
    cbn in He.
    apply Nat.ltb_nlt in Hc; flia Ha Hb Hc Hd He Hf.
  } {
    apply Nat.leb_nle in Ha; apply Nat.leb_le in Hb; apply Nat.leb_le in Hd.
    apply Nat.leb_nle in He; apply Nat.leb_nle in Hf.
    destruct c; [ apply Nat.ltb_lt in Hc; flia Ha Hb Hc Hd He Hf | ].
    cbn in Hb.
    apply Nat.ltb_nlt in Hc; flia Ha Hb Hc Hd He Hf.
  } {
    apply Nat.leb_nle in Ha; apply Nat.leb_le in Hb; apply Nat.leb_nle in Hd.
    apply Nat.leb_le in He; apply Nat.leb_le in Hf.
    destruct c; [ apply Nat.ltb_lt in Hc; flia Ha Hb Hc Hd He Hf | ].
    cbn in Hb.
    apply Nat.ltb_nlt in Hc; flia Ha Hb Hc Hd He Hf.
  } {
    apply Nat.leb_nle in Ha; apply Nat.leb_le in Hb; apply Nat.leb_nle in Hd.
    apply Nat.leb_nle in He; apply Nat.leb_nle in Hf.
    destruct c; [ apply Nat.ltb_lt in Hc; flia Ha Hb Hc Hd He Hf | ].
    apply Nat.ltb_nlt in Hc; flia Ha Hb Hc Hd He Hf.
  } {
    apply Nat.leb_nle in Ha; apply Nat.leb_nle in Hb; apply Nat.leb_le in Hd.
    apply Nat.leb_le in He; apply Nat.leb_le in Hf.
    destruct c; [ apply Nat.ltb_lt in Hc; flia Ha Hb Hc Hd He Hf | ].
    cbn in He.
    apply Nat.ltb_nlt in Hc; flia Ha Hb Hc Hd He Hf.
  } {
    apply Nat.leb_nle in Ha; apply Nat.leb_nle in Hb; apply Nat.leb_le in Hd.
    apply Nat.leb_le in He; apply Nat.leb_nle in Hf.
    destruct c; [ apply Nat.ltb_lt in Hc; flia Ha Hb Hc Hd He Hf | ].
    cbn in He.
    apply Nat.ltb_nlt in Hc; flia Ha Hb Hc Hd He Hf.
  } {
    apply Nat.leb_nle in Ha; apply Nat.leb_nle in Hb; apply Nat.leb_le in Hd.
    apply Nat.leb_nle in He; apply Nat.leb_le in Hf.
    destruct c; [ apply Nat.ltb_lt in Hc; flia Ha Hb Hc Hd He Hf | ].
    apply Nat.ltb_nlt in Hc; flia Ha Hb Hc Hd He Hf.
  } {
    apply Nat.leb_nle in Ha; apply Nat.leb_nle in Hb; apply Nat.leb_nle in Hd.
    apply Nat.leb_le in He; apply Nat.leb_le in Hf.
    destruct c; [ apply Nat.ltb_lt in Hc; flia Ha Hb Hc Hd He Hf | ].
    apply Nat.ltb_nlt in Hc; flia Ha Hb Hc Hd He Hf.
  } {
    apply Nat.leb_nle in Ha; apply Nat.leb_nle in Hb; apply Nat.leb_nle in Hd.
    apply Nat.leb_le in He; apply Nat.leb_nle in Hf.
    destruct c; [ apply Nat.ltb_lt in Hc; flia Ha Hb Hc Hd He Hf | ].
    apply Nat.ltb_nlt in Hc; flia Ha Hb Hc Hd He Hf.
  } {
    apply Nat.leb_nle in Ha; apply Nat.leb_nle in Hb; apply Nat.leb_nle in Hd.
    apply Nat.leb_nle in He; apply Nat.leb_le in Hf.
    destruct c; [ apply Nat.ltb_lt in Hc; flia Ha Hb Hc Hd He Hf | ].
    apply Nat.ltb_nlt in Hc; flia Ha Hb Hc Hd He Hf.
  }
}
Qed.

Theorem glop1 : ∀ n (A : matrix n n T) i j,
  subm (subm A i j) 0 0 = subm (subm A 0 0) (i - 1) (j - 1).
Proof.
intros.
rewrite subm_subm_swap.
unfold δ_lt.
now destruct i, j.
Qed.

(*
Compute map (λ i, list_of_vect (permut 4 i)) (seq 0 (fact 4)).
*)

Definition swap_in_permut n i j k := vect_swap_elem (canon_permut n k) i j.

(*
Compute (map (λ i, list_of_vect (permut_swap_last 0 1 3 i)) (seq 0 (fact 3))).
Compute (map (λ i, list_of_vect (permut_swap_last 0 2 3 i)) (seq 0 (fact 3))).
Compute (map (λ i, list_of_vect (permut_swap_last 1 2 3 i)) (seq 0 (fact 3))).
Compute (map (λ i, list_of_vect (permut_swap_last 0 1 6 i)) (seq 0 (fact 6))).
*)

Theorem det_two_rows_are_eq :
  rngl_is_comm = true →
  rngl_has_opp = true →
  ∀ n (A : matrix n n T) i,
  0 < i < n
  → (∀ j, mat_el A i j = mat_el A 0 j)
  → determinant A = 0%F.
Proof.
intros Hic Hop * Hiz Ha.
rewrite det_is_det_by_canon_permut; [ | easy ].
unfold determinant'.
destruct n; [ flia Hiz | ].
erewrite rngl_summation_eq_compat. 2: {
  intros j Hj.
  rewrite rngl_product_succ_succ.
Abort. (*
  erewrite rngl_product_eq_compat; [ | easy | ]. 2: {
    intros k Hk.
    now rewrite Nat.sub_succ, Nat.sub_0_r.
  }
  easy.
}
cbn - [ iter_seq fact ε_permut permut ].
change
  (Σ (k = 0, fact (S n) - 1),
   ε_permut (S n) k *
   Π (j = 0, n), mat_el A j (vect_el (permut (S n) k) j) = 0)%F.
...
erewrite rngl_summation_eq_compat. 2: {
  intros j Hj.
  rewrite rngl_product_split_first; [ | easy | flia ].
  rewrite (rngl_product_split _ i); [ | flia Hiz ].
  rewrite rngl_product_split_last; [ | easy ].
  do 3 rewrite rngl_mul_assoc.
  rewrite <- rngl_mul_assoc.
  rewrite rngl_mul_mul_swap; [ | easy ].
  rewrite rngl_mul_assoc.
  rewrite rngl_mul_mul_swap; [ | easy ].
  rewrite Ha.
  easy.
}
cbn - [ iter_seq fact ε_permut permut ].
...
erewrite summation_pair.
...
Theorem rngl_summation_permut : ∀ b e f g,
  Permutation (seq b (S e - b)) (map g (seq b (S e - b)))
  → (Σ (i = b, e), f i = Σ (i = b, e), f (g i))%F.
Proof.
intros * Hp.
unfold iter_seq.
Search Permutation.
...
assert
  (H :
   ∀ k, ∃ k', k' ≠ k ∧
   vect_el (permut (S n) k') 0 = vect_el (permut (S n) k) i ∧
   vect_el (permut (S n) k') i = vect_el (permut (S n) k) 0 ∧
   (∀ j, j ≠ 0 → j ≠ i →
    vect_el (permut (S n) k') j = vect_el (permut (S n) k) j)). {
  intros k.
...
induction n; [ easy | clear Hnz ].
rewrite Nat.sub_succ, Nat.sub_0_r.
cbn - [ iter_seq fact ].
...
destruct i; [ easy | ].
destruct i. {
  destruct Hiz as (_, Hiz).
  apply Nat.succ_lt_mono in Hiz.
  destruct n; [ easy | ].
  clear Hiz.
  rewrite rngl_summation_split_first; [ | easy | flia ].
  cbn - [ iter_seq ].
  rewrite rngl_mul_1_l.
  rewrite rngl_add_comm.
  rewrite rngl_summation_split_first; [ | easy | flia ].
  rewrite rngl_add_comm.
  cbn - [ iter_seq Nat.leb ].
  rewrite rngl_summation_split_first; [ | easy | flia ].
  rewrite Nat.add_0_l.
  rewrite (rngl_summation_split_first _ 0); [ | flia ].
  cbn - [ iter_seq Nat.leb ].
  replace (Nat.b2n (1 <=? 0)) with 0 by easy.
  do 2 rewrite rngl_mul_1_l.
  remember (iter_seq _ _ _ _) as x.
  erewrite rngl_summation_eq_compat. 2: {
    intros i Hi.
    replace (Nat.b2n (1 <=? i)) with 1 by now destruct i.
    easy.
  }
  cbn - [ iter_seq Nat.leb ].
  remember (iter_seq _ _ _ _) as y in |-*.
  rewrite Ha.
  rewrite Ha.
  assert (H : subm (subm A 0 0) 0 0 = subm (subm A 0 1) 0 0). {
    rewrite subm_subm_swap; cbn.
    now specialize (subm_subm_swap A 0 1 0 0) as H1.
  }
  cbn in H; rewrite <- H; clear H.
  rewrite rngl_mul_add_distr_l.
  rewrite rngl_mul_add_distr_l.
  do 2 rewrite rngl_add_assoc.
  do 2 rewrite rngl_mul_assoc.
  specialize rngl_opt_mul_comm as rngl_mul_comm.
  rewrite Hic in rngl_mul_comm.
  rewrite (rngl_mul_comm (mat_el A 0 0)).
  rewrite rngl_mul_opp_l; [ | easy ].
  rewrite rngl_mul_1_l.
  rewrite rngl_mul_opp_l; [ | easy ].
  rewrite rngl_mul_opp_l; [ | easy ].
  remember (_ * _ * _)%F as z.
  rewrite (rngl_add_add_swap z).
  rewrite fold_rngl_sub; [ | easy ].
  rewrite rngl_add_opp_r, rngl_add_0_l.
  (* yeah! *)
  clear z Heqz.
  move y before x.
  rewrite rngl_mul_opp_l; [ | easy ].
  rewrite fold_rngl_sub; [ | easy ].
  rewrite rngl_summation_succ_succ.
  erewrite rngl_summation_eq_compat in Heqx. 2: {
    now intros i Hi; rewrite Ha.
  }
  cbn - [ iter_seq ] in Heqx.
  erewrite rngl_summation_eq_compat in Heqy. 2: {
    now intros i Hi; rewrite Ha.
  }
  cbn - [ iter_seq ] in Heqy.
  erewrite rngl_summation_eq_compat. 2: {
    intros i Hi.
    rewrite rngl_mul_summation_distr_l.
    easy.
  }
  cbn - [ iter_seq Nat.leb ].
(**)
  destruct n. {
    cbn in Heqx, Heqy |-*; subst x y; cbn.
    rewrite rngl_mul_0_r, rngl_mul_0_r, rngl_add_0_r.
    apply rngl_add_opp_r.
  }
  rewrite rngl_summation_split_first; [ | easy | flia ].
  rewrite <- rngl_mul_summation_distr_l.
  cbn - [ iter_seq Nat.leb subm det_loop ].
  rewrite rngl_mul_1_l.
  rewrite rngl_summation_split_first; [ | easy | flia ].
  cbn - [ iter_seq Nat.leb subm det_loop ].
  rewrite rngl_mul_1_l.
  remember (Nat.b2n (2 <=? 0)) as z; cbn in Heqz; subst z.
  rewrite rngl_mul_add_distr_l.
  destruct n. {
    cbn in Heqx, Heqy |-*; subst x y; cbn.
    do 5 rewrite rngl_add_0_l.
    do 2 rewrite rngl_mul_1_l.
    rewrite rngl_mul_opp_l; [ | easy ].
    rewrite rngl_mul_opp_l; [ | easy ].
    rewrite rngl_mul_opp_l; [ | easy ].
    rewrite rngl_mul_opp_l; [ | easy ].
    do 2 rewrite rngl_mul_1_l.
    do 2 rewrite rngl_mul_1_r.
    rewrite rngl_add_0_r.
    rewrite rngl_mul_opp_r; [ | easy ].
    rewrite rngl_mul_opp_r; [ | easy ].
    unfold rngl_sub; rewrite Hop.
    rewrite rngl_opp_involutive; [ | easy ].
    do 4 rewrite rngl_mul_assoc.
    rewrite rngl_mul_opp_r; [ | easy ].
    rewrite rngl_mul_opp_l; [ | easy ].
    do 2 rewrite Ha.
    rewrite rngl_add_assoc.
    rewrite (rngl_add_add_swap (- _)%F).
    rewrite (rngl_add_comm (- _)%F).
    rewrite (rngl_mul_comm (mat_el A 0 2)).
    rewrite fold_rngl_sub; [ | easy ].
    rewrite fold_rngl_sub; [ | easy ].
    rewrite rngl_add_opp_r, rngl_add_0_l.
    rewrite (rngl_mul_comm (mat_el A 0 1)).
    apply rngl_add_opp_r.
  }
...
  rewrite (rngl_summation_split_first _ 2 (S (S n))); [ | flia ].
  rewrite rngl_summation_split_first; [ | easy | flia ].
  remember (Nat.b2n (2 <=? 1)) as z; cbn in Heqz; subst z.
  rewrite Nat.add_0_r.
  cbn - [ iter_seq Nat.leb subm det_loop ].
  rewrite rngl_mul_opp_l; [ | easy ].
  rewrite rngl_mul_opp_l; [ | easy ].
  rewrite rngl_mul_opp_l; [ | easy ].
  do 2 rewrite rngl_mul_1_l.
...
  rewrite rngl_summation_split_first; [ | easy | flia ].
  remember (Nat.b2n (2 <=? 2)) as z; cbn in Heqz; subst z.
  replace (2 + 1) with 3 by easy.
  cbn - [ iter_seq Nat.leb subm det_loop ].
  rewrite rngl_mul_opp_l; [ | easy ].
  rewrite rngl_mul_opp_l; [ | easy ].
  rewrite rngl_mul_opp_l; [ | easy ].
  do 2 rewrite rngl_mul_1_l.
...
  destruct n. {
    cbn in Heqx, Heqy |-*.
    subst x y.
    do 2 rewrite rngl_mul_0_r.
    rewrite rngl_add_0_r.
    apply rngl_add_opp_r.
  }
  rewrite rngl_summation_split_first in Heqx; [ | easy | flia ].
  rewrite rngl_summation_split_first in Heqy; [ | easy | flia ].
  cbn - [ iter_seq det_loop ] in Heqx, Heqy.
...
  rewrite rngl_summation_shift; [ | flia ].
  do 2 rewrite Nat.sub_succ.
  rewrite Nat.sub_0_r.
  rewrite rngl_summation_summation_exch'; [ | easy ].
  rewrite rngl_summation_split_first; [ | easy | flia ].
  erewrite rngl_summation_eq_compat. 2: {
    intros i Hi.
    cbn - [ det_loop ].
    rewrite rngl_mul_1_l.
    easy.
  }
  cbn - [ iter_seq det_loop Nat.leb ].
... (*
...
destruct n; [ flia Hiz | ].
cbn - [ iter_seq ].
rewrite (rngl_summation_split _ i); [ | flia Hiz ].
rewrite rngl_summation_split_last; [ | flia ].
rewrite rngl_summation_shift; [ | flia Hiz ].
erewrite rngl_summation_eq_compat. 2: {
  intros j Hj.
  now rewrite Nat.add_comm, Nat.add_sub.
}
cbn - [ iter_seq ].
...
(* blocked by the present implementation of discriminant *)
erewrite rngl_summation_eq_compat; [ | easy | ]. 2: {
  intros j Hj.
  rewrite (rngl_summation_split _ (i - 1)); [ | flia Hiz ].
  rewrite Nat.sub_add; [ | easy ].
  easy.
}
cbn - [ iter_seq ].
...
rewrite rngl_summation_split_first; [ | easy | flia ].
cbn - [ iter_seq ].
rewrite rngl_mul_1_l.
rewrite (rngl_summation_split _ i); [ | flia Hiz ].
rewrite rngl_summation_split_last;[ | easy ].
...
rewrite all_0_rngl_summation_0; [ | easy | ]. 2: {
  intros k Hk.
...
*)
*)

(* If we add a row (column) of A multiplied by a scalar k to another
   row (column) of A, then the determinant will not change. *)
(* https://math.vanderbilt.edu/sapirmv/msapir/proofdet1.html *)
(* doing it only when the first row is 0; can be generalized later *)

Theorem det_add_row_mul_scal_row :
  rngl_is_comm = true →
  ∀ n (M : matrix n n T) v k,
  n ≠ 0
  → determinant (mat_add_row_mul_scal_row M 0 v k) = determinant M.
Proof.
intros Hic * Hrz.
remember
  (mk_mat n n
     (λ i j,
      if Nat.eq_dec i 0 then (v * mat_el M k j)%F else mat_el M i j))
   as C eqn:Hc.
rewrite (det_sum_row_row _ M C Hrz); cycle 1. {
  now intros; rewrite Hc.
} {
  intros i j Hi.
  now cbn; destruct (Nat.eq_dec i 0).
} {
  intros i j Hi; rewrite Hc; cbn.
  now destruct (Nat.eq_dec i 0).
} {
  remember
    (mk_mat n n (λ i j, if Nat.eq_dec i 0 then mat_el M k j else mat_el M i j))
       as D eqn:Hd.
  specialize (det_mul_row_0_by_scal Hic) as H1.
  specialize (H1 n D v Hrz).
  assert (H : mat_mul_row_by_scal 0 D v = C). {
    unfold mat_mul_row_by_scal; rewrite Hc, Hd; cbn.
    apply matrix_eq; cbn.
    intros i j Hi Hj.
    now destruct (Nat.eq_dec i 0).
  }
  rewrite H in H1; clear H.
Abort. (*
...
  assert (H : determinant D = 0%F). {
    rewrite Hd.
 (* blocked because needs the previous lemma
...
*)
*)

(* proof that the swapping two rows negates the determinant  *)

Theorem det_swap_rows : ∀ n (M : matrix n n T) i j,
  i ≠ j
  → i < n
  → j < n
  → determinant (mat_swap_rows M i j) = (- determinant M)%F.
Proof.
intros * Hij Hi Hj.
(* look point 5 at
https://math.vanderbilt.edu/sapirmv/msapir/proofdet1.html
*)
Abort. (*
intros * Hsm Hij Hi Hj.
unfold is_square_mat in Hsm.
unfold determinant; cbn.
remember (mat_ncols M) as c eqn:Hc; symmetry in Hc.
rename Hsm into Hr.
destruct c; [ flia Hr Hi | ].
remember (mat_swap_rows M i j) as M' eqn:HM'.
cbn - [ iter_seq ].
rewrite rng_opp_summation; [ | easy | easy ].
destruct (Nat.eq_dec i 0) as [Hiz| Hiz]. {
  subst i.
  destruct c; [ flia Hr Hij Hj | ].
(**)
  symmetry.
  rewrite rngl_summation_split_first; [ | easy | flia ].
  rewrite (rngl_summation_split _ j); [ | flia Hr Hj ].
  rewrite rngl_summation_split_last; [ | flia Hij ].
  cbn - [ iter_seq mat_el ].
  rewrite rngl_mul_1_l.
  remember
    (Σ (j0 = 0, c),
     minus_one_pow j0 * mat_el (subm M 0 0) 0 j0 *
     det_loop (subm (subm M 0 0) 0 j0) c)%F as K5.
  remember
    (Σ (i = 2, j),
     - (minus_one_pow (i - 1) * mat_el M 0 (i - 1) *
        (Σ (j0 = 0, c),
         minus_one_pow j0 * mat_el (subm M 0 (i - 1)) 0 j0 *
         det_loop (subm (subm M 0 (i - 1)) 0 j0) c)))%F as K6.
  remember
    (Σ (j0 = 0, c),
     minus_one_pow j0 * mat_el (subm M 0 j) 0 j0 *
     det_loop (subm (subm M 0 j) 0 j0) c)%F as K7.
  remember
    (Σ (i = j + 1, S c),
     - (minus_one_pow i * mat_el M 0 i *
        (Σ (j0 = 0, c),
         minus_one_pow j0 * mat_el (subm M 0 i) 0 j0 *
         det_loop (subm (subm M 0 i) 0 j0) c)))%F as K8.
(* I should isolate "mat_el M j j" from K5 in order to get its
   product with "mat_el M 0 0", the rest being a sub-discriminant
   which is supposed to be equal to the equivalent in M' in the
   rhs *)
...
  symmetry.
...
  rewrite rngl_summation_split_first; [ symmetry | easy | flia ].
  rewrite rngl_summation_split_first; [ symmetry | easy | flia ].
  rewrite (rngl_summation_split _ j); [ symmetry | flia Hr Hj ].
  rewrite (rngl_summation_split _ j); [ symmetry | flia Hr Hj ].
  rewrite rngl_summation_split_last; [ symmetry | flia Hij ].
  rewrite rngl_summation_split_last; [ symmetry | flia Hij ].
  cbn - [ iter_seq mat_el ].
  do 2 rewrite rngl_mul_1_l.
  remember
     (Σ (j0 = 0, c),
      minus_one_pow j0 * mat_el (subm M' 0 0) 0 j0 *
      det_loop (subm (subm M' 0 0) 0 j0) c)%F as K1.
  remember
    (Σ (i = 2, j),
     minus_one_pow (i - 1) * mat_el M' 0 (i - 1) *
     (Σ (j0 = 0, c),
      minus_one_pow j0 * mat_el (subm M' 0 (i - 1)) 0 j0 *
      det_loop (subm (subm M' 0 (i - 1)) 0 j0) c))%F as
      K2.
  remember
    (Σ (j0 = 0, c),
     minus_one_pow j0 * mat_el (subm M' 0 j) 0 j0 *
     det_loop (subm (subm M' 0 j) 0 j0) c)%F as K3.
  remember
    (Σ (i = j + 1, S c),
     minus_one_pow i * mat_el M' 0 i *
     (Σ (j0 = 0, c),
      minus_one_pow j0 * mat_el (subm M' 0 i) 0 j0 *
      det_loop (subm (subm M' 0 i) 0 j0) c))%F as K4.
  remember
    (Σ (j0 = 0, c),
     minus_one_pow j0 * mat_el (subm M 0 0) 0 j0 *
     det_loop (subm (subm M 0 0) 0 j0) c)%F as K5.
  remember
    (Σ (i = 2, j),
     - (minus_one_pow (i - 1) * mat_el M 0 (i - 1) *
        (Σ (j0 = 0, c),
         minus_one_pow j0 * mat_el (subm M 0 (i - 1)) 0 j0 *
         det_loop (subm (subm M 0 (i - 1)) 0 j0) c)))%F as K6.
  remember
    (Σ (j0 = 0, c),
     minus_one_pow j0 * mat_el (subm M 0 j) 0 j0 *
     det_loop (subm (subm M 0 j) 0 j0) c)%F as K7.
  remember
    (Σ (i = j + 1, S c),
     - (minus_one_pow i * mat_el M 0 i *
        (Σ (j0 = 0, c),
         minus_one_pow j0 * mat_el (subm M 0 i) 0 j0 *
         det_loop (subm (subm M 0 i) 0 j0) c)))%F as K8.
...
*)

(* proof that det_from_row is equal to determinant *)

Theorem det_from_row_is_det : ∀ n (M : matrix n n T) i,
  n ≠ 0
  → det_from_row M i = determinant M.
Proof.
intros * Hnz.
destruct (Nat.eq_dec i 0) as [Hiz| Hiz]. {
  subst i.
  unfold determinant, det_from_row.
  cbn - [ iter_seq ].
  rewrite rngl_mul_1_l.
  destruct n; [ easy | clear Hnz ].
  rewrite Nat.sub_succ, Nat.sub_0_r at 1.
  cbn - [ iter_seq ].
  apply rngl_summation_eq_compat.
  intros i Hi.
  f_equal; f_equal.
  now rewrite Nat.sub_0_r.
}
apply not_eq_sym in Hiz.
Abort. (*
specialize (det_swap_rows M Hiz) as H.
apply (f_equal rng_opp) in H.
rewrite rng_opp_involutive in H.
rewrite <- H; clear H.
apply not_eq_sym in Hiz.
unfold det_from_row, determinant.
cbn - [ iter_seq ].
remember (mat_ncols M) as c eqn:Hc; symmetry in Hc.
destruct c; [ easy | clear Hcz ].
rewrite Nat.sub_succ, Nat.sub_0_r.
cbn - [ iter_seq ].
rewrite rngl_mul_summation_distr_l; [ | easy ].
rewrite rng_opp_summation; [ | easy | easy ].
apply rngl_summation_eq_compat; [ easy | ].
intros j Hj.
rewrite rngl_mul_comm.
rewrite <- rngl_mul_assoc.
rewrite <- rng_mul_opp_r.
f_equal.
rewrite rngl_mul_comm; symmetry.
apply rng_opp_inj.
rewrite rng_opp_involutive.
...
*)

(*
End in_ring.
Require Import ZArith.
Open Scope Z_scope.
Existing Instance Z_ring_op.
Compute determinant (mat_of_list_list 0 [[1; 2]; [3; 4]]).
Compute determinant (mat_of_list_list 0 [[-2; 2; -3]; [-1; 1; 3]; [2; 0; -1]]). (* 18: seems good *)
*)

(*
(* If the i-th row (column) in A is a sum of the i-th row (column) of
   a matrix B and the i-th row (column) of a matrix C and all other
   rows in B and C are equal to the corresponding rows in A (that is B
   and C differ from A by one row only), then det(A)=det(B)+det(C). *)
(* https://math.vanderbilt.edu/sapirmv/msapir/proofdet1.html *)

(* Well, since my definition of the determinant only covers the
   row 0, we can prove that only when i=0; this will able us to
   prove the next theorem, swapping rows by going via row 0 *)

Theorem det_sum_row_row : ∀ A B C n,
  n ≠ 0
  → mat_nrows A = n
  → mat_nrows B = n
  → mat_nrows C = n
  → mat_ncols A = n
  → mat_ncols B = n
  → mat_ncols C = n
  → (∀ j, mat_el A 0 j = (mat_el B 0 j + mat_el C 0 j)%F)
  → (∀ i j, i ≠ 0 → mat_el B i j = mat_el A i j)
  → (∀ i j, i ≠ 0 → mat_el C i j = mat_el A i j)
  → determinant A = (determinant B + determinant C)%F.
Proof.
intros * Hnz Hra Hrb Hrc Hca Hcb Hcc Hbc Hb Hc.
unfold determinant.
rewrite Hca, Hcb, Hcc.
destruct n; [ easy | clear Hnz ].
cbn - [ iter_seq ].
assert (Hab : ∀ j, subm A 0 j = subm B 0 j). {
  intros.
  apply matrix_eq; cbn; [ now rewrite Hra, Hrb | now rewrite Hca, Hcb | ].
  intros i j' Hi Hj'.
  destruct (lt_dec j' j); symmetry; apply Hb; flia.
}
assert (Hac : ∀ j, subm A 0 j = subm C 0 j). {
  intros.
  apply matrix_eq; cbn; [ now rewrite Hra, Hrc | now rewrite Hca, Hcc | ].
  intros i j' Hi Hj'.
  destruct (lt_dec j' j); symmetry; apply Hc; flia.
}
erewrite rngl_summation_eq_compat. 2: {
  intros j Hj.
  rewrite Hbc.
  rewrite rngl_mul_add_distr_l.
  rewrite rngl_mul_add_distr_r.
  rewrite Hab at 1.
  rewrite Hac at 1.
  easy.
}
cbn - [ iter_seq ].
now apply rngl_summation_add_distr.
Qed.
*)

(* comatrix *)

Definition comatrix {n} (M : matrix n n T) : matrix n n T :=
  {| mat_el i j := (minus_one_pow (i + j) * determinant (subm M i j))%F |}.

End a.

Arguments det_loop {T ro} {n}%nat M%M i%nat.
Arguments determinant {T ro n} M%M.
Arguments subm {T m n} M%M i%nat j%nat.

Arguments determinant {T ro} {n%nat} M%M.
Arguments det_loop {T ro} {n%nat} M%M i%nat.
Arguments det_from_row {T}%type {ro} {n}%nat M%M i%nat.
Arguments det_from_col {T}%type {ro} {n}%nat M%M j%nat.
Arguments comatrix {T}%type {ro} {n}%nat M%M.
