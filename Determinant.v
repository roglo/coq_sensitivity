Set Nested Proofs Allowed.
Set Implicit Arguments.

Require Import Utf8 Arith Bool.
Require Import Permutation.
Import List List.ListNotations.

Require Import Misc RingLike IterAdd IterMul.
Require Import MyVector Matrix PermutSeq Signature Pigeonhole.
Import matrix_Notations.

Definition list_of_fun {A} n (f : _ → A) := map f (seq 0 n).
Definition fun_of_list {A} (d : A) l i := nth i l d.

Section a.

Context {T : Type}.
Context (ro : ring_like_op T).
Context (rp : ring_like_prop T).

(* determinant *)

(*
   determinant n M recursively computes determinant

      0     n-1
      |     |
      v     v
     ---------    ---------   ---------   ---------
0    |x      |    | x     |   |  x    |   |   x   |
     | ......| -  |. .....| + |.. ....| - |... ...| + etc.
     | ......|    |. .....|   |.. ....|   |... ...|
n-1  | ......|    |. .....|   |.. ....|   |... ...|
     ---------    ---------   ---------   ---------

   each term is the term "x" multiplied by det (n-1) of
   the sub-matrix represented by the dots. The "x" goes through
   the first row.
*)

Fixpoint determinant_loop n (M : matrix T) :=
  (match n with
   | 0 => λ _, 1%F
   | S n' =>
       λ M' : matrix T,
       ∑ (j = 0, n'),
       minus_one_pow j * mat_el M' 0 j * determinant_loop n' (subm M' 0 j)
   end) M.

Definition determinant M := determinant_loop (mat_nrows M) M.
Arguments determinant M%M.

Theorem determinant_zero : ∀ (M : matrix T),
  determinant_loop 0 M = 1%F.
Proof. easy. Qed.

Theorem determinant_succ : ∀ n (M : matrix T),
  determinant_loop (S n) M =
     ∑ (j = 0, n),
     minus_one_pow j * mat_el M 0 j * determinant_loop n (subm M 0 j).
Proof. easy. Qed.

Definition mat_permut_rows_fun (σ : nat → nat) (M : matrix T) :=
  mk_mat (map (λ i, nth (σ i) (mat_list_list M) []) (seq 0 (mat_nrows M))).

Definition mat_permut_rows (σ : vector nat) (M : matrix T) :=
  mat_permut_rows_fun (vect_el 0 σ) M.

(* the following versions of computing the determinant should
   (to be proven) be equivalent; perhaps could help for proving
   Cramer's rule of resolving equations *)

Definition det_from_row {n} (M : matrix T) i :=
  (minus_one_pow i *
   ∑ (j = 0, n),
     minus_one_pow j * mat_el M i j * determinant_loop n (subm M i j))%F.

Definition det_from_col {n} (M : matrix T) j :=
  (minus_one_pow j *
   ∑ (i = 0, n - 1),
     minus_one_pow i * mat_el M i j * determinant_loop n (subm M i j))%F.

(* Alternative version of the determinant: sum of product of the
   factors a_{i,σ(i)} where σ goes through all permutations of
   the naturals of the interval [0, n-1].
   The permutations generated are in the same order as the
   terms generated by the determinant defined by induction on
   the size of the matrix.
     The order happens to be the canonical (alphabetical) order.
   Example for n=3
     = [[0; 1; 2]; [0; 2; 1]; [1; 0; 2]; [1; 2; 0]; [2; 0; 1]; [2; 1; 0]]
   Having the same terms order, the proof of equality of both definitions
   of both determinants is easy.
   See PermutSeq.v *)

(* definition of determinant by sum of products involving all
   permutations *)

Definition determinant' n (M : matrix T) :=
  ∑ (k = 0, fact n - 1),
    ε n (canon_sym_gr_list n k) *
    ∏ (i = 1, n), mat_el M (i - 1) (ff_app (canon_sym_gr_list n k) (i - 1)).

Arguments determinant' n%nat M%M.

(*
Definition determinant' n (M : matrix T) :=
  ∑ (k = 0, fact n - 1),
    ε n (vect_vect_nat_el (mk_canon_sym_gr_vect n) k) *
    ∏ (i = 1, n),
    mat_el M (i - 1)
      (vect_el 0%nat (vect_vect_nat_el (mk_canon_sym_gr_vect n) k) (i - 1)).
*)

(* Proof that both definitions of determinants are equal *)

Theorem det_is_det_by_canon_permut : rngl_is_field →
  ∀ (M : matrix T),
  is_square_matrix M = true
  → determinant M = determinant' (mat_nrows M) M.
Proof.
intros (Hic & Hop & Hin & H10 & Hit & Hde & Hch) * Hm.
unfold determinant'.
remember (mat_nrows M) as n eqn:Hr; symmetry in Hr.
unfold determinant.
rewrite Hr.
revert M Hm Hr.
induction n; intros. {
  cbn.
  rewrite rngl_summation_only_one.
  unfold ε, iter_seq, iter_list; cbn.
  rewrite rngl_mul_1_r.
  rewrite rngl_div_1_r; [ easy | now left | easy ].
}
rewrite determinant_succ.
destruct (Nat.eq_dec n 0) as [Hnz| Hnz]. {
  subst n; cbn.
  rewrite rngl_summation_only_one; cbn.
  rewrite rngl_summation_only_one; cbn.
  rewrite rngl_product_only_one; cbn.
  unfold ε; cbn.
  do 4 rewrite rngl_product_only_one; cbn.
  rewrite rngl_mul_1_r.
  rewrite rngl_div_1_r; [ easy | now left | easy ].
}
erewrite rngl_summation_eq_compat. 2: {
  intros i Hi.
  rewrite IHn; cycle 1. {
    apply is_squ_mat_subm; [ now rewrite Hr | rewrite Hr; flia Hi | easy ].
  } {
    rewrite mat_nrows_subm, Hr; cbn.
    apply Nat.sub_0_r.
  }
  easy.
}
cbn - [ canon_sym_gr_list fact nth ].
clear IHn.
erewrite rngl_summation_eq_compat. 2: {
  intros i Hi.
  rewrite rngl_mul_summation_distr_l; [ | now left ].
  easy.
}
cbn - [ canon_sym_gr_list fact nth ].
rewrite rngl_summation_summation_distr.
rewrite <- Nat.sub_succ_l; [ | apply Nat.neq_0_lt_0, fact_neq_0 ].
rewrite Nat_sub_succ_1.
rewrite <- Nat_fact_succ.
apply rngl_summation_eq_compat.
intros k Hk.
(* elimination of "mat_el M 0 (k / (n!)" *)
symmetry.
rewrite rngl_product_split_first; [ | flia ].
rewrite Nat.sub_diag.
cbn [ canon_sym_gr_list nth ].
remember (mat_el M 0 _) as x eqn:Hx.
rewrite rngl_mul_comm; [ | easy ].
symmetry.
rewrite <- rngl_mul_assoc.
rewrite rngl_mul_comm; [ | easy ].
do 3 rewrite <- rngl_mul_assoc.
f_equal.
(* elimination done *)
(* separation factors "∏" and "ε" *)
rewrite rngl_mul_comm; [ | easy ].
rewrite <- rngl_mul_assoc.
f_equal. {
  (* equality of the two "∏" *)
  rewrite rngl_product_shift; [ | flia Hnz ].
  rewrite (rngl_product_shift _ 2); [ | flia Hnz ].
  rewrite Nat.sub_succ.
  apply rngl_product_eq_compat.
  intros i Hi.
  rewrite Nat.add_comm, Nat.add_sub.
  replace (2 + i - 1) with (S i) by flia.
  unfold mat_el.
  unfold ff_app.
  cbn - [ subm fact ].
  rewrite (List_map_nth' 0); [ | rewrite length_canon_sym_gr_list; flia Hi Hnz ].
  cbn - [ butn ].
  rewrite (List_map_nth' []). 2: {
    apply is_sm_mat_iff in Hm.
    destruct Hm as (Hcr & Hc).
    rewrite butn_length, fold_mat_nrows, Hr.
    cbn; flia Hi Hnz.
  }
  unfold succ_when_ge, Nat.b2n.
  rewrite if_leb_le_dec.
  destruct (le_dec (k / n!) _) as [H1| H1]. {
    rewrite nth_butn_before; [ | easy ].
    rewrite nth_butn_before; [ | easy ].
    now rewrite (Nat.add_1_r i).
  } {
    apply Nat.nle_gt in H1.
    rewrite Nat.add_0_r.
    rewrite nth_butn_after; [ | easy ].
    rewrite nth_butn_before; [ | easy ].
    now rewrite Nat.add_1_r.
  }
  (* end proof equality of the two "∏" *)
}
(* equality of the two "ε" *)
symmetry.
apply ε_of_sym_gr_permut_succ; try easy.
apply (le_lt_trans _ ((S n)! - 1)); [ easy | ].
apply Nat.sub_lt; [ | easy ].
apply Nat.le_succ_l, Nat.neq_0_lt_0, fact_neq_0.
Qed.

(* multilinearity *)

Theorem determinant_multilinear : rngl_is_field →
  ∀ n (M : matrix T) i a b U V,
  is_square_matrix M = true
  → mat_nrows M = n
  → vect_size U = n
  → vect_size V = n
  → i < n
  → determinant (mat_repl_vect i M (a × U + b × V)%V) =
       (a * determinant (mat_repl_vect i M U) +
        b * determinant (mat_repl_vect i M V))%F.
Proof.
intros Hif * Hsm Hr Hu Hv Hi.
specialize (square_matrix_ncols _ Hsm) as Hcn.
(* using the snd version of determinants: determinant' *)
rewrite (det_is_det_by_canon_permut Hif). 2: {
  apply mat_repl_vect_is_square; [ congruence | cbn | easy ].
  rewrite map2_length.
  do 2 rewrite map_length, fold_vect_size.
  rewrite Hu, Hv.
  now rewrite Nat.min_id.
}
rewrite (det_is_det_by_canon_permut Hif). 2: {
  apply mat_repl_vect_is_square; [ congruence | congruence | easy ].
}
rewrite (det_is_det_by_canon_permut Hif). 2: {
  apply mat_repl_vect_is_square; [ congruence | congruence | easy ].
}
unfold determinant'.
(* simplification of the lhs *)
remember (a × U + b × V)%V as UV eqn:HUV.
assert (Hvm : vect_size UV = mat_nrows M). {
  rewrite Hr, HUV; cbn.
  rewrite map2_length.
  do 2 rewrite map_length.
  do 2 rewrite fold_vect_size.
  rewrite Hu, Hv.
  apply Nat.min_id.
}
erewrite rngl_summation_eq_compat. 2: {
  intros k Hk.
  assert (Hkn : k < n!). {
    eapply le_lt_trans; [ apply Hk | ].
    rewrite mat_repl_vect_nrows; [ | easy ].
    rewrite Hr.
    apply Nat.sub_lt; [ | flia ].
    apply Nat.neq_0_lt_0, fact_neq_0.
  }
  erewrite rngl_product_eq_compat. 2: {
    intros j Hj.
    rewrite HUV in Hj; cbn in Hj.
    do 2 rewrite map2_length in Hj.
    do 2 rewrite map_length in Hj.
    do 2 rewrite fold_vect_size in Hj.
    rewrite fold_mat_nrows, Hr, Hu, Hv in Hj.
    do 2 rewrite Nat.min_id in Hj.
    rewrite mat_el_repl_vect; cycle 1. {
      now apply squ_mat_is_corr.
    } {
      subst UV; cbn.
      rewrite map2_length.
      do 2 rewrite map_length.
      do 2 rewrite fold_vect_size.
      rewrite Hu, Hv, Nat.min_id.
      flia Hj.
    } {
      rewrite Hr; flia Hj.
    } {
      unfold ff_app.
      rewrite Hcn.
      rewrite mat_repl_vect_nrows; [ | easy ].
      rewrite Hr.
      apply canon_sym_gr_list_ub; [ easy | flia Hj ].
    } {
      now rewrite Hcn, Hr.
    }
    unfold vect_el, ff_app.
    cbn - [ Nat.eq_dec ].
    rewrite map2_length, fold_mat_nrows, fold_vect_size.
    rewrite Hvm, Hr, Nat.min_id.
    easy.
  }
  easy.
}
cbn - [ mat_el ].
(* put a and b inside the sigma in the rhs *)
rewrite rngl_mul_summation_distr_l; [ | now destruct Hif; left ].
rewrite rngl_mul_summation_distr_l; [ | now destruct Hif; left ].
symmetry.
erewrite rngl_summation_eq_compat. 2: {
  intros k Hk.
  rewrite map2_length, fold_mat_nrows, fold_vect_size in Hk |-*.
  rewrite Hr, Hu, Nat.min_id in Hk |-*.
  assert (Hkn : k < fact n). {
    specialize (fact_neq_0 n) as Hnz.
    flia Hk Hnz.
  }
  rewrite rngl_mul_assoc.
  destruct Hif as (Hic & Hop & Hin & H10 & Hit & Hde & Hch) in Hsm.
  rewrite (rngl_mul_comm Hic a).
  erewrite rngl_product_eq_compat. 2: {
    intros j Hj.
    rewrite mat_el_repl_vect; cycle 1. {
      now apply squ_mat_is_corr.
    } {
      rewrite Hu; flia Hj.
    } {
      rewrite Hr; flia Hj.
    } {
      cbn.
      rewrite Hcn, Hr.
      apply canon_sym_gr_list_ub; [ easy | flia Hj ].
    } {
      now rewrite Hcn, Hr.
    }
    now unfold vect_el, ff_app; cbn.
  }
  easy.
}
do 3 rewrite map2_length, fold_mat_nrows, fold_vect_size.
rewrite Hvm, Hr, Hu, Hv, Nat.min_id.
rewrite rngl_add_comm.
erewrite rngl_summation_eq_compat. 2: {
  intros k Hk.
  assert (Hkn : k < fact n). {
    specialize (fact_neq_0 n) as Hnz.
    flia Hk Hnz.
  }
  rewrite rngl_mul_assoc.
  destruct Hif as (Hic & Hop & Hin & H10 & Hit & Hde & Hch) in Hsm.
  rewrite (rngl_mul_comm Hic b).
  erewrite rngl_product_eq_compat. 2: {
    intros j Hj.
    rewrite mat_el_repl_vect; cycle 1. {
      now apply squ_mat_is_corr.
    } {
      rewrite Hv; flia Hj.
    } {
      rewrite Hr; flia Hj.
    } {
      rewrite Hcn, Hr.
      apply canon_sym_gr_list_ub; [ easy | flia Hj ].
    } {
      now rewrite Hcn, Hr.
    }
    now unfold vect_el, ff_app; cbn.
  }
  easy.
}
rewrite rngl_add_comm.
(* make one summation *)
rewrite <- rngl_summation_add_distr.
apply rngl_summation_eq_compat.
intros k Hk.
do 2 rewrite <- rngl_mul_assoc.
rewrite <- rngl_mul_add_distr_l.
(* elimination of the ε-s *)
f_equal.
(* *)
assert (Hkn : k < fact n). {
  specialize (fact_neq_0 n) as Hnz.
  flia Hk Hnz.
}
specialize (canon_sym_gr_surjective Hkn Hi) as Hp.
destruct Hp as (p & Hp & Hpp).
rewrite (rngl_product_split (p + 1)); [ | flia Hp ].
rewrite rngl_product_split_last; [ | flia ].
erewrite rngl_product_eq_compat. 2: {
  intros j Hj.
  replace (j - 1 - 1) with (j - 2) by flia.
  destruct (Nat.eq_dec (nth (j - 2) (canon_sym_gr_list n k) 0) i)
    as [Hpj| Hpj]. {
    exfalso.
    rewrite <- Hpp in Hpj.
    apply nth_canon_sym_gr_list_inj1 in Hpj; [ | easy | flia Hp Hj | easy ].
    flia Hj Hpj.
  }
  easy.
}
destruct Hif as (Hic & Hop & Hin & H10 & Hit & Hde & Hch) in Hsm.
rewrite (rngl_mul_comm Hic (iter_seq _ _ _ _)).
rewrite rngl_add_comm.
rewrite (rngl_product_split (p + 1)); [ | flia Hp ].
rewrite rngl_product_split_last; [ | flia ].
erewrite rngl_product_eq_compat. 2: {
  intros j Hj.
  replace (j - 1 - 1) with (j - 2) by flia.
  destruct (Nat.eq_dec (nth (j - 2) (canon_sym_gr_list n k) 0) i)
    as [Hpj| Hpj]. {
    exfalso.
    rewrite <- Hpp in Hpj.
    apply nth_canon_sym_gr_list_inj1 in Hpj; [ | easy | flia Hp Hj | easy ].
    flia Hj Hpj.
  }
  easy.
}
rewrite (rngl_mul_comm Hic (iter_seq _ _ _ _)).
rewrite rngl_add_comm.
symmetry.
rewrite (rngl_product_split (p + 1)); [ | flia Hp ].
rewrite rngl_product_split_last; [ | flia ].
erewrite rngl_product_eq_compat. 2: {
  intros j Hj.
  replace (j - 1 - 1) with (j - 2) by flia.
  destruct (Nat.eq_dec (nth (j - 2) (canon_sym_gr_list n k) 0) i)
    as [Hpj| Hpj]. {
    exfalso.
    rewrite <- Hpp in Hpj.
    apply nth_canon_sym_gr_list_inj1 in Hpj; [ | easy | flia Hp Hj | easy ].
    flia Hj Hpj.
  }
  easy.
}
rewrite (rngl_mul_comm Hic (iter_seq _ _ _ _)).
rewrite Nat.add_sub.
unfold ff_app in Hpp.
rewrite Hpp.
destruct (Nat.eq_dec i i) as [H| H]; [ clear H | easy ].
do 4 rewrite rngl_mul_assoc.
subst UV.
cbn - [ mat_el ].
rewrite map2_nth with (a := 0%F) (b := 0%F); cycle 1. {
  now rewrite map_length, fold_vect_size, Hu.
} {
  now rewrite map_length, fold_vect_size, Hv.
}
rewrite (List_map_nth' 0%F); [ | now rewrite fold_vect_size, Hu ].
rewrite (List_map_nth' 0%F); [ | now rewrite fold_vect_size, Hv ].
do 2 rewrite fold_vect_el.
(* elimination of the following term (q) *)
remember
  (∏ (i0 = 2, p + 1),
   mat_el M (i0 - 2) (nth (i0 - 2) (canon_sym_gr_list n k) O))
  as q eqn:Hq.
rewrite (rngl_mul_mul_swap Hic _ _ q).
do 3 rewrite (rngl_mul_comm Hic _ q).
do 5 rewrite <- rngl_mul_assoc.
rewrite <- rngl_mul_add_distr_l.
f_equal.
clear q Hq.
erewrite rngl_product_eq_compat. 2: {
  intros j Hj.
  destruct (Nat.eq_dec (nth (j - 1) (canon_sym_gr_list n k) 0) i)
    as [Hpj| Hpj]. {
    rewrite <- Hpp in Hpj.
    apply nth_canon_sym_gr_list_inj1 in Hpj; [ | easy | flia Hp Hj | easy ].
    flia Hj Hpj.
  }
  easy.
}
symmetry.
erewrite rngl_product_eq_compat. 2: {
  intros j Hj.
  destruct (Nat.eq_dec (nth (j - 1) (canon_sym_gr_list n k) 0) i)
    as [Hpj| Hpj]. {
    rewrite <- Hpp in Hpj.
    apply nth_canon_sym_gr_list_inj1 in Hpj; [ | easy | flia Hp Hj | easy ].
    flia Hj Hpj.
  }
  easy.
}
rewrite rngl_add_comm.
erewrite rngl_product_eq_compat. 2: {
  intros j Hj.
  destruct (Nat.eq_dec (nth (j - 1) (canon_sym_gr_list n k) 0) i)
    as [Hpj| Hpj]. {
    rewrite <- Hpp in Hpj.
    apply nth_canon_sym_gr_list_inj1 in Hpj; [ | easy | flia Hp Hj | easy ].
    flia Hj Hpj.
  }
  easy.
}
cbn.
rewrite rngl_add_comm.
do 2 rewrite rngl_mul_assoc.
now rewrite <- rngl_mul_add_distr_r.
Qed.

(* list of terms in determinant' (determinant by sum of products of
   permutations *)

Definition determinant'_list n (M : matrix T) :=
  map (λ k,
    (ε_permut n k *
     ∏ (i = 1, n),
     mat_el M (i - 1) (ff_app (canon_sym_gr_list n k) (i - 1)))%F)
    (seq 0 n!).

Arguments determinant'_list n%nat M%M.

Theorem determinant'_by_list : rngl_is_field →
  ∀ n (M : matrix T),
  determinant' n M = ∑ (k = 0, fact n - 1), nth k (determinant'_list n M) 0.
Proof.
intros (Hic & Hop & Hin & H10 & Hit & Hde & Hch) *.
unfold determinant', determinant'_list.
apply rngl_summation_eq_compat; intros k Hk.
assert (Hkn : k < fact n). {
  specialize (fact_neq_0 n) as Hn.
  flia Hk Hn.
}
rewrite List_map_nth' with (a := 0); [ | now rewrite seq_length ].
rewrite seq_nth; [ | easy ].
rewrite Nat.add_0_l.
f_equal.
now apply ε_of_permut_ε.
Qed.

Theorem det_is_det_by_any_permut : rngl_is_field →
  ∀ n (M : matrix T) l,
  mat_nrows M = n
  → is_square_matrix M = true
  → Permutation l (determinant'_list n M)
  → determinant M = ∑ (k = 0, fact n - 1), nth k l 0.
Proof.
intros Hif * Hr Hsm Hl.
rewrite det_is_det_by_canon_permut; [ | easy | easy ].
rewrite determinant'_by_list; [ | easy ].
rewrite Hr.
apply rngl_summation_permut; [ now symmetry | | ]. {
  unfold determinant'_list.
  now rewrite List_map_seq_length.
} {
  apply Permutation_length in Hl.
  unfold determinant'_list in Hl.
  now rewrite List_map_seq_length in Hl.
}
Qed.

(*
(* yet another definition of determinant *)

Definition determinant'' p q n (M : matrix T) :=
  ∑ (k = 0, n! - 1),
    ε_permut n k *
    ∏ (i = 1, n),
    mat_el M (i - 1) (ff_app (sym_gr_elem_swap_last p q n k) (i - 1)).

Definition determinant'' p q n (M : matrix T) :=
  ∑ (k = 0, fact n - 1),
    ε_permut n k *
    ∏ (i = 1, n),
    mat_el M (i - 1) (vect_el 0%nat (sym_gr_elem_swap_last p q n k) (i - 1)).

Definition determinant''_list p q n (M : matrix T) :=
  map (λ k,
    (ε_permut n k *
     ∏ (i = 1, n),
     mat_el M (i - 1) (vect_el 0%nat
       (sym_gr_elem_swap_last p q n k) (i - 1)))%F)
    (seq 0 (fact n)).

Theorem determinant''_by_list : ∀ n p q (M : matrix T),
  determinant'' p q n M =
    ∑ (k = 0, fact n - 1), nth k (determinant''_list p q n M) 0.
Proof.
intros.
unfold determinant'', determinant''_list.
apply rngl_summation_eq_compat; intros k Hk.
assert (Hkn : k < fact n). {
  specialize (fact_neq_0 n) as Hn.
  flia Hk Hn.
}
rewrite (List_map_nth' 0); [ | now rewrite seq_length ].
rewrite seq_nth; [ | easy ].
now rewrite Nat.add_0_l.
Qed.
*)

(* already defined as list_swap_elem in PermutSeq.v
Definition list_swap_scal {A} d i1 i2 (l : list A) :=
  map (λ i, nth (transposition i1 i2 i) l d) (seq 0 (length l)).
*)

Definition mat_swap_rows i1 i2 (M : matrix T) :=
  mk_mat (list_swap_elem [] (mat_list_list M) i1 i2).

Theorem list_swap_scal_0_succ_cons : ∀ A (d : A) j a l,
  list_swap_elem d (a :: l) 0 (S j) =
  nth j l d :: map (λ i, if i =? j then a else nth i l d) (seq 0 (length l)).
Proof.
intros.
cbn - [ nth ].
f_equal.
rewrite <- seq_shift, map_map.
apply map_ext_in.
intros i Hi; apply in_seq in Hi.
unfold transposition.
cbn - [ nth ].
do 2 rewrite if_eqb_eq_dec.
now destruct (Nat.eq_dec i j).
Qed.

Theorem mat_swap_rows_is_square : ∀ (M : matrix T) p q,
  p < mat_nrows M
  → q < mat_nrows M
  → is_square_matrix M = true
  → is_square_matrix (mat_swap_rows p q M) = true.
Proof.
intros * Hp Hq Hsm.
remember (mat_nrows M) as n eqn:Hr.
symmetry in Hr.
specialize (square_matrix_ncols _ Hsm) as Hcn.
specialize (squ_mat_is_corr M Hsm) as Hco.
apply is_sm_mat_iff in Hsm.
apply is_sm_mat_iff.
destruct Hsm as (Hcr & Hc).
cbn; unfold list_swap_elem.
rewrite List_map_seq_length.
unfold mat_swap_rows, list_swap_elem; cbn.
split. {
  unfold mat_ncols; cbn.
  rewrite List_hd_nth_0.
  rewrite fold_mat_nrows; rewrite Hr.
  rewrite (List_map_nth' 0); [ | rewrite seq_length; flia Hp ].
  rewrite seq_nth; [ | flia Hp ].
  rewrite Nat.add_0_l.
  rewrite Hc; [ now intros Hn; subst n | ].
  apply nth_In; rewrite fold_mat_nrows; rewrite Hr.
  unfold transposition.
  do 2 rewrite if_eqb_eq_dec.
  destruct (Nat.eq_dec 0 p); [ easy | ].
  destruct (Nat.eq_dec 0 q); [ easy | ].
  flia Hp.
} {
  intros la Hla.
  apply in_map_iff in Hla.
  rewrite fold_mat_nrows, Hr in Hla.
  destruct Hla as (a & Ha & Hla).
  apply in_seq in Hla; subst la.
  rewrite fold_corr_mat_ncols; [ easy | easy | rewrite Hr ].
  unfold transposition.
  do 2 rewrite if_eqb_eq_dec.
  destruct (Nat.eq_dec a p); [ easy | ].
  destruct (Nat.eq_dec a q); [ easy | ].
  easy.
}
Qed.

Theorem mat_swap_rows_nrows : ∀ (M : matrix T) p q,
  mat_nrows (mat_swap_rows p q M) = mat_nrows M.
Proof.
intros.
unfold mat_swap_rows; cbn.
unfold list_swap_elem.
rewrite map_length.
now rewrite seq_length.
Qed.

Theorem corr_mat_swap_rows_ncols : ∀ (M : matrix T) p q,
  p < mat_nrows M
  → q < mat_nrows M
  → is_correct_matrix M
  → mat_ncols (mat_swap_rows p q M) = mat_ncols M.
Proof.
intros * Hp Hq Hcm.
destruct (Nat.eq_dec (mat_nrows M) 0) as [Hrz| Hrz]. {
  unfold mat_nrows in Hrz.
  apply length_zero_iff_nil in Hrz.
  unfold mat_ncols; cbn.
  now rewrite Hrz.
}
apply Nat.neq_0_lt_0 in Hrz.
unfold mat_swap_rows; cbn.
unfold list_swap_elem.
unfold mat_ncols; cbn.
rewrite List_hd_nth_0.
rewrite (List_map_nth' 0); [ | now rewrite seq_length ].
rewrite seq_nth; [ | easy ].
rewrite Nat.add_0_l.
unfold transposition.
do 2 rewrite if_eqb_eq_dec.
destruct (Nat.eq_dec 0 p) as [Hzp| Hzp]. {
  now rewrite fold_corr_mat_ncols.
}
destruct (Nat.eq_dec 0 q) as [Hzq| Hzq]. {
  now rewrite fold_corr_mat_ncols.
}
now rewrite List_hd_nth_0.
Qed.

Theorem is_permut_canon_transp : ∀ n k p q,
  k < n!
  → p < n
  → q < n
  → is_permut n (list_swap_elem 0 (canon_sym_gr_list n k) p q).
Proof.
intros * Hkn Hpn Hqn.
split. {
  split. {
    intros j Hj.
    rewrite length_list_swap_elem, length_canon_sym_gr_list.
    unfold list_swap_elem in Hj.
    rewrite length_canon_sym_gr_list in Hj.
    apply in_map_iff in Hj.
    destruct Hj as (i & Hij & Hi).
    apply in_seq in Hi.
    rewrite <- Hij.
    unfold transposition.
    do 2 rewrite if_eqb_eq_dec.
    destruct (Nat.eq_dec i p) as [Hip| Hip]. {
      now apply canon_sym_gr_list_ub.
    }
    destruct (Nat.eq_dec i q) as [Hiq| Hiq]. {
      now apply canon_sym_gr_list_ub.
    }
    now apply canon_sym_gr_list_ub.
  } {
    intros u v Hu Hv Huv.
    rewrite length_list_swap_elem in Hu, Hv.
    unfold list_swap_elem in Huv.
    rewrite length_canon_sym_gr_list in Hu, Hv, Huv.
    unfold ff_app in Huv.
    rewrite (List_map_nth' 0) in Huv; [ | now rewrite seq_length ].
    rewrite (List_map_nth' 0) in Huv; [ | now rewrite seq_length ].
    rewrite seq_nth in Huv; [ | easy ].
    rewrite seq_nth in Huv; [ | easy ].
    cbn in Huv.
    assert (Htu : transposition p q u < n) by now apply transposition_lt.
    assert (Htv : transposition p q v < n) by now apply transposition_lt.
    apply nth_canon_sym_gr_list_inj1 in Huv; [ | easy | easy | easy ].
    now apply transposition_injective in Huv.
  }
}
rewrite length_list_swap_elem.
apply length_canon_sym_gr_list.
Qed.

Theorem nth_transposition_canon_sym_gr_list_inj : ∀ n k p q i j,
  k < n!
  → p < n
  → q < n
  → i < n
  → j < n
  → nth (transposition p q i) (canon_sym_gr_list n k) 0 =
    nth (transposition p q j) (canon_sym_gr_list n k) 0
  → i = j.
Proof.
intros * Hkn Hpn Hqn Hin Hjn Hij.
unfold transposition in Hij.
do 4 rewrite if_eqb_eq_dec in Hij.
destruct (Nat.eq_dec i p) as [Hip| Hip]. {
  destruct (Nat.eq_dec j p) as [Hjp| Hjp]; [ congruence | ].
  destruct (Nat.eq_dec j q) as [Hjq| Hjq]. {
    apply nth_canon_sym_gr_list_inj1 in Hij; [ | easy | easy | easy ].
    congruence.
  }
  apply Nat.neq_sym in Hjq.
  now apply nth_canon_sym_gr_list_inj1 in Hij.
}
destruct (Nat.eq_dec i q) as [Hiq| Hiq]. {
  destruct (Nat.eq_dec j p) as [Hjp| Hjp]. {
    apply nth_canon_sym_gr_list_inj1 in Hij; [ | easy | easy | easy ].
    congruence.
  }
  destruct (Nat.eq_dec j q) as [Hjq| Hjq]; [ congruence | ].
  apply Nat.neq_sym in Hjp.
  now apply nth_canon_sym_gr_list_inj1 in Hij.
}
destruct (Nat.eq_dec j p) as [Hjp| Hjp]. {
  now apply nth_canon_sym_gr_list_inj1 in Hij.
}
destruct (Nat.eq_dec j q) as [Hjq| Hjq]. {
  now apply nth_canon_sym_gr_list_inj1 in Hij.
}
now apply nth_canon_sym_gr_list_inj1 in Hij.
Qed.

Theorem determinant_alternating : rngl_is_field →
  ∀ (M : matrix T) p q,
  p ≠ q
  → p < mat_nrows M
  → q < mat_nrows M
  → is_square_matrix M = true
  → determinant (mat_swap_rows p q M) = (- determinant M)%F.
Proof.
intros Hif * Hpq Hp Hq Hsm.
remember (mat_nrows M) as n eqn:Hr; symmetry in Hr.
rewrite det_is_det_by_canon_permut; [ | easy | ]. 2: {
  rewrite <- Hr in Hp, Hq.
  now apply mat_swap_rows_is_square.
}
unfold determinant'.
rewrite mat_swap_rows_nrows.
rewrite Hr.
erewrite rngl_summation_eq_compat. 2: {
  intros k Hk.
  rewrite rngl_product_shift; [ | flia Hp ].
  erewrite rngl_product_eq_compat. 2: {
    intros i Hi.
    now rewrite Nat.add_comm, Nat.add_sub.
  }
  easy.
}
cbn - [ mat_swap_rows ].
erewrite rngl_summation_eq_compat. 2: {
  intros k Hk.
  rewrite rngl_product_change_var with
    (g := transposition p q) (h := transposition p q). 2: {
    intros i Hi.
    apply transposition_involutive.
  }
  rewrite Nat.sub_0_r.
  rewrite <- Nat.sub_succ_l; [ | flia Hp ].
  rewrite Nat_sub_succ_1.
  easy.
}
cbn - [ mat_swap_rows ].
erewrite rngl_summation_eq_compat. 2: {
  intros k Hk.
  destruct Hif as (Hic & Hop & Hin & H10 & Hit & Hde & Hch) in Hsm.
  rewrite rngl_product_list_permut with (l2 := seq 0 n); [ | easy | ]. 2: {
    apply permut_list_Permutation.
    now apply transposition_is_permut.
  }
  easy.
}
cbn - [ mat_swap_rows ].
erewrite rngl_summation_eq_compat. 2: {
  intros k Hk.
  assert (Hkn : k < n!). {
    specialize (fact_neq_0 n) as Hn.
    flia Hk Hn.
  }
  erewrite rngl_product_list_eq_compat. 2: {
    intros i Hi.
    replace (mat_el _ _ _) with
      (mat_el M i
         (ff_app (canon_sym_gr_list n k) (transposition p q i))). 2: {
      unfold ff_app; cbn.
      unfold mat_el; f_equal.
      unfold list_swap_elem.
      rewrite (List_map_nth' 0). 2: {
        rewrite seq_length.
        rewrite fold_mat_nrows, Hr.
        apply in_seq in Hi.
        now apply transposition_lt.
      }
      rewrite fold_mat_nrows, Hr.
      unfold transposition.
      do 2 rewrite if_eqb_eq_dec.
      destruct (Nat.eq_dec i p) as [Hip| Hip]. {
        subst i.
        rewrite seq_nth; [ | easy ].
        rewrite Nat.add_0_l.
        rewrite Nat.eqb_refl.
        apply Nat.neq_sym in Hpq.
        now destruct (Nat.eq_dec q p).
      }
      rewrite if_eqb_eq_dec.
      destruct (Nat.eq_dec i q) as [Hiq| Hiq]. {
        subst i.
        rewrite seq_nth; [ | easy ].
        rewrite Nat.add_0_l.
        rewrite <- if_eqb_eq_dec.
        now rewrite Nat.eqb_refl.
      }
      apply in_seq in Hi.
      rewrite seq_nth; [ | easy ].
      rewrite Nat.add_0_l.
      rewrite if_eqb_eq_dec.
      destruct (Nat.eq_dec i p) as [H| H]; [ easy | clear H ].
      now destruct (Nat.eq_dec i q).
    }
    easy.
  }
  easy.
}
cbn.
set (f := λ k, list_swap_elem 0 (canon_sym_gr_list n k) p q).
erewrite rngl_summation_eq_compat. 2: {
  intros k Hk.
  erewrite rngl_product_list_eq_compat. 2: {
    intros i Hi.
    apply in_seq in Hi.
    replace (ff_app _ _) with
       (ff_app (list_swap_elem 0 (canon_sym_gr_list n k) p q) i). 2: {
(* lemme à faire *)
      unfold list_swap_elem.
      unfold ff_app.
      rewrite (List_map_nth' 0). 2: {
        now rewrite seq_length, length_canon_sym_gr_list.
      }
      rewrite seq_nth; [ easy | now rewrite length_canon_sym_gr_list ].
    }
    fold (f k).
    easy.
  }
  easy.
}
cbn.
erewrite rngl_summation_eq_compat. 2: {
  intros k Hk.
  assert (Hkn : k < n!). {
    specialize (fact_neq_0 n) as Hn.
    flia Hk Hn.
  }
  erewrite rngl_product_seq_product; [ | flia Hp ].
  rewrite Nat.add_0_l.
  replace (canon_sym_gr_list n k) with
     (map (λ i, ff_app (f k) (transposition p q i)) (seq 0 n)). 2: {
    rewrite List_map_nth_seq with (d := 0).
    rewrite length_canon_sym_gr_list.
    apply map_ext_in.
    intros i Hi; cbn.
    apply in_seq in Hi.
    unfold ff_app, f, list_swap_elem.
    rewrite (List_map_nth' 0). 2: {
      rewrite seq_length, length_canon_sym_gr_list.
      now apply transposition_lt.
    }
    rewrite seq_nth. 2: {
      rewrite length_canon_sym_gr_list.
      now apply transposition_lt.
    }
    rewrite Nat.add_0_l.
    now rewrite transposition_involutive.
  }
  replace (map (λ i, ff_app (f k) (transposition p q i)) (seq 0 n))
  with (f k ° map (λ i, transposition p q i) (seq 0 n)). 2: {
    unfold "°"; cbn.
    now rewrite map_map.
  }
  rewrite signature_comp; [ easy | easy | | ]. {
    split. 2: {
      unfold f.
      rewrite length_list_swap_elem.
      apply length_canon_sym_gr_list.
    }
    split. {
      intros i Hi.
      apply In_nth with (d := 0) in Hi.
      destruct Hi as (j & Hj & Hji).
      rewrite <- Hji.
      apply permut_list_ub; [ | easy ].
      unfold f.
      apply list_swap_elem_is_permut_list. {
        now rewrite length_canon_sym_gr_list.
      } {
        now rewrite length_canon_sym_gr_list.
      } {
        now apply canon_sym_gr_list_is_permut.
      }
    }
    unfold f, ff_app.
    rewrite length_list_swap_elem.
    rewrite length_canon_sym_gr_list.
    intros i j Hi Hj Hij.
(* lemme à faire ? *)
    unfold list_swap_elem in Hij.
    rewrite (List_map_nth' 0) in Hij. 2: {
      now rewrite seq_length, length_canon_sym_gr_list.
    }
    rewrite (List_map_nth' 0) in Hij. 2: {
      now rewrite seq_length, length_canon_sym_gr_list.
    }
    rewrite seq_nth in Hij; [ | now rewrite length_canon_sym_gr_list ].
    rewrite seq_nth in Hij; [ | now rewrite length_canon_sym_gr_list ].
    cbn in Hij.
    now apply nth_transposition_canon_sym_gr_list_inj in Hij.
  }
  now apply transposition_is_permut.
}
cbn.
erewrite rngl_summation_eq_compat. 2: {
  intros k (_, Hk).
  destruct Hif as (Hic & Hop & Hin & H10 & Hit & Hde & Hch) in Hsm.
  rewrite (rngl_mul_comm Hic (ε n (f k))).
  rewrite <- rngl_mul_assoc.
  now rewrite transposition_signature.
}
cbn - [ f ].
rewrite <- rngl_mul_summation_distr_l; [ | now destruct Hif; left ].
rewrite rngl_mul_opp_l; [ | now destruct Hif ].
f_equal.
rewrite rngl_mul_1_l.
symmetry.
set (g := λ k, canon_sym_gr_list_inv n (f k)).
rewrite rngl_summation_change_var with (g0 := g) (h := g). 2: {
  intros k (_, Hk).
  assert (Hkn : k < n!). {
    specialize (fact_neq_0 n) as Hn.
    flia Hk Hn.
  }
  unfold g, f.
  unfold list_swap_elem.
  do 2 rewrite length_canon_sym_gr_list.
  erewrite map_ext_in. 2: {
    intros i Hi; apply in_seq in Hi.
    rewrite permut_in_canon_sym_gr_of_its_rank. 2: {
(* lemme à faire ? *)
      split; [ | now rewrite map_length, seq_length ].
      split. {
        intros j Hj.
        rewrite map_length, seq_length.
        apply in_map_iff in Hj.
        destruct Hj as (m & Hmj & Hm).
        apply in_seq in Hm.
        rewrite <- Hmj.
        apply canon_sym_gr_list_ub; [ easy | ].
        now apply transposition_lt.
      } {
        rewrite map_length, seq_length.
        intros u v Hu Hv.
        unfold ff_app.
        rewrite (List_map_nth' 0); [ | now rewrite seq_length ].
        rewrite (List_map_nth' 0); [ | now rewrite seq_length ].
        rewrite seq_nth; [ | easy ].
        rewrite seq_nth; [ | easy ].
        do 2 rewrite Nat.add_0_l.
        intros Huv.
        now apply nth_transposition_canon_sym_gr_list_inj in Huv.
      }
    }
    rewrite (List_map_nth' 0). 2: {
      now rewrite seq_length; apply transposition_lt.
    }
    rewrite seq_nth; [ | now apply transposition_lt ].
    rewrite Nat.add_0_l.
    rewrite transposition_involutive.
    easy.
  }
  rewrite <- List_map_nth_seq'; [ | now rewrite length_canon_sym_gr_list ].
  now apply canon_sym_gr_inv_of_canon_sym_gr.
}
rewrite Nat.sub_0_r.
rewrite <- Nat.sub_succ_l; [ | apply Nat.neq_0_lt_0, fact_neq_0 ].
rewrite Nat_sub_succ_1.
rewrite rngl_summation_list_permut with (l2 := seq 0 n!). 2: {
(* *** *)
  apply permut_list_Permutation.
(* lemma to do? *)
  unfold g, f.
  split; [ | now rewrite map_length, seq_length ].
  split. {
    intros i Hi.
    rewrite map_length, seq_length.
    apply in_map_iff in Hi.
    destruct Hi as (j & Hji & Hj).
    apply in_seq in Hj.
    rewrite <- Hji.
    apply canon_sym_gr_list_inv_ub.
    apply list_swap_elem_is_permut; [ easy | easy | ].
    now apply canon_sym_gr_list_is_permut.
  } {
    rewrite map_length, seq_length.
    intros i j Hi Hj Hij.
    unfold ff_app in Hij.
    rewrite (List_map_nth' 0) in Hij; [ | now rewrite seq_length ].
    rewrite (List_map_nth' 0) in Hij; [ | now rewrite seq_length ].
    rewrite seq_nth in Hij; [ | easy ].
    rewrite seq_nth in Hij; [ | easy ].
    do 2 rewrite Nat.add_0_l in Hij.
(* lemme à faire ? *)
    apply rank_of_permut_in_canon_gr_list_inj in Hij; cycle 1. {
      apply list_swap_elem_is_permut; [ easy | easy | ].
      now apply canon_sym_gr_list_is_permut.
    } {
      apply list_swap_elem_is_permut; [ easy | easy | ].
      now apply canon_sym_gr_list_is_permut.
    }
(* lemme à faire ? *)
    unfold list_swap_elem in Hij.
    do 2 rewrite length_canon_sym_gr_list in Hij.
    apply nth_canon_sym_gr_list_inj2 with (n := n); [ easy | easy | ].
    intros k Hkn.
    apply ext_in_map with (a := transposition p q k) in Hij. 2: {
      apply in_seq.
      split; [ flia | ].
      now apply transposition_lt.
    }
    now rewrite transposition_involutive in Hij.
  }
}
rewrite det_is_det_by_canon_permut; [ | easy | easy ].
rewrite Hr.
unfold determinant'.
rewrite rngl_summation_seq_summation; [ | apply fact_neq_0 ].
rewrite Nat.add_0_l.
apply rngl_summation_eq_compat.
intros k Hk.
assert (Hkn : k < n!). {
  specialize (fact_neq_0 n) as Hn.
  flia Hk Hn.
}
assert (Hc : canon_sym_gr_list n k = f (g k)). {
  unfold g, f.
  rewrite permut_in_canon_sym_gr_of_its_rank. 2: {
    apply list_swap_elem_is_permut; [ easy | easy | ].
    now apply canon_sym_gr_list_is_permut.
  }
  rewrite list_swap_elem_involutive; [ easy | | ]. {
    now rewrite length_canon_sym_gr_list.
  } {
    now rewrite length_canon_sym_gr_list.
  }
}
f_equal; [ now rewrite Hc | ].
rewrite rngl_product_shift; [ | flia Hp ].
apply rngl_product_eq_compat.
intros i Hi.
rewrite Nat.add_comm, Nat.add_sub.
now rewrite Hc.
Qed.

Theorem determinant_same_rows : rngl_is_field →
  ∀ (M : matrix T) p q,
  is_square_matrix M = true
  → p ≠ q
  → p < mat_nrows M
  → q < mat_nrows M
  → (∀ j, mat_el M p j = mat_el M q j)
  → determinant M = 0%F.
Proof.
intros (Hic & Hop & Hin & H10 & Hit & Hde & Hch) * Hsm Hpq Hpn Hqn Hjpq.
remember (mat_nrows M) as n eqn:Hr; symmetry in Hr.
specialize (square_matrix_ncols M Hsm) as Hc.
assert (HM : determinant M = (- determinant M)%F). {
  rewrite <- Hr in Hpn, Hqn.
  rewrite <- determinant_alternating with (p := p) (q := q); try easy.
  f_equal.
(**)
  destruct M as (ll); cbn in *.
  unfold mat_swap_rows; cbn; f_equal.
  rewrite (List_map_nth_seq ll) with (d := []) at 1.
  apply map_ext_in.
  intros i Hi; apply in_seq in Hi.
  unfold transposition.
  do 2 rewrite if_eqb_eq_dec.
  destruct (Nat.eq_dec i p) as [Hip| Hip]. {
    subst i.
    rewrite List_map_nth_seq with (d := 0%F); symmetry.
    rewrite List_map_nth_seq with (d := 0%F); symmetry.
    apply is_sm_mat_iff in Hsm.
    cbn in Hsm.
    destruct Hsm as (Hcz, Hsm).
    rewrite Hsm; [ | now apply nth_In ].
    rewrite Hsm; [ | now apply nth_In ].
    apply map_ext_in.
    intros j Hj.
    apply Hjpq.
  }
  destruct (Nat.eq_dec i q) as [Hiq| Hiq]. {
    subst i.
    rewrite List_map_nth_seq with (d := 0%F); symmetry.
    rewrite List_map_nth_seq with (d := 0%F); symmetry.
    apply is_sm_mat_iff in Hsm.
    cbn in Hsm.
    destruct Hsm as (Hcz, Hsm).
    rewrite Hsm; [ | now apply nth_In ].
    rewrite Hsm; [ | now apply nth_In ].
    apply map_ext_in.
    intros j Hj.
    symmetry; apply Hjpq.
  }
  easy.
}
apply rngl_add_move_0_r in HM; [ | easy ].
apply eq_rngl_add_same_0 in HM; try easy; [ now left | ].
apply orb_true_iff.
now left.
Qed.

(* transpositions list of permutation *)

Fixpoint first_non_fixpoint it i σ :=
  match it with
  | 0 => None
  | S it' => if i =? σ i then first_non_fixpoint it' (i + 1) σ else Some i
  end.

Fixpoint tlopf_loop it n (σ : nat → nat) :=
  match it with
  | 0 => []
  | S it' =>
      match first_non_fixpoint n 0 σ with
      | None => []
      | Some i =>
          let σ' := comp (transposition i (σ i)) σ in
          (i, σ i) :: tlopf_loop it' n σ'
      end
  end.

Definition transp_list_of_permut_fun n (σ : nat → nat) := tlopf_loop n n σ.

Definition transp_list_of_permut {n} (σ : vector nat) :=
  transp_list_of_permut_fun n (vect_el 0 σ).

Theorem first_non_fixpoint_Some_iff : ∀ σ it i j,
  first_non_fixpoint it i σ = Some j
  ↔ i ≤ j ∧ j - i < it ∧ (∀ k, i ≤ k < j → σ k = k) ∧ σ j ≠ j.
Proof.
intros.
split. {
  intros Hs.
  revert σ i j Hs.
  induction it; intros; [ easy | cbn in Hs ].
  rewrite if_eqb_eq_dec in Hs.
  destruct (Nat.eq_dec i (σ i)) as [Hii| Hii]. {
    specialize (IHit σ (i + 1) j Hs) as (H1 & H2 & H3 & H4).
    split; [ flia H1 | ].
    split; [ flia H2 | ].
    split; [ | easy ].
    intros k Hk.
    destruct (Nat.eq_dec i k) as [Hik| Hik]; [ now subst k | ].
    apply H3; flia Hk Hik.
  } {
    injection Hs; clear Hs; intros; subst j.
    split; [ flia | ].
    split; [ flia | ].
    split; [ | now apply Nat.neq_sym ].
    intros k Hk; flia Hk.
  }
} {
  intros (Hij & Hji & Hj & Hjj).
  revert i j Hij Hji Hj Hjj.
  induction it; intros; [ easy | cbn ].
  rewrite if_eqb_eq_dec.
  destruct (Nat.eq_dec i (σ i)) as [Hii| Hii]. {
    assert (Heij : i ≠ j) by now intros H; symmetry in Hii; subst i.
    apply IHit; [ flia Hij Hji Heij | flia Hij Hji Heij | | easy ].
    intros k Hk.
    apply Hj.
    flia Hk.
  }
  destruct (Nat.eq_dec i j) as [Heij| Heij]; [ congruence | exfalso ].
  assert (H : i ≤ i < j) by flia Hij Heij.
  specialize (Hj _ H) as H1.
  now symmetry in H1.
}
Qed.

Theorem first_non_fixpoint_None_if : ∀ σ it i,
  first_non_fixpoint it i σ = None
  → ∀ k, i ≤ k < i + it → k = σ k.
Proof.
intros * Hs k Hik.
revert σ i k Hik Hs.
induction it; intros; [ flia Hik | ].
cbn in Hs.
rewrite if_eqb_eq_dec in Hs.
destruct (Nat.eq_dec i (σ i)) as [H1| H1]; [ | easy ].
destruct (Nat.eq_dec i k) as [H2| H2]; [ now subst i | ].
eapply IHit; [ | apply Hs ].
flia Hik H2.
Qed.

(*
Fixpoint nb_gool_loop it i σ :=
  match it with
  | 0 => 0
  | S it' => Nat.b2n (σ i =? i) + nb_gool_loop it' (i + 1) σ
  end.

Definition nb_good n σ := nb_good_loop n 0 σ.

Print count_occ.
*)

(*
Theorem nb_good_loop_comp_transp : ∀ n it σ i k,
  is_permut n σ
  → k < i ≤ n
  → ff_app σ k < i
  → n = i + it
  → nb_good_loop it i (comp (transposition k (ff_app σ k)) (ff_app σ)) =
    nb_good_loop it i (ff_app σ).
Proof.
intros * Hp Hkin Hski Hnit.
...
revert i k Hkin Hski Hnit.
induction it; intros; [ easy | cbn ].
replace (i + S it) with (i + 1 + it) in Hnit by flia.
unfold comp at 1, transposition at 1, Nat.b2n.
do 4 rewrite if_eqb_eq_dec.
destruct (Nat.eq_dec (σ i) k) as [Hsik| Hsik]. {
  rewrite Hsik.
  destruct (Nat.eq_dec k i) as [H| H]; [ flia Hkin H | clear H ].
  rewrite Nat.add_0_l.
  destruct (Nat.eq_dec (σ k) i) as [H| H]; [ flia Hski H | clear H ].
  rewrite Nat.add_0_l.
  apply IHit; try easy; [ | flia Hski ].
  split; [ flia Hkin | ].
  flia Hnit.
}
destruct (Nat.eq_dec (σ i) (σ k)) as [Hsisk| Hsisk]. {
  apply Hp in Hsisk; [ flia Hkin Hsisk | | flia Hkin ].
  flia Hnit.
}
f_equal.
apply IHit; [ | flia Hski | easy ].
split; [ flia Hkin | flia Hnit ].
Qed.
*)

Theorem comp_transp_permut_id : ∀ n σ i j k,
  is_permut n σ
  → i < k
  → k < j < n
  → ff_app σ k = i
  → comp (transposition i (ff_app σ i)) (ff_app σ) j = ff_app σ j.
Proof.
intros * Hp Hikn Hkp Hski.
unfold comp, transposition.
do 2 rewrite if_eqb_eq_dec.
destruct (Nat.eq_dec (ff_app σ j) i) as [Hsji| Hsji]. {
  exfalso.
  rewrite <- Hski in Hsji.
  destruct Hp as (Hp1, Hp2).
  rewrite <- Hp2 in Hkp.
  apply Hp1 in Hsji; [ flia Hkp Hsji | easy | flia Hkp ].
}
destruct (Nat.eq_dec (ff_app σ j) (ff_app σ i)) as [Hspi| Hspi]; [ | easy ].
destruct Hp as (Hp1, Hp2).
rewrite <- Hp2 in Hkp.
apply Hp1 in Hspi; [ | easy | flia Hikn Hkp ].
flia Hikn Hkp Hspi.
Qed.

(*
Theorem nb_good_loop_comp_transp_permit_id : ∀ n it σ i k,
  is_permut_fun σ n
  → i < n
  → k < n
  → n = k + it
  → (∀ j, k ≤ j → comp (transposition i (σ i)) σ j = σ j)
  → nb_good_loop it k (comp (transposition i (σ i)) σ) =
    nb_good_loop it k σ.
Proof.
intros * Hp Hin Hkn Hnit Hj.
revert i k Hin Hkn Hj Hnit.
induction it; intros; [ easy | cbn ].
unfold comp at 1, transposition at 1, Nat.b2n.
do 4 rewrite if_eqb_eq_dec.
destruct (Nat.eq_dec (σ k) i) as [Hski| Hski]. {
  rewrite Hski.
  destruct (Nat.eq_dec i k) as [Hik| Hik]. {
    move Hik at top; subst k.
    rewrite Hski.
    rewrite <- if_eqb_eq_dec, Nat.eqb_refl.
    f_equal.
    clear.
    remember (i + 1) as k eqn:Hk; clear Hk.
    revert i k.
    induction it; intros; [ easy | cbn ].
    unfold comp at 1, transposition at 1, Nat.b2n.
    do 4 rewrite if_eqb_eq_dec.
    destruct (Nat.eq_dec (σ k) i) as [Hki| Hki]. {
      rewrite Hki.
      now rewrite IHit.
    }
    now rewrite IHit.
  }
  destruct (Nat.eq_dec (σ i) k) as [Hsik| Hsik]. {
    exfalso.
    specialize (Hj k (le_refl _)).
    unfold comp, transposition in Hj.
    rewrite Hski, Nat.eqb_refl in Hj.
    apply Hik, Hp; [ easy | easy | congruence ].
  }
  f_equal.
  specialize (Hj k (le_refl _)).
  unfold comp, transposition in Hj.
  rewrite Hski, Nat.eqb_refl in Hj.
  rewrite <- Hj in Hski.
  apply Hp in Hski; [ congruence | easy | easy ].
}
destruct (Nat.eq_dec (σ k) (σ i)) as [Hsksi| Hsksi]. {
  apply Hp in Hsksi; [ | easy | easy ].
  subst k.
  rewrite <- if_eqb_eq_dec, Nat.eqb_refl.
  destruct (Nat.eq_dec (σ i) i) as [H| H]; [ easy | clear H ].
  specialize (Hj i (le_refl _)).
  unfold comp, transposition in Hj.
  rewrite if_eqb_eq_dec in Hj.
  destruct (Nat.eq_dec (σ i) i) as [H| H]; [ easy | clear H ].
  rewrite Nat.eqb_refl in Hj.
  congruence.
}
f_equal.
destruct (Nat.eq_dec (k + 1) n) as [Hk1n| Hk1n]. {
  destruct it; [ easy | ].
  flia Hnit Hk1n.
}
rewrite IHit; [ easy | easy | flia Hkn Hk1n | | flia Hnit ].
intros j Hkj.
apply Hj; flia Hkj.
Qed.

Theorem nb_good_loop_comp_transp2 : ∀ n it σ i,
  is_permut_fun σ n
  → (∀ k, k < i → σ k = k)
  → σ i ≠ i
  → σ (σ i) ≠ i
  → σ (σ i) ≠ σ i
  → n = i + 1 + it
  → nb_good_loop it (i + 1) (comp (transposition i (σ i)) σ) =
    nb_good_loop it (i + 1) σ.
Proof.
intros * Hp Hi Hsii Hssii Hssisi Hnit.
remember (σ i) as j eqn:Hj; symmetry in Hj.
remember (permut_fun_inv_loop σ n i) as k eqn:Hk.
assert (Hkd : σ k = i). {
  subst k.
  apply fun_permut_fun_inv_loop; [ easy | flia Hnit ].
}
assert (Hik : i < k). {
  assert (H1 : i ≤ k). {
    apply Nat.nlt_ge; intros H.
    apply Hi in H.
    rewrite Hkd in H; move H at top; subst k.
    congruence.
  }
  destruct (Nat.eq_dec i k) as [Hik| Hik]; [ | flia Hik H1 ].
  move Hik at top; subst k.
  congruence.
}
assert (Hjk : j ≠ k). {
  now intros H; move H at top; subst k.
}
assert (Hij : i < j). {
  apply Nat.nle_gt; intros H.
  assert (H' : j < i) by flia Hsii H.
  now apply Hi in H'.
}
assert (Hkn : k < n). {
  rewrite Hk.
  apply permut_ub; [ | flia Hnit ].
  now apply permut_fun_inv_loop_is_permut.
}
clear Hk.
clear Hi.
clear Hj.
clear Hsii.
clear Hssii.
remember (i + 1) as p eqn:Hp'.
assert (Hip : i < p) by flia Hp'.
clear Hp'.
revert i j k p Hssisi Hnit Hkd Hik Hjk Hij Hip Hkn.
induction it; intros; [ easy | cbn ].
replace (p + S it) with (p + 1 + it) in Hnit by flia.
unfold comp at 1, transposition at 1, Nat.b2n.
do 4 rewrite if_eqb_eq_dec.
destruct (Nat.eq_dec (σ p) i) as [Hspi| Hspi]. {
  rewrite Hspi.
  rewrite <- Hkd in Hspi.
  apply Hp in Hspi; [ | flia Hnit | easy ].
  move Hspi at top; subst p.
  destruct (Nat.eq_dec j k) as [H| H]; [ easy | clear H ].
  destruct (Nat.eq_dec i k) as [H| H]; [ flia Hip H | clear H ].
  cbn.
  apply IHit with (k := k); try easy; flia Hip.
}
destruct (Nat.eq_dec (σ p) j) as [Hspj| Hspj]. {
  rewrite Hspj.
  destruct (Nat.eq_dec i p) as [H| H]; [ flia Hip H | clear H ].
  destruct (Nat.eq_dec j p) as [Hjp| Hjp]. {
    now move Hjp at top; subst p.
  }
  cbn.
  apply IHit with (k := k); try easy; flia Hip.
}
f_equal.
apply IHit with (k := k); try easy; flia Hip.
Qed.

Theorem nb_good_loop_comp_transp' : ∀ n it σ i d,
  is_permut_fun σ n
  → i < n
  → d ≠ 0
  → (∀ k, k < i → σ k = k)
  → (∀ k, k < d → σ (i + k) ≠ i)
  → σ (σ i) = i
  → n = i + d + it
  → nb_good_loop it (i + d) (comp (transposition i (σ i)) σ) =
     nb_good_loop it (i + d) σ + 1.
Proof.
intros * Hp Hin Hdz Hskk Hsii Hssi Hnit.
revert i d Hin Hdz Hskk Hsii Hssi Hnit.
induction it; intros; cbn. {
  exfalso.
  destruct Hp as (Hp1, Hp2).
  rewrite Nat.add_0_r in Hnit.
  specialize (Hp1 i Hin) as H1.
  clear - d Hin Hnit Hsii Hskk Hssi H1.
  assert (Hisi : i ≤ σ i). {
    apply Nat.nlt_ge; intros H2.
    specialize (Hskk (σ i) H2) as H3.
    flia Hssi H2 H3.
  }
  specialize (Hsii (σ i - i)) as H2.
  assert (H : σ i - i < d). {
    apply Nat.add_lt_mono_r with (p := i).
    rewrite (Nat.add_comm d), <- Hnit.
    now rewrite Nat.sub_add.
  }
  specialize (H2 H); clear H.
  rewrite Nat.add_sub_assoc in H2; [ | easy ].
  now rewrite Nat.add_comm, Nat.add_sub in H2.
}
replace (i + d + S it) with (i + d + 1 + it) in Hnit by flia.
unfold comp at 1, transposition at 1, Nat.b2n.
do 4 rewrite if_eqb_eq_dec.
destruct (Nat.eq_dec (σ (i + d)) i) as [Hsi2i| Hsi2i]. {
  rewrite Hsi2i.
  destruct (Nat.eq_dec (σ i) (i + d)) as [Hsiid| Hsiid]. {
    destruct (Nat.eq_dec i (i + d)) as [H| H]; [ flia Hdz H | clear H ].
    rewrite Nat.add_0_l, Nat.add_comm; f_equal.
    apply nb_good_loop_comp_transp with (n := n); [ easy | | | easy ]. {
      flia Hnit.
    }
    flia Hsiid.
  }
  destruct (Nat.eq_dec i (i + d)) as [H| H]; [ flia Hdz H | clear H ].
  rewrite <- Nat.add_assoc; cbn.
  replace (i + d + 1 + it) with (i + (d + 1) + it) in Hnit by flia.
  rewrite <- Hssi in Hsi2i at 2.
  apply Nat.neq_sym in Hsiid.
  apply Hp in Hsi2i; [ easy | flia Hnit | ].
  now apply Hp.
}
destruct (Nat.eq_dec (σ (i + d)) (σ i)) as [Hsidsi| Hsidsi]. {
  apply Hp in Hsidsi; [ | flia Hnit | easy ].
  flia Hdz Hsidsi.
}
rewrite <- (Nat.add_assoc (if Nat.eq_dec _ _ then _ else _)).
f_equal.
rewrite <- Nat.add_assoc.
replace (i + d + 1 + it) with (i + (d + 1) + it) in Hnit by flia.
apply IHit; try easy; [ flia | ].
intros k Hk.
destruct (Nat.eq_dec k d) as [Hkd| Hkd]; [ now subst k | ].
apply Hsii.
flia Hk Hkd.
Qed.

Theorem nb_good_loop_comp_transp_eq : ∀ it n σ i k,
  is_permut_fun σ n
  → first_non_fixpoint n 0 σ = Some i
  → k ≤ i
  → n = k + it
  → nb_good_loop it k (comp (transposition i (σ i)) σ) =
    nb_good_loop it k σ + 1 + Nat.b2n (σ (σ i) =? i).
Proof.
intros * Hp Hi Hki Hnit.
apply first_non_fixpoint_Some_iff in Hi.
rewrite Nat.sub_0_r in Hi.
destruct Hi as (_ & Hin & Hi & Hsii).
revert i k Hin Hi Hsii Hki Hnit.
induction it; intros; cbn. {
  flia Hin Hki Hnit.
}
replace (k + S it) with (k + 1 + it) in Hnit by flia.
unfold comp at 1, transposition at 1, Nat.b2n.
do 5 rewrite if_eqb_eq_dec.
destruct (Nat.eq_dec (σ k) i) as [Hski| Hski]. {
  destruct (Nat.eq_dec k i) as [Heki| Heki]; [ congruence | ].
  assert (H : 0 ≤ k < i) by flia Hki Heki.
  specialize (Hi _ H); clear H.
  congruence.
}
destruct (Nat.eq_dec (σ k) (σ i)) as [Hsksi| Hsksi]. {
  apply Hp in Hsksi; [ | flia Hnit | easy ].
  move Hsksi at top; subst k.
  rewrite <- if_eqb_eq_dec, Nat.eqb_refl.
  clear Hski Hki.
  destruct (Nat.eq_dec (σ i) i) as [H| H]; [ easy | clear H ].
  rewrite Nat.add_0_l.
  destruct (Nat.eq_dec (σ (σ i)) i) as [Hssii| Hssii]. {
    rewrite Nat.add_comm; f_equal.
    apply nb_good_loop_comp_transp' with (n := n); try easy. {
      intros k Hk.
      apply Hi.
      split; [ flia | easy ].
    }
    intros k Hk.
    destruct k; [ | flia Hk ].
    now rewrite Nat.add_0_r.
  }
  rewrite Nat.add_comm, Nat.add_0_r; f_equal.
  destruct (Nat.eq_dec (σ (σ i)) (σ i)) as [Hssisi| Hssisi]. {
    apply Hp in Hssisi; [ easy | | easy ].
    now apply Hp.
  }
  apply nb_good_loop_comp_transp2 with (n := n); try easy.
  intros k Hk.
  apply Hi; flia Hk.
}
do 2 rewrite <- Nat.add_assoc.
f_equal.
destruct (Nat.eq_dec k i) as [Hk1i| Hk1i]. {
  now move Hk1i at top; subst k.
}
rewrite IHit; try easy; [ | flia Hki Hk1i ].
unfold Nat.b2n.
rewrite if_eqb_eq_dec.
symmetry.
apply Nat.add_assoc.
Qed.
*)

Theorem first_non_fixpoint_enough_iter : ∀ n m σ i j,
  n ≤ m
  → first_non_fixpoint n i σ = Some j
  → first_non_fixpoint m i σ = Some j.
Proof.
intros * Hnm Hij.
revert i j n σ Hnm Hij.
induction m; intros; cbn. {
  now apply Nat.le_0_r in Hnm; subst n.
}
rewrite if_eqb_eq_dec.
destruct (Nat.eq_dec i (σ i)) as [Hii| Hii]. {
  destruct n; [ easy | ].
  cbn in Hij.
  rewrite <- Hii, Nat.eqb_refl in Hij.
  apply Nat.succ_le_mono in Hnm.
  now apply IHm with (n := n).
}
apply first_non_fixpoint_Some_iff in Hij.
destruct Hij as (Hij & Hjin & Hikj & Hjj).
destruct (Nat.eq_dec i j) as [H1| H1]; [ now subst i | ].
exfalso; apply Hii; symmetry.
apply Hikj.
split; [ flia | flia Hij H1 ].
Qed.

(* If we add a row (column) of A multiplied by a scalar k to another
   row (column) of A, then the determinant will not change. *)
(* https://math.vanderbilt.edu/sapirmv/msapir/proofdet1.html *)
(* doing it only when the first row is 0; can be generalized later *)

Definition mat_add_row_mul_scal_row n (M : matrix T) i1 v i2 :=
  mk_mat
    (map
      (λ i,
       map
         (λ j,
          if Nat.eq_dec i i1 then (mat_el M i1 j + v * mat_el M i2 j)%F
          else mat_el M i j)
         (seq 0 n))
     (seq 0 n)).

(* *)

Definition mat_mul_row_by_scal n k (M : matrix T) s :=
  mk_mat
    (map
       (λ i,
        map
          (λ j, if Nat.eq_dec i k then (s * mat_el M i j)%F else mat_el M i j)
          (seq 0 n))
       (seq 0 n)).

Theorem subm_mat_mul_row_by_scal : ∀ (A : matrix T) i v,
  is_square_matrix A = true
  → subm (mat_mul_row_by_scal (mat_nrows A) 0 A v) 0 i = subm A 0 i.
Proof.
intros * Hsm.
remember (mat_nrows A) as n eqn:Hr; symmetry in Hr.
unfold subm.
f_equal.
f_equal.
unfold butn.
do 2 rewrite firstn_O.
f_equal.
do 2 rewrite List_skipn_1.
destruct A as (ll).
destruct ll as [| la ll]; [ now subst n; cbn | ].
apply is_sm_mat_iff in Hsm.
cbn in Hsm.
destruct Hsm as (Hcr & Hc).
destruct n; [ easy | ].
cbn in Hr.
apply Nat.succ_inj in Hr.
cbn - [ mat_mul_row_by_scal ].
rewrite List_map_nth_seq with (d := []).
rewrite Hr.
cbn - [ seq mat_el ].
rewrite List_map_tl.
remember (tl (seq 0 (S n))) as x eqn:Hx.
cbn in Hx; subst x.
rewrite <- seq_shift.
rewrite map_map.
apply map_ext_in.
intros j Hj.
apply in_seq in Hj.
destruct Hj as (_, Hj).
rewrite List_map_nth_seq with (d := 0%F).
rewrite Hc. 2: {
  right.
  apply nth_In.
  now rewrite Hr.
}
rewrite Hr.
apply map_ext_in.
intros k Hk.
now destruct (Nat.eq_dec (S j) 0).
Qed.

(* If we multiply a row (column) of A by a number, the determinant of
   A will be multiplied by the same number. *)
(* https://math.vanderbilt.edu/sapirmv/msapir/proofdet1.html
   point 1 *)

(* Well, since my definition of the determinant only covers the
   row 0, we can prove that only when i=0; this will able us to
   prove next theorems, swapping rows by going via row 0 *)

Theorem det_mul_row_0_by_scal :
  rngl_has_opp = true ∨ rngl_has_sous = true →
  rngl_is_comm = true →
  ∀ (A : matrix T) v,
  mat_nrows A ≠ 0
  → is_square_matrix A = true
  → determinant (mat_mul_row_by_scal (mat_nrows A) 0 A v) =
    (v * determinant A)%F.
Proof.
intros Hom Hic * Hnz Hsm.
remember (mat_nrows A) as n eqn:Hr; symmetry in Hr.
destruct n; [ easy | clear Hnz ].
unfold determinant; rewrite Hr.
cbn - [ mat_mul_row_by_scal ].
rewrite rngl_mul_summation_distr_l; [ | easy ].
cbn - [ seq ].
rewrite List_map_seq_length.
rewrite determinant_succ.
apply rngl_summation_eq_compat.
intros i (_, Hi).
symmetry.
rewrite (rngl_mul_comm Hic).
symmetry.
do 3 rewrite <- rngl_mul_assoc.
f_equal.
rewrite rngl_mul_assoc, (rngl_mul_mul_swap Hic).
rewrite (rngl_mul_comm Hic _ v).
f_equal. {
  destruct i; [ easy | cbn ].
  rewrite (List_map_nth' 0); [ | now rewrite seq_length ].
  now rewrite seq_nth.
}
f_equal.
rewrite <- Hr.
now apply subm_mat_mul_row_by_scal.
Qed.

(* If the i-th row (column) in A is a sum of the i-th row (column) of
   a matrix B and the i-th row (column) of a matrix C and all other
   rows in B and C are equal to the corresponding rows in A (that is B
   and C differ from A by one row only), then det(A)=det(B)+det(C). *)
(* https://math.vanderbilt.edu/sapirmv/msapir/proofdet1.html
   point 2 *)

(* Well, since my definition of the discriminant only covers the
   row 0, we can prove that only when i=0; this will able us to
   prove the next theorem, swapping rows by going via row 0 *)

Theorem det_sum_row_row : ∀ n (A B C : matrix T),
  n ≠ 0
  → mat_nrows A = n
  → mat_nrows B = n
  → mat_nrows C = n
  → is_square_matrix A = true
  → is_square_matrix B = true
  → is_square_matrix C = true
  → (∀ j, mat_el A 0 j = (mat_el B 0 j + mat_el C 0 j)%F)
  → (∀ i j, i ≠ 0 → mat_el B i j = mat_el A i j)
  → (∀ i j, i ≠ 0 → mat_el C i j = mat_el A i j)
  → determinant A = (determinant B + determinant C)%F.
Proof.
intros * Hnz Hra Hrb Hrc Hsma Hsmb Hsmc Hbc Hb Hc.
specialize (square_matrix_ncols _ Hsma) as Hca.
specialize (square_matrix_ncols _ Hsmb) as Hcb.
rewrite Hra in Hca.
rewrite Hrb in Hcb.
destruct n; [ easy | clear Hnz; cbn ].
assert (Hab : ∀ j, subm A 0 j = subm B 0 j). {
  intros.
  destruct A as (lla).
  destruct B as (llb).
  cbn in *.
  unfold subm; f_equal.
  cbn - [ butn ].
  rewrite (List_map_nth_seq lla []).
  rewrite (List_map_nth_seq llb []).
  rewrite Hra, Hrb.
  do 2 rewrite <- map_butn.
  do 2 rewrite map_map.
  apply map_ext_in.
  intros u Hu.
  destruct (Nat.eq_dec u 0) as [Huz| Huz]. {
    subst u; cbn in Hu.
    now apply in_seq in Hu.
  }
  rewrite (List_map_nth_seq (nth u lla []) 0%F).
  rewrite (List_map_nth_seq (nth u llb []) 0%F).
  apply is_sm_mat_iff in Hsma.
  destruct Hsma as (_ & Hca').
  apply in_butn, in_seq in Hu.
  rewrite Hca'. 2: {
    cbn; apply nth_In.
    now rewrite Hra.
  }
  apply is_sm_mat_iff in Hsmb.
  destruct Hsmb as (_ & Hcb').
  rewrite Hcb'. 2: {
    cbn; apply nth_In.
    now rewrite Hrb.
  }
  f_equal; cbn; rewrite Hra, Hrb.
  apply map_ext_in.
  intros v Hv.
  apply in_seq in Hv.
  now symmetry; apply Hb.
}
assert (Hac : ∀ j, subm A 0 j = subm C 0 j). {
  intros.
  intros.
  destruct A as (lla).
  destruct C as (llc).
  cbn in *.
  unfold subm; f_equal.
  cbn - [ butn ].
  rewrite (List_map_nth_seq lla []).
  rewrite (List_map_nth_seq llc []).
  rewrite Hra, Hrc.
  do 2 rewrite <- map_butn.
  do 2 rewrite map_map.
  apply map_ext_in.
  intros u Hu.
  destruct (Nat.eq_dec u 0) as [Huz| Huz]. {
    subst u; cbn in Hu.
    now apply in_seq in Hu.
  }
  rewrite (List_map_nth_seq (nth u lla []) 0%F).
  rewrite (List_map_nth_seq (nth u llc []) 0%F).
  apply is_sm_mat_iff in Hsma.
  destruct Hsma as (_ & Hca').
  apply in_butn, in_seq in Hu.
  rewrite Hca'. 2: {
    cbn; apply nth_In.
    now rewrite Hra.
  }
  apply is_sm_mat_iff in Hsmc.
  destruct Hsmc as (_ & Hcc').
  rewrite Hcc'. 2: {
    cbn; apply nth_In.
    now rewrite Hrc.
  }
  f_equal; cbn; rewrite Hra, Hrc.
  apply map_ext_in.
  intros v Hv.
  apply in_seq in Hv.
  now symmetry; apply Hc.
}
unfold determinant; rewrite Hra, Hrb, Hrc.
cbn.
erewrite rngl_summation_eq_compat. 2: {
  intros j Hj.
  rewrite Hbc.
  rewrite rngl_mul_add_distr_l.
  rewrite rngl_mul_add_distr_r.
  rewrite Hab at 1.
  rewrite Hac at 1.
  easy.
}
cbn.
now apply rngl_summation_add_distr.
Qed.

(* If two rows (columns) in A are equal then det(A)=0. *)
(* https://math.vanderbilt.edu/sapirmv/msapir/proofdet1.html
   point 3 *)
(* doing it only when the first row is 0; can be generalized later *)

Definition δ_lt i k := Nat.b2n (i <? k).

Theorem subm_subm_swap : ∀ (A : matrix T) i j k l,
  subm (subm A i j) k l =
  subm (subm A (k + δ_lt i k) (l + δ_lt j l)) (i - δ_lt k i) (j - δ_lt l j).
Proof.
intros.
rewrite mat_eq_map_seq; symmetry.
rewrite mat_eq_map_seq; symmetry.
f_equal.
unfold δ_lt.
do 4 rewrite mat_nrows_subm.
unfold Nat.b2n; do 8 rewrite if_ltb_lt_dec.
destruct (lt_dec i (mat_nrows A)) as [Hir| Hir]. 2: {
  apply Nat.nlt_ge in Hir.
  rewrite Nat.sub_0_r.
  destruct (lt_dec i k) as [Hik| Hik]. {
    destruct (lt_dec k i) as [H| H]; [ flia Hik H | clear H ].
    rewrite Nat.sub_0_r.
    destruct (lt_dec k (mat_nrows A)) as [H| H]; [ flia Hir Hik H | clear H ].
    rewrite Nat.sub_0_r.
    destruct (lt_dec (k + 1) (mat_nrows A)) as [H| H]; [ flia Hir Hik H | ].
    clear H; rewrite Nat.sub_0_r.
    destruct (lt_dec i (mat_nrows A)) as [H| H]; [ flia Hir H | clear H ].
    rewrite Nat.sub_0_r.
    apply map_ext_in.
    intros u Hu; apply in_seq in Hu.
    destruct (lt_dec j l) as [Hjl| Hjl]. {
      destruct (lt_dec l j) as [H| H]; [ flia Hjl H | clear H ].
      rewrite Nat.sub_0_r.
      unfold subm; cbn.
      do 6 rewrite map_butn.
      rewrite nth_butn_after; [ | flia Hik Hir Hu ].
      rewrite nth_butn_after; [ | flia Hir Hu ].
      rewrite nth_butn_after; [ | flia Hir Hu ].
      rewrite nth_butn_after; [ | flia Hik Hir Hu ].
      do 2 rewrite map_map.
      f_equal.
      apply map_ext_in.
      intros la Hla.
      apply butn_butn; flia Hjl.
    } {
      apply Nat.nlt_ge in Hjl.
      rewrite Nat.add_0_r.
      destruct (lt_dec l j) as [Hlj| Hlj]. 2: {
        apply Nat.nlt_ge in Hlj.
        replace l with j by flia Hjl Hlj.
        clear l Hjl Hlj.
        rewrite Nat.sub_0_r.
        rewrite subm_subm_r_r; [ easy | flia Hik ].
      }
      rewrite (@subm_out_l _ (k + 1) i A); [ | flia Hir Hik | easy ].
      rewrite (@subm_out_l _ k i); cycle 1. {
        rewrite mat_nrows_subm; flia Hir Hik.
      } {
        rewrite mat_nrows_subm; flia Hir.
      }
      symmetry.
      destruct (lt_dec l (j - 1)) as [Hlj1| Hlj1]. 2: {
        apply Nat.nlt_ge in Hlj1.
        replace j with (l + 1) by flia Hlj Hlj1.
        rewrite Nat.add_sub.
        f_equal; f_equal.
        now apply subm_subm_l_l.
      }
      f_equal; f_equal.
      rewrite subm_subm_l_l; [ | flia Hlj1 ].
      rewrite Nat.sub_add; [ easy | flia Hlj ].
    }
  } {
    apply Nat.nlt_ge in Hik.
    rewrite Nat.add_0_r.
    destruct (lt_dec k i) as [Hki| Hki]. 2: {
      replace k with i by flia Hik Hki.
      clear k Hik Hki.
      destruct (lt_dec i (mat_nrows A)) as [H| H]; [ flia Hir H | clear H ].
      do 2 rewrite Nat.sub_0_r.
      destruct (lt_dec i (mat_nrows A)) as [H| H]; [ flia Hir H | clear H ].
      rewrite Nat.sub_0_r.
      destruct (lt_dec j l) as [Hjl| Hjl]. {
        rewrite subm_subm_l_l; [ | flia Hjl ].
        destruct (lt_dec l j) as [H| H]; [ flia Hjl H | clear H ].
        now rewrite Nat.sub_0_r.
      } {
        destruct (lt_dec l j) as [Hlj| Hlj]. 2: {
          replace l with j by flia Hjl Hlj.
          now rewrite Nat.add_0_r, Nat.sub_0_r.
        }
        rewrite Nat.add_0_r.
        symmetry.
        destruct (lt_dec l (j - 1)) as [Hlj1| Hlj1]. 2: {
          replace j with (l + 1) by flia Hlj Hlj1.
          rewrite Nat.add_sub.
          clear j Hjl Hlj Hlj1.
          rename l into j.
          now rewrite subm_subm_l_l.
        }
        clear Hjl Hlj.
        rewrite subm_subm_l_l; [ | flia Hlj1 ].
        rewrite Nat.sub_add; [ easy | flia Hlj1 ].
      }
    } {
      destruct (lt_dec k (mat_nrows A)) as [Hkr| Hkr]. {
        destruct (lt_dec (i - 1) (mat_nrows A - 1)) as [H| H];
          [ flia Hir H | clear H ].
        rewrite Nat.sub_0_r.
        destruct (lt_dec j l) as [Hjl| Hjl]. {
          destruct (lt_dec l j) as [H| H]; [ flia Hjl H | clear H ].
          rewrite Nat.sub_0_r.
          apply map_ext_in.
          intros m Hm.
          f_equal; f_equal; clear m Hm.
          rewrite subm_subm_exch; [ easy | easy | flia Hjl ].
        }
        destruct (lt_dec l j) as [Hlj| Hlj]. {
          rewrite Nat.add_0_r.
          apply map_ext_in.
          intros m Hm.
          f_equal; f_equal; clear m Hm.
          now apply subm_subm_exch'.
        }
        rewrite Nat.add_0_r, Nat.sub_0_r.
        replace l with j by flia Hjl Hlj.
        clear l Hjl Hlj.
        apply map_ext_in.
        intros l Hl.
        apply in_seq in Hl.
        destruct (lt_dec k (i - 1)) as [Hki1| Hki1]. {
          symmetry.
          rewrite subm_subm_r_r; [ | flia Hki1 ].
          rewrite Nat.sub_add; [ easy | flia Hki ].
        }
        assert (Hk : k = mat_nrows A - 1) by flia Hir Hki Hkr Hki1.
        assert (Hi : i = mat_nrows A) by flia Hir Hki Hkr Hki1.
        assert (Hr : mat_nrows A ≠ 0) by flia Hkr.
        clear Hir Hik Hki Hkr Hki1.
        rewrite <- Hi in Hl, Hk, Hr.
        replace i with (k + 1) by flia Hk Hi Hr.
        rewrite Nat.add_sub.
        rewrite subm_subm_l_l; [ | easy ].
        unfold subm; cbn.
        rewrite (List_map_nth' []). 2: {
          rewrite butn_length, map_length.
          rewrite butn_length, fold_mat_nrows.
          unfold Nat.b2n.
          do 2 rewrite if_ltb_lt_dec.
          rewrite <- Hi.
          destruct (lt_dec (k + 1) i) as [H| H]; [ flia Hk H | clear H ].
          rewrite Nat.sub_0_r.
          destruct (lt_dec k i) as [H| H]; [ flia Hl H | clear H ].
          rewrite Nat.sub_0_r; flia Hl Hi.
        }
        rewrite nth_butn_after; [ | flia Hl Hk ].
        rewrite (List_map_nth' []). 2: {
          rewrite butn_length, fold_mat_nrows, <- Hi.
          unfold Nat.b2n; rewrite if_ltb_lt_dec.
          destruct (lt_dec (k + 1) i); flia Hl Hi.
        }
        rewrite nth_butn_after; [ | flia Hl Hk ].
        do 3 rewrite map_butn.
        rewrite nth_butn_after; [ | flia Hl Hk ].
        rewrite nth_butn_after; [ | flia Hl Hk ].
        rewrite (List_map_nth' []). 2: {
          rewrite map_length, fold_mat_nrows, <- Hi; flia Hl.
        }
        rewrite (List_map_nth' []). 2: {
          rewrite fold_mat_nrows, <- Hi; flia Hl.
        }
        now rewrite butn_butn.
      }
      apply Nat.nlt_ge in Hkr.
      rewrite Nat.sub_0_r.
      destruct (lt_dec (i - 1) (mat_nrows A)) as [Hi1r| Hi1r]. 2: {
        apply Nat.nlt_ge in Hi1r.
        rewrite Nat.sub_0_r.
        apply map_ext_in.
        intros m Hm; apply in_seq in Hm.
        destruct (lt_dec j l) as [Hjl| Hjl]. {
          destruct (lt_dec l j) as [H| H]; [ flia Hjl H | clear H ].
          rewrite Nat.sub_0_r.
          rewrite subm_subm_exch; [ easy | easy | flia Hjl ].
        } {
          apply Nat.nlt_ge in Hjl.
          rewrite Nat.add_0_r.
          f_equal; f_equal.
          destruct (lt_dec l j) as [Hlj| Hlj]. 2: {
            replace l with j by flia Hjl Hlj.
            rewrite Nat.sub_0_r.
            destruct (lt_dec k (i - 1)) as [Hki1| Hki1]. {
              symmetry; rewrite subm_subm_r_r; [ | flia Hki1 ].
              rewrite Nat.sub_add; [ easy | flia Hki1 ].
            } {
              replace i with (k + 1) by flia Hki Hki1.
              rewrite Nat.add_sub.
              rewrite subm_subm_l_l; [ | easy ].
              rewrite (@subm_out_l _ (k + 1) k); [ | flia Hkr | easy ].
              now apply subm_subm_l_l.
            }
          } {
            now rewrite subm_subm_exch'.
          }
        }
      }
      flia Hki Hkr Hi1r.
    }
  }
}
destruct (lt_dec k (mat_nrows A - 1)) as [Hkr1| Hkr1]. 2: {
  apply Nat.nlt_ge in Hkr1.
  rewrite Nat.sub_0_r.
  destruct (lt_dec i k) as [Hik| Hik]. {
    destruct (lt_dec k i) as [H| H]; [ flia Hik H | clear H ].
    rewrite Nat.sub_0_r.
    destruct (lt_dec (k + 1) (mat_nrows A)) as [H| H]; [ flia Hkr1 H | ].
    clear H; rewrite Nat.sub_0_r.
    destruct (lt_dec i (mat_nrows A)) as [H| H]; [ clear H | flia Hir H ].
    apply map_ext_in.
    intros m Hm; apply in_seq in Hm.
    f_equal; f_equal.
    destruct (lt_dec j l) as [Hjl| Hjl]. {
      destruct (lt_dec l j) as [H| H]; [ flia Hjl H | clear H ].
      rewrite Nat.sub_0_r.
      symmetry.
      rewrite subm_subm_exch'; [ | flia Hik | flia Hjl ].
      now do 2 rewrite Nat.add_sub.
    } {
      apply Nat.nlt_ge in Hjl.
      rewrite Nat.add_0_r.
      destruct (lt_dec l j) as [Hlj| Hlj]. 2: {
        replace l with j by flia Hjl Hlj.
        rewrite Nat.sub_0_r.
        apply subm_subm_r_r; flia Hik.
      } {
        symmetry.
        destruct (lt_dec l (j - 1)) as [Hlj1| Hlj1]. {
          rewrite subm_subm_exch; [ | flia Hik | flia Hlj1 ].
          rewrite Nat.add_sub.
          rewrite Nat.sub_add; [ easy | flia Hlj ].
        }
        replace l with (j - 1) by flia Hlj Hlj1.
        rewrite <- subm_subm_exch''; [ | flia Hik ].
        rewrite Nat.sub_add; [ easy | flia Hlj ].
      }
    }
  } {
    apply Nat.nlt_ge in Hik.
    replace k with i by flia Hir Hkr1 Hik.
    assert (Hir1 : i = mat_nrows A - 1) by flia Hir Hkr1 Hik.
    assert (Hrz : mat_nrows A ≠ 0) by flia Hir.
    clear k Hir Hkr1 Hik.
    rewrite Nat.add_0_r.
    destruct (lt_dec i i) as [H| H]; [ flia H | clear H ].
    destruct (lt_dec i (mat_nrows A)) as [H| H]; [ | flia Hrz Hir1 H ].
    clear H; rewrite Nat.sub_0_r.
    destruct (lt_dec i (mat_nrows A - 1)) as [H| H]; [ flia Hir1 H | ].
    clear H; rewrite Nat.sub_0_r.
    apply map_ext_in.
    intros k Hk; apply in_seq in Hk.
    destruct (lt_dec j l) as [Hjl| Hjl]. {
      destruct (lt_dec l j) as [H| H]; [ flia Hjl H | clear H ].
      rewrite Nat.sub_0_r.
      rewrite subm_subm_l_l; [ easy | flia Hjl ].
    } {
      destruct (lt_dec l j) as [Hlj| Hlj]. 2: {
        replace l with j by flia Hjl Hlj.
        now rewrite Nat.add_0_r, Nat.sub_0_r.
      }
      clear Hjl; rewrite Nat.add_0_r.
      destruct (lt_dec l (j - 1)) as [Hlj1| Hlj1]. {
        symmetry.
        rewrite subm_subm_l_l; [ | flia Hlj ].
        rewrite Nat.sub_add; [ easy | flia Hlj ].
      }
      replace l with (j - 1) by flia Hlj Hlj1.
      symmetry.
      rewrite subm_subm_l_l; [ | easy ].
      rewrite Nat.sub_add; [ easy | flia Hlj ].
    }
  }
}
destruct (lt_dec i k) as [Hik| Hik]. {
  destruct (lt_dec (k + 1) (mat_nrows A)) as [H| H]; [ | flia Hkr1 H ].
  clear H.
  destruct (lt_dec k i) as [H| H]; [ flia Hik H | clear H ].
  rewrite Nat.sub_0_r.
  destruct (lt_dec i (mat_nrows A - 1)) as [Hir1| Hir1]. 2: {
    flia Hir Hir1 Hkr1 Hik.
  }
  apply map_ext_in.
  intros m Hm; apply in_seq in Hm.
  destruct (lt_dec j l) as [Hjl| Hjl]. {
    destruct (lt_dec l j) as [H| H]; [ flia Hjl H | clear H ].
    rewrite Nat.sub_0_r.
    symmetry.
    rewrite subm_subm_exch'; [ | flia Hik | flia Hjl ].
    now do 2 rewrite Nat.add_sub.
  } {
    destruct (lt_dec l j) as [Hlj| Hlj]. {
      rewrite Nat.add_0_r.
      f_equal; f_equal.
      destruct (lt_dec l (j - 1)) as [Hlj1| Hlj1]. {
        symmetry.
        rewrite subm_subm_exch; [ | flia Hik | flia Hlj1 ].
        rewrite Nat.sub_add; [ | flia Hlj ].
        now rewrite Nat.add_sub.
      }
      replace j with (l + 1) by flia Hlj Hlj1.
      rewrite Nat.add_sub.
      symmetry.
      rewrite subm_subm_exch''; [ easy | flia Hik ].
    }
    rewrite Nat.add_0_r, Nat.sub_0_r.
    f_equal; f_equal.
    replace j with l by flia Hjl Hlj.
    apply subm_subm_r_r; flia Hik.
  }
} {
  apply Nat.nlt_ge in Hik.
  rewrite Nat.add_0_r.
  destruct (lt_dec k i) as [Hki| Hki]. {
    destruct (lt_dec k (mat_nrows A)) as [H| H]; [ clear H | flia Hkr1 H ].
    destruct (lt_dec (i - 1) (mat_nrows A - 1)) as [H| H];
      [ clear H | flia Hir Hki H ].
    apply map_ext_in.
    intros m Hm; apply in_seq in Hm.
    destruct (lt_dec j l) as [Hjl| Hjl]. {
      destruct (lt_dec l j) as [H| H]; [ flia Hjl H | clear H ].
      rewrite Nat.sub_0_r.
      f_equal; f_equal.
      rewrite subm_subm_exch; [ easy | easy | flia Hjl ].
    }
    apply Nat.nlt_ge in Hjl.
    rewrite Nat.add_0_r.
    destruct (lt_dec l j) as [Hlj| Hlj]. 2: {
      rewrite Nat.sub_0_r.
      replace l with j by flia Hjl Hlj.
      f_equal; f_equal.
      destruct (lt_dec k (i - 1)) as [Hki1| Hki1]. {
        symmetry.
        rewrite subm_subm_r_r; [ | flia Hki1 ].
        rewrite Nat.sub_add; [ easy | flia Hki ].
      }
      replace i with (k + 1) by flia Hki Hki1.
      rewrite Nat.add_sub.
      rewrite subm_subm_l_l; [ | easy ].
      rewrite subm_subm_exch; [ | flia | easy ].
      now rewrite Nat.add_sub.
    }
    f_equal; f_equal.
    now apply subm_subm_exch'.
  }
  replace i with k by flia Hik Hki.
  clear i Hir Hik Hki.
  rename k into i.
  rewrite Nat.sub_0_r.
  destruct (lt_dec i (mat_nrows A)) as [H| H]; [ clear H | flia Hkr1 H ].
  destruct (lt_dec i (mat_nrows A - 1)) as [H| H]; [ | flia Hkr1 H ].
  clear H.
  apply map_ext_in.
  intros k Hk; apply in_seq in Hk.
  f_equal; f_equal.
  destruct (lt_dec j l) as [Hjl| Hjl]. {
    destruct (lt_dec l j) as [H| H]; [ flia Hjl H | clear H ].
    rewrite Nat.sub_0_r.
    rewrite subm_subm_l_l; [ easy | flia Hjl ].
  }
  rewrite Nat.add_0_r.
  destruct (lt_dec l j) as [Hlj| Hlj]. {
    symmetry.
    rewrite subm_subm_l_l; [ | flia Hlj ].
    rewrite Nat.sub_add; [ easy | flia Hlj ].
  }
  rewrite Nat.sub_0_r.
  now replace l with j by flia Hjl Hlj.
}
Qed.

(*
Definition swap_in_permut n i j k :=
  vect_swap_elem (vect_vect_nat_el (mk_canon_sym_gr_vect n) k) i j.
*)

(* comatrix *)

Definition comatrix (M : matrix T) : matrix T :=
  mk_mat
    (map
      (λ i,
       map (λ j, (minus_one_pow (i + j) * determinant (subm M i j))%F)
         (seq 0 (mat_ncols M)))
      (seq 0 (mat_nrows M))).

Arguments comatrix M%M.

Theorem mat_swap_same_rows : ∀ (M : matrix T) i,
  mat_swap_rows i i M = M.
Proof.
intros.
destruct M as (ll); cbn.
unfold mat_swap_rows; f_equal.
cbn - [ list_swap_elem ].
rewrite (List_map_nth_seq ll (nth i ll [])) at 2.
unfold list_swap_elem.
apply map_ext_in.
intros j Hj; apply in_seq in Hj.
unfold transposition.
do 2 rewrite if_eqb_eq_dec.
destruct (Nat.eq_dec j i) as [Hji| Hji]. {
  subst j.
  now apply nth_indep.
}
now apply nth_indep.
Qed.

Theorem mat_swap_rows_comm : ∀ (M : matrix T) p q,
  mat_swap_rows p q M = mat_swap_rows q p M.
Proof.
intros.
unfold mat_swap_rows; f_equal; cbn.
unfold list_swap_elem.
apply map_ext_in.
intros i Hi; apply in_seq in Hi.
now rewrite transposition_comm.
Qed.

Theorem subm_mat_swap_rows_lt_lt : ∀ (M : matrix T) p q r j,
  p < q
  → q < r
  → subm (mat_swap_rows p q M) r j = mat_swap_rows p q (subm M r j).
Proof.
intros * Hpq Hq.
destruct M as (ll); cbn.
unfold subm, mat_swap_rows; cbn; f_equal.
rewrite map_length.
rewrite butn_length.
rewrite <- map_butn, map_map.
rewrite map_butn_seq.
rewrite Nat.add_0_l.
apply map_ext_in.
intros i Hi; apply in_seq in Hi.
unfold Nat.b2n.
rewrite if_leb_le_dec.
destruct Hi as (_, Hi).
destruct (le_dec r i) as [Hir| Hir]. 2: {
  apply Nat.nle_gt in Hir.
  rewrite Nat.add_0_r.
  destruct (Nat.eq_dec i p) as [Hip| Hip]. {
    subst i; clear Hir.
    rewrite transposition_1.
    destruct (lt_dec q (length (butn r ll))) as [Hqrl| Hqrl]. {
      rewrite (List_map_nth' []); [ | easy ].
      now rewrite nth_butn_after.
    }
    apply Nat.nlt_ge in Hqrl.
    symmetry.
    rewrite nth_overflow; [ | now rewrite map_length ].
    rewrite butn_length in Hqrl.
    destruct (le_dec (length ll) q) as [Hlq| Hlq]. {
      rewrite nth_overflow with (n := q); [ | easy ].
      now rewrite butn_nil.
    }
    apply Nat.nle_gt in Hlq.
    unfold Nat.b2n in Hi, Hqrl.
    rewrite if_ltb_lt_dec in Hi, Hqrl.
    destruct (lt_dec r (length ll)) as [Hrl| Hrl]; [ | flia Hqrl Hlq ].
    flia Hq Hrl Hqrl Hlq.
  }
  destruct (Nat.eq_dec i q) as [Hiq| Hiq]. {
    subst i; clear Hir.
    rewrite transposition_2.
    destruct (lt_dec p (length (butn r ll))) as [Hprl| Hprl]. {
      rewrite (List_map_nth' []); [ | easy ].
      rewrite nth_butn_after; [ easy | flia Hpq Hq ].
    }
    apply Nat.nlt_ge in Hprl.
    rewrite butn_length in Hprl.
    flia Hpq Hi Hprl.
  }
  unfold transposition.
  do 2 rewrite if_eqb_eq_dec.
  destruct (Nat.eq_dec i p) as [H| H]; [ easy | clear H ].
  destruct (Nat.eq_dec i q) as [H| H]; [ easy | clear H ].
  rewrite map_butn.
  rewrite nth_butn_after; [ | easy ].
  rewrite (List_map_nth' []); [ easy | flia Hi ].
}
unfold transposition.
do 4 rewrite if_eqb_eq_dec.
destruct (Nat.eq_dec i p) as [H| H]; [ flia Hpq Hq Hir H | clear H ].
destruct (Nat.eq_dec i q) as [H| H]; [ flia Hq Hir H | clear H ].
destruct (Nat.eq_dec (i + 1) p) as [H| H]; [ flia Hpq Hq Hir H | clear H ].
destruct (Nat.eq_dec (i + 1) q) as [H| H]; [ flia Hq Hir H | clear H ].
rewrite map_butn.
rewrite nth_butn_before; [ | easy ].
rewrite (List_map_nth' []); [ easy | ].
unfold Nat.b2n in Hi.
rewrite if_ltb_lt_dec in Hi.
destruct (lt_dec r (length ll)) as [Hrl| Hrl]; [ flia Hi Hir | ].
flia Hrl Hi Hir.
Qed.

Theorem subm_mat_swap_rows_lt : ∀ (M : matrix T) p q r j,
  p < r
  → q < r
  → subm (mat_swap_rows p q M) r j = mat_swap_rows p q (subm M r j).
Proof.
intros * Hp Hq.
destruct (lt_dec p q) as [Hpq| Hpq]; [ now apply subm_mat_swap_rows_lt_lt | ].
do 2 rewrite mat_swap_rows_comm with (p := p).
destruct (lt_dec q p) as [Hqp| Hqp]; [ now apply subm_mat_swap_rows_lt_lt | ].
replace q with p by flia Hpq Hqp.
now do 2 rewrite mat_swap_same_rows.
Qed.

Theorem mat_el_mat_swap_rows : ∀ (M : matrix T) p q j,
  q < mat_nrows M
  → mat_el (mat_swap_rows p q M) q j = mat_el M p j.
Proof.
intros * Hql; cbn.
destruct M as (ll); cbn in Hql |-*.
f_equal; clear j.
rewrite (List_map_nth' 0); [ | now rewrite seq_length ].
rewrite seq_nth; [ | easy ].
rewrite Nat.add_0_l.
now rewrite transposition_2.
Qed.

Theorem length_fold_left_map_transp : ∀ A (ll : list A) sta len f g d,
  length
    (fold_left
       (λ ll' k,
        map (λ i, nth (transposition (f k) (g k) i) ll' d)
          (seq 0 (length ll')))
       (seq sta len) ll) = length ll.
Proof.
intros.
induction len; [ easy | ].
rewrite seq_S.
rewrite fold_left_app; cbn.
rewrite List_map_seq_length.
apply IHlen.
Qed.

Theorem mat_nrows_fold_left_swap : ∀ (M : matrix T) p q f g,
  mat_nrows (fold_left (λ M' k, mat_swap_rows (f k) (g k) M') (seq p q) M) =
  mat_nrows M.
Proof.
intros.
unfold mat_nrows.
rewrite fold_left_mat_fold_left_list_list.
apply length_fold_left_map_transp.
Qed.

Theorem nth_fold_left_map_transp_1 : ∀ A (la : list A) i sta len d,
  i < length la
  → i < sta ∨ sta + len < i
  → nth i
      (fold_left
         (λ la' k,
            map (λ j, nth (transposition k (k + 1) j) la' d)
              (seq 0 (length la')))
         (seq sta len) la) d =
    nth i la d.
Proof.
intros * Hi Hip.
induction len; [ easy | ].
rewrite seq_S; cbn.
rewrite fold_left_app; cbn.
rewrite (List_map_nth' 0). 2: {
  rewrite seq_length.
  now rewrite length_fold_left_map_transp.
}
rewrite seq_nth. 2: {
  now rewrite length_fold_left_map_transp.
}
rewrite Nat.add_0_l.
unfold transposition.
do 2 rewrite if_eqb_eq_dec.
destruct (Nat.eq_dec i (sta + len)) as [His| His]; [ flia His Hip | ].
destruct (Nat.eq_dec i (sta + len + 1)) as [Hip1| Hip1]; [ flia Hip Hip1 | ].
apply IHlen.
flia Hip His.
Qed.

Theorem nth_0_fold_left_cons_cons : ∀ A B (b : A) (la : list B) lb lc d f,
  nth 0 (fold_left (λ v i, nth 0 v d :: f v i) la (b :: lb)) lc = b.
Proof.
intros.
revert lb.
induction la as [| a]; intros; [ easy | cbn ].
now rewrite IHla.
Qed.

Theorem nth_0_fold_left_nth_transp: ∀ A (b : A) lb d f n,
  nth 0
    (fold_left
       (λ v i, nth (transposition i (i + 1) 0) v d :: f v i) (seq 0 (S n))
       (b :: lb))
    d = nth 0 lb d.
Proof.
intros; cbn.
rewrite <- seq_shift.
rewrite List_fold_left_map; cbn.
now rewrite nth_0_fold_left_cons_cons.
Qed.

Theorem nth_succ_fold_left_app_cons : ∀ A B n (b : A) (la : list B) lb d f g,
  length lb = S n
  → (∀ v i, length (g v i) = n)
  → nth (S n)
       (fold_left (λ v i, f v i :: g v i ++ [nth (S n) v d]) la (b :: lb)) d =
    nth n lb d.
Proof.
intros * Hlb Hf.
revert b lb Hlb Hf.
induction la as [| a]; intros; [ easy | cbn ].
rewrite IHla; [ | | apply Hf ]. 2: {
  rewrite app_length; cbn.
  rewrite Nat.add_1_r; f_equal.
  apply Hf.
}
rewrite app_nth2; [ | now unfold "≥"; rewrite Hf ].
now rewrite Hf, Nat.sub_diag.
Qed.

Theorem nth_fold_left_seq_gen : ∀ A (u : list A) i d n sta,
  sta + n ≤ length u
  → sta ≤ i < sta + n - 1
  → nth i
      (fold_left
         (λ la' k,
            map (λ j, nth (transposition k (k + 1) j) la' d)
              (seq 0 (length la')))
         (seq sta n) u) d =
     nth (i + 1) u d.
Proof.
intros * Hn Hi.
revert i Hi.
induction n; intros; [ flia Hi  | ].
assert (H : sta + n ≤ length u) by flia Hn.
specialize (IHn H); clear H.
rewrite <- Nat.add_sub_assoc in Hi; [ | flia ].
rewrite Nat_sub_succ_1 in Hi.
rewrite seq_S.
rewrite fold_left_app.
destruct (Nat.eq_dec i (sta + n - 1)) as [Hin| Hin]. {
  subst i.
  rewrite Nat.sub_add; [ | flia Hi ].
  cbn.
  rewrite length_fold_left_map_transp.
  rewrite (List_map_nth' 0); [ | rewrite seq_length; flia Hn ].
  rewrite seq_nth; [ | flia Hn ].
  rewrite transposition_out; [ cbn | flia Hi | flia ].
  destruct n; [ flia Hi | ].
  rewrite <- Nat.add_sub_assoc; [ | flia ].
  rewrite Nat_sub_succ_1.
  rewrite seq_S; cbn.
  rewrite fold_left_app; cbn.
  rewrite length_fold_left_map_transp.
  rewrite (List_map_nth' 0); [ | rewrite seq_length; flia Hn ].
  rewrite seq_nth; [ | flia Hn ].
  rewrite transposition_1.
  rewrite Nat.add_1_r.
  rewrite nth_fold_left_map_transp_1; [ | flia Hn | right; flia ].
  now rewrite <- Nat.add_succ_comm.
}
cbn.
rewrite length_fold_left_map_transp.
rewrite (List_map_nth' 0); [ | rewrite seq_length; flia Hn Hi ].
rewrite seq_nth; [ | flia Hn Hi ].
rewrite transposition_out; [ cbn | flia Hi | flia Hi Hin ].
apply IHn.
flia Hi Hin.
Qed.

Theorem nth_fold_left_map_transp : ∀ A (la : list A) i sta len d,
  nth i
    (fold_left
       (λ la' k,
          map (λ j, nth (transposition k (k + 1) j) la' d)
            (seq 0 (length la')))
       (seq sta len) la) d =
  if le_dec (length la) i then d
  else if Nat.eq_dec i (sta + len) then nth sta la d
  else if le_dec (length la) sta then nth i la d
  else if le_dec (length la) (sta + len) then
    nth i
      (fold_left
         (λ la' k,
          map (λ j, nth (transposition k (k + 1) j) la' d)
            (seq 0 (length la)))
         (seq sta (length la - sta)) la) d
  else
    nth (i + Nat.b2n ((sta <=? i) && (i <=? sta + len))) la d.
Proof.
intros.
destruct (le_dec (length la) i) as [Hi| Hi]. {
  rewrite nth_overflow; [ easy | ].
  now rewrite length_fold_left_map_transp.
}
apply Nat.nle_gt in Hi.
destruct (Nat.eq_dec i (sta + len)) as [Hisl| Hisl]. {
  subst i.
  revert la sta d Hi.
  induction len; intros. {
    rewrite Nat.add_0_r in Hi |-*.
    now destruct la.
  }
  cbn.
  rewrite <- Nat.add_succ_comm in Hi.
  rewrite <- Nat.add_succ_comm.
  rewrite IHlen; [ | now rewrite map_length, seq_length ].
  rewrite (List_map_nth' 0); [ | rewrite seq_length; flia Hi ].
  rewrite seq_nth; [ | flia Hi ].
  rewrite Nat.add_0_l, Nat.add_1_r.
  now rewrite transposition_2.
}
unfold Nat.b2n, "&&", negb.
destruct (le_dec (length la) sta) as [Hsla| Hsla]. {
  rewrite List_fold_left_map_nth_len.
  erewrite List_fold_left_ext_in. 2: {
    intros j v Hj; apply in_seq in Hj.
    erewrite map_ext_in. 2: {
      intros k Hk; apply in_seq in Hk.
      rewrite transposition_out; [ | flia Hsla Hj Hk | flia Hsla Hj Hk ].
      easy.
    }
    easy.
  }
  rewrite <- (List_seq_shift' len).
  rewrite List_fold_left_map.
  rewrite <- List_fold_left_map_nth_len.
  rewrite List_fold_left_nop_r.
  rewrite seq_length.
  rewrite repeat_apply_id. 2: {
    intros u.
    symmetry; apply List_map_nth_seq.
  }
  easy.
}
apply Nat.nle_gt in Hsla.
destruct (le_dec (length la) (sta + len)) as [Hsl| Hsl]. {
  replace len with (length la - sta + (sta + len - length la)) at 1
    by flia Hsla Hsl.
  rewrite seq_app.
  rewrite fold_left_app.
  rewrite Nat.add_comm, Nat.sub_add; [ | flia Hsla ].
  rewrite List_fold_left_map_nth_len.
  erewrite List_fold_left_ext_in. 2: {
    intros j v Hj; apply in_seq in Hj.
    erewrite map_ext_in. 2: {
      intros k Hk; apply in_seq in Hk.
      rewrite length_fold_left_map_transp in Hk.
      rewrite transposition_out; [ | flia Hsla Hj Hk | flia Hsla Hj Hk ].
      easy.
    }
    easy.
  }
  rewrite <- List_fold_left_map_nth_len.
  rewrite List_fold_left_nop_r.
  rewrite seq_length.
  rewrite repeat_apply_id. 2: {
    intros u.
    symmetry; apply List_map_nth_seq.
  }
  now rewrite <- List_fold_left_map_nth_len.
}
apply Nat.nle_gt in Hsl.
rewrite if_leb_le_dec.
destruct (le_dec sta i) as [Hip| Hip]. 2: {
  apply Nat.nle_gt in Hip.
  rewrite Nat.add_0_r.
  apply nth_fold_left_map_transp_1; [ easy | now left ].
}
rewrite if_leb_le_dec.
destruct (le_dec i (sta + len)) as [Hip'| Hip']. 2: {
  apply Nat.nle_gt in Hip'.
  rewrite Nat.add_0_r.
  apply nth_fold_left_map_transp_1; [ easy | now right ].
}
assert (H : i < sta + len) by flia Hisl Hip'.
clear Hisl Hip'; rename H into Hisl.
destruct (Nat.eq_dec i (length la - 1)) as [Hila| Hila]. {
  flia Hsl Hisl Hila.
}
destruct (Nat.eq_dec i (sta + len - 1)) as [Hisl1| Hisl1]. 2: {
  rewrite nth_fold_left_seq_gen; [ easy | flia Hsl | flia Hip Hisl Hisl1 ].
}
rewrite Hisl1.
rewrite Nat.sub_add; [ | flia Hisl ].
destruct len; [ flia Hip Hisl | ].
rewrite seq_S.
rewrite fold_left_app; cbn.
rewrite <- Nat.add_sub_assoc; [ | flia ].
rewrite Nat_sub_succ_1.
rewrite length_fold_left_map_transp.
rewrite (List_map_nth' 0); [ | rewrite seq_length; flia Hsl ].
rewrite seq_nth; [ | flia Hsl ].
rewrite transposition_1.
rewrite <- Nat.add_assoc, Nat.add_1_r.
apply nth_fold_left_map_transp_1; [ easy | right; flia ].
Qed.

Theorem mat_el_circ_rot_rows_succ_1 : ∀ (M : matrix T) i j p q,
  i < mat_nrows M
  → i < p ∨ p + q < i
  → mat_el M i j =
    mat_el (fold_left (λ M' k, mat_swap_rows k (k + 1) M') (seq p q) M)
      i j.
Proof.
intros * Hi Hpi.
destruct M as (ll); cbn in Hi; cbn.
unfold mat_el.
rewrite fold_left_mat_fold_left_list_list; cbn.
f_equal; clear j; symmetry.
rewrite nth_fold_left_map_transp.
destruct (le_dec (length ll) i) as [H| H]; [ flia Hi H | clear H ].
destruct (Nat.eq_dec i (p + q)) as [H| H]; [ | clear H ]. {
  destruct Hpi as [Hpi| Hpi]; flia H Hpi.
}
destruct (le_dec (length ll) p) as [Hlp| Hlp]; [ easy | ].
apply Nat.nle_gt in Hlp.
destruct (le_dec (length ll) (p + q)) as [Hpql| Hpql]. 2: {
  apply Nat.nle_gt in Hpql.
  unfold Nat.b2n.
  rewrite andb_if.
  do 2 rewrite if_leb_le_dec.
  destruct (le_dec p i) as [Hpi'| Hpi']; [ | now rewrite Nat.add_0_r ].
  destruct (le_dec i (p + q)) as [H| H]; [ | clear H ]. {
    destruct Hpi as [Hpi| Hpi]; flia H Hpi Hpi'.
  }
  now rewrite Nat.add_0_r.
}
destruct Hpi as [Hpi| Hpi]; [ | flia Hi Hpi Hpql ].
rewrite <- List_fold_left_map_nth_len.
rewrite nth_fold_left_map_transp_1; [ easy | easy | now left ].
Qed.

Theorem mat_el_circ_rot_rows : ∀ (M : matrix T) i j,
  i < mat_nrows M
  → mat_el M 0 j =
      mat_el (fold_left (λ M' k, mat_swap_rows k (k + 1) M') (seq 0 i) M) i j.
Proof.
intros * Hi.
revert M Hi.
induction i; intros; [ easy | ].
rewrite seq_S.
rewrite fold_left_app.
cbn - [ mat_swap_rows ].
rewrite Nat.add_1_r.
rewrite mat_el_mat_swap_rows. 2: {
  now rewrite mat_nrows_fold_left_swap.
}
apply IHi.
flia Hi.
Qed.

Theorem nth_fold_left_map_transp' : ∀ A (la : list A) i len d,
  i + 1 < length la
  → i < len
  → nth i
      (fold_left
         (λ la' k,
            map (λ j, nth (transposition k (k + 1) j) la' d)
              (seq 0 (length la'))) 
         (seq 0 len) la) d =
    nth (i + 1) la d.
Proof.
intros * Hi Hpi.
rewrite nth_fold_left_map_transp; cbn.
rewrite Nat.sub_0_r.
destruct (le_dec (length la) i) as [H| H]; [ flia Hi H | clear H ].
destruct (Nat.eq_dec i len) as [H| H]; [ flia Hpi H | clear H ].
destruct (le_dec (length la) 0) as [H| H]; [ flia Hi H | clear H ].
destruct (le_dec (length la) len) as [Hll| Hll]. 2: {
  apply Nat.nle_gt in Hll.
  unfold Nat.b2n.
  rewrite if_leb_le_dec.
  destruct (le_dec i len) as [H| H]; [ easy | flia Hpi H ].
}
clear len Hpi Hll.
rewrite <- List_fold_left_map_nth_len.
rewrite nth_fold_left_seq_gen; [ easy | easy | flia Hi ].
Qed.

Theorem mat_el_circ_rot_rows_succ : ∀ (M : matrix T) i j p,
  i + 1 < mat_nrows M
  → i + 1 ≠ p
  → mat_el M (i + 1) j =
    mat_el
      (fold_left (λ (M' : matrix T) (k : nat), mat_swap_rows k (k + 1) M')
         (seq 0 (p - 1)) M) (i + Nat.b2n (p <=? i)) j.
Proof.
intros * Hi Hi1p.
destruct M as (ll); cbn in Hi |-*.
unfold mat_el; f_equal; clear j.
rewrite fold_left_mat_fold_left_list_list; cbn.
unfold Nat.b2n.
rewrite if_leb_le_dec.
destruct (le_dec p i) as [Hpi| Hpi]. {
  destruct (le_dec p i) as [H| H]; [ clear H | flia Hpi H ].
  rewrite nth_fold_left_map_transp; cbn.
  destruct (le_dec (length ll) (i + 1)) as [H| H]; [ flia Hi H | clear H ].
  destruct (Nat.eq_dec (i + 1) (p - 1)) as [H| H]; [ flia Hpi H | clear H ].
  destruct (le_dec (length ll) 0) as [H| H]; [ flia Hi H | clear H ].
  destruct (le_dec (length ll) (p - 1)) as [H| H]; [ flia Hi Hpi H | clear H ].
  unfold Nat.b2n.
  rewrite if_leb_le_dec.
  destruct (le_dec (i + 1) (p - 1)) as [H| H]; [ flia Hpi H | clear H ].
  now rewrite Nat.add_0_r.
}
apply Nat.nle_gt in Hpi.
rewrite Nat.add_0_r.
symmetry.
apply nth_fold_left_map_transp'; [ easy | flia Hi1p Hpi ].
Qed.

Theorem subm_mat_swap_rows_succ_succ : ∀ (M : matrix T) i j,
  i + 2 < mat_nrows M
  → subm (mat_swap_rows (i + 1) (i + 2) (mat_swap_rows i (i + 1) M)) (S i) j =
    subm (mat_swap_rows i (i + 1) M) (S (S i)) j.
Proof.
intros * Hi2.
destruct M as (ll); cbn in Hi2 |-*.
unfold subm; f_equal; cbn - [ list_swap_elem butn ].
unfold list_swap_elem.
rewrite List_map_seq_length.
do 2 rewrite <- map_butn.
do 2 rewrite map_map.
do 2 rewrite map_butn_seq.
unfold Nat.b2n.
do 2 rewrite if_ltb_lt_dec.
destruct (lt_dec (S i) (length ll)) as [H| H]; [ clear H | flia Hi2 H ].
destruct (lt_dec (S (S i)) (length ll)) as [H| H]; [ clear H | flia Hi2 H ].
do 2 rewrite Nat.add_0_l.
apply map_ext_in.
intros k Hk; apply in_seq in Hk.
unfold Nat.b2n.
do 2 rewrite if_leb_le_dec.
destruct (le_dec (S i) k) as [Hksi| Hksi]. 2: {
  apply Nat.nle_gt in Hksi.
  rewrite (@transposition_out (i + 1)); [ | flia Hksi | flia Hksi ].
  destruct (le_dec (S (S i)) k) as [Hkssi| Hkssi]. 2: {
    apply Nat.nle_gt in Hkssi.
    rewrite (List_map_nth' 0); [ | rewrite seq_length; flia Hk ].
    rewrite seq_nth; [ easy | flia Hk ].
  }
  flia Hi2 Hk Hksi Hkssi.
} {
  destruct (le_dec (S (S i)) k) as [Hkssi| Hkssi]. 2: {
    apply Nat.nle_gt in Hkssi.
    replace k with (i + 1) by flia Hksi Hkssi.
    rewrite Nat.add_0_r.
    rewrite <- Nat.add_assoc.
    do 2 rewrite transposition_2.
    rewrite List_nth_map_seq; [ | flia Hk Hksi ].
    now rewrite transposition_2.
  }
  rewrite (@transposition_out i (i + 1) (k + 1)); [ | flia Hksi | flia Hksi ].
  rewrite List_nth_map_seq. 2: {
    apply transposition_lt; [ flia Hi2 | easy | flia Hk ].
  }
  rewrite Nat.add_0_l.
  rewrite (@transposition_out (i + 1)); [ | flia Hkssi | flia Hkssi ].
  rewrite transposition_out; [ easy | flia Hkssi | flia Hkssi ].
}
Qed.

(*
Theorem butn_list_swap_scal_0_l : ∀ d (l : list T) p,
  p < length l
  → butn 0 (list_swap_scal d 0 p l) =
    butn p
      (fold_left (λ l' k, list_swap_scal d k (k + 1) l') (seq 0 (p - 1)) l).
Proof.
intros * Hp.
revert l Hp.
induction p; intros. {
  unfold list_swap_scal.
  cbn - [ nth ].
  erewrite map_ext_in. 2: {
    intros i Hi; apply in_seq in Hi.
    now rewrite transposition_id.
  }
  now rewrite <- (List_map_nth_seq l d).
}
...
intros * Hp.
destruct l as [| a]; intros; [ easy | cbn in Hp ].
destruct p. {
  unfold list_swap_scal.
  cbn - [ nth ].
  rewrite <- seq_shift, map_map.
  erewrite map_ext_in. 2: {
    intros i Hi; apply in_seq in Hi.
    now cbn.
  }
  symmetry.
  apply List_map_nth_seq.
}
apply Nat.succ_lt_mono in Hp.
rewrite list_swap_scal_0_succ_cons.
rewrite butn_0.
rewrite Nat_sub_succ_1.
cbn - [ butn ].
revert p Hp.
induction l as [| b]; intros; [ easy | ].
destruct p. {
  cbn - [ nth ]; f_equal.
  rewrite <- seq_shift, map_map; cbn.
  symmetry.
  apply List_map_nth_seq.
}
cbn in Hp.
apply Nat.succ_lt_mono in Hp.
cbn - [ map nth butn fold_left ].
rewrite map_cons.
cbn - [ map nth butn fold_left ].
remember (nth 0 _ _) as x; cbn in Heqx; subst x.
rewrite <- seq_shift, map_map.
erewrite map_ext_in; [ | now intros i Hi; cbn ].
rewrite IHl; [ clear IHl | easy ].
replace (0 :: seq 1 p) with (seq 0 (S p)) by easy.
rewrite seq_S, Nat.add_0_l.
rewrite fold_left_app.
remember (S p) as sp.
cbn - [ butn list_swap_scal ].
unfold list_swap_scal at 2.
unfold list_swap_scal.
rewrite length_fold_left_map_transp.
rewrite <- map_butn.
rewrite map_butn_seq.
rewrite Nat.add_0_l.
cbn - [ "<=?" "-" ].
unfold Nat.b2n at 2.
rewrite if_ltb_lt_dec.
destruct (lt_dec (S sp) (S (S (length l)))) as [H| H]; [ | flia Hp Heqsp H ].
clear H.
rewrite Nat_sub_succ_1.
cbn; f_equal. {
  unfold transposition at 1.
  do 2 rewrite if_eqb_eq_dec.
  destruct (Nat.eq_dec 0 (p + 1)) as [H| H]; [ flia H | clear H ].
  destruct (Nat.eq_dec 0 p) as [Hpz| Hpz]; [ now subst p | ].
  destruct p; [ easy | ].
...
Theorem mat_list_list_fold_left : ∀ A (M : matrix T) f g (l : list A),
  mat_list_list (fold_left f l M) = g M.
Proof.
intros.
destruct l as [| a]; intros; cbn.
(*
  mat_list_list M = g M
*)
...
intros.
revert M.
induction l as [| a]; intros; [ | cbn ].
cbn.
rewrite IHl.
...
g M = mat_list_list M
g (f M a) = g M
Search (mat_list_list (fold_left _ _ _)).
...
Search (nth 0).
Search (nth _ (fold_left _ _ _)).

Search (nth (transposition _ _ _)).
...
Search (length (fold_left _ _ _)).
Search mat_swap_rows.
About mat_el_circ_rot_rows.
...
unfold list_swap_scal at 2.
Search (length (fold_left _ _ _)).
...
unfold butn at 2.
Search (firstn (S _)).
...
Search (butn (S _)).
rewrite butn_cons.
cbn - [ butn list_swap_scal ].
cbn - [ fold_left].
...
rewrite map_cons.
cbn - [ nth ].
...
*)

Theorem subm_mat_swap_rows_circ : ∀ (M : matrix T) p q,
  p < mat_nrows M
  → subm (mat_swap_rows 0 p M) 0 q =
    subm (fold_left (λ M' k, mat_swap_rows k (k + 1) M') (seq 0 (p - 1)) M)
      p q.
Proof.
intros * Hp.
destruct M as (ll); cbn in Hp |-*.
unfold subm; f_equal.
cbn - [ butn ].
f_equal; clear q.
rewrite fold_left_mat_fold_left_list_list.
cbn - [ butn ].
rewrite List_map_nth_seq with (d := []); symmetry.
rewrite List_map_nth_seq with (d := []); symmetry.
rewrite butn_length, map_length, seq_length.
rewrite butn_length.
rewrite length_fold_left_map_transp.
unfold Nat.b2n.
do 2 rewrite if_ltb_lt_dec.
destruct (lt_dec 0 (length ll)) as [H| H]; [ clear H | flia H Hp ].
destruct (lt_dec p (length ll)) as [H| H]; [ clear H | flia H Hp ].
apply map_ext_in.
intros i Hi; apply in_seq in Hi.
cbn in Hi.
rewrite <- map_butn.
rewrite (List_map_nth' 0). 2: {
  rewrite butn_length, seq_length.
  unfold Nat.b2n.
  rewrite if_ltb_lt_dec.
  destruct (lt_dec 0 (length ll)) as [H| H]; [ easy | flia Hp H ].
}
rewrite nth_butn_before; [ | flia ].
rewrite seq_nth; [ cbn | flia Hi ].
destruct (le_dec p i) as [Hpi| Hpi]. 2: {
  apply Nat.nle_gt in Hpi.
  rewrite nth_butn_after; [ | easy ].
  rewrite nth_fold_left_map_transp; cbn.
  rewrite Nat.sub_0_r.
  destruct (le_dec (length ll) i) as [H| H]; [ flia Hi H | clear H ].
  destruct (Nat.eq_dec i (p - 1)) as [Hip1| Hip1]. {
    rewrite Hip1, Nat.sub_add; [ | flia Hpi ].
    now rewrite transposition_2.
  }
  destruct (le_dec (length ll) 0) as [H| H]; [ flia Hp H | clear H ].
  destruct (le_dec (length ll) (p - 1)) as [H| H]; [ flia Hp H | clear H ].
  unfold transposition.
  unfold Nat.b2n.
  do 2 rewrite if_eqb_eq_dec.
  rewrite if_leb_le_dec.
  rewrite Nat.add_1_r.
  destruct (Nat.eq_dec (S i) 0) as [H| H]; [ easy | clear H ].
  destruct (Nat.eq_dec (S i) p) as [H| H]; [ flia Hip1 H | clear H ].
  destruct (le_dec i (p - 1)) as [H| H]; [ | flia Hpi H ].
  now rewrite Nat.add_1_r.
}
rewrite transposition_out; [ | flia | flia Hpi ].
rewrite nth_butn_before; [ | easy ].
symmetry.
rewrite nth_fold_left_map_transp; cbn; rewrite Nat.sub_0_r.
destruct (le_dec (length ll) (i + 1)) as [H| H]; [ flia Hi H | clear H ].
destruct (Nat.eq_dec (i + 1) (p - 1)) as [H| H]; [ flia Hpi H | clear H ].
destruct (le_dec (length ll) 0) as [H| H]; [ flia Hp H | clear H ].
destruct (le_dec (length ll) (p - 1)) as [H| H]; [ flia Hp H | clear H ].
unfold Nat.b2n.
rewrite if_leb_le_dec.
destruct (le_dec (i + 1) (p - 1)) as [H| H]; [ flia Hpi H | clear H ].
now rewrite Nat.add_0_r.
Qed.

Theorem mat_swap_rows_fold_left : ∀ (M : matrix T) i,
  mat_swap_rows i (S i)
    (fold_left (λ M' k, mat_swap_rows k (k + 1) M') (seq 0 i) M) =
   fold_left (λ M' k, mat_swap_rows k (k + 1) M') (seq 0 (S i)) M.
Proof.
intros.
rewrite seq_S; cbn.
rewrite fold_left_app; cbn.
now rewrite Nat.add_1_r.
Qed.

Theorem subm_fold_left_lt : ∀ (M : matrix T) i j m,
  m < i
  → subm
      (fold_left (λ M' k, mat_swap_rows k (k + 1) M')
         (seq 0 m) M) i j =
    fold_left
      (λ M' k, mat_swap_rows k (k + 1) M')
      (seq 0 m) (subm M i j).
Proof.
intros * Hmi.
revert i Hmi.
induction m; intros; [ easy | ].
rewrite seq_S; cbn.
do 2 rewrite fold_left_app; cbn.
rewrite <- IHm; [ | flia Hmi ].
apply subm_mat_swap_rows_lt; flia Hmi.
Qed.

Theorem determinant_circular_shift_rows : rngl_is_field →
  ∀ (M : matrix T) i,
  i < mat_nrows M
  → is_square_matrix M = true
  → determinant (fold_left (λ M' k, mat_swap_rows k (k + 1) M') (seq 0 i) M) =
    (minus_one_pow i * determinant M)%F.
Proof.
intros (Hic & Hop & Hiv & H10 & Hit & Hde & Hch) * Hin Hsm.
remember (mat_nrows M) as n eqn:Hr; symmetry in Hr.
revert M Hsm Hr.
induction i; intros; [ now cbn; rewrite rngl_mul_1_l | ].
assert (H : i < n) by flia Hin.
specialize (IHi H); clear H.
rewrite seq_S; cbn.
rewrite fold_left_app; cbn - [ determinant ].
rewrite determinant_alternating; [ | easy | flia | | | ]; cycle 1. {
  rewrite mat_nrows_fold_left_swap, Hr; flia Hin.
} {
  now rewrite mat_nrows_fold_left_swap, Hr, Nat.add_1_r.
} {
  specialize (square_matrix_ncols _ Hsm) as Hc1.
  apply is_sm_mat_iff.
  apply is_sm_mat_iff in Hsm.
  destruct Hsm as (Hcr & Hc).
  rewrite Hr in Hc1.
  rewrite mat_nrows_fold_left_swap.
  split. {
    intros Hc'.
    unfold mat_ncols in Hc'.
    rewrite fold_left_mat_fold_left_list_list in Hc'.
    cbn in Hc'.
    apply length_zero_iff_nil in Hc'.
    rewrite List_hd_nth_0 in Hc'.
    rewrite nth_fold_left_map_transp in Hc'.
    rewrite fold_mat_nrows in Hc'.
    do 2 rewrite Nat.add_0_l in Hc'.
    destruct (le_dec (mat_nrows M) 0) as [Hlz| Hlz]. {
      now apply Nat.le_0_r in Hlz.
    }
    apply Nat.nle_gt in Hlz.
    destruct (Nat.eq_dec 0 i) as [Hiz| Hiz]. {
      subst i.
      apply Hcr.
      unfold mat_ncols.
      rewrite List_hd_nth_0.
      now rewrite Hc'.
    }
    rewrite Nat.sub_0_r in Hc'.
    destruct (le_dec (mat_nrows M) i) as [Hri| Hri]. {
      unfold mat_nrows in Hc'.
      rewrite <- List_fold_left_map_nth_len in Hc'.
      rewrite nth_fold_left_map_transp' in Hc'; cycle 1. {
        rewrite fold_mat_nrows.
        flia Hin Hr.
      } {
        now rewrite fold_mat_nrows.
      }
      cbn in Hc'.
      apply (f_equal length) in Hc'.
      rewrite Hc in Hc'. 2: {
        apply nth_In.
        rewrite fold_mat_nrows.
        flia Hr Hin.
      }
      easy.
    }
    apply Nat.nle_gt in Hri.
    cbn in Hc'.
    apply (f_equal length) in Hc'.
    rewrite Hc in Hc'. 2: {
      apply nth_In.
      rewrite fold_mat_nrows.
      flia Hr Hin.
    }
    easy.
  }
  intros la Hla.
  rewrite fold_left_mat_fold_left_list_list in Hla.
  cbn in Hla.
  apply In_nth with (d := []) in Hla.
  rewrite length_fold_left_map_transp, fold_mat_nrows in Hla.
  destruct Hla as (j & Hj & Hla).
  rewrite nth_fold_left_map_transp in Hla.
  rewrite fold_mat_nrows in Hla.
  rewrite Nat.add_0_l in Hla.
  destruct (le_dec (mat_nrows M) j) as [H| H]; [ flia Hj H | clear H ].
  destruct (Nat.eq_dec j i) as [Hji| Hji]. {
    subst la.
    apply Hc, nth_In.
    rewrite fold_mat_nrows; flia Hj.
  }
  destruct (le_dec (mat_nrows M) 0) as [H| H]; [ flia Hj H | clear H ].
  destruct (le_dec (mat_nrows M) i) as [H| H]; [ flia Hin Hr H | clear H ].
  subst la.
  unfold Nat.b2n.
  rewrite andb_if.
  do 2 rewrite if_leb_le_dec.
  destruct (le_dec 0 j) as [Hjz| Hjz]. {
    destruct (le_dec j i) as [Hji'| Hji']. {
      apply Hc, nth_In.
      rewrite fold_mat_nrows.
      rewrite Hr in Hj |-*.
      flia Hji' Hin.
    }
    apply Nat.nle_gt in Hji'.
    rewrite Nat.add_0_r.
    apply Hc, nth_In.
    now rewrite fold_mat_nrows.
  }
  now apply Nat.nle_gt in Hjz.
}
rewrite IHi; [ | easy | easy ].
rewrite minus_one_pow_succ; [ | easy ].
now symmetry; apply rngl_mul_opp_l.
Qed.

...

Theorem determinant_subm_mat_swap_rows_0_i : rngl_is_field →
  ∀ n (M : matrix T) i j,
  is_square_matrix (S n) M = true
  → 0 < i ≤ n
  → j ≤ n
  → determinant n (subm (mat_swap_rows 0 i M) 0 j) =
    (- minus_one_pow i * determinant n (subm M i j))%F.
Proof.
intros (Hic & Hop & Hiv & H10 & Hit & Hde & Hch) * Hsm (Hiz, Hin) Hjn.
rewrite subm_mat_swap_rows_circ. 2: {
  apply is_sm_mat_iff in Hsm.
  destruct Hsm as (Hr, _).
  rewrite Hr; flia Hin.
}
destruct i; [ flia Hiz | ].
rewrite minus_one_pow_succ; [ | easy ].
rewrite rngl_opp_involutive; [ | easy ].
rewrite Nat_sub_succ_1.
rewrite subm_fold_left_lt; [ | flia ].
apply determinant_circular_shift_rows; try easy.
apply is_squ_mat_subm; [ flia Hin | flia Hin | flia Hjn | easy ].
Qed.

(* Laplace formulas *)

Theorem laplace_formula_on_rows : rngl_is_field →
  ∀ n (M : matrix T) i,
  is_square_matrix n M = true
  → i < n
  → determinant n M =
    ∑ (j = 0, n - 1), mat_el M i j * mat_el (comatrix n M) i j.
Proof.
intros Hif * Hsm Hlin.
specialize (square_matrix_ncols M Hsm) as Hc.
specialize (proj1 (is_sm_mat_iff n M) Hsm) as H1.
destruct H1 as (Hr & Hcr & Hc').
destruct (Nat.eq_dec i 0) as [Hiz| Hiz]. {
  subst i.
  destruct n; [ easy | cbn ].
  rewrite Nat.sub_0_r at 1.
  symmetry.
  apply rngl_summation_eq_compat.
  intros j Hj.
  destruct Hif as (Hic & Hop & Hin & H10 & Hit & Hde & Hch).
  rewrite rngl_mul_comm; [ | easy ].
  rewrite rngl_mul_mul_swap; [ | easy ].
  rewrite (List_map_nth' 0); [ | rewrite seq_length; flia Hr ].
  rewrite (List_map_nth' 0); [ | rewrite seq_length; flia Hj Hc ].
  rewrite seq_nth; [ | flia Hr ].
  rewrite seq_nth; [ | flia Hj Hc ].
  rewrite Nat.sub_0_r.
  do 3 rewrite Nat.add_0_l.
  easy.
}
move i before n.
move Hiz after Hlin.
destruct n; [ easy | cbn ].
rewrite Nat.sub_0_r.
symmetry.
erewrite rngl_summation_eq_compat. 2: {
  intros j Hj.
  destruct Hif as (Hic & Hop & Hin & H10 & Hit & Hde & Hch) in Hj.
  rewrite (List_map_nth' 0); [ | rewrite seq_length; flia Hlin Hr ].
  rewrite (List_map_nth' 0); [ | rewrite seq_length; flia Hj Hc ].
  rewrite seq_nth; [ | flia Hlin Hr ].
  rewrite seq_nth; [ | flia Hj Hc ].
  do 2 rewrite Nat.add_0_l.
  rewrite rngl_mul_comm; [ | easy ].
  rewrite rngl_mul_mul_swap; [ | easy ].
  easy.
}
cbn.
rename i into p.
remember (mat_swap_rows 0 p M) as M'.
erewrite rngl_summation_eq_compat. 2: {
  intros j Hj.
  rewrite rngl_mul_mul_swap; [ | now destruct Hif ].
  rewrite Nat.add_comm.
  rewrite minus_one_pow_add_r; [ | now destruct Hif ].
  do 2 rewrite <- rngl_mul_assoc.
  rewrite rngl_mul_comm; [ | now destruct Hif ].
  rewrite rngl_mul_assoc.
  remember (minus_one_pow p * _)%F as x eqn:Hx.
  rewrite <- rngl_opp_involutive in Hx; [ | now destruct Hif ].
  rewrite <- rngl_mul_opp_l in Hx; [ | now destruct Hif ].
  specialize determinant_subm_mat_swap_rows_0_i as H1.
  specialize (H1 Hif).
  specialize (H1 n M p j Hsm).
  cbn in H1.
  rewrite <- H1 in Hx; [ | flia Hiz Hlin | easy ].
  subst x; clear H1.
  rewrite rngl_mul_comm; [ | now destruct Hif ].
  rewrite rngl_mul_assoc, rngl_mul_mul_swap; [ | now destruct Hif ].
  replace (mat_el M p j) with (mat_el (mat_swap_rows 0 p M) 0 j). 2: {
    unfold mat_swap_rows.
    cbn; unfold list_swap_elem.
    rewrite fold_mat_nrows.
    rewrite (List_map_nth' 0); [ | rewrite seq_length; flia Hr ].
    rewrite seq_nth; [ | flia Hr ].
    rewrite Nat.add_0_r, transposition_1.
    easy.
  }
  rewrite <- HeqM'.
  rewrite rngl_mul_opp_r; [ | now destruct Hif ].
  easy.
}
cbn.
rewrite <- rngl_opp_summation; [ | now destruct Hif ].
do 2 rewrite <- determinant_succ.
subst M'.
rewrite <- rngl_opp_involutive; [ | now destruct Hif ].
f_equal.
apply determinant_alternating; try easy; flia Hiz.
Qed.

Theorem rngl_product_seq_permut :
  rngl_is_comm = true →
  ∀ n σ (f : nat → T),
  n ≠ 0
  → is_permut n σ
  → ∏ (i = 0, n - 1), f (ff_app σ i) = ∏ (i = 0, n - 1), f i.
Proof.
intros Hic * Hnz Hσ.
destruct n; [ easy | clear Hnz ].
rewrite Nat_sub_succ_1.
destruct Hσ as ((Hs, Hinj) & Hσl).
revert σ Hs Hinj Hσl.
induction n; intros; cbn. {
  do 2 rewrite rngl_product_only_one.
  destruct σ as [| a l]; [ easy | ].
  destruct l; [ | easy ].
  specialize (Hs a (or_introl eq_refl)).
  now apply Nat.lt_1_r in Hs; subst a.
}
set
  (g := λ i,
   if lt_dec i (ff_app (permut_list_inv σ) (S n)) then i else i + 1).
set (σ' := map (λ i, ff_app σ (g i)) (seq 0 (S n))).
assert (Hσ'l : length σ' = S n). {
  now unfold σ'; rewrite map_length, seq_length.
}
move g after Hσl; move σ' after Hσl.
specialize (IHn σ').
rewrite Hσ'l in IHn.
assert (Hs' : ∀ x, x ∈ σ' → x < S n). {
  intros x Hx.
  apply in_map_iff in Hx.
  destruct Hx as (i & Hxi & Hi); apply in_seq in Hi.
  rewrite <- Hxi.
  unfold g.
  destruct (lt_dec i _) as [His| His]. {
    specialize (Hs (ff_app σ i)) as H1.
    assert (H : ff_app σ i ∈ σ) by (apply nth_In; rewrite Hσl; flia Hi).
    specialize (H1 H); clear H.
    rewrite Hσl in H1.
    enough (H : ff_app σ i ≠ S n) by flia H1 H; intros Hσs.
    rewrite <- Hσs in His.
    rewrite (permut_inv_permut (S (S n))) in His; [ | easy | flia Hi ].
    now apply lt_irrefl in His.
  } {
    rewrite Nat.add_1_r.
    specialize (Hs (ff_app σ (S i))) as H1.
    assert (H : ff_app σ (S i) ∈ σ). {
      apply nth_In; rewrite Hσl.
      now apply -> Nat.succ_lt_mono.
    }
    specialize (H1 H); clear H.
    rewrite Hσl in H1.
    enough (H : ff_app σ (S i) ≠ S n) by flia H1 H; intros Hσs.
    rewrite <- Hσs in His.
    rewrite (permut_inv_permut (S (S n))) in His; [ | easy | flia Hi ].
    now apply His.
  }
}
move Hs' before Hs.
specialize (IHn Hs').
assert (H : ∀ i j, i < S n → j < S n → ff_app σ' i = ff_app σ' j → i = j). {
  intros i j Hi Hj Hij; unfold σ', ff_app in Hij.
  rewrite (List_map_nth' 0) in Hij; [ | now rewrite seq_length ].
  rewrite (List_map_nth' 0) in Hij; [ | now rewrite seq_length ].
  rewrite seq_nth in Hij; [ | easy ].
  rewrite seq_nth in Hij; [ | easy ].
  do 2 rewrite Nat.add_0_l in Hij.
  unfold g in Hij; cbn in Hij.
  rewrite Hσl in Hinj.
  destruct (lt_dec i _) as [His| His]. {
    destruct (lt_dec j _) as [Hjs| Hjs]. {
      apply Hinj in Hij; [ easy | flia Hi | flia Hj ].
    }
    rewrite Nat.add_1_r in Hij.
    apply Nat.nlt_ge in Hjs.
    apply Hinj in Hij; [ flia His Hjs Hij | flia Hi | ].
    now apply -> Nat.succ_lt_mono.
  }
  apply Nat.nlt_ge in His.
  rewrite Nat.add_1_r in Hij.
  destruct (lt_dec j _) as [Hjs| Hjs]. {
    apply Hinj in Hij; [ flia His Hjs Hij | | flia Hj ].
    now apply -> Nat.succ_lt_mono.
  }
  rewrite Nat.add_1_r in Hij.
  apply Nat.succ_lt_mono in Hi, Hj.
  apply Hinj in Hij; [ | easy | easy ].
  now apply Nat.succ_inj in Hij.
}
specialize (IHn H eq_refl); clear H.
remember (ff_app (permut_list_inv σ) (S n)) as k eqn:Hk.
destruct (Nat.eq_dec k (S n)) as [Hksn| Hksn]. {
  erewrite rngl_product_eq_compat in IHn. 2: {
    intros i Hi.
    unfold σ', g; cbn - [ seq ].
    unfold ff_app.
    rewrite (List_map_nth' 0); [ | rewrite seq_length; flia Hi ].
    rewrite seq_nth; [ | flia Hi ].
    rewrite Nat.add_0_l.
    destruct (lt_dec i k) as [H| H]; [ easy | flia Hksn Hi H ].
  }
  cbn in IHn.
  rewrite rngl_product_split_last; [ | flia ].
  rewrite rngl_product_succ_succ' with (g0 := λ i, f (ff_app σ i)).
  symmetry.
  rewrite rngl_product_split_last; [ | flia ].
  rewrite rngl_product_succ_succ'.
  symmetry; unfold ff_app at 1.
  rewrite IHn; f_equal; f_equal.
  rewrite Hk in Hksn.
  rewrite <- Hksn at 1.
  now apply (permut_permut_inv (S (S n))).
}
specialize permut_list_inv_is_permut_list as H1.
specialize (H1 σ).
assert (H : is_permut_list σ) by easy.
specialize (H1 H); clear H.
rewrite rngl_product_split with (j := k) in IHn. 2: {
  split; [ flia | ].
  destruct H1 as (H1 & H2).
  apply -> Nat.succ_le_mono.
  rewrite length_permut_list_inv, Hσl in H1.
  specialize (H1 k).
  assert (H : k ∈ permut_list_inv σ). {
    rewrite Hk.
    apply nth_In.
    now rewrite length_permut_list_inv, Hσl.
  }
  specialize (H1 H); clear H.
  flia Hksn H1.
}
rewrite rngl_product_split_last in IHn; [ | flia ].
destruct (Nat.eq_dec k 0) as [Hkz| Hkz]. {
  move Hkz at top; subst k.
  rewrite rngl_product_empty in IHn; [ | flia ].
  rewrite rngl_mul_1_l, Nat.add_0_l in IHn.
  unfold σ' in IHn at 1.
  cbn - [ seq ] in IHn.
  unfold ff_app in IHn at 1.
  rewrite (List_map_nth' 0) in IHn; [ | rewrite seq_length; flia ].
  rewrite seq_nth in IHn; [ | flia ].
  rewrite Nat.add_0_l in IHn.
  erewrite rngl_product_eq_compat in IHn. 2: {
    intros i Hi.
    unfold ff_app, σ'.
    rewrite (List_map_nth' 0); [ | rewrite seq_length; flia Hi ].
    rewrite seq_nth; [ | flia Hi ].
    rewrite Nat.add_0_l.
    easy.
  }
  symmetry.
  rewrite rngl_product_split_last; [ | flia ].
  rewrite rngl_product_succ_succ'.
  rewrite <- IHn.
  symmetry.
  rewrite rngl_product_split_first; [ | flia ].
  rewrite rngl_product_succ_succ.
  rewrite rngl_product_split_first; [ | flia ].
  rewrite rngl_mul_comm; [ | easy ].
  do 2 rewrite <- rngl_mul_assoc.
  f_equal.
  f_equal. 2: {
    f_equal; rewrite Hk.
    now apply (permut_permut_inv (S (S n))).
  }
  apply rngl_product_eq_compat.
  intros i Hi.
  unfold g; rewrite Nat.add_1_r.
  destruct (lt_dec i 0) as [H| H]; [ flia Hi H | easy ].
}
erewrite rngl_product_eq_compat in IHn. 2: {
  intros i Hi.
  unfold σ'; cbn - [ seq ].
  assert (H : i - 1 < S n). {
    destruct H1 as (H1, H2).
    specialize (H1 k).
    assert (H : k ∈ permut_list_inv σ). {
      rewrite Hk; unfold ff_app.
      apply nth_In.
      now rewrite length_permut_list_inv, Hσl.
    }
    specialize (H1 H); clear H.
    rewrite length_permut_list_inv, Hσl in H1.
    flia H1 Hi.
  }
  unfold ff_app at 1.
  rewrite (List_map_nth' 0); [ | now rewrite seq_length ].
  rewrite seq_nth; [ | easy ].
  rewrite Nat.add_0_l.
  unfold g.
  clear H.
  destruct (lt_dec (i - 1) k) as [H| H]; [ | flia Hi H ].
  easy.
}
cbn - [ seq ] in IHn.
destruct k; [ easy | clear Hkz ].
rewrite rngl_product_succ_succ' with (g0 := λ i, f (ff_app σ i)) in IHn.
erewrite rngl_product_eq_compat with (b := S k + 1) in IHn. 2: {
  intros i Hi.
  unfold ff_app, σ'.
  rewrite (List_map_nth' 0); [ | rewrite seq_length; flia Hi ].
  rewrite seq_nth; [ | flia Hi ].
  rewrite Nat.add_0_l.
  unfold g.
  destruct (lt_dec i (S k)) as [H| H]; [ flia Hi H | easy ].
}
cbn in IHn.
rewrite rngl_mul_mul_swap in IHn; [ | easy ].
symmetry.
rewrite rngl_product_split_last; [ | flia ].
rewrite rngl_product_succ_succ'.
rewrite <- IHn.
symmetry.
rewrite rngl_product_split with (j := k). 2: {
  split; [ flia | ].
  rewrite Hk.
  destruct H1 as (H1, H2).
  rewrite length_permut_list_inv, Hσl in H1.
  apply Nat.lt_le_incl.
  apply H1, nth_In.
  now rewrite length_permut_list_inv, Hσl.
}
do 2 rewrite <- rngl_mul_assoc.
f_equal.
rewrite rngl_product_split_last. 2: {
  rewrite Nat.add_1_r, Hk.
  destruct H1 as (H1, H2).
  rewrite length_permut_list_inv, Hσl in H1.
  apply Nat.lt_succ_r.
  apply H1, nth_In.
  now rewrite length_permut_list_inv, Hσl.
}
rewrite rngl_product_succ_succ' with (g0 := λ i, f (ff_app σ i)).
rewrite rngl_product_split_first. 2: {
  rewrite Nat.add_1_r.
  destruct H1 as (H1, H2).
  rewrite length_permut_list_inv, Hσl in H1.
  specialize (H1 (S k)).
  assert (H : S k ∈ permut_list_inv σ). {
    rewrite Hk.
    apply nth_In.
    now rewrite length_permut_list_inv, Hσl.
  }
  specialize (H1 H); clear H.
  flia Hksn H1.
}
replace (ff_app σ (k + 1)) with (S n). 2: {
  rewrite Nat.add_1_r.
  rewrite Hk.
  symmetry.
  now apply (permut_permut_inv (S (S n))).
}
rewrite <- rngl_mul_assoc.
rewrite rngl_mul_comm; [ | easy ].
rewrite rngl_mul_assoc.
f_equal.
destruct
  (Nat.eq_dec (ff_app (permut_list_inv σ) (S n)) n) as [H7| H7]. {
  rewrite H7 in Hk.
  rewrite Nat.add_1_r.
  rewrite Hk.
  rewrite rngl_product_empty; [ | flia ].
  rewrite rngl_product_empty; [ | flia ].
  rewrite (List_map_nth' 0); [ | rewrite seq_length; flia Hk ].
  rewrite seq_nth; [ | flia Hk ].
  unfold g; cbn.
  destruct (lt_dec (S k) (S k)) as [H| H]; [ flia H | clear H ].
  now rewrite Nat.add_1_r, Hk.
}
assert (Hkn : S (k + 1) ≤ n). {
  rewrite Nat.add_1_r.
  destruct H1 as (H1, H2).
  apply Nat.le_succ_l.
  rewrite length_permut_list_inv, Hσl in H1.
  specialize (H1 (S k)).
  assert (H : S k ∈ permut_list_inv σ). {
    rewrite Hk.
    apply nth_In.
    now rewrite length_permut_list_inv, Hσl.
  }
  specialize (H1 H); clear H.
  rewrite <- Hk in H7.
  flia Hksn H1 H7.
}
rewrite rngl_product_split_first; [ | easy ].
rewrite <- rngl_mul_assoc.
rewrite rngl_mul_comm; [ | easy ].
unfold g.
rewrite (List_map_nth' 0); [ | rewrite seq_length; flia Hkn ].
rewrite seq_nth; [ | flia Hkn ].
rewrite Nat.add_1_r.
cbn.
destruct (lt_dec (S k) (S k)) as [H| H]; [ flia H | clear H ].
rewrite Nat.add_1_r.
f_equal.
symmetry.
rewrite rngl_product_split_last; [ | flia Hkn ].
rewrite Nat.add_1_r.
f_equal.
apply rngl_product_eq_compat.
intros i Hi.
rewrite Nat.sub_add; [ easy | flia Hi ].
Qed.

Theorem permut_comp_assoc : ∀ n f g h,
  length g = n
  → is_permut n h
  → (f ° (g ° h) = (f ° g) ° h)%F.
Proof.
intros * Hg (Hph, Hh).
unfold "°", comp_list; cbn.
rewrite map_map.
apply map_ext_in.
intros i Hi.
unfold ff_app.
rewrite (List_map_nth' 0); [ easy | ].
rewrite Hg, <- Hh.
now apply Hph.
Qed.

Theorem List_find_nth_not_None : ∀ n l i,
  is_permut n l
  → i < n
  → List_find_nth (Nat.eqb i) l ≠ None.
Proof.
intros n f i (Hs, Hf) Hi Hx.
specialize (List_find_nth_None 0 _ _ Hx) as H1; cbn.
specialize (pigeonhole_list n (i :: f)) as H2.
rewrite List_length_cons in H2.
assert (H : n < S (length f)) by now rewrite Hf.
specialize (H2 H); clear H.
assert (H : ∀ x, x ∈ i :: f → x < n). {
  intros x [Hxi| Hxf]; [ now subst x | ].
  now rewrite <- Hf; apply Hs.
}
specialize (H2 H); clear H.
remember (pigeonhole_comp_list (i :: f)) as xx eqn:Hxx.
symmetry in Hxx.
destruct xx as (x, x').
specialize (H2 x x' eq_refl).
destruct H2 as (Hxf & Hx'f & Hxx' & Hxx'if).
destruct x. {
  rewrite List_nth_0_cons in Hxx'if.
  destruct x'; [ easy | ].
  apply Nat.succ_lt_mono in Hx'f.
  cbn in Hxx'if.
  specialize (H1 x' Hx'f).
  now apply Nat.eqb_neq in H1.
}
rewrite List_nth_succ_cons in Hxx'if.
destruct x'. {
  apply Nat.succ_lt_mono in Hxf.
  cbn in Hxx'if; symmetry in Hxx'if.
  specialize (H1 x Hxf).
  now apply Nat.eqb_neq in H1.
}
cbn in Hxx'if.
apply Nat.succ_lt_mono in Hxf, Hx'f.
apply Hs in Hxx'if; [ | easy | easy ].
now rewrite Hxx'if in Hxx'.
Qed.

Theorem comp_permut_permut_inv : ∀ n f,
  is_permut n f
  → (f ° permut_list_inv f = seq 0 n).
Proof.
intros * Hf.
unfold "°"; cbn.
unfold permut_list_inv.
rewrite map_map.
rewrite (List_map_nth_seq (seq 0 n)) with (d := 0).
rewrite seq_length.
destruct Hf as (Hs, Hf).
rewrite Hf.
apply map_ext_in.
intros i Hi; apply in_seq in Hi.
rewrite seq_nth; [ | easy ].
rewrite Nat.add_0_l.
remember (List_find_nth (Nat.eqb i) f) as x eqn:Hx.
symmetry in Hx.
destruct x as [x| ]. {
  apply (List_find_nth_Some 0) in Hx; cbn.
  destruct Hx as (Hx & Hbef & Hix).
  now apply Nat.eqb_eq in Hix.
} {
  exfalso.
  revert Hx.
  now apply (List_find_nth_not_None (conj Hs Hf)).
}
Qed.

Theorem comp_permut_inv_permut : ∀ n f,
  is_permut n f
  → (permut_list_inv f ° f = seq 0 n).
Proof.
intros * Hf.
unfold "°"; cbn.
rewrite (List_map_nth_seq f) with (d := 0) at 2.
rewrite (List_map_nth_seq (seq 0 n)) with (d := 0).
rewrite (proj2 Hf).
rewrite seq_length.
rewrite map_map.
apply map_ext_in.
intros i Hi; apply in_seq in Hi.
destruct Hi as (_, Hi); cbn in Hi.
rewrite seq_nth; [ | easy ].
now apply (permut_inv_permut n).
Qed.

Theorem comp_id_l : ∀ n l, (∀ i, i ∈ l → i < n) → seq 0 n ° l = l.
Proof.
intros * Hn.
unfold "°".
unfold ff_app.
erewrite map_ext_in. 2: {
  intros i Hi.
  rewrite seq_nth; [ | now apply Hn ].
  now rewrite Nat.add_0_l.
}
apply map_id.
Qed.

Theorem comp_id_r : ∀ n l, length l = n → l ° seq 0 n = l.
Proof.
intros * Hn.
now symmetry; apply List_map_nth_seq'.
Qed.

(*
Fixpoint vect_eqb_loop A (n : nat) (eqb : A → A → bool) d (u v : vector A) i :=
  match i with
  | 0 => true
  | S i' =>
      if eqb (vect_el d u i') (vect_el d v i') then
        vect_eqb_loop n eqb d u v i'
      else false
  end.

Definition vect_eqb A (n : nat) (eqb : A → A → bool) d (u v : vector A) : bool :=
  vect_eqb_loop n eqb d u v n.

*)

Fixpoint vect_find_loop A (f : A → bool) d (u : vector A) i :=
  match i with
  | 0 => 0
  | S i' => if f (vect_el d u i') then i else vect_find_loop f d u i'
  end.

(* 0 => not found ; S n => found at position n *)
Definition vect_find A n (f : A → bool) d (u : vector A) : nat :=
  vect_find_loop f d u n.

(*
Check is_permut_vect.

Theorem sym_gr_surj : ∀ n (σ : vector (vector nat)) p,
  n ≠ 0
  → is_sym_gr_vect n! σ
  → is_permut_vect n p
  → { i | i < n! ∧ vect_el (vect_zero 0) σ i = p }.
Proof.
intros * Hnz Hσ Hp.
destruct Hσ as (H1, H2).
destruct Hp as (H3, H4).
exists (vect_find (vect_eqb Nat.eqb p) σ - 1).
split. {
  unfold vect_find.
...
*)

(*
Theorem sym_gr_surj : ∀ n (σ : vector n! _) p,
  n ≠ 0
  → is_sym_gr_vect σ
  → is_permut_vect p
  → { i | i < n! ∧ vect_el σ i = p }.
Proof.
intros * Hnz Hσ Hp.
destruct Hσ as (H1, H2).
destruct Hp as (H3, H4).
exists (vect_find (vect_eqb Nat.eqb p) σ - 1).
split. {
  unfold vect_find.
...
Print is_sym_gr.
Print Module Pigeonhole.
Check find.
Print vector_eq.
Search (vector _ _ → vector _ _ → bool).
Search (vector _ _ → vector _ _ → _).
...
Check (permut_fun_inv_loop (λ k, vect_el (vect_el σ k) n)).
Print permut_fun_inv_loop.
Check (λ k, vect_el (vect_el σ k)).
Print permut_fun_inv_loop.
Print permut_fun_inv_loop'.
Print is_permut_fun.
Search permut_fun_inv_loop.
...
unfold is_permut_fun in H2.
Print permut_fun_inv_loop'.
permut_fun = vect_el σ
exists (permut_fun_inv_loop n
...

Theorem glop : ∀ n (σ σ' : vector n! _),
  n ≠ 0
  → is_sym_gr σ
  → is_sym_gr σ'
  → { σ'' : vector n! _ |
      is_sym_gr σ'' ∧ ∀ i, vect_el σ i ° vect_el σ'' i = vect_el σ' i }.
Proof.
intros * Hnz Hσ Hσ'.
destruct Hσ as (H1, H2).
destruct Hσ' as (H3, H4).
...
*)

(*
Theorem glop : ∀ n sg,
  is_sym_gr_vect n sg
  → ∀ i j k, i < n → j < n
  → length (filter (λ v, vect_el 0 v i =? k) (vect_list sg)) =
    length (filter (λ v, vect_el 0 v j =? k) (vect_list sg)).
Proof.
intros * Hsg * Hin Hjn.
destruct Hsg as (Hsg & Hsg1 & Hsg2 & Hsg3).
...
destruct sg as (ll); cbn in Hsg, Hsg1, Hsg2, Hsg3 |-*.
...
*)

(*
Theorem length_filter_sym_gr : ∀ n sg i,
  i ≤ n
  → is_sym_gr_vect (S n) sg
  → length (filter (λ v, vect_el 0 v 0 =? i) (vect_list sg)) = n!.
Proof.
intros * Hin Hsg.
revert sg i Hsg Hin.
induction n; intros. {
  apply Nat.le_0_r in Hin; subst i.
  destruct Hsg as (Hsg & Hsg1 & Hsg2 & Hsg3).
  destruct sg as (ll); cbn in Hsg |-*.
  destruct ll as [| la]; [ easy | ].
  destruct ll; [ clear Hsg; cbn | easy ].
  rewrite if_eqb_eq_dec.
  destruct (Nat.eq_dec (vect_el 0 la 0) 0) as [Hi| Hi]; [ easy | exfalso ].
  apply Hi; clear Hi.
  cbn - [ vect_el ] in Hsg1, Hsg2, Hsg3.
  specialize (Hsg1 0 Nat.lt_0_1).
  cbn in Hsg1.
  specialize (Hsg3 0 Nat.lt_0_1).
  cbn in Hsg3.
  destruct Hsg3 as (H1, H2).
  specialize (H1 0 Nat.lt_0_1).
  now apply Nat.lt_1_r in H1.
}
...

Theorem glop : ∀ n sg σ,
  is_sym_gr_vect n sg
  → is_permut_vect n σ
  → (∀ j, j < length (vect_list sg) → σ ≠ vect_el empty_vect sg j)
  → False.
Proof.
intros * Hsg Hσ Hsσg.
revert sg σ Hsg Hσ Hsσg.
induction n; intros. {
  destruct Hsg as (Hsg & Hsg1 & Hsg2 & Hsg3).
  destruct Hσ as (Hs & Hσ1 & Hσ2).
  specialize (Hsg1 0 Nat.lt_0_1).
  specialize (Hsσg 0).
  assert (H : 0 < length (vect_list sg)). {
    unfold vect_size in Hsg.
    rewrite Hsg; cbn; flia.
  }
  specialize (Hsσg H); clear H.
  apply Hsσg.
  destruct σ as (l).
  destruct sg as (lv).
  cbn in Hsg, Hs |-*.
  apply length_zero_iff_nil in Hs; subst l.
  destruct lv as [| v]; [ easy | ].
  destruct lv as [| v1]; [ | easy ].
  cbn in Hsg1.
  unfold vect_size in Hsg1.
  apply length_zero_iff_nil in Hsg1.
  destruct v as (l').
  now cbn in Hsg1; subst l'.
}
(* create an sg of size n! from sg by removing all permutations but
   the ones starting with n, and removing in them this initial n *)
set (ll1 := filter (λ v, vect_el 0 v 0 =? n) (vect_list sg)).
set (ll2 := map (λ v, mk_vect (map (λ i, vect_el 0 v (S i)) (seq 0 n!))) ll1).
set (sg' := mk_vect ll2).
specialize (IHn sg') as H1.
set (k := unsome 0 (List_find_nth (Nat.eqb n) (vect_list σ))).
set (l := map (λ i, vect_el 0 σ (if lt_dec i n then i else S i)) (seq 0 n)).
set (σ' := mk_vect l).
specialize (H1 σ').
assert (H : is_sym_gr_vect n sg'). {
  split. {
    unfold sg', ll2, ll1; cbn.
    rewrite map_length.
    destruct Hsg as (Hsg & Hsg1 & Hsg2 & Hsg3).
...
now apply length_filter_sym_gr.
...
Search (length (filter _ _)).
...
destruct sg as (lv).
cbn in Hsσg.
destruct Hsg as (Hsg & Hsg1 & Hsg2 & Hsg3).
cbn in Hsg, Hsg1, Hsg2, Hsg3.
destruct σ as (l).
destruct Hσ as (Hs & Hσ1 & Hσ2).
cbn in Hs, Hσ1, Hσ2.
rewrite Hsg in Hsσg.
...

Theorem glop : ∀ n sg σ,
  is_sym_gr_vect n sg
  → is_permut_vect n σ
  → vect_el empty_vect sg (rank_of_permut_in_sym_gr sg σ) = σ.
Proof.
intros * Hsg Hσ.
unfold rank_of_permut_in_sym_gr.
unfold unsome.
remember (List_find_nth _ _) as i eqn:Hi; symmetry in Hi.
destruct i as [i| ]. {
  clear Hsg Hσ.
  specialize (List_find_nth_Some empty_vect (vect_eqb Nat.eqb σ)) as H1.
  specialize (H1 (vect_list sg) i Hi).
  destruct H1 as (H1, H2).
  now apply vect_eqb_eq in H2.
} {
  exfalso.
  specialize (List_find_nth_None empty_vect (vect_eqb Nat.eqb σ)) as H1.
  specialize (H1 (vect_list sg) Hi).
  assert
    (Hjσ : ∀ j, j < length (vect_list sg) → σ ≠ vect_el empty_vect sg j). {
    intros j Hj.
    apply vect_eqb_neq.
    now apply H1.
  }
  clear H1.
  clear Hi.
...
  destruct Hsg as (Hsg & Hsg1 & Hsg2 & Hsg3).
  destruct Hσ as (Hs & Hσ1 & Hσ2).
...
cbn in H0.
...
About vect_eqb_eq.
Theorem vect_eqb_neq : ∀ u v : vector nat,
  vect_eqb Nat.eqb u v = false → u ≠ v.
Proof.
Admitted.
specialize (H1 0).
assert (H : 0 < length (vect_list sg)) by ...
specialize (H1 H); clear H.
apply vect_eqb_neq in H1.
unfold vect_el.
...
  specialize (List_find_nth_None empty_vect sg) as H1.
...
  apply List_find_nth_None in Hi.
...
Print vect_find_nth_loop.
Theorem glop : ∀ A f d (v : vector A) i j,
  vect_size v ≤ i
  → vect_find_nth_loop f i d v = Some j
  → f (vect_el d v j) = true.
Proof.
intros * Hvi Hj.
revert v j Hvi Hj.
induction i; intros; [ easy | ].
cbn in Hj.
remember (f (vect_el d v i)) as b eqn:Hb; symmetry in Hb.
destruct b; [ now injection Hj; clear Hj; intros; subst j | ].
destruct (Nat.eq_dec (vect_size v) (S i)) as [Hvsi| Hvsi]. 2: {
  apply IHi; [ | easy ].
  flia Hvi Hvsi.
}
clear Hvi.
...
specialize (IHi (mk_vect (removelast (vect_list v)))) as H1.
specialize (H1 j).
cbn in H1.
assert (H : length (removelast (vect_list v)) ≤ i). {
  clear - Hvsi.
  destruct v as (la); cbn in Hvsi |-*.
  induction la using rev_ind; [ easy | ].
  rewrite app_length, Nat.add_1_r in Hvsi.
  apply Nat.succ_inj in Hvsi.
  rewrite removelast_last.
  now rewrite Hvsi.
}
specialize (H1 H); clear H.
assert (H : vect_find_nth_loop f i d (mk_vect (removelast (vect_list v))) = Some j). {
  clear - Hb Hj Hvsi.
  induction i; [ easy | ].
  cbn in Hj |-*.
...
destruct i; [ easy | ].
cbn in Hj.
remember (f (vect_el d v i)) as b1 eqn:Hb1.
symmetry in Hb1.
destruct b1. {
  now injection Hj; clear Hj; intros; subst j.
}
...
*)

(*
Theorem fun_betw_sym_gr : ∀ n (sg sg' : vector _),
  n ≠ 0
  → is_sym_gr_vect n sg
  → is_sym_gr_vect n sg'
  → { f | ∀ i, i < n! →
      vect_el empty_vect sg (f i) = vect_el empty_vect sg' i }.
Proof.
intros * Hnz Hsg Hsg'.
exists (λ i, rank_of_permut_in_sym_gr sg (vect_el empty_vect sg' i)).
intros i Hi.
Theorem rank_of_permut_in_sym_gr_enough_iter : ∀ it sg σ,
  vect_size sg ≤ it
  → rank_of_permut_in_sym_gr sg σ =
    match vect_find_nth_loop (vect_eqb Nat.eqb σ) it {| vect_list := [] |} sg with
    | Some i => i
    | None => 0
    end.
Proof.
intros * Hit.
induction it; cbn. {
  apply Nat.le_0_r in Hit.
  unfold rank_of_permut_in_sym_gr.
  now rewrite Hit.
}
(**)
destruct (Nat.eq_dec (vect_size sg) (S it)) as [Hs| Hs]. {
  unfold rank_of_permut_in_sym_gr.
  now rewrite Hs.
}
assert (H : vect_size sg ≤ it) by flia Hit Hs.
specialize (IHit H); clear H.
remember (vect_eqb Nat.eqb σ (vect_el empty_vect sg it)) as b eqn:Hb.
symmetry in Hb.
destruct b; [ | apply IHit ].
apply vect_eqb_eq in Hb.
rewrite Hb.
...
remember (vect_size sg) as s eqn:Hs.
replace (vect_size sg) with (vect_size sg + 0) in Hs by flia.
remember 0 as m eqn:Hm in Hs.
clear Hm; subst s.
revert m.
remember (vect_size sg) as s eqn:Hs; symmetry in Hs.
clear Hs.
induction s; intros. {
  destruct Hsg as (Hsgs & Hsges & H3 & H4).
  rewrite Hsgs in Hs.
  now apply fact_neq_0 in Hs.
}
cbn.
remember
  (vect_eqb Nat.eqb (vect_el {| vect_list := [] |} sg' i)
     (vect_el {| vect_list := [] |} sg (s + m)))
  as b eqn:Hb; symmetry in Hb.
destruct b; [ now apply vect_eqb_eq in Hb | ].
rewrite <- rank_of_permut_in_sym_gr_enough_iter.
unfold rank_of_permut_in_sym_gr.
rewrite Hs.
...
apply IHs.
...

specialize (rank_of_permut_in_sym_gr_enough_iter) as H1.
specialize (H1 (s + m) sg).
remember (vect_el empty_vect sg' i) as σ eqn:Hσ.
specialize (H1 σ).
...
rewrite <- rank_of_permut_in_sym_gr_enough_iter.
...
*)

(*
Theorem fun_betw_sym_gr : ∀ n (σ σ' : vector n! _),
  n ≠ 0
  → is_sym_gr σ
  → is_sym_gr σ'
  → { f | ∀ i, i < n! → vect_el σ (f i) = vect_el σ' i }.
Proof.
intros * Hnz Hσ Hσ'.
destruct n; [ easy | clear Hnz ].
destruct Hσ as (H1, H2).
destruct Hσ' as (H3, H4).
assert (Hσp : ∀ p, is_permut_fun p → { i | vect_el σ i = p }). {
  intros p Hp.
...
intros * Hnz Hσ Hσ'.
destruct n; [ easy | clear Hnz ].
induction n. {
  cbn.
  exists (λ i, i).
  intros i Hi.
  apply vector_eq.
  intros j Hj.
  apply Nat.lt_1_r in Hi.
  apply Nat.lt_1_r in Hj.
  subst i j.
  destruct Hσ as (H1, H2).
  destruct Hσ' as (H3, H4).
  specialize (H2 0 Nat.lt_0_1).
  destruct H2 as (H2, H2').
  specialize (H2 0 Nat.lt_0_1).
  apply Nat.lt_1_r in H2.
  specialize (H4 0 Nat.lt_0_1).
  destruct H4 as (H4, H4').
  specialize (H4 0 Nat.lt_0_1).
  apply Nat.lt_1_r in H4.
  cbn in H2, H4.
  congruence.
}
Check (mk_vect (S n)! (λ i, vect_el σ (i / (S n)!))).
assert (∀ i, i < S (S n)! → IHn (
...
specialize (IHn (mk_vect (S n)! (λ i, let j := i / (S n)! in
...
intros * Hσ Hσ'.
destruct Hσ as (H1, H2).
destruct Hσ' as (H3, H4).
...
*)

Theorem det_by_any_sym_gr : rngl_is_field →
  ∀ n (M : matrix T) (sg : list (list nat)),
  n ≠ 0
  → is_square_matrix n M = true
  → is_sym_gr_list n sg
  → determinant n M =
    ∑ (k = 0, n! - 1),
    ε n (nth k sg []) *
    ∏ (i = 1, n), mat_el M (i - 1) (ff_app (nth k sg []) (i - 1)).
Proof.
intros (Hic & Hop & Hiv & H10 & Hit & Hed & Hch) * Hnz Hsm Hsg.
rewrite det_is_det_by_canon_permut; try easy.
unfold determinant'.
set (g := λ i, canon_sym_gr_list_inv n (nth i sg [])).
set (h := λ i, sym_gr_inv sg (canon_sym_gr_list n i)).
rewrite rngl_summation_change_var with (g0 := g) (h0 := h). 2: {
  intros i (_, Hi).
  unfold g, h.
  rewrite (nth_sym_gr_inv_sym_gr Hsg). 2: {
    apply canon_sym_gr_list_is_permut.
    specialize (fact_neq_0 n) as H.
    flia Hi H.
  }
  apply canon_sym_gr_inv_of_canon_sym_gr.
  specialize (fact_neq_0 n) as H.
  flia Hi H.
}
rewrite Nat.sub_0_r.
rewrite <- Nat.sub_succ_l; [ | apply Nat.neq_0_lt_0, fact_neq_0 ].
rewrite Nat_sub_succ_1.
erewrite rngl_summation_list_eq_compat. 2: {
  intros i Hi.
  apply in_map_iff in Hi.
  destruct Hi as (j & Hji & Hj).
  apply in_seq in Hj.
  unfold g.
  rewrite permut_in_canon_sym_gr_of_its_rank. 2: {
    split. {
      apply Hsg; rewrite <- Hji.
      now apply (sym_gr_inv_lt _ Hnz).
    } {
      destruct Hsg as (H1 & H2 & H3).
      apply H1; rewrite <- Hji.
      now apply (sym_gr_inv_lt _ Hnz).
    }
  }
  easy.
}
cbn.
apply rngl_summation_list_permut.
rewrite Nat.sub_0_r.
rewrite <- Nat.sub_succ_l; [ | apply Nat.neq_0_lt_0, fact_neq_0 ].
rewrite Nat_sub_succ_1.
apply permut_list_Permutation.
(* lemma to do? *)
unfold h.
split; [ | now rewrite map_length, seq_length ].
split. {
  intros i Hi.
  rewrite map_length, seq_length.
  apply in_map_iff in Hi.
  destruct Hi as (j & Hji & Hj).
  apply in_seq in Hj.
  rewrite <- Hji.
  rewrite <- sym_gr_size with (sg := sg); [ | easy ].
  now apply (sym_gr_inv_lt _ Hnz).
} {
  rewrite map_length, seq_length.
  intros i j Hi Hj Hij.
  unfold ff_app in Hij.
  rewrite (List_map_nth' 0) in Hij; [ | now rewrite seq_length ].
  rewrite (List_map_nth' 0) in Hij; [ | now rewrite seq_length ].
  rewrite seq_nth in Hij; [ | easy ].
  rewrite seq_nth in Hij; [ | easy ].
  do 2 rewrite Nat.add_0_l in Hij.
  apply (@sym_gr_inv_inj n) in Hij; [ | easy | | ]; cycle 1. {
    now apply canon_sym_gr_list_is_permut.
  } {
    now apply canon_sym_gr_list_is_permut.
  }
  now apply canon_sym_gr_list_inj in Hij.
}
Qed.

Theorem map_permut_seq_is_permut : ∀ n σ,
  is_permut n σ
  → is_permut n (map (ff_app σ) (seq 0 n)).
Proof.
intros * Hσ.
split; [ | now rewrite map_length, seq_length ].
split. {
  intros i Hi.
  apply in_map_iff in Hi.
  destruct Hi as (j & Hji & Hj).
  apply in_seq in Hj.
  rewrite map_length, seq_length.
  rewrite <- Hji.
  destruct Hσ as (H1, H2).
  rewrite <- H2 in Hj |-*.
  now apply permut_list_ub.
} {
  rewrite map_length, seq_length.
  intros i j Hi Hj Hij.
  apply NoDup_nth in Hij; [ easy | | | ]; cycle 1. {
    now rewrite map_length, seq_length.
  } {
    now rewrite map_length, seq_length.
  }
  apply (NoDup_map_iff 0).
  rewrite seq_length.
  intros u v Hu Hv Huv.
  rewrite seq_nth in Huv; [ | easy ].
  rewrite seq_nth in Huv; [ | easy ].
  do 2 rewrite Nat.add_0_l in Huv.
  apply Hσ; [ destruct Hσ; congruence | destruct Hσ; congruence | easy ].
}
Qed.

Theorem rngl_product_map_permut :
  rngl_is_comm = true →
   ∀ n f σ,
  is_permut n σ
  → ∏ (i ∈ map (ff_app σ) (seq 0 n)), f i = ∏ (i = 1, n), f (i - 1)%nat.
Proof.
intros Hic * Hσ.
destruct (Nat.eq_dec n 0) as [Hnz| Hnz]; [ now subst n | ].
rewrite rngl_product_list_permut with (l2 := seq 0 n); [ | easy | ]. 2: {
  apply permut_list_Permutation.
  now apply map_permut_seq_is_permut.
}
unfold iter_seq.
rewrite Nat_sub_succ_1.
rewrite <- seq_shift.
replace n with (S (n - 1) - 0) by flia Hnz.
rewrite <- rngl_product_change_var; [ easy | ].
intros i Hi.
now rewrite Nat.sub_succ, Nat.sub_0_r.
Qed.

Theorem map_ff_app_permut_permut_is_permut : ∀ n l1 l2,
  is_permut n l1
  → is_permut n l2
  → is_permut n (map (ff_app l1) l2).
Proof.
intros n l σ (Hl1, Hl2) (Hσ1, Hσ2).
split; [ | now rewrite map_length ].
split. {
  intros i Hi; apply in_map_iff in Hi.
  destruct Hi as (j & Hji & Hj).
  rewrite map_length.
  rewrite <- Hji.
  rewrite Hσ2, <- Hl2.
  apply permut_list_ub; [ easy | ].
  rewrite Hl2, <- Hσ2.
  now apply Hσ1.
} {
  rewrite map_length.
  intros i j Hi Hj Hij.
  apply NoDup_nth in Hij; [ easy | | | ]; cycle 1. {
    now rewrite map_length.
  } {
    now rewrite map_length.
  }
  apply (NoDup_map_iff 0).
  intros u v Hu Hv Huv.
  apply Hl1 in Huv; cycle 1. {
    rewrite Hl2, <- Hσ2.
    now apply Hσ1, nth_In.
  } {
    rewrite Hl2, <- Hσ2.
    now apply Hσ1, nth_In.
  }
  now apply Hσ1 in Huv.
}
Qed.

Theorem permut_list_inv_inj2 : ∀ l1 l2,
  is_permut_list l1
  → is_permut_list l2
  → permut_list_inv l1 = permut_list_inv l2
  → l1 = l2.
Proof.
intros * Hpl1 Hpl2 Hill.
assert (Hll : length l1 = length l2). {
  apply List_eq_iff in Hill.
  now do 2 rewrite length_permut_list_inv in Hill.
}
apply (f_equal (comp_list l1)) in Hill.
rewrite (@comp_permut_permut_inv (length l1)) in Hill; [ | easy ].
apply (f_equal (λ l, comp_list l l2)) in Hill.
rewrite <- (@permut_comp_assoc (length l2)) in Hill; [ | | easy ]. 2: {
  apply length_permut_list_inv.
}
rewrite (@comp_permut_inv_permut (length l2)) in Hill; [ | easy ].
rewrite comp_id_r in Hill; [ | easy ].
rewrite comp_id_l in Hill; [ easy | ].
rewrite Hll.
apply Hpl2.
Qed.

Theorem permut_list_inv_comp : ∀ n l1 l2,
  is_permut n l1
  → is_permut n l2
  → permut_list_inv (l1 ° l2) = permut_list_inv l2 ° permut_list_inv l1.
Proof.
intros * Hnl1 Hnl2.
unfold "°".
unfold permut_list_inv; cbn.
rewrite map_length.
rewrite map_map.
destruct Hnl1 as (Hp1, Hl1).
destruct Hnl2 as (Hp2, Hl2).
rewrite Hl2, <- Hl1.
apply map_ext_in.
intros i Hi; apply in_seq in Hi.
unfold ff_app.
rewrite (List_map_nth' 0). 2: {
  rewrite seq_length.
  unfold unsome.
  remember (List_find_nth _ _) as x eqn:Hx.
  symmetry in Hx.
  destruct x as [x| ]. {
    apply (List_find_nth_Some 0) in Hx.
    destruct Hx as (Hxσ & Hbefx & Hx).
    congruence.
  }
  flia Hi.
}
remember (List_find_nth _ _) as x eqn:Hx.
remember (List_find_nth _ l2) as y eqn:Hy.
symmetry in Hx, Hy.
destruct x as [x| ]. {
  apply (List_find_nth_Some 0) in Hx.
  rewrite map_length in Hx.
  destruct Hx as (Hxl & Hbefx & Hx).
  apply Nat.eqb_eq in Hx.
  rewrite (List_map_nth' 0) in Hx; [ | easy ].
  destruct y as [y| ]. {
    apply (List_find_nth_Some 0) in Hy.
    destruct Hy as (Hyl & Hbefy & Hy).
    apply Nat.eqb_eq in Hy.
    unfold unsome in Hy.
    remember (List_find_nth (Nat.eqb i) l1) as z eqn:Hz.
    symmetry in Hz.
    destruct z as [z| ]. {
      apply (List_find_nth_Some 0) in Hz.
      destruct Hz as (Hzl & Hbefz & Hz).
      apply Nat.eqb_eq in Hz.
      rewrite seq_nth in Hy; [ | congruence ].
      rewrite Nat.add_0_l in Hy.
      rewrite Hx in Hz.
      apply Hp1 in Hz; [ | | easy ]. 2: {
        rewrite Hl1, <- Hl2.
        now apply Hp2, nth_In.
      }
      rewrite Hy in Hz.
      apply Hp2 in Hz; [ | easy | easy ].
      easy.
    }
    rewrite seq_nth in Hy; [ | flia Hi ].
    specialize (List_find_nth_None 0 _ _ Hz) as H1.
    specialize (H1 (nth x l2 0)).
    assert (H : nth x l2 0 < length l1). {
      rewrite Hl1, <- Hl2.
      apply Hp2.
      now apply (nth_In _ 0).
    }
    specialize (H1 H); clear H.
    now apply Nat.eqb_neq in H1.
  }
  exfalso.
  revert Hy.
  apply (@List_find_nth_not_None n); [ easy | ].
  unfold unsome.
  remember (List_find_nth (Nat.eqb i) l1) as z eqn:Hz.
  symmetry in Hz.
  destruct z as [z| ]. {
    apply (List_find_nth_Some 0) in Hz.
    destruct Hz as (Hzl & Hbefz & Hz).
    rewrite seq_nth; [ | easy ].
    now rewrite Hl1 in Hzl.
  }
  rewrite seq_nth; [ flia Hl2 Hxl | flia Hi ].
}
exfalso.
revert Hx.
apply (@List_find_nth_not_None n); [ | now rewrite <- Hl1 ].
now apply map_ff_app_permut_permut_is_permut.
Qed.

Theorem permut_list_inv_involutive : ∀ l,
  is_permut_list l
  → permut_list_inv (permut_list_inv l) = l.
Proof.
intros * Hl.
unfold permut_list_inv.
rewrite map_length, seq_length.
rewrite List_map_nth_seq with (d := 0).
apply map_ext_in.
intros i Hi; apply in_seq in Hi.
remember (List_find_nth _ _) as x eqn:Hx; symmetry in Hx.
destruct x as [x| ]. {
  apply (List_find_nth_Some 0) in Hx.
  rewrite map_length, seq_length in Hx.
  destruct Hx as (Hxl & Hbefx & Hx).
  rewrite (List_map_nth' 0) in Hx; [ | now rewrite seq_length ].
  rewrite seq_nth in Hx; [ | easy ].
  rewrite Nat.add_0_l in Hx.
  apply Nat.eqb_eq in Hx.
  unfold unsome in Hx.
  remember (List_find_nth (Nat.eqb x) l) as y eqn:Hy.
  symmetry in Hy.
  destruct y as [y| ]. {
    subst y.
    apply (List_find_nth_Some 0) in Hy.
    destruct Hy as (Hyl & Hbefy & Hy).
    now apply Nat.eqb_eq in Hy.
  }
  exfalso.
  revert Hy.
  apply (@List_find_nth_not_None (length l)); [ | easy ].
  easy.
}
exfalso.
revert Hx.
apply (@List_find_nth_not_None (length l)); [ | easy ].
now apply permut_list_inv_is_permut.
Qed.

Theorem mat_transp_nrows : ∀ M, mat_nrows M⁺ = mat_ncols M.
Proof.
intros.
unfold mat_ncols; cbn.
now rewrite map_length, seq_length.
Qed.

Theorem mat_transp_ncols : ∀ M, mat_ncols M ≠ 0 → mat_ncols M⁺ = mat_nrows M.
Proof.
intros * Hcr.
unfold mat_ncols; cbn.
rewrite List_hd_nth_0.
rewrite (List_map_nth' 0); [ | now rewrite seq_length; apply Nat.neq_0_lt_0 ].
now rewrite map_length, seq_length.
Qed.

Theorem mat_transp_is_square : ∀ n M,
  is_square_matrix n M = true
  → is_square_matrix n M⁺ = true.
Proof.
intros * Hsm.
specialize (square_matrix_ncols _ Hsm) as Hc.
apply is_sm_mat_iff in Hsm.
apply is_sm_mat_iff.
destruct Hsm as (Hr & Hcr & Hcl).
cbn; rewrite map_length, seq_length.
split; [ easy | ].
split. {
  intros Hct.
  destruct (Nat.eq_dec (mat_ncols M) 0) as [Hcz| Hcz]; [ easy | ].
  rewrite mat_transp_ncols in Hct; [ | easy ].
  congruence.
} {
  intros l Hl.
  apply in_map_iff in Hl.
  destruct Hl as (i & Hi & Hic).
  now rewrite <- Hi, map_length, seq_length.
}
Qed.

Theorem det_any_permut_l : rngl_is_field →
  ∀ n (M : matrix T) (σ : list nat),
  n ≠ 0
  → is_square_matrix n M = true
  → is_permut n σ
  → determinant n M =
    (∑ (μ ∈ canon_sym_gr_list_list n), ε n μ * ε n σ *
     ∏ (k = 0, n - 1), mat_el M (ff_app σ k) (ff_app μ k))%F.
Proof.
intros (Hop & Hiv & Hic & Hde & H10 & Hit & Hch) * Hnz Hsm Hσ.
erewrite rngl_summation_list_eq_compat. 2: {
  intros μ Hμ.
  assert (Hpμ : is_permut n μ). {
    apply in_map_iff in Hμ.
    destruct Hμ as (i & Hiμ & Hi).
    apply in_seq in Hi.
    rewrite <- Hiμ.
    now apply canon_sym_gr_list_is_permut.
  }
  remember (μ ° permut_list_inv σ) as ν eqn:Hν.
  assert (Hσν : ν ° σ = μ). {
    rewrite Hν.
    assert (H : length (permut_list_inv σ) = n). {
      rewrite length_permut_list_inv; apply Hσ.
    }
    rewrite <- (permut_comp_assoc _ _ H Hσ); clear H.
    rewrite (@comp_permut_inv_permut n); [ | easy ].
    apply comp_id_r, Hpμ.
  }
  subst ν.
  rewrite <- Hσν at 1.
  replace (ε n ((μ ° permut_list_inv σ) ° σ)) with
      (ε n (μ ° permut_list_inv σ) * ε n σ)%F. 2: {
    destruct Hσ.
    rewrite <- signature_comp; try easy.
    apply comp_is_permut; [ easy | ].
    now apply permut_list_inv_is_permut.
  }
  rewrite <- (rngl_mul_assoc _ (ε n σ) (ε n σ)).
  replace (ε n σ * ε n σ)%F with 1%F by now symmetry; apply ε_square.
  rewrite rngl_mul_1_r.
  easy.
}
cbn.
unfold canon_sym_gr_list_list.
rewrite <- rngl_summation_list_change_var.
rewrite rngl_summation_seq_summation; [ | apply fact_neq_0 ].
rewrite Nat.add_0_l.
erewrite rngl_summation_eq_compat. 2: {
  intros i (_, Hi).
  rewrite rngl_product_change_var with
      (g := ff_app (permut_list_inv σ)) (h := ff_app σ). 2: {
    intros j (_, Hj).
    apply (@permut_inv_permut n); [ easy | ].
    flia Hj Hnz.
  }
  rewrite Nat.sub_0_r.
  rewrite <- Nat.sub_succ_l; [ | flia Hnz ].
  rewrite Nat_sub_succ_1.
  erewrite rngl_product_list_eq_compat. 2: {
    intros j Hj.
    apply in_map_iff in Hj.
    destruct Hj as (k & Hkj & Hk).
    apply in_seq in Hk.
    rewrite (@permut_permut_inv n); [ | easy | ]. 2: {
      rewrite <- Hkj.
      destruct Hσ as (H1, H2).
      rewrite <- H2 in Hk |-*.
      now apply permut_list_ub.
    }
    easy.
  }
  cbn.
  rewrite rngl_product_map_permut; [ | easy | easy ].
  easy.
}
cbn.
set (sg := map (λ k, canon_sym_gr_list n k ° permut_list_inv σ) (seq 0 n!)).
erewrite rngl_summation_eq_compat. 2: {
  intros k Hk.
  assert (Hkn : k < n!). {
    specialize (fact_neq_0 n) as H.
    flia Hk H.
  }
  replace (_ ° _) with (nth k sg []). 2: {
    unfold sg.
    rewrite (List_map_nth' 0); [ | now rewrite seq_length ].
    now rewrite seq_nth.
  }
  erewrite rngl_product_eq_compat. 2: {
    intros i Hi.
    replace (ff_app _ _) with (ff_app (nth k sg []) (i - 1)). 2: {
      unfold sg.
      rewrite (List_map_nth' 0); [ | now rewrite seq_length ].
      rewrite seq_nth; [ | easy ].
      rewrite Nat.add_0_l.
      unfold "°".
      unfold ff_app.
      rewrite (List_map_nth' 0). 2: {
        rewrite length_permut_list_inv.
        destruct Hσ as (H1, H2); rewrite H2.
        flia Hi.
      }
      easy.
    }
    easy.
  }
  easy.
}
cbn.
apply det_by_any_sym_gr; try easy.
unfold sg.
split. {
  rewrite map_length, seq_length.
  intros i Hi.
  rewrite (List_map_nth' 0); [ | now rewrite seq_length ].
  rewrite seq_nth; [ | easy ].
  rewrite Nat.add_0_l.
  split. {
    unfold "°"; cbn.
    rewrite map_length.
    rewrite length_permut_list_inv.
    now destruct Hσ.
  } {
    apply (comp_is_permut_list n). {
      now apply canon_sym_gr_list_is_permut.
    } {
      now apply permut_list_inv_is_permut.
    }
  }
}
split. {
  rewrite map_length, seq_length.
  intros i j Hi Hj Hij.
  rewrite (List_map_nth' 0) in Hij; [ | now rewrite seq_length ].
  rewrite (List_map_nth' 0) in Hij; [ | now rewrite seq_length ].
  rewrite seq_nth in Hij; [ | easy ].
  rewrite seq_nth in Hij; [ | easy ].
  do 2 rewrite Nat.add_0_l in Hij.
  unfold "°" in Hij.
  specialize (ext_in_map Hij) as H1.
  apply (nth_canon_sym_gr_list_inj2 n); [ easy | easy | ].
  intros k Hk.
  apply H1.
(* lemme à faire ? *)
  unfold permut_list_inv.
  apply in_map_iff.
  exists (ff_app σ k).
  split. {
    unfold unsome.
    remember (List_find_nth _ _) as x eqn:Hx.
    symmetry in Hx.
    destruct x as [x| ]. {
      apply (List_find_nth_Some 0) in Hx.
      destruct Hx as (Hxl & Hbefx & Hx).
      apply Nat.eqb_eq in Hx.
      destruct Hσ as (Hσ1, Hσ2).
      rewrite <- Hσ2 in Hk.
      now apply Hσ1.
    } {
      specialize (List_find_nth_None 0 _ _ Hx) as H2.
      destruct Hσ as (Hσ1, Hσ2).
      rewrite <- Hσ2 in Hk.
      specialize (H2 k Hk).
      now rewrite Nat.eqb_refl in H2.
    }
  } {
    apply in_seq.
    split; [ easy | ].
    rewrite Nat.add_0_l.
    destruct Hσ as (Hσ1, Hσ2).
    rewrite <- Hσ2 in Hk.
    now apply permut_list_ub.
  }
} {
  intros l Hl.
  apply in_map_iff.
  destruct Hl as (Hl1, Hl2).
  destruct Hσ as (Hσ1, Hσ2).
  exists (canon_sym_gr_list_inv n (map (ff_app l) σ)).
  rewrite permut_in_canon_sym_gr_of_its_rank. 2: {
    now apply map_ff_app_permut_permut_is_permut.
  }
  split. {
    unfold "°".
    unfold ff_app.
    erewrite map_ext_in. 2: {
      intros i Hi.
      rewrite (List_map_nth' 0). 2: {
        now apply in_permut_list_inv_lt.
      }
      easy.
    }
    unfold permut_list_inv.
    rewrite map_map.
    rewrite (List_map_nth_seq l 0) at 1.
    rewrite Hl2, <- Hσ2.
    apply map_ext_in.
    intros i Hi; apply in_seq in Hi.
    unfold unsome.
    remember (List_find_nth _ _) as x eqn:Hx.
    symmetry in Hx.
    destruct x as [x| ]. {
      apply (List_find_nth_Some 0) in Hx.
      destruct Hx as (Hxσ & Hbefx & Hx).
      apply Nat.eqb_eq in Hx.
      now rewrite <- Hx.
    }
    exfalso; revert Hx.
    rewrite Hσ2 in Hi.
    now apply (List_find_nth_not_None (conj Hσ1 Hσ2)).
  }
  apply in_seq.
  split; [ easy | ].
  rewrite Nat.add_0_l.
  apply canon_sym_gr_list_inv_ub.
  now apply map_ff_app_permut_permut_is_permut.
}
Qed.

Theorem det_any_permut_r : rngl_is_field →
  ∀ n (M : matrix T) (σ : list nat),
  n ≠ 0
  → is_square_matrix n M = true
  → is_permut n σ
  → determinant n M =
    (∑ (μ ∈ canon_sym_gr_list_list n), ε n μ * ε n σ *
     ∏ (k = 0, n - 1), mat_el M (ff_app μ k) (ff_app σ k))%F.
Proof.
intros Hif * Hnz Hsm Hσ.
(*
intros Hop Hiv Hic Hde H10 Hit Hch * Hnz Hsm Hσ.
*)
erewrite rngl_summation_list_eq_compat. 2: {
  intros μ Hμ.
  assert (Hpμ : is_permut n μ). {
    apply in_map_iff in Hμ.
    destruct Hμ as (i & Hiμ & Hi).
    apply in_seq in Hi.
    rewrite <- Hiμ.
    now apply canon_sym_gr_list_is_permut.
  }
  remember (σ ° permut_list_inv μ) as ν eqn:Hν.
  assert (Hσν : ν ° μ = σ). {
    rewrite Hν.
    assert (H : length (permut_list_inv μ) = n). {
      rewrite length_permut_list_inv.
      apply Hpμ.
    }
    rewrite <- (permut_comp_assoc _ _ H); clear H; [ | apply Hpμ ].
    rewrite (@comp_permut_inv_permut n); [ | easy ].
    apply comp_id_r, Hσ.
  }
  subst ν.
  rewrite <- Hσν at 1.
  replace (ε n ((σ ° permut_list_inv μ) ° μ)) with
      (ε n (σ ° permut_list_inv μ) * ε n μ)%F. 2: {
    destruct Hif.
    rewrite <- signature_comp; try easy.
    apply comp_is_permut; [ easy | ].
    now apply permut_list_inv_is_permut.
  }
  destruct Hif as (Hic & Hop & Hiv & Hit & H10 & Hde & Hch) in Hsm.
  rewrite (rngl_mul_comm Hic _ (ε n μ)).
  rewrite rngl_mul_assoc.
  replace (ε n μ * ε n μ)%F with 1%F by now symmetry; apply ε_square.
  rewrite rngl_mul_1_l.
  easy.
}
cbn.
unfold canon_sym_gr_list_list.
rewrite <- rngl_summation_list_change_var.
rewrite rngl_summation_seq_summation; [ | apply fact_neq_0 ].
rewrite Nat.add_0_l.
erewrite rngl_summation_eq_compat. 2: {
  intros i (_, Hi).
  assert (Hc : is_permut n (canon_sym_gr_list n i)). {
    apply canon_sym_gr_list_is_permut.
    specialize (fact_neq_0 n) as H.
    flia Hi H.
  }
  rewrite rngl_product_change_var with
      (g := ff_app (permut_list_inv (canon_sym_gr_list n i)))
      (h := ff_app (canon_sym_gr_list n i)). 2: {
    intros j (_, Hj).
    apply (@permut_inv_permut n); [ | flia Hj Hnz ].
    apply canon_sym_gr_list_is_permut.
    specialize (fact_neq_0 n) as H.
    flia Hi H.
  }
  rewrite Nat.sub_0_r.
  rewrite <- Nat.sub_succ_l; [ | flia Hnz ].
  rewrite Nat_sub_succ_1.
  erewrite rngl_product_list_eq_compat. 2: {
    intros j Hj.
    apply in_map_iff in Hj.
    destruct Hj as (k & Hkj & Hk).
    apply in_seq in Hk.
    rewrite (@permut_permut_inv n); [ easy | easy | ].
    rewrite <- Hkj.
    rewrite <- length_canon_sym_gr_list with (k := i).
    apply permut_list_ub; [ apply Hc | ].
    now rewrite length_canon_sym_gr_list.
  }
  cbn.
  destruct Hif as (Hic & Hop & Hiv & Hit & H10 & Hde & Hch) in Hsm.
  rewrite rngl_product_map_permut; [ | easy | easy ].
  easy.
}
cbn.
set (sg := map (λ k, σ ° permut_list_inv (canon_sym_gr_list n k)) (seq 0 n!)).
erewrite rngl_summation_eq_compat. 2: {
  intros k Hk.
  assert (Hkn : k < n!). {
    specialize (fact_neq_0 n) as H.
    flia Hk H.
  }
  replace (_ ° _) with (nth k sg []). 2: {
    unfold sg.
    rewrite (List_map_nth' 0); [ | now rewrite seq_length ].
    now rewrite seq_nth.
  }
  erewrite rngl_product_eq_compat. 2: {
    intros i Hi.
    replace (ff_app _ _) with (ff_app (nth k sg []) (i - 1)). 2: {
      unfold sg.
      rewrite (List_map_nth' 0); [ | now rewrite seq_length ].
      rewrite seq_nth; [ | easy ].
      rewrite Nat.add_0_l.
      unfold "°".
      unfold ff_app.
      rewrite (List_map_nth' 0). 2: {
        rewrite length_permut_list_inv.
        rewrite length_canon_sym_gr_list.
        flia Hi.
      }
      easy.
    }
    easy.
  }
  easy.
}
cbn.
apply det_by_any_sym_gr; try easy.
unfold sg.
split. {
  rewrite map_length, seq_length.
  intros i Hi.
  rewrite (List_map_nth' 0); [ | now rewrite seq_length ].
  rewrite seq_nth; [ | easy ].
  rewrite Nat.add_0_l.
  split. {
    unfold "°"; cbn.
    rewrite map_length.
    rewrite length_permut_list_inv.
    apply length_canon_sym_gr_list.
  } {
    apply (comp_is_permut_list n); [ easy | ].
    apply permut_list_inv_is_permut.
    now apply canon_sym_gr_list_is_permut.
  }
}
split. {
  rewrite map_length, seq_length.
  intros i j Hi Hj Hij.
  rewrite (List_map_nth' 0) in Hij; [ | now rewrite seq_length ].
  rewrite (List_map_nth' 0) in Hij; [ | now rewrite seq_length ].
  rewrite seq_nth in Hij; [ | easy ].
  rewrite seq_nth in Hij; [ | easy ].
  do 2 rewrite Nat.add_0_l in Hij.
  unfold "°" in Hij.
  apply (f_equal (map (ff_app (permut_list_inv σ)))) in Hij.
  do 2 rewrite map_map in Hij.
  erewrite map_ext_in in Hij. 2: {
    intros k Hk.
    apply (In_nth _ _ 0) in Hk.
    destruct Hk as (u & Hu1 & Hu2).
    rewrite permut_inv_permut with (n := n); [ | easy | ]. 2: {
      rewrite <- Hu2.
      eapply Nat.lt_le_trans. {
        apply permut_list_ub; [ | easy ].
        apply permut_list_inv_is_permut_list.
        now apply canon_sym_gr_list_is_permut.
      }
      rewrite length_permut_list_inv.
      now rewrite length_canon_sym_gr_list.
    }
    easy.
  }
  symmetry in Hij.
  erewrite map_ext_in in Hij. 2: {
    intros k Hk.
    apply (In_nth _ _ 0) in Hk.
    destruct Hk as (u & Hu1 & Hu2).
    rewrite permut_inv_permut with (n := n); [ | easy | ]. 2: {
      rewrite <- Hu2.
      eapply Nat.lt_le_trans. {
        apply permut_list_ub; [ | easy ].
        apply permut_list_inv_is_permut_list.
        now apply canon_sym_gr_list_is_permut.
      }
      rewrite length_permut_list_inv.
      now rewrite length_canon_sym_gr_list.
    }
    easy.
  }
  symmetry in Hij.
  do 2 rewrite map_id in Hij.
  apply permut_list_inv_inj2 in Hij; cycle 1. {
    now apply canon_sym_gr_list_is_permut_list.
  } {
    now apply canon_sym_gr_list_is_permut_list.
  }
  now apply canon_sym_gr_list_inj in Hij.
} {
  intros l Hl.
  apply in_map_iff.
  exists (canon_sym_gr_list_inv n (permut_list_inv l ° σ)).
  rewrite permut_in_canon_sym_gr_of_its_rank. 2: {
    apply comp_is_permut; [ | easy ].
    now apply permut_list_inv_is_permut.
  }
  rewrite (@permut_list_inv_comp n); [ | | easy ]. 2: {
    now apply permut_list_inv_is_permut.
  }
  rewrite (@permut_comp_assoc n); cycle 1. {
    rewrite length_permut_list_inv.
    now destruct Hσ.
  } {
    now do 2 apply permut_list_inv_is_permut.
  }
  rewrite (@comp_permut_permut_inv n); [ | easy ].
  rewrite comp_id_l. 2: {
    intros i Hi.
    apply in_permut_list_inv_lt in Hi.
    rewrite length_permut_list_inv in Hi.
    destruct Hl as (H1, H2).
    now rewrite H2 in Hi.
  }
  rewrite permut_list_inv_involutive; [ | now destruct Hl ].
  split; [ easy | ].
  apply in_seq.
  split; [ easy | ].
  apply canon_sym_gr_list_inv_ub.
  apply comp_is_permut; [ | easy ].
  now apply permut_list_inv_is_permut.
}
Qed.

(* https://proofwiki.org/wiki/Permutation_of_Determinant_Indices *)

Theorem determinant_transpose : rngl_is_field →
  ∀ n (M : matrix T),
  is_square_matrix n M = true
  → determinant n M⁺ = determinant n M.
Proof.
intros Hif * Hsm.
destruct (Nat.eq_dec n 0) as [Hnz| Hnz]; [ now subst n | ].
specialize (mat_transp_is_square n M Hsm) as Hts.
assert (Hs : is_permut n (seq 0 n)) by apply seq_is_permut.
rewrite det_any_permut_l with (σ := seq 0 n); try easy.
rewrite det_any_permut_r with (σ := seq 0 n); try easy.
apply rngl_summation_list_eq_compat.
intros p Hp.
f_equal.
apply rngl_product_eq_compat.
intros k Hk.
unfold mat_transp.
cbn - [ ff_app ].
rewrite (List_map_nth' 0). 2: {
  rewrite seq_length.
  unfold ff_app.
  rewrite seq_nth; [ | flia Hnz Hk ].
  rewrite (@square_matrix_ncols n); [ | easy ].
  flia Hnz Hk.
}
assert (Hpr : ff_app p k < mat_nrows M). {
  apply in_map_iff in Hp.
  destruct Hp as (i & Hi & His).
  apply in_seq in His.
  rewrite <- Hi.
  apply is_sm_mat_iff in Hsm.
  destruct Hsm as (Hr, _).
  rewrite Hr.
  apply canon_sym_gr_list_ub; [ easy | ].
  flia Hnz Hk.
}
rewrite (List_map_nth' 0); [ | now rewrite seq_length ].
rewrite seq_nth; [ | easy ].
rewrite seq_nth. 2: {
  unfold ff_app.
  rewrite seq_nth; [ | flia Hnz Hk ].
  rewrite (@square_matrix_ncols n); [ | easy ].
  flia Hnz Hk.
}
easy.
Qed.

Theorem laplace_formula_on_cols : rngl_is_field →
  ∀ n (M : matrix T) j,
  j < n
  → determinant n M = ∑ (i = 0, n - 1), mat_el M i j * mat_el (comatrix n M) i j.
Proof.
intros Hif * Hlin.
Check laplace_formula_on_rows.
Print comatrix.
Theorem comatrix_transp : ∀ n M,
  is_square_matrix n M = true
  → comatrix n M⁺ = ((comatrix n M)⁺)%M.
Proof.
intros * Hsm.
unfold comatrix.
rewrite mat_transp_nrows.
rewrite (@square_matrix_nrows n); [ | easy ].
rewrite (@square_matrix_ncols n); [ | now apply mat_transp_is_square ].
unfold mat_transp; cbn.
f_equal.
destruct (Nat.eq_dec n 0) as [Hnz| Hnz]. {
  rewrite (@square_matrix_ncols n); [ now subst n | easy ].
}
rewrite (@square_matrix_nrows n); [ | easy ].
rewrite map_length, seq_length.
unfold mat_ncols; cbn.
do 2 rewrite List_hd_nth_0.
rewrite (List_map_nth' 0); [ | rewrite seq_length; flia Hnz ].
rewrite map_length, seq_length.
apply map_ext_in.
intros i Hi.
rewrite <- List_hd_nth_0 in Hi |-*.
rewrite fold_mat_ncols in Hi |-*.
apply in_seq in Hi.
apply map_ext_in.
intros j Hj; apply in_seq in Hj.
rewrite (List_map_nth' 0); [ | now rewrite seq_length ].
rewrite seq_nth; [ | easy ].
rewrite (@square_matrix_ncols n) in Hi |-*; [ | easy | easy ].
rewrite (List_map_nth' 0); [ cbn | now rewrite seq_length ].
rewrite seq_nth; [ | easy ].
rewrite Nat.add_0_l, (Nat.add_comm j).
f_equal.
unfold subm; cbn.
Abort.
Abort.

End a.

Arguments comatrix {T}%type {ro} n%nat M%M.
Compute (let M := mk_mat [[1]] in (comatrix (mat_nrows M) M⁺ = ((comatrix (mat_nrows M) M)⁺)%M)).

...

Theorem laplace_formula_on_cols :
  rngl_is_comm = true →
  rngl_has_opp = true →
  rngl_has_inv = true →
  rngl_is_integral = true →
  rngl_has_1_neq_0 = true →
  rngl_has_dec_eq = true →
  rngl_characteristic = 0 →
  ∀ n (M : matrix n n T) j,
  j < n
  → determinant M = ∑ (i = 0, n - 1), mat_el M i j * mat_el (comatrix M) i j.
Proof.
intros Hic Hop Hin Hit H10 Hde Hch * Hlin.
...
Check determinant_transp.
...

Theorem mat_swap_rows_involutive : ∀ n (M : matrix n n T) i j,
  mat_swap_rows i j (mat_swap_rows i j M) = M.
Proof.
intros.
apply matrix_eq.
intros p q Hp Hq; cbn.
destruct (Nat.eq_dec p i) as [Hpi| Hpi]. {
  subst p.
  destruct (Nat.eq_dec j i) as [Hji| Hji]; [ now subst j | ].
  now rewrite <- (if_eqb_eq_dec j), Nat.eqb_refl.
}
destruct (Nat.eq_dec p j) as [Hpj| Hpj]; [ | easy ].
subst p.
now rewrite <- (if_eqb_eq_dec i), Nat.eqb_refl.
Qed.

(*
The following two theorems, "determinant_with_row" and determinant_with_bad_row
have some similitudes.
  The theorem "determinant_with_row" says that we can compute the determinant
by going through any row (not necessarily the 0th one). Here, row "i".
  The theorem "determinant_with_bad_row" says that if we go through another
row "k" different from "i", the same formula (where "M i j" is replaced
with "M k j") returns 0. It is what I call a "bad determinant formula".

determinant_with_row
  ∀ (i n : nat) (M : matrix (S n) (S n) T),
  i ≤ n
  → ∑ (j = 0, n), minus_one_pow (i + j) * M i j * det (subm M i j) = det M

determinant_with_bad_row
  ∀ (i k n : nat) (M : matrix (S n) (S n) T),
  i ≤ n → k ≤ n → i ≠ k
  → ∑ (j = 0, n), minus_one_pow (i + j) * M k j * det (subm M i j) = 0%F

Isn't it strange? (or beautiful?)
*)

Theorem determinant_with_row :
  rngl_is_comm = true →
  rngl_has_opp = true →
  rngl_has_inv = true →
  rngl_is_integral = true →
  rngl_has_1_neq_0 = true →
  rngl_has_dec_eq = true →
  rngl_characteristic = 0 →
  ∀ i n (M : matrix (S n) (S n) T),
  i ≤ n
  → ∑ (j = 0, n),
    minus_one_pow (i + j) * mat_el M i j * determinant (subm M i j) =
    determinant M.
Proof.
intros Hic Hop Hiv Hit H10 Hde Hch * Hin.
symmetry.
destruct (Nat.eq_dec i 0) as [Hiz| Hiz]; [ now subst i | ].
apply rngl_opp_inj; [ easy | ].
rewrite <- determinant_alternating with (p := 0) (q := i); try easy;
  [ | flia Hiz | flia | flia Hin ].
rewrite determinant_succ at 1.
erewrite rngl_summation_eq_compat. 2: {
  intros j Hj.
  rewrite mat_swap_rows_comm.
  rewrite mat_el_mat_swap_rows.
  easy.
}
rewrite rngl_opp_summation; [ | easy | easy ].
apply rngl_summation_eq_compat.
intros j Hj.
rewrite <- rngl_mul_assoc; symmetry.
rewrite <- rngl_mul_opp_r; [ | easy ].
rewrite (Nat.add_comm i j).
rewrite minus_one_pow_add_r; [ | easy | easy ].
do 2 rewrite <- rngl_mul_assoc.
f_equal.
rewrite rngl_mul_comm; [ | easy ].
rewrite <- rngl_mul_assoc.
f_equal.
rewrite rngl_mul_opp_l, <- rngl_mul_opp_r; [ | easy | easy ].
rewrite rngl_mul_comm; [ | easy ].
symmetry.
rewrite mat_swap_rows_comm.
apply determinant_subm_mat_swap_rows_0_i; try easy.
flia Hiz Hin.
Qed.

Theorem determinant_with_bad_row :
  rngl_is_comm = true →
  rngl_has_opp = true →
  rngl_has_inv = true →
  rngl_is_integral = true →
  rngl_has_1_neq_0 = true →
  rngl_has_dec_eq = true →
  rngl_characteristic = 0 →
  ∀ i k n (M : matrix (S n) (S n) T),
  i ≤ n
  → k ≤ n
  → i ≠ k
  → ∑ (j = 0, n),
    minus_one_pow (i + j) * mat_el M k j * determinant (subm M i j) = 0%F.
Proof.
intros Hic Hop Hiv Hit H10 Hde Hch.
intros * Hi Hk Hik.
remember
  (mk_mat (S n) (S n) (λ p q, mat_el M (if Nat.eq_dec p i then k else p) q))
  as A eqn:HA.
assert (H1 : determinant A = 0%F). {
  subst A.
  apply Nat.lt_succ_r in Hi.
  apply Nat.lt_succ_r in Hk.
  apply determinant_same_rows with (p := i) (q := k); try easy.
  intros j.
  cbn.
  rewrite <- (if_eqb_eq_dec i), Nat.eqb_refl.
  now destruct (Nat.eq_dec k i).
}
rewrite <- determinant_with_row with (i := i) in H1; try easy.
rewrite <- H1 at 2.
apply rngl_summation_eq_compat.
intros j Hj.
do 2 rewrite <- rngl_mul_assoc.
f_equal; f_equal. {
  rewrite HA; cbn.
  now rewrite <- if_eqb_eq_dec, Nat.eqb_refl.
}
f_equal.
rewrite HA.
apply matrix_eq.
intros p q Hp Hq; cbn.
destruct (Nat.eq_dec (p + Nat.b2n (i <=? p)) i) as [Hpi| Hpi]; [ | easy ].
destruct (le_dec i p) as [Hip| Hip]. {
  apply Nat.leb_le in Hip.
  rewrite Hip in Hpi.
  cbn in Hpi.
  apply Nat.leb_le in Hip.
  flia Hpi Hip.
} {
  apply Nat.leb_nle in Hip.
  rewrite Hip in Hpi.
  cbn in Hpi.
  apply Nat.leb_nle in Hip.
  flia Hpi Hip.
}
Qed.

Theorem matrix_comatrix_mul :
  rngl_is_comm = true →
  rngl_has_opp = true →
  rngl_has_inv = true →
  rngl_is_integral = true →
  rngl_has_1_neq_0 = true →
  rngl_has_dec_eq = true →
  rngl_characteristic = 0 →
  ∀ n (M : matrix n n T),
  (M * (comatrix M)⁺ = determinant M × mI n)%M.
Proof.
intros Hic Hop Hiv Hit H10 Hde Hch *.
apply matrix_eq.
intros i j Hi Hj.
rewrite laplace_formula_on_rows with (i := i); try easy; cbn.
destruct (Nat.eq_dec i j) as [Hij| Hij]. {
  subst j.
  now rewrite rngl_mul_1_r.
}
rewrite rngl_mul_0_r; [ | now left ].
destruct n; [ easy | ].
rewrite Nat.sub_succ at 1.
rewrite Nat.sub_0_r.
erewrite rngl_summation_eq_compat. 2: {
  intros k Hk.
  rewrite rngl_mul_comm; [ | easy ].
  rewrite rngl_mul_mul_swap; [ | easy ].
  easy.
}
cbn.
apply -> Nat.lt_succ_r in Hi.
apply -> Nat.lt_succ_r in Hj.
apply Nat.neq_sym in Hij.
now apply determinant_with_bad_row.
Qed.

Theorem comatrix_matrix_mul :
  rngl_is_comm = true →
  rngl_has_opp = true →
  rngl_has_inv = true →
  rngl_is_integral = true →
  rngl_has_1_neq_0 = true →
  rngl_has_dec_eq = true →
  rngl_characteristic = 0 →
  ∀ n (M : matrix n n T),
  ((comatrix M)⁺ * M = determinant M × mI n)%M.
Proof.
intros Hic Hop Hiv Hit H10 Hde Hch *.
apply matrix_eq.
intros i j Hi Hj.
rewrite laplace_formula_on_cols with (j := j); try easy; cbn.
destruct (Nat.eq_dec i j) as [Hij| Hij]. {
  subst i.
  rewrite rngl_mul_1_r.
  apply rngl_summation_eq_compat.
  intros k Hk.
  rewrite rngl_mul_mul_swap; [ | easy ].
  rewrite rngl_mul_assoc.
  f_equal.
  now apply rngl_mul_comm.
}
rewrite rngl_mul_0_r; [ | now left ].
...
destruct n; [ easy | ].
rewrite Nat.sub_succ at 1.
rewrite Nat.sub_0_r.
erewrite rngl_summation_eq_compat. 2: {
  intros k Hk.
  rewrite rngl_mul_comm; [ | easy ].
  rewrite rngl_mul_mul_swap; [ | easy ].
  easy.
}
cbn.
apply -> Nat.lt_succ_r in Hi.
apply -> Nat.lt_succ_r in Hj.
apply Nat.neq_sym in Hij.
now apply determinant_with_bad_row.
Qed.

Definition mat_inv n (M : matrix n n T) :=
  ((determinant M)⁻¹ × (comatrix M)⁺)%M.

Theorem matrix_right_inv :
  rngl_is_comm = true →
  rngl_has_opp = true →
  rngl_has_inv = true →
  rngl_is_integral = true →
  rngl_has_1_neq_0 = true →
  rngl_has_dec_eq = true →
  rngl_characteristic = 0 →
  ∀ n (M : matrix n n T),
  determinant M ≠ 0%F → (M * mat_inv M = mI n)%M.
Proof.
intros Hic Hop Hiv Hit H10 Hde Hch *.
intros Hdz.
unfold mat_inv.
rewrite mat_mul_mul_scal_l; [ | easy | easy ].
rewrite matrix_comatrix_mul; try easy.
rewrite mat_mul_scal_l_mul_assoc; [ | easy ].
rewrite rngl_mul_inv_l; [ | easy | easy ].
now apply mat_mul_scal_1_l.
Qed.

Theorem matrix_left_inv :
  rngl_is_comm = true →
  rngl_has_opp = true →
  rngl_has_inv = true →
  rngl_is_integral = true →
  rngl_has_1_neq_0 = true →
  rngl_has_dec_eq = true →
  rngl_characteristic = 0 →
  ∀ n (M : matrix n n T),
  determinant M ≠ 0%F → (mat_inv M * M = mI n)%M.
Proof.
intros Hic Hop Hiv Hit H10 Hde Hch *.
intros Hdz.
unfold mat_inv.
rewrite mat_mul_scal_l_mul; [ | easy ].
...
rewrite matrix_comatrix_mul; try easy.
rewrite mat_mul_scal_l_mul_assoc; [ | easy ].
rewrite rngl_mul_inv_l; [ | easy | easy ].
now apply mat_mul_scal_1_l.
...

End a.

Arguments determinant {T ro} {n%nat} M%M.
Arguments det_from_row {T}%type {ro} {n}%nat M%M i%nat.
Arguments det_from_col {T}%type {ro} {n}%nat M%M j%nat.
Arguments comatrix {T}%type {ro} {n}%nat M%M.
Arguments subm {T m n} M%M i%nat j%nat.
