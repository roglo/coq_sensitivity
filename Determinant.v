Set Nested Proofs Allowed.
Set Implicit Arguments.

Require Import Utf8 Arith Bool.
Require Import Permutation.
Import List List.ListNotations.

Require Import Misc RingLike Matrix.
Require Import RLsummation RLproduct.
Require Import Pigeonhole.
Import matrix_Notations.
Import Init.Nat.

Section a.

Context {T : Type}.
Context (ro : ring_like_op T).
Context (rp : ring_like_prop T).

(* determinant *)

Fixpoint det_loop {n} (M : matrix n n T) i :=
  match i with
  | 0 => 1%F
  | S i' =>
      (Σ (j = 0, i'),
       minus_one_pow j * mat_el M 0 j * det_loop (subm M 0 j) i')%F
  end.

Definition determinant {n} (M : matrix n n T) := det_loop M n.

(* the following versions of computing the determinant should
   (to be proven) be equivalent; perhaps could help for proving
   Cramer's rule of resolving equations *)

Definition det_from_row {n} (M : matrix n n T) i :=
  (minus_one_pow i *
   Σ (j = 0, n - 1),
     minus_one_pow j * mat_el M i j * determinant (subm M i j))%F.

Definition det_from_col {n} (M : matrix n n T) j :=
  (minus_one_pow j *
   Σ (i = 0, n - 1),
     minus_one_pow i * mat_el M i j * determinant (subm M i j))%F.

(* things about making permutations *)

Definition is_permut_fun f n :=
  (∀ i, i < n → f i < n) ∧
  (∀ i j, i < n → j < n → f i = f j → i = j).

Definition is_permut {n} (σ : vector n nat) := is_permut_fun (vect_el σ) n.

Theorem permut_fun_ub : ∀ n f i, is_permut_fun f n → i < n → f i < n.
Proof.
intros * Hp Hin.
now apply Hp.
Qed.

Theorem vect_el_permut_ub : ∀ n (σ : vector n nat) i,
  is_permut σ → i < n → vect_el σ i < n.
Proof.
intros * Hp Hin.
destruct Hp as (Hp1, Hp2).
now apply Hp1.
Qed.

(* Alternative version of the determinant: sum of product of the
   factors a_{i,σ(i)} where σ goes through all permutations of
   the naturals of the interval [0, n-1].
   The permutations generated are in the same order as the
   terms generated by the determinant defined by induction on
   the size of the matrix.
     The order happens to be the canonical (alphabetical) order.
   Example for n=3
     = [[0; 1; 2]; [0; 2; 1]; [1; 0; 2]; [1; 2; 0]; [2; 0; 1]; [2; 1; 0]]
   Having the same terms order, the proof of equality of both definitions
   of both determinants is easy.

   The permutations are built this way. The k-th permutation is a
   vector of size n where
   - the first value is k/fact(n-1)
   - the rest is the (k mod fact(n-1))-th permutation of n-1 values
     (from 0 to n-2) where
     * all values less than the first value (k/fact(n-1)) are unchanged
     * all values greater or equal to it are increased by 1
   Example. For n=4 and k=0
   - first value: 0
   - rest: shift of 0;1;2 by 1, i.e. 1;2;3
   Result : 0;1;2;3
   Other example. For n=4 and k=13
   - first value: 13/3! = 13/6 = 2
   - rest: k' = 13 mod 3! = 13 mod 6 = 1 for n'=3, resulting 0;2;1
     0 and 1 are not shifted (both < 2), 2 is shifted, resulting 0;3;1
     final result: 2;0;3;1
  *)

Definition canon_permut_fun {n} (σ_n : nat → vector n nat) k j :=
  match j with
  | 0 => k / fact n
  | S j' =>
      vect_el (σ_n (k mod fact n)) j' +
      Nat.b2n (k / fact n <=? vect_el (σ_n (k mod fact n)) j')
  end.

Fixpoint canon_permut n k : vector n nat :=
  match n with
  | 0 => mk_vect 0 (λ _, 0)
  | S n' => mk_vect (S n') (canon_permut_fun (canon_permut n') k)
  end.

Fixpoint canon_permut_inv n k (j : nat) :=
  match n with
  | 0 => 0
  | S n' =>
      if lt_dec j (k / fact n') then
        S (canon_permut_inv n' (k mod fact n') j)
      else if lt_dec (k / fact n') j then
        S (canon_permut_inv n' (k mod fact n') (j - 1))
      else 0
  end.

Theorem canon_permut_inv_upper_bound : ∀ n k j,
  k < fact n
  → j < n
  → canon_permut_inv n k j < n.
Proof.
intros * Hkn Hjn.
revert k j Hkn Hjn.
induction n; intros; [ easy | ].
cbn.
destruct (lt_dec j (k / fact n)) as [Hjkn| Hjkn]. {
  apply -> Nat.succ_lt_mono.
  destruct n. {
    cbn in Hkn.
    apply Nat.lt_1_r in Hkn; subst k.
    now cbn in Hjkn.
  }
  destruct (Nat.eq_dec j (S n)) as [Hjsn| Hjsn]. {
    subst j.
    clear Hjn.
    exfalso; apply Nat.nle_gt in Hjkn; apply Hjkn; clear Hjkn.
    rewrite Nat_fact_succ in Hkn.
    rewrite Nat.mul_comm in Hkn.
    apply Nat.lt_succ_r.
    apply Nat.div_lt_upper_bound; [ | easy ].
    apply fact_neq_0.
  } {
    apply IHn; [ | flia Hjn Hjsn ].
    apply Nat.mod_upper_bound, fact_neq_0.
  }
} {
  apply Nat.nlt_ge in Hjkn.
  destruct (lt_dec (k / fact n) j) as [Hknj| Hknj]; [ | flia ].
  apply -> Nat.succ_lt_mono.
  destruct n. {
    now apply Nat.lt_1_r in Hjn; subst j.
  }
  apply IHn; [ | flia Hjn Hknj ].
  apply Nat.mod_upper_bound, fact_neq_0.
}
Qed.

(* should use permut_fun_blah_blah... *)
Theorem canon_permut_permut_inv : ∀ n k j,
  j < n
  → k < fact n
  → vect_el (canon_permut n k) (canon_permut_inv n k j) = j.
Proof.
intros * Hjn Hkn.
revert j k Hjn Hkn.
induction n; intros; [ easy | ].
cbn.
destruct (lt_dec j (k / fact n)) as [Hjkn| Hjkn]. {
  cbn.
  destruct n. {
    rewrite Nat.div_1_r in Hjkn; cbn in Hkn.
    flia Hkn Hjkn.
  }
  destruct (lt_dec k (fact (S n))) as [Hksn| Hksn]. {
    now rewrite Nat.div_small in Hjkn.
  }
  apply Nat.nlt_ge in Hksn.
  destruct (Nat.eq_dec j (S n)) as [Hjsn| Hjsn]. {
    subst j.
    clear Hjn.
    exfalso; apply Nat.nle_gt in Hjkn; apply Hjkn; clear Hjkn.
    rewrite Nat_fact_succ in Hkn.
    rewrite Nat.mul_comm in Hkn.
    apply Nat.lt_succ_r.
    apply Nat.div_lt_upper_bound; [ | easy ].
    apply fact_neq_0.
  }
  rewrite IHn; [ | flia Hjn Hjsn | ]. 2: {
    apply Nat.mod_upper_bound, fact_neq_0.
  }
  remember (k / fact (S n) <=? j) as b eqn:Hb.
  symmetry in Hb.
  destruct b; [ exfalso | apply Nat.add_0_r ].
  apply Nat.leb_le in Hb.
  flia Hjkn Hb.
} {
  apply Nat.nlt_ge in Hjkn.
  destruct (lt_dec (k / fact n) j) as [Hkj| Hkj]. 2: {
    apply Nat.nlt_ge in Hkj; cbn.
    now apply Nat.le_antisymm.
  }
  clear Hjkn.
  destruct j; [ easy | ].
  rewrite Nat.sub_succ, Nat.sub_0_r.
  cbn.
  destruct n; [ flia Hjn | ].
  apply Nat.succ_lt_mono in Hjn.
  rewrite IHn; [ | easy | ]. 2: {
    apply Nat.mod_upper_bound, fact_neq_0.
  }
  remember (k / fact (S n) <=? j) as b eqn:Hb.
  symmetry in Hb.
  destruct b; [ apply Nat.add_1_r | exfalso ].
  apply Nat.leb_nle in Hb.
  now apply Nat.succ_le_mono in Hkj.
}
Qed.

(* perhaps, I could prove it by proving that canon_inv_permut
   is indeed the invert (permut_inv) of canon_permut *)
Theorem canon_permut_inv_permut : ∀ n k i,
  i < n
  → k < fact n
  → canon_permut_inv n k (vect_el (canon_permut n k) i) = i.
Proof.
intros * Hi Hkn.
revert k i Hi Hkn.
induction n; intros; [ flia Hi | ].
destruct i. {
  clear Hi; cbn.
  remember (k / fact n) as p eqn:Hp.
  destruct (lt_dec p p) as [H| H]; [ flia H | easy ].
}
apply Nat.succ_lt_mono in Hi.
cbn.
remember (k / fact n) as p eqn:Hp.
remember (vect_el (canon_permut n (k mod fact n)) i) as q eqn:Hq.
move q before p.
remember (p <=? q) as b eqn:Hb; symmetry in Hb.
destruct b. {
  apply Nat.leb_le in Hb; cbn.
  destruct (lt_dec (q + 1) p) as [Hpq| Hqp]; [ flia Hb Hpq | ].
  apply Nat.nlt_ge in Hqp.
  destruct (lt_dec p (q + 1)) as [Hpq| Hpq]; [ | flia Hb Hpq ].
  clear Hpq Hqp.
  f_equal.
  rewrite Nat.add_sub.
  rewrite Hq.
  apply IHn; [ easy | ].
  apply Nat.mod_upper_bound, fact_neq_0.
} {
  apply Nat.leb_gt in Hb; cbn.
  rewrite Nat.add_0_r.
  destruct (lt_dec q p) as [H| H]; [ clear H | flia Hb H ].
  f_equal.
  rewrite Hq.
  apply IHn; [ easy | ].
  apply Nat.mod_upper_bound, fact_neq_0.
}
Qed.

Theorem canon_permut_surjective : ∀ n k j,
  k < fact n
  → j < n
  → ∃ i : nat, i < n ∧ vect_el (canon_permut n k) i = j.
Proof.
intros * Hkn Hjn.
exists (canon_permut_inv n k j).
destruct n; [ easy | ].
split. {
  cbn.
  destruct (lt_dec j (k / fact n)) as [Hjk| Hjk]. {
    apply -> Nat.succ_lt_mono.
    destruct n. {
      now apply Nat.lt_1_r in Hkn; subst k.
    }
    destruct (Nat.eq_dec j (S n)) as [Hjsn| Hjsn]. {
      subst j; clear Hjn.
      apply Nat.nle_gt in Hjk.
      exfalso; apply Hjk; clear Hjk.
      rewrite Nat_fact_succ in Hkn.
      rewrite Nat.mul_comm in Hkn.
      apply Nat.lt_succ_r.
      apply Nat.div_lt_upper_bound; [ | easy ].
      apply fact_neq_0.
    }
    apply canon_permut_inv_upper_bound; [ | flia Hjn Hjsn ].
    apply Nat.mod_upper_bound, fact_neq_0.
  } {
    apply Nat.nlt_ge in Hjk.
    destruct (lt_dec (k / fact n) j) as [Hkj| Hkj]; [ | flia ].
    apply -> Nat.succ_lt_mono.
    destruct n. {
      apply Nat.lt_1_r in Hkn; subst k.
      flia Hjn Hkj.
    }
    apply canon_permut_inv_upper_bound; [ | flia Hjn Hkj ].
    apply Nat.mod_upper_bound, fact_neq_0.
  }
}
now apply canon_permut_permut_inv.
Qed.

Theorem canon_permut_injective : ∀ n k i j,
  k < fact n
  → i < n
  → j < n
  → vect_el (canon_permut n k) i = vect_el (canon_permut n k) j
  → i = j.
Proof.
intros * Hk Hi Hj Hij.
assert (Hnz : n ≠ 0) by flia Hi.
rewrite <- canon_permut_inv_permut with (n := n) (k := k); [ | easy | easy ].
symmetry.
rewrite <- canon_permut_inv_permut with (n := n) (k := k); [ | easy | easy ].
now f_equal.
Qed.

(* signature of the k-th permutation of "canon_permut" above *)

Fixpoint ε_canon_permut n k :=
  match n with
  | 0 => 1%F
  | S n' => (minus_one_pow (k / fact n') * ε_canon_permut n' (k mod fact n'))%F
  end.

(* signature of a permutation *)

Definition δ i j u v := if i <? j then (rngl_of_nat v - rngl_of_nat u)%F else 1%F.

Definition ε_fun f n :=
  ((Π (i = 1, n), Π (j = 1, n), δ i j (f (i - 1)%nat) (f (j - 1)%nat)) /
   (Π (i = 1, n), Π (j = 1, n), δ i j i j))%F.

Definition ε {n} (p : vector n nat) := ε_fun (vect_el p) n.

(* alternative version of signature of a permutation
   using only signs: ws = with sign *)

Definition sign_diff u v := if v <? u then 1%F else (-1)%F.
Definition abs_diff u v := if v <? u then u - v else v - u.

Definition ε_fun_ws f n :=
  (Π (i = 1, n), Π (j = 1, n),
   if i <? j then sign_diff (f (j - 1)%nat) (f (i - 1)%nat) else 1)%F.

Definition ε_ws {n} (p : vector n nat) := ε_fun_ws (vect_el p) n.

(*
End a.
Require Import Zrl.
Require Import ZArith.
Compute (list_of_vect (canon_permut 4 1)).
Compute let n := 4 in map (λ i, (ε_canon_permut Z_ring_like_op n i)) (seq 0 (fact n)).
Compute let n := 4 in map (λ i, (ε Z_ring_like_op (canon_permut n i))) (seq 0 (fact n)).
Compute let n := 4 in map (λ i, (ε_ws Z_ring_like_op (canon_permut n i))) (seq 0 (fact n)).
Compute let n := 5 in map (λ i, (ε_canon_permut Z_ring_like_op n i)) (seq 0 (fact n)).
Compute let n := 5 in map (λ i, (ε Z_ring_like_op (canon_permut n i))) (seq 0 (fact n)).
Compute let n := 5 in map (λ i, (ε_ws Z_ring_like_op (canon_permut n i))) (seq 0 (fact n)).
*)

(* *)

Definition comp {A B C} (f : B → C) (g : A → B) x := f (g x).

Definition permut_comp {n} (σ₁ σ₂ : vector n nat) :=
  mk_vect n (comp (vect_el σ₁) (vect_el σ₂)).

Notation "σ₁ ° σ₂" := (permut_comp σ₁ σ₂) (at level 40).

Fixpoint permut_fun_inv f i j :=
  match i with
  | 0 => 42
  | S i' => if Nat.eq_dec (f i') j then i' else permut_fun_inv f i' j
  end.

Theorem rngl_product_change_var : ∀ A b e f g (h : _ → A),
  (∀ i, b ≤ i ≤ e → g (h i) = i)
  → (Π (i = b, e), f i = Π (i ∈ map h (seq b (S e - b))), f (g i))%F.
Proof.
intros * Hgh.
unfold iter_seq, iter_list.
rewrite List_fold_left_map.
apply List_fold_left_ext_in.
intros i c Hi.
f_equal; f_equal; symmetry.
apply Hgh.
apply in_seq in Hi.
flia Hi.
Qed.

Theorem fun_find_prop : ∀ f n i,
  (∀ i j, i < n → j < n → f i = f j → i = j)
  → i < n
  → permut_fun_inv f n (f i) = i.
Proof.
intros * Hp2 Hin.
revert i Hin.
induction n; intros; [ easy | cbn ].
destruct (Nat.eq_dec (f n) (f i)) as [Hfni| Hfni]. {
  apply Hp2; [ flia | easy | easy ].
}
rename Hin into Hisn.
assert (Hin : i < n). {
  destruct (Nat.eq_dec n i) as [H| H]; [ now subst n | ].
  flia Hisn H.
}
clear Hisn.
apply IHn; [ | easy ].
intros j k Hj Hk Hjk.
apply Hp2; [ flia Hj | flia Hk | easy ].
Qed.

(* the proof that "vect_el σ (vect_el (permut_inv σ) i) = i"
   is proven by the pigeonhole principle *)

Definition permut_fun_inv' f n i :=
  let '(x, x') :=
    pigeonhole_fun (S n) (λ j, if Nat.eq_dec j n then i else f j)
  in
  if Nat.eq_dec x n then x' else x.

Theorem fun_find_permut_fun_inv' : ∀ f n,
  is_permut_fun f n
  → ∀ i, i < n
  → permut_fun_inv f n i = permut_fun_inv' f n i.
Proof.
intros * (Hfub, Hinj) * Hin.
unfold permut_fun_inv'.
remember (pigeonhole_fun _ _) as xx eqn:Hxx.
symmetry in Hxx.
destruct xx as (j, j').
unfold pigeonhole_fun in Hxx.
remember (find_dup _ _) as fd eqn:Hfd.
symmetry in Hfd.
destruct fd as [(x, x')| ]. {
  injection Hxx; clear Hxx; intros; subst x x'.
  apply find_dup_some in Hfd.
  destruct Hfd as (Hij & la1 & la2 & la3 & Hfd).
  destruct (Nat.eq_dec j n) as [Hjn| Hjn]. {
    subst j.
    destruct (Nat.eq_dec j' n) as [Hin'| Hin']. {
      subst j'; clear Hij.
      exfalso.
      revert Hfd.
      apply List_seq_nothing_after_last.
    }
    subst i.
    apply fun_find_prop; [ easy | ].
    assert (H : j' ∈ seq 0 (S n)). {
      rewrite Hfd.
      apply in_app_iff; right; right.
      now apply in_app_iff; right; left.
    }
    apply in_seq in H.
    flia Hin' H.
  }
  destruct (Nat.eq_dec j' n) as [Hjn'| Hjn']. {
    subst j' i.
    apply fun_find_prop; [ easy | ].
    assert (H : j ∈ seq 0 (S n)). {
      rewrite Hfd.
      apply in_app_iff; right.
      now left.
    }
    apply in_seq in H.
    flia Hjn H.
  }
  apply Hinj in Hij; cycle 1. {
    assert (H : j ∈ seq 0 (S n)). {
      rewrite Hfd.
      apply in_app_iff; right.
      now left.
    }
    apply in_seq in H.
    flia Hjn H.
  } {
    assert (H : j' ∈ seq 0 (S n)). {
      rewrite Hfd.
      apply in_app_iff; right; right.
      now apply in_app_iff; right; left.
    }
    apply in_seq in H.
    flia Hjn' H.
  }
  subst j'.
  exfalso.
  specialize (seq_NoDup (S n) 0) as H1.
  rewrite Hfd in H1.
  apply NoDup_app_remove_l in H1.
  rewrite app_comm_cons in H1.
  specialize (proj1 (NoDup_app_iff _ _) H1) as (_ & _ & H2).
  specialize (H2 j (or_introl eq_refl)).
  apply H2.
  now left.
}
injection Hxx; clear Hxx; intros; subst j j'.
apply find_dup_none in Hfd.
replace (if Nat.eq_dec _ _ then _ else _) with 0. 2: {
  now destruct (Nat.eq_dec 0 n).
}
specialize (proj1 (NoDup_map_iff 0 _ _) Hfd) as H1.
rewrite seq_length in H1.
assert
  (H2 : ∀ j k,
   j < S n
   → k < S n
   → (if Nat.eq_dec j n then i else f j) = (if Nat.eq_dec k n then i else f k)
   → j = k). {
  intros j k Hj Hk.
  specialize (H1 j k Hj Hk).
  now do 2 rewrite seq_nth in H1.
}
clear H1; rename H2 into H1.
apply not_NoDup_map_f_seq with (b := n) in Hfd; [ easy | flia | ].
intros j Hj.
destruct (Nat.eq_dec j n) as [Hjn| Hjn]; [ easy | ].
apply Hfub.
flia Hj Hjn.
Qed.

Theorem pigeonhole' : ∀ f n,
  (∀ i, i < n → f i < n)
  → (∀ i j, i < n → j < n → f i = f j → i = j)
  → ∀ i, i < n
  → ∀ j, j = permut_fun_inv' f n i
  → j < n ∧ f j = i.
Proof.
intros * Hp1 Hp2 * Hin * Hj.
subst j.
unfold permut_fun_inv'.
remember (pigeonhole_fun _ _) as xx eqn:Hxx.
symmetry in Hxx.
destruct xx as (x, x').
specialize pigeonhole as H1.
specialize (H1 (S n) n).
specialize (H1 (λ j, if Nat.eq_dec j n then i else f j)).
specialize (H1 (Nat.lt_succ_diag_r n)).
cbn in H1.
assert (H : ∀ j, j < S n → (if Nat.eq_dec j n then i else f j) < n). {
  intros j Hj.
  destruct (Nat.eq_dec j n) as [Hjn| Hjn]; [ now subst j | ].
  apply Hp1; flia Hj Hjn.
}
specialize (H1 H x x' Hxx); clear H.
destruct H1 as (Hxn & Hx'n & Hxx' & H1).
destruct (Nat.eq_dec x n) as [H2| H2]. {
  subst x.
  destruct (Nat.eq_dec x' n) as [H2| H2]; [ now subst x' | ].
  split; [ flia Hx'n H2 | easy ].
} {
  destruct (Nat.eq_dec x' n) as [H3| H3]. {
    split; [ flia Hxn H2 | easy ].
  }
  apply Hp2 in H1; [ easy | flia Hxn H2 | flia Hx'n H3 ].
}
Qed.

Theorem fun_permut_fun_inv : ∀ f n,
  is_permut_fun f n
  → ∀ i, i < n
  → f (permut_fun_inv f n i) = i.
Proof.
intros * (Hp1, Hp2) * Hin.
rewrite fun_find_permut_fun_inv'; [ | easy | easy ].
apply (proj2 (pigeonhole' f Hp1 Hp2 Hin eq_refl)).
Qed.

Theorem rngl_product_change_list :
  rngl_is_comm = true →
  ∀ A (la lb : list A) f,
  Permutation la lb
  → (Π (i ∈ la), f i = Π (i ∈ lb), f i)%F.
Proof.
intros Hic * P.
induction P; [ easy | | | ]. {
  rewrite rngl_product_list_cons; [ | easy ].
  rewrite rngl_product_list_cons; [ | easy ].
  now rewrite IHP.
} {
  do 4 (rewrite rngl_product_list_cons; [ | easy ]).
  do 2 rewrite rngl_mul_assoc.
  f_equal.
  specialize rngl_opt_mul_comm as rngl_mul_comm.
  rewrite Hic in rngl_mul_comm.
  apply rngl_mul_comm.
} {
  etransitivity; [ apply IHP1 | apply IHP2 ].
}
Qed.

Theorem permut_fun_inv_is_permut : ∀ n f,
  is_permut_fun f n
  → is_permut_fun (permut_fun_inv f n) n.
Proof.
intros * Hp.
destruct Hp as (Hp1, Hp2).
split. {
  intros i Hin; cbn.
  rewrite fun_find_permut_fun_inv'; [ | easy | easy ].
  unfold permut_fun_inv'.
  remember (pigeonhole_fun _ _) as xx eqn:Hxx.
  symmetry in Hxx; destruct xx as (x, x').
  destruct (Nat.eq_dec x n) as [Hxn| Hxn]. {
    subst x.
    unfold pigeonhole_fun in Hxx.
    remember (find_dup _ _) as fd eqn:Hfd; symmetry in Hfd.
    destruct fd as [(x, n')| ]. {
      injection Hxx; clear Hxx; intros; subst x x'.
      apply find_dup_some in Hfd.
      destruct Hfd as (Hij & la1 & la2 & la3 & Hfd).
      exfalso.
      revert Hfd.
      apply List_seq_nothing_after_last.
    }
    now injection Hxx; clear Hxx; intros; subst n x'.
  } {
    unfold pigeonhole_fun in Hxx.
    remember (find_dup _ _) as fd eqn:Hfd; symmetry in Hfd.
    destruct fd as [(n'', n')| ]. {
      injection Hxx; clear Hxx; intros; subst x x'.
      apply find_dup_some in Hfd.
      destruct Hfd as (Hij & la1 & la2 & la3 & Hfd).
      destruct (Nat.eq_dec n'' n) as [Hn''n| Hn''n]; [ now subst n'' | ].
      destruct (Nat.eq_dec n' n) as [Hn'n| Hn'n]. {
        subst n'.
        now apply List_sorted_in_seq in Hfd.
      }
      assert (H : n' ∈ seq 0 (S n)). {
        rewrite Hfd.
        apply in_app_iff; right; right.
        now apply in_app_iff; right; left.
      }
      apply in_seq in H.
      apply List_sorted_in_seq in Hfd.
      apply (Nat.lt_le_trans _ n'); [ easy | flia H ].
    }
    injection Hxx; clear Hxx; intros; subst x x'.
    flia Hin.
  }
}
intros i j Hi Hj Hij.
cbn in Hij.
rewrite fun_find_permut_fun_inv' in Hij; [ | easy | easy ].
rewrite fun_find_permut_fun_inv' in Hij; [ | easy | easy ].
unfold permut_fun_inv' in Hij.
remember (pigeonhole_fun _ _) as xx eqn:Hxx in Hij.
remember (pigeonhole_fun _ _) as yy eqn:Hyy in Hij.
symmetry in Hxx; destruct xx as (x, x').
symmetry in Hyy; destruct yy as (y, y').
move y before x; move y' before x'.
unfold pigeonhole_fun in Hxx, Hyy.
remember (find_dup _ _) as fdi eqn:Hfdi in Hxx.
remember (find_dup _ _) as fdj eqn:Hfdj in Hyy.
symmetry in Hfdi, Hfdj.
move fdj before fdi.
move Hfdj before Hfdi.
destruct fdi as [(x1, x2)| ]. {
  injection Hxx; clear Hxx; intros; subst x1 x2.
  apply find_dup_some in Hfdi.
  destruct Hfdi as (Hij1 & la1 & la2 & la3 & Hfdi).
  destruct (Nat.eq_dec x n) as [Hxn| Hxn]. {
    subst x.
    now apply List_seq_nothing_after_last in Hfdi.
  }
  destruct fdj as [(x1, x2)| ]. {
    injection Hyy; clear Hyy; intros; subst x1 x2.
    apply find_dup_some in Hfdj.
    destruct Hfdj as (Hij2 & lb1 & lb2 & lb3 & Hfdj).
    destruct (Nat.eq_dec y n) as [Hyn| Hyn]; subst y. {
      now apply List_seq_nothing_after_last in Hfdj.
    }
    clear Hyn.
    destruct (Nat.eq_dec x' n) as [Hx'n| Hx'n]. {
      subst x'.
      destruct (Nat.eq_dec y' n) as [Hy'n| Hy'n]; [ congruence | ].
      apply Hp2 in Hij2; cycle 1. {
        assert (H : x ∈ seq 0 (S n)). {
          rewrite Hfdi.
          now apply in_app_iff; right; left.
        }
        apply in_seq in H; cbn in H; flia Hxn H.
      } {
        assert (H : y' ∈ seq 0 (S n)). {
          rewrite Hfdj.
          apply in_app_iff; right; right.
          now apply in_app_iff; right; left.
        }
        apply in_seq in H; cbn in H; flia Hy'n H.
      }
      subst y'.
      apply List_sorted_in_seq in Hfdj.
      now apply Nat.lt_irrefl in Hfdj.
    }
    apply Hp2 in Hij1; cycle 1. {
      assert (H : x ∈ seq 0 (S n)). {
        rewrite Hfdi.
        now apply in_app_iff; right; left.
      }
      apply in_seq in H; cbn in H; flia Hxn H.
    } {
      assert (H : x' ∈ seq 0 (S n)). {
        rewrite Hfdi.
        apply in_app_iff; right; right.
        now apply in_app_iff; right; left.
      }
      apply in_seq in H; cbn in H; flia Hx'n H.
    }
    subst x'.
    apply List_sorted_in_seq in Hfdi.
    now apply Nat.lt_irrefl in Hfdi.
  }
  apply find_dup_none in Hfdj.
  exfalso; revert Hfdj.
  apply not_NoDup_map_f_seq with (b := n); [ flia | ].
  intros k Hk.
  destruct (Nat.eq_dec k n) as [Hkn| Hkn]; [ easy | ].
  apply Hp1; flia Hk Hkn.
}
apply find_dup_none in Hfdi.
exfalso; revert Hfdi.
apply not_NoDup_map_f_seq with (b := n); [ flia | ].
intros k Hk.
destruct (Nat.eq_dec k n) as [Hkn| Hkn]; [ easy | ].
apply Hp1; flia Hk Hkn.
Qed.

Definition permut_inv n (σ : vector n nat) :=
  mk_vect n (permut_fun_inv (vect_el σ) n).

Theorem permut_inv_is_permut : ∀ n (σ : vector n nat),
  is_permut σ
  → is_permut (permut_inv σ).
Proof.
intros * Hperm.
now apply permut_fun_inv_is_permut.
Qed.

Theorem permut_fun_without_last : ∀ n i (a : _ → nat),
  is_permut_fun a (S n)
  → i = permut_fun_inv a (S n) n
  → ∃ b,
     is_permut_fun b n ∧
     map a (seq 0 i ++ seq (S i) (n - i)) = map b (seq 0 n).
Proof.
intros * Hp Hi.
exists (λ j, if lt_dec j i then a j else a (j + 1)).
split. 2: {
  destruct n. {
    cbn in Hi; cbn.
    destruct (Nat.eq_dec (a 0) 0) as [Haz| Haz]; [ now subst i | exfalso ].
    apply Haz.
    destruct Hp as (Hp1, Hp2).
    enough (H : a 0 < 1) by flia H.
    apply Hp1; flia.
  }
  destruct (Nat.eq_dec (a (S n)) (S n)) as [Han| Han]. {
    remember (S n) as sn; cbn in Hi; subst sn.
    rewrite Han in Hi.
    destruct (Nat.eq_dec (S n) (S n)) as [H| H]; [ clear H | easy ].
    subst i.
    rewrite Nat.sub_diag; cbn.
    f_equal.
    rewrite app_nil_r.
    apply map_ext_in.
    intros i Hi.
    apply in_seq in Hi.
    now destruct (lt_dec i (S n)).
  }
  destruct (Nat.eq_dec i (S n)) as [Hsni| Hsni]. {
    rewrite Hsni, Nat.sub_diag.
    cbn; f_equal.
    rewrite app_nil_r.
    apply map_ext_in.
    intros j Hj.
    destruct (lt_dec j (S n)) as [Hjsn| Hjsn]; [ easy | ].
    exfalso; apply Hjsn; clear Hjsn.
    now apply in_seq in Hj.
  }
  symmetry.
  rewrite (List_seq_cut i). 2: {
    apply in_seq.
    split; [ flia | cbn ].
    enough (H : i < S (S n)) by flia Hsni H.
    rewrite Hi.
    apply permut_fun_ub; [ | flia ].
    now apply permut_fun_inv_is_permut.
  }
  symmetry; cbn - [ "-" ].
  rewrite Nat.sub_0_r, Nat.sub_succ.
  rewrite Nat.sub_succ_l. 2: {
    assert (H : i < S (S n)). {
      rewrite Hi.
      apply permut_fun_ub; [ | flia ].
      now apply permut_fun_inv_is_permut.
    }
    flia Hsni H.
  }
  do 2 rewrite map_app.
  f_equal. {
    apply map_ext_in_iff.
    intros j Hj.
    destruct (lt_dec j i) as [Hji| Hji]; [ easy | ].
    now apply in_seq in Hj.
  }
  cbn.
  destruct (lt_dec i i) as [H| H]; [ now apply lt_irrefl in H | clear H ].
  rewrite Nat.add_1_r; f_equal.
  rewrite <- seq_shift.
  rewrite map_map.
  apply map_ext_in_iff.
  intros j Hj.
  rewrite Nat.add_1_r.
  destruct (lt_dec j i) as [Hji| Hji]; [ | easy ].
  apply in_seq in Hj.
  flia Hj Hji.
}
split. {
  intros j Hj.
  assert (Hin : a i = n). {
    rewrite Hi.
    apply fun_permut_fun_inv; [ easy | flia ].
  }
  destruct (lt_dec j i) as [Hji| Hji]. {
    destruct (Nat.eq_dec (a j) n) as [Hajn| Hajn]. {
      rewrite <- Hajn in Hin.
      apply Hp in Hin; [ flia Hji Hin | | flia Hj ].
      rewrite Hi.
      apply permut_fun_ub; [ | flia ].
      now apply permut_fun_inv_is_permut.
    }
    enough (H : a j < S n) by flia Hajn H.
    apply Hp; flia Hj.
  }
  apply Nat.nlt_ge in Hji.
  destruct Hp as (Hp1, Hp2).
  apply Nat.succ_lt_mono in Hj.
  specialize (Hp1 _ Hj) as H1.
  rewrite Nat.add_1_r.
  destruct (Nat.eq_dec (a (S j)) n) as [Hajn| Hajn]. {
    rewrite <- Hajn in Hin.
    apply Hp2 in Hin; [ flia Hin Hji | flia Hj Hji | easy ].
  }
  flia H1 Hajn.
}
intros j k Hj Hk Hjk.
destruct (lt_dec j i) as [Hji| Hji]. {
  destruct (lt_dec k i) as [Hki| Hki]. {
    apply Hp in Hjk; [ easy | flia Hj | flia Hk ].
  }
  apply Nat.nlt_ge in Hki.
  apply Hp in Hjk; [ flia Hji Hki Hjk | flia Hj | flia Hk ].
}
destruct (lt_dec k i) as [Hki| Hki]. {
  apply Hp in Hjk; [ | flia Hj | flia Hk ].
  apply Nat.nlt_ge in Hji.
  flia Hji Hki Hjk.
}
apply Hp in Hjk; [ flia Hjk | flia Hj | flia Hk ].
Qed.

Theorem permut_fun_Permutation : ∀ f n,
  is_permut_fun f n
  → Permutation (map f (seq 0 n)) (seq 0 n).
Proof.
intros a n * Hp.
symmetry.
revert a Hp.
induction n; intros; [ easy | ].
rewrite List_seq_succ_r at 1.
remember (permut_fun_inv a (S n) n) as i eqn:Hi.
remember (seq 0 n) as s eqn:Hs.
rewrite (List_seq_cut i); subst s. 2: {
  subst i.
  apply in_seq.
  split; [ flia | ].
  apply permut_fun_ub; [ | flia ].
  now apply permut_fun_inv_is_permut.
}
rewrite Nat.sub_0_r; cbn.
rewrite map_app; cbn.
rewrite Hi at 2.
rewrite fun_permut_fun_inv; [ | easy | flia ].
apply Permutation_elt.
rewrite app_nil_r.
rewrite <- map_app.
destruct (permut_fun_without_last Hp Hi) as (g & Hpg & Hg).
rewrite Hg.
now apply IHn.
Qed.

Theorem rngl_product_seq_product : ∀ b len f,
  len ≠ 0
  → (Π (i ∈ seq b len), f i = Π (i = b, b + len - 1), f i)%F.
Proof.
intros * Hlen.
unfold iter_seq.
f_equal; f_equal.
flia Hlen.
Qed.

Theorem rngl_product_product_by_swap :
  rngl_is_comm = true →
  ∀ n f,
  (Π (i ∈ seq 0 n), Π (j ∈ seq 0 n), f i j)%F =
  ((Π (i ∈ seq 0 n), f i i) *
   (Π (i ∈ seq 0 (n - 1)), Π (j = i + 1, n - 1), (f i j * f j i)))%F.
Proof.
intros Hic *.
specialize rngl_opt_mul_comm as rngl_mul_comm.
rewrite Hic in rngl_mul_comm.
induction n. {
  unfold iter_seq, iter_list; cbn.
  now rewrite rngl_mul_1_l.
}
destruct (Nat.eq_dec n 0) as [Hnz| Hnz]. {
  subst n; unfold iter_list; cbn.
  now rewrite rngl_mul_1_l, rngl_mul_1_r.
}
destruct (Nat.eq_dec n 1) as [Hn1| Hn1]. {
  subst n; unfold iter_seq, iter_list; cbn.
  do 5 rewrite rngl_mul_1_l.
  repeat rewrite <- rngl_mul_assoc.
  f_equal; symmetry.
  rewrite rngl_mul_comm.
  now rewrite rngl_mul_assoc.
}
erewrite rngl_product_list_eq_compat. 2: {
  intros i Hi.
  rewrite List_seq_succ_r.
  rewrite iter_list_app.
  unfold iter_list at 1; cbn.
  easy.
}
cbn - [ seq ].
rewrite Nat.sub_0_r.
rewrite rngl_product_list_mul_distr; [ | easy ].
rewrite List_seq_succ_r.
rewrite iter_list_app.
unfold iter_list at 1; cbn.
rewrite IHn.
rewrite iter_list_app; cbn.
rewrite iter_list_app; cbn.
unfold iter_list at 4 6; cbn.
do 3 rewrite <- rngl_mul_assoc.
f_equal.
rewrite (rngl_mul_comm (f n n)).
do 2 rewrite rngl_mul_assoc.
f_equal.
symmetry.
rewrite rngl_product_seq_product; [ | easy ].
cbn - [ seq ].
rewrite rngl_product_split_last; [ | flia Hnz ].
rewrite rngl_product_shift; [ | flia Hnz Hn1 ].
rewrite Nat.sub_add; [ | flia Hnz ].
unfold iter_seq.
rewrite Nat.sub_0_r.
rewrite <- Nat.sub_succ_l; [ | flia Hnz Hn1 ].
rewrite Nat.sub_succ, Nat.sub_0_r.
erewrite rngl_product_list_eq_compat. 2: {
  intros i Hi.
  rewrite (Nat.add_comm 1), Nat.add_sub.
  rewrite Nat.add_1_r.
  rewrite Nat.sub_succ.
  apply in_seq in Hi.
  replace (n - i) with (S (n - i - 1)) by flia Hnz Hn1 Hi.
  rewrite List_seq_succ_r.
  replace (S i + (n - i - 1)) with n by flia Hnz Hn1 Hi.
  unfold iter_list.
  rewrite fold_left_app.
  cbn - [ seq ].
  rewrite fold_iter_list.
  easy.
}
cbn - [ seq "-" ].
symmetry.
erewrite rngl_product_list_eq_compat. 2: {
  intros i Hi.
  rewrite Nat.add_1_r.
  rewrite Nat.sub_succ.
  now rewrite Nat_sub_sub_swap.
}
cbn - [ seq "-" ].
rewrite rngl_product_list_mul_distr; [ | easy ].
do 2 rewrite <- rngl_mul_assoc.
f_equal.
rewrite Nat.sub_succ_l; [ | easy ].
rewrite Nat.sub_diag.
unfold iter_list at 4; cbn.
rewrite rngl_mul_1_l.
rewrite rngl_product_seq_product; [ | easy ].
cbn - [ seq ].
rewrite rngl_product_split_last; [ | flia Hnz ].
rewrite rngl_product_shift; [ | flia Hnz Hn1 ].
unfold iter_seq.
rewrite Nat.sub_0_r.
rewrite <- Nat.sub_succ_l; [ | flia Hnz Hn1 ].
rewrite Nat.sub_succ, Nat.sub_0_r.
erewrite rngl_product_list_eq_compat. 2: {
  intros i Hi.
  rewrite (Nat.add_comm 1), Nat.add_sub.
  easy.
}
rewrite rngl_product_list_mul_distr; [ | easy ].
symmetry.
rewrite <- rngl_mul_assoc.
rewrite rngl_mul_comm.
do 3 rewrite <- rngl_mul_assoc.
f_equal.
rewrite rngl_mul_comm.
rewrite <- rngl_mul_assoc.
f_equal.
symmetry.
rewrite rngl_product_seq_product; [ | easy ].
cbn - [ seq ].
rewrite rngl_product_split_last; [ | flia Hnz ].
rewrite rngl_product_shift; [ | flia Hnz Hn1 ].
unfold iter_seq.
rewrite Nat.sub_0_r.
rewrite <- Nat.sub_succ_l; [ | flia Hnz Hn1 ].
rewrite Nat.sub_succ, Nat.sub_0_r.
erewrite rngl_product_list_eq_compat. 2: {
  intros i Hi.
  rewrite (Nat.add_comm 1), Nat.add_sub.
  easy.
}
easy.
Qed.

Theorem permut_swap_mul_cancel : ∀ n σ f,
  rngl_is_comm = true →
  rngl_has_inv = true →
  rngl_has_1_neq_0 = true →
  is_permut_fun σ n
  → (∀ i j, f i j = f j i)
  → (∀ i j, i < n → j < n → i ≠ j → f i j ≠ 0%F)
  → ∀ i j, i < n → j < n →
    (((if σ i <? σ j then f i j else 1) / (if i <? j then f i j else 1)) *
     ((if σ j <? σ i then f j i else 1) / (if j <? i then f j i else 1)))%F =
    1%F.
Proof.
intros * Hic Hin H10 Hp Hfij Hfijnz * Hlin Hljn.
specialize rngl_opt_mul_comm as rngl_mul_comm.
specialize rngl_opt_1_neq_0 as rngl_1_neq_0.
rewrite Hic in rngl_mul_comm.
rewrite H10 in rngl_1_neq_0.
do 4 rewrite if_ltb_lt_dec.
destruct (lt_dec (σ i) (σ j)) as [H1| H1]. {
  destruct (lt_dec (σ j) (σ i)) as [H| H]; [ flia H1 H | clear H ].
  destruct (lt_dec i j) as [H3| H3]. {
    destruct (lt_dec j i) as [H| H]; [ flia H3 H | clear H ].
    rewrite Hfij.
    rewrite rngl_mul_inv_r; [ | now left | ]. 2: {
      apply Hfijnz; [ easy | easy | flia H3 ].
    }
    rewrite rngl_mul_1_l.
    apply rngl_mul_inv_r; [ now left | easy ].
  }
  destruct (lt_dec j i) as [H4| H4]. {
    rewrite Hfij.
    rewrite rngl_div_1_r; [ | now left | easy ].
    rewrite rngl_div_1_l; [ | easy ].
    rewrite fold_rngl_div; [ | easy ].
    apply rngl_mul_inv_r; [ now left | ].
    apply Hfijnz; [ easy | easy | flia H4 ].
  }
  exfalso.
  apply Nat.nlt_ge in H3.
  apply Nat.nlt_ge in H4.
  apply Nat.le_antisymm in H3; [ | easy ].
  subst j; flia H1.
}
destruct (lt_dec (σ j) (σ i)) as [H2| H2]. {
  destruct (lt_dec i j) as [H3| H3]. {
    destruct (lt_dec j i) as [H| H]; [ flia H3 H | clear H ].
    rewrite Hfij.
    rewrite rngl_div_1_r; [ | now left | easy ].
    rewrite rngl_div_1_l; [ | easy ].
    rewrite rngl_mul_comm.
    rewrite fold_rngl_div; [ | easy ].
    apply rngl_mul_inv_r; [ now left | ].
    apply Hfijnz; [ easy | easy | flia H3 ].
  }
  destruct (lt_dec j i) as [H4| H4]. {
    rewrite Hfij.
    rewrite rngl_div_1_r; [ | now left | easy ].
    rewrite rngl_mul_1_l.
    apply rngl_mul_inv_r; [ now left | ].
    apply Hfijnz; [ easy | easy | flia H4 ].
  }
  exfalso.
  apply Nat.nlt_ge in H3.
  apply Nat.nlt_ge in H4.
  apply Nat.le_antisymm in H3; [ | easy ].
  subst j; flia H2.
}
apply Nat.nlt_ge in H1.
apply Nat.nlt_ge in H2.
apply Nat.le_antisymm in H1; [ | easy ].
destruct (lt_dec i j) as [H3| H3]. {
  destruct (lt_dec j i) as [H| H]; [ flia H3 H | clear H ].
  apply Hp in H1; [ flia H1 H3 | easy | easy ].
}
destruct (lt_dec j i) as [H4| H4]. {
  apply Hp in H1; [ flia H1 H4 | easy | easy ].
}
rewrite rngl_div_1_r; [ | now left | easy ].
apply rngl_mul_1_l.
Qed.

Theorem product_product_if_permut_div :
  rngl_is_comm = true →
  rngl_has_1_neq_0 = true →
  rngl_has_inv = true →
  ∀ n σ f,
  is_permut_fun σ n
  → (∀ i j, f i j = f j i)
  → (∀ i j, i < n → j < n → i ≠ j → f i j ≠ 0%F)
  → (Π (i ∈ seq 0 n), Π (j ∈ seq 0 n),
      ((if σ i <? σ j then f i j else 1) / (if i <? j then f i j else 1)))%F =
     1%F.
Proof.
intros Hic H10 Hin * Hp Hfij Hfijnz.
specialize rngl_opt_mul_comm as rngl_mul_comm.
specialize rngl_opt_1_neq_0 as rngl_1_neq_0.
rewrite Hic in rngl_mul_comm.
rewrite H10 in rngl_1_neq_0.
rewrite rngl_product_product_by_swap; [ | easy ].
rewrite all_1_rngl_product_list_1; [ | easy | ]. 2: {
  intros i Hi.
  do 2 rewrite if_ltb_lt_dec.
  destruct (lt_dec _ _) as [H| H]; [ flia H | clear H ].
  destruct (lt_dec _ _) as [H| H]; [ flia H | clear H ].
  apply rngl_div_1_r; [ now left | easy ].
}
rewrite rngl_mul_1_l.
apply all_1_rngl_product_list_1; [ easy | ].
intros i Hi.
apply all_1_rngl_product_list_1; [ easy | ].
intros j Hj.
apply in_seq in Hi.
apply in_seq in Hj.
apply (@permut_swap_mul_cancel n); try easy; [ flia Hi | flia Hj ].
Qed.

Theorem rngl_product_product_div_eq_1 :
  rngl_is_comm = true →
  rngl_has_inv = true →
  rngl_is_integral = true →
  rngl_has_1_neq_0 = true →
  rngl_has_dec_eq = true →
  ∀ n f g,
  (∀ i j, i < n → j < n → g i j ≠ 0%F)
  → (Π (i ∈ seq 0 n), (Π (j ∈ seq 0 n), (f i j / g i j)))%F = 1%F
  → (Π (i ∈ seq 0 n), (Π (j ∈ seq 0 n), f i j))%F =
    (Π (i ∈ seq 0 n), (Π (j ∈ seq 0 n), g i j))%F.
Proof.
intros Hic Hid Hin H10 Hed * Hg Hs.
specialize rngl_opt_1_neq_0 as rngl_1_neq_0.
specialize rngl_opt_eq_dec as rngl_eq_dec.
specialize @rngl_product_list_opt_integral as rngl_product_list_integral.
rewrite H10 in rngl_1_neq_0.
rewrite Hed in rngl_eq_dec.
specialize (rngl_product_list_integral T ro rp Hin H10).
destruct (Nat.eq_dec n 0) as [Hnz| Hnz]; [ now subst n | ].
remember (Π (i ∈ _), _)%F as a eqn:Ha in |-*.
remember (Π (i ∈ _), _)%F as b eqn:Hb in |-*.
destruct (rngl_eq_dec b 0%F) as [Hbz| Hbz]. {
  rewrite Hbz in Hb |-*; clear Hbz; subst a; symmetry in Hb.
  apply rngl_product_list_integral in Hb.
  destruct Hb as (i & His & Hb).
  apply rngl_product_list_integral in Hb.
  destruct Hb as (j & Hjs & Hb).
  move j before i.
  exfalso; revert Hb.
  apply in_seq in His.
  apply in_seq in Hjs.
  now apply Hg.
}
apply rngl_mul_reg_r with (c := (¹/ b)%F); [ now left | | ]. {
  intros Hbiz.
  apply (f_equal (rngl_mul b)) in Hbiz.
  rewrite fold_rngl_div in Hbiz; [ | easy ].
  rewrite rngl_mul_inv_r in Hbiz; [ | now left | easy ].
  now rewrite rngl_mul_0_r in Hbiz.
}
remember (_ * _)%F as c.
rewrite fold_rngl_div; [ | easy ].
rewrite rngl_mul_inv_r; [ | now left | easy ].
subst c b.
(**)
rewrite rngl_inv_product_list; [ | easy | easy | easy | ]. 2: {
  intros i Hi H1.
  apply rngl_product_list_integral in H1.
  destruct H1 as (j & Hjs & Hijz).
  exfalso.
  revert Hijz.
  apply in_seq in Hi.
  apply in_seq in Hjs.
  now apply Hg.
}
subst a.
erewrite rngl_product_list_permut with (l1 := rev _); [ | easy | ]. 2: {
  symmetry; apply Permutation_rev.
}
rewrite <- rngl_product_list_mul_distr; [ | easy ].
erewrite rngl_product_list_eq_compat. 2 :{
  intros i Hi.
  rewrite rngl_inv_product_list; [ | easy | easy | easy | ]. 2: {
    intros j Hj.
    apply in_seq in Hi.
    apply in_seq in Hj.
    now apply Hg.
  }
  erewrite rngl_product_list_permut with (l1 := rev _); [ | easy | ]. 2: {
    symmetry; apply Permutation_rev.
  }
  rewrite <- rngl_product_list_mul_distr; [ | easy ].
  erewrite rngl_product_list_eq_compat. 2: {
    intros j Hj.
    rewrite fold_rngl_div; [ | easy ].
    easy.
  }
  easy.
}
easy.
Qed.

Theorem product_product_if_permut :
  rngl_is_comm = true →
  rngl_has_inv = true →
  rngl_is_integral = true →
  rngl_has_1_neq_0 = true →
  rngl_has_dec_eq = true →
  ∀ n σ f,
  is_permut_fun σ n
  → (∀ i j, f i j = f j i)
  → (∀ i j, i < n → j < n → i ≠ j → f i j ≠ 0%F)
  → (Π (i ∈ seq 0 n), (Π (j ∈ seq 0 n), if σ i <? σ j then f i j else 1))%F =
    (Π (i ∈ seq 0 n), (Π (j ∈ seq 0 n), if i <? j then f i j else 1))%F.
Proof.
intros Hic Hid Hin H10 Hed * Hp Hfij Hfijnz.
specialize rngl_opt_1_neq_0 as rngl_1_neq_0.
rewrite H10 in rngl_1_neq_0.
apply rngl_product_product_div_eq_1; try easy. {
  intros i j Hi Hj.
  rewrite if_ltb_lt_dec.
  destruct (lt_dec i j) as [Hij| Hij]; [ | easy ].
  apply Hfijnz; [ easy | easy | flia Hij ].
}
now apply product_product_if_permut_div.
Qed.

Theorem rngl_of_nat_sub :
  rngl_has_opp = true →
  ∀ i j,
  i < j
  → (rngl_of_nat j - rngl_of_nat i)%F = rngl_of_nat (j - i).
Proof.
intros Hop * Hij.
revert j Hij.
induction i; intros; cbn. {
  rewrite rngl_sub_0_r; f_equal.
  now destruct j.
}
destruct j; [ easy | cbn ].
rewrite rngl_add_comm.
rewrite rngl_sub_add_distr; [ | easy ].
rewrite rngl_add_sub.
apply IHi.
now apply Nat.succ_lt_mono in Hij.
Qed.

Theorem rngl_of_nat_add : ∀ a b,
  (rngl_of_nat a + rngl_of_nat b)%F = rngl_of_nat (a + b).
Proof.
intros.
induction a; [ apply rngl_add_0_l | ].
now cbn; rewrite <- rngl_add_assoc; f_equal.
Qed.

Theorem rngl_of_nat_mul : ∀ a b,
  (rngl_of_nat a * rngl_of_nat b)%F = rngl_of_nat (a * b).
Proof.
intros.
induction a; [ apply rngl_mul_0_l | cbn ].
rewrite rngl_mul_add_distr_r.
rewrite rngl_mul_1_l.
rewrite IHa.
apply rngl_of_nat_add.
Qed.

Theorem rngl_product_rngl_of_nat :
  ∀ n, (Π (i = 1, n), rngl_of_nat i)%F = rngl_of_nat (fact n).
Proof.
intros.
induction n. {
  rewrite rngl_product_empty; [ | flia ].
  symmetry; apply rngl_add_0_r.
}
rewrite rngl_product_split_last; [ | flia ].
rewrite rngl_product_succ_succ.
erewrite rngl_product_eq_compat. 2: {
  intros i Hi.
  now rewrite Nat.sub_succ, Nat.sub_0_r.
}
rewrite IHn.
rewrite Nat_fact_succ.
rewrite Nat.mul_comm.
apply rngl_of_nat_mul.
Qed.

(* ε (σ₁ ° σ₂) = ε σ₁ * ε σ₂ *)

Theorem signature_comp_fun_expand_1 :
  rngl_has_opp = true →
  rngl_has_inv = true →
  rngl_has_1_neq_0 = true →
  rngl_is_integral = true →
  rngl_characteristic = 0 →
  ∀ n f g,
  is_permut_fun g n
  → (Π (i = 1, n),
        (Π (j = 1, n), δ i j (f (g (i - 1)%nat)) (f (g (j - 1)%nat))) /
      Π (i = 1, n), (Π (j = 1, n), δ i j (g (i - 1)%nat) (g (j - 1)%nat)))%F =
    (Π (i = 1, n), (Π (j = 1, n), δ i j (f (i - 1)%nat) (f (j - 1)%nat)) /
      Π (i = 1, n), (Π (j = 1, n), δ i j i j))%F
  → ε_fun (comp f g) n = (ε_fun f n * ε_fun g n)%F.
Proof.
intros Hop Hin H10 Hit Hch * Hp2 Hs.
unfold ε_fun, comp; cbn.
specialize rngl_opt_1_neq_0 as rngl_1_neq_0.
rewrite H10 in rngl_1_neq_0.
rewrite <- Hs; symmetry.
apply rngl_div_mul_div; [ easy | ].
intros Hij.
specialize (rngl_product_opt_integral Hit H10) as rngl_product_integral.
apply rngl_product_integral in Hij.
destruct Hij as (i & Hi & Hij).
apply rngl_product_integral in Hij.
destruct Hij as (j & Hj & Hij).
unfold δ in Hij.
rewrite if_ltb_lt_dec in Hij.
destruct (lt_dec i j) as [Hlij| Hlij]; [ | easy ].
apply rngl_sub_move_0_r in Hij; [ | easy ].
apply rngl_of_nat_inj in Hij; [ | easy ].
destruct Hp2 as (Hp21, Hp22).
apply Hp22 in Hij; [ flia Hi Hj Hlij Hij | flia Hj | flia Hi ].
Qed.

Theorem signature_comp_fun_expand_2_1 :
  rngl_has_opp = true →
  rngl_has_inv = true →
  rngl_is_comm = true →
  rngl_has_1_neq_0 = true →
  rngl_is_integral = true →
  rngl_characteristic = 0 →
  ∀ n f g,
  is_permut_fun g n
  → (Π (i = 1, n),
      (Π (j = 1, n), δ i j (f (g (i - 1)%nat)) (f (g (j - 1)%nat))) /
     Π (i = 1, n), (Π (j = 1, n), δ i j (g (i - 1)%nat) (g (j - 1)%nat)))%F =
    (Π (i = 1, n),
      (Π (j = 1, n),
       (if i <? j then
         (rngl_of_nat (f (g (j - 1)%nat)) - rngl_of_nat (f (g (i - 1)%nat))) /
         (rngl_of_nat (g (j - 1)%nat) - rngl_of_nat (g (i - 1)%nat))
       else 1)))%F.
Proof.
intros Hop Hin Hic H10 Hit Hch * Hp2.
specialize rngl_opt_1_neq_0 as rngl_1_neq_0.
rewrite H10 in rngl_1_neq_0.
unfold rngl_div; rewrite Hin.
rewrite rngl_inv_product_comm; [ | easy | easy | easy | easy | ]. 2: {
  intros i Hi Hij.
  specialize (rngl_product_opt_integral Hit H10) as rngl_product_integral.
  apply rngl_product_integral in Hij.
  destruct Hij as (j & Hj & Hij).
  unfold δ in Hij.
  rewrite if_ltb_lt_dec in Hij.
  destruct (lt_dec i j) as [Hlij| Hlij]; [ | easy ].
  apply rngl_sub_move_0_r in Hij; [ | easy ].
  apply rngl_of_nat_inj in Hij; [ | easy ].
  apply Hp2 in Hij; [ flia Hi Hj Hlij Hij | flia Hj | flia Hi ].
}
erewrite <- rngl_product_mul_distr; [ | easy ].
erewrite rngl_product_eq_compat. 2: {
  intros i Hi.
  rewrite rngl_inv_product_comm; [ | easy | easy | easy | easy | ]. 2: {
    intros j Hj Hij.
    unfold δ in Hij.
    rewrite if_ltb_lt_dec in Hij.
    destruct (lt_dec i j) as [Hlij| Hlij]; [ | easy ].
    apply rngl_sub_move_0_r in Hij; [ | easy ].
    apply rngl_of_nat_inj in Hij; [ | easy ].
    apply Hp2 in Hij; [ flia Hi Hj Hlij Hij | flia Hj | flia Hi ].
  }
  erewrite <- rngl_product_mul_distr; [ | easy ].
  easy.
}
cbn - [ "<?" ].
erewrite rngl_product_eq_compat. 2: {
  intros i Hi.
  erewrite rngl_product_eq_compat. 2: {
    intros j Hj.
    move j before i.
    unfold δ.
    rewrite rngl_inv_if_then_else_distr.
    rewrite rngl_mul_if_then_else_distr.
    rewrite fold_rngl_div; [ | easy ].
    rewrite rngl_inv_1; [ | easy | easy ].
    rewrite rngl_mul_1_l.
    easy.
  }
  easy.
}
cbn - [ "<?" ].
unfold rngl_div; rewrite Hin.
easy.
Qed.

Theorem signature_comp_fun_expand_2_2 :
  rngl_has_opp = true →
  rngl_has_inv = true →
  rngl_is_comm = true →
  rngl_has_1_neq_0 = true →
  rngl_is_integral = true →
  rngl_characteristic = 0 →
  ∀ n f,
  (Π (i = 1, n), (Π (j = 1, n), δ i j (f (i - 1)%nat) (f (j - 1)%nat)) /
   Π (i = 1, n), (Π (j = 1, n), δ i j i j))%F =
  (Π (i = 1, n),
   (Π (j = 1, n),
    (if i <? j then
      (rngl_of_nat (f (j - 1)%nat) - rngl_of_nat (f (i - 1)%nat)) /
      rngl_of_nat (j - i)
     else 1)))%F.
Proof.
intros Hop Hin Hic H10 Hit Hch *.
specialize rngl_opt_1_neq_0 as rngl_1_neq_0.
rewrite H10 in rngl_1_neq_0.
unfold rngl_div; rewrite Hin.
rewrite rngl_inv_product_comm; [ | easy | easy | easy | easy | ]. 2: {
  intros i Hi Hij.
  specialize @rngl_product_opt_integral as rngl_product_integral.
  specialize (rngl_product_integral T ro rp Hit H10).
  apply rngl_product_integral in Hij.
  destruct Hij as (j & Hj & Hij).
  unfold δ in Hij.
  rewrite if_ltb_lt_dec in Hij.
  destruct (lt_dec i j) as [Hlij| Hlij]; [ | easy ].
  apply rngl_sub_move_0_r in Hij; [ | easy ].
  apply rngl_of_nat_inj in Hij; [ | easy ].
  flia Hlij Hij.
}
erewrite <- rngl_product_mul_distr; [ | easy ].
erewrite rngl_product_eq_compat. 2: {
  intros i Hi.
  rewrite rngl_inv_product_comm; [ | easy | easy | easy | easy | ]. 2: {
    intros j Hj Hij.
    unfold δ in Hij.
    rewrite if_ltb_lt_dec in Hij.
    destruct (lt_dec i j) as [Hlij| Hlij]; [ | easy ].
    apply rngl_sub_move_0_r in Hij; [ | easy ].
    apply rngl_of_nat_inj in Hij; [ | easy ].
    flia Hlij Hij.
  }
  erewrite <- rngl_product_mul_distr; [ | easy ].
  easy.
}
erewrite rngl_product_eq_compat. 2: {
  intros i Hi.
  erewrite rngl_product_eq_compat. 2: {
    intros j Hj.
    move j before i.
    unfold δ.
    rewrite rngl_inv_if_then_else_distr.
    rewrite rngl_mul_if_then_else_distr.
    rewrite fold_rngl_div; [ | easy ].
    rewrite rngl_inv_1; [ | easy | easy ].
    rewrite rngl_mul_1_l.
    easy.
  }
  easy.
}
unfold rngl_div; rewrite Hin.
apply rngl_product_eq_compat.
intros i Hi.
apply rngl_product_eq_compat.
intros j Hj.
do 2 rewrite if_ltb_lt_dec.
destruct (lt_dec i j) as [Hij| Hij]; [ | easy ].
f_equal; f_equal.
now apply rngl_of_nat_sub.
Qed.

Theorem signature_comp_fun_changement_of_variable :
  rngl_has_opp = true →
  rngl_has_inv = true →
  rngl_is_comm = true →
  rngl_has_dec_eq = true →
  rngl_has_1_neq_0 = true →
  rngl_is_integral = true →
  rngl_characteristic = 0 →
  ∀ n f g,
  is_permut_fun f n
  → is_permut_fun g n
  → (Π (i = 1, n),
     (Π (j = 1, n),
      (if i <? j then
         (rngl_of_nat (f (g (j - 1)%nat)) - rngl_of_nat (f (g (i - 1)%nat))) /
         (rngl_of_nat (g (j - 1)%nat) - rngl_of_nat (g (i - 1)%nat))
       else 1)))%F =
    (Π (i = 1, n),
     (Π (j = 1, n),
      (if i <? j then
         (rngl_of_nat (f (j - 1)%nat) - rngl_of_nat (f (i - 1)%nat)) /
         rngl_of_nat (j - i)
       else 1)))%F.
Proof.
intros Hop Hin Hic Hde H10 Hit Hch * Hp1 Hp2.
destruct (Nat.eq_dec n 0) as [Hnz| Hnz]; [ now subst n | ].
rewrite rngl_product_shift; [ | flia Hnz ].
erewrite rngl_product_eq_compat. 2: {
  intros i Hi.
  erewrite rngl_product_eq_compat. 2: {
    intros j Hj.
    now rewrite (Nat.add_comm 1), Nat.add_sub.
  }
  easy.
}
cbn - [ "<?" ].
rewrite rngl_product_change_var with (g := permut_fun_inv g n) (h := g). 2: {
  intros i Hi.
  rewrite fun_find_prop; [ easy | apply Hp2 | flia Hi Hnz ].
}
rewrite <- Nat.sub_succ_l; [ | flia Hnz ].
rewrite Nat.sub_succ, Nat.sub_0_r, Nat.sub_0_r.
erewrite rngl_product_list_eq_compat. 2: {
  intros i Hi.
  rewrite rngl_product_shift; [ | flia Hnz ].
  rewrite rngl_product_change_var with
      (g := permut_fun_inv g n) (h := g). 2: {
    intros j Hj.
    rewrite fun_find_prop; [ easy | apply Hp2 | flia Hj Hnz ].
  }
  rewrite <- Nat.sub_succ_l; [ | flia Hnz ].
  rewrite Nat.sub_succ, Nat.sub_0_r, Nat.sub_0_r.
  erewrite rngl_product_list_eq_compat. 2: {
    intros j Hj.
    rewrite (Nat.add_comm _ 1).
    rewrite Nat_ltb_mono_l.
    rewrite fun_permut_fun_inv; [ | apply Hp2 | ]. 2: {
      apply in_map_iff in Hi.
      destruct Hi as (k & Hk & Hkn).
      apply in_seq in Hkn.
      rewrite <- Hk.
      now apply Hp2.
    }
    rewrite Nat.add_comm, Nat.add_sub.
    rewrite fun_permut_fun_inv; [ | apply Hp2 | ]. 2: {
      apply in_map_iff in Hj.
      destruct Hj as (k & Hk & Hkn).
      apply in_seq in Hkn.
      rewrite <- Hk.
      now apply Hp2.
    }
    easy.
  }
  easy.
}
cbn - [ "<?" ].
erewrite rngl_product_list_eq_compat. 2: {
  intros j Hj.
  erewrite rngl_product_change_list; [ | easy | ]. 2: {
    now apply permut_fun_Permutation.
  }
  easy.
}
cbn - [ "<?" ].
erewrite rngl_product_change_list; [ | easy | ]. 2: {
  now apply permut_fun_Permutation.
}
symmetry.
rewrite rngl_product_shift; [ | flia Hnz ].
erewrite rngl_product_eq_compat. 2: {
  intros i Hi.
  rewrite rngl_product_shift; [ | flia Hnz ].
  erewrite rngl_product_eq_compat. 2: {
    intros j Hj.
    rewrite Nat_ltb_mono_l.
    rewrite Nat.add_comm, Nat.add_sub.
    rewrite Nat.add_comm, Nat.add_sub.
    do 2 rewrite Nat.add_1_r.
    cbn - [ "<?" ].
    easy.
  }
  easy.
}
unfold iter_seq.
rewrite <- Nat.sub_succ_l; [ | flia Hnz ].
rewrite Nat.sub_succ, Nat.sub_0_r, Nat.sub_0_r.
symmetry.
rewrite product_product_if_permut; try easy. {
  apply rngl_product_list_eq_compat.
  intros i Hi.
  apply rngl_product_list_eq_compat.
  intros j Hj.
  do 2 rewrite if_ltb_lt_dec.
  destruct (lt_dec i j) as [Hij| Hij]; [ | easy ].
  f_equal.
  now apply rngl_of_nat_sub.
} {
  now apply permut_fun_inv_is_permut.
} {
  intros i j.
  destruct (Nat.eq_dec i j) as [Hij| Hij]; [ now subst j | ].
  rewrite <- rngl_opp_sub_distr; [ | easy ].
  unfold rngl_div.
  rewrite Hin.
  rewrite rngl_mul_opp_l; [ | easy ].
  rewrite <- rngl_mul_opp_r; [ | easy ].
  f_equal.
  rewrite rngl_opp_inv; [ | easy | easy | easy | ]. 2: {
    intros H.
    apply rngl_sub_move_0_r in H; [ | easy ].
    apply Hij; symmetry.
    now apply rngl_of_nat_inj in H.
  }
  now rewrite rngl_opp_sub_distr.
} {
  intros * Hi Hj Hij.
  unfold rngl_div.
  rewrite Hin.
  intros H.
  specialize rngl_opt_integral as rngl_integral.
  rewrite Hit in rngl_integral.
  apply rngl_integral in H.
  destruct H as [H| H]. {
    apply rngl_sub_move_0_r in H; [ | easy ].
    apply rngl_of_nat_inj in H; [ | easy ].
    apply Hij; symmetry.
    now apply Hp1 in H.
  } {
    revert H.
    apply rngl_inv_neq_0; [ easy | easy | ].
    intros H.
    apply rngl_sub_move_0_r in H; [ | easy ].
    apply rngl_of_nat_inj in H; [ | easy ].
    now apply Hij; symmetry.
  }
}
Qed.

Theorem signature_comp_fun :
  rngl_has_opp = true →
  rngl_has_inv = true →
  rngl_is_comm = true →
  rngl_has_dec_eq = true →
  rngl_has_1_neq_0 = true →
  rngl_is_integral = true →
  rngl_characteristic = 0 →
  ∀ n f g,
  is_permut_fun f n
  → is_permut_fun g n
  → ε_fun (comp f g) n = (ε_fun f n * ε_fun g n)%F.
Proof.
intros Hop Hin Hic Hde H10 Hit Hch * Hp1 Hp2.
apply signature_comp_fun_expand_1; try easy.
rewrite signature_comp_fun_expand_2_1; try easy.
rewrite signature_comp_fun_expand_2_2; try easy.
now apply signature_comp_fun_changement_of_variable.
Qed.

Theorem signature_comp :
  rngl_has_opp = true →
  rngl_has_inv = true →
  rngl_is_comm = true →
  rngl_has_dec_eq = true →
  rngl_has_1_neq_0 = true →
  rngl_is_integral = true →
  rngl_characteristic = 0 →
  ∀ n (σ₁ σ₂ : vector n nat),
  is_permut σ₁
  → is_permut σ₂
  → ε (σ₁ ° σ₂) = (ε σ₁ * ε σ₂)%F.
Proof.
intros Hop Hin Hic Hde H10 Hit Hch * Hp1 Hp2.
now apply signature_comp_fun.
Qed.

(* definition of determinant by sum of products involving all
   permutations *)

Definition determinant' n (M : matrix n n T) :=
  (Σ (k = 0, fact n - 1), ε (canon_permut n k) *
   Π (i = 1, n), mat_el M (i - 1) (vect_el (canon_permut n k) (i - 1)%nat))%F.

Theorem ε_canon_permut_succ : ∀ n k,
  k < fact (S n)
  → ε_canon_permut (S n) k =
     (minus_one_pow (k / fact n) * ε_canon_permut n (k mod fact n))%F.
Proof. easy. Qed.

Theorem ε_canon_permut_ε_canon_permut :
  rngl_has_inv = true ∨ rngl_has_no_inv_but_div = true →
  rngl_has_1_neq_0 = true →
  ∀ n k, k < fact n → ε (canon_permut n k) = ε_canon_permut n k.
Proof.
intros Hin H10 * Hkn.
unfold ε.
revert k Hkn.
induction n; intros. {
  apply rngl_mul_inv_r; [ easy | cbn ].
  specialize rngl_opt_1_neq_0 as rngl_1_neq_0.
  now rewrite H10 in rngl_1_neq_0.
}
cbn.
rewrite <- IHn. 2: {
  apply Nat.mod_upper_bound.
  apply fact_neq_0.
}
Abort. (*
...
unfold ε_fun.
unfold rngl_div.
destruct rngl_has_inv. {
rewrite rngl_mul_assoc.
rewrite rngl_mul_mul_swap. {
specialize rngl_opt_mul_comm as rngl_mul_comm.
destruct rngl_is_comm. {
rewrite rngl_mul_comm.
f_equal.
...
*)

(*
Theorem minus_one_pow_ε :
  rngl_has_opp = true →
  rngl_has_inv = true ∨ rngl_has_no_inv_but_div = true →
  rngl_has_1_neq_0 = true →
  ∀ n k,
  k < fact (S n)
  → ε (canon_permut (S n) k) =
    (minus_one_pow (k / fact n) * ε (canon_permut n (k mod fact n)))%F.
Proof.
(*
intros Hop Hiv H10 * Hk.
rewrite ε_canon_permut_ε_canon_permut.
rewrite ε_canon_permut_ε_canon_permut.
apply ε_canon_permut_succ.
...
unfold ε.
cbn - [ canon_permut ].
...
*)
intros Hop Hiv H10 * Hk.
revert k Hk.
induction n; intros. {
  apply Nat.lt_1_r in Hk; subst k.
  cbn - [ "/" "mod" canon_permut ].
  rewrite Nat.div_1_r, Nat.mod_1_r.
  unfold ε, ε_fun; cbn.
  unfold iter_seq, iter_list; cbn.
  now do 3 rewrite rngl_mul_1_l.
}
(*
unfold ε.
remember (S n) as sn; cbn; subst sn.
*)
destruct n. {
  cbn in Hk.
  destruct k. {
    unfold ε, ε_fun; cbn.
    unfold iter_seq, iter_list; cbn.
    rewrite rngl_add_0_r, rngl_sub_0_r.
    rewrite rngl_add_sub.
    now do 5 rewrite rngl_mul_1_l.
  }
  destruct k; [ cbn | flia Hk ].
  unfold ε, ε_fun; cbn.
  unfold iter_seq, iter_list; cbn.
  rewrite rngl_add_0_r.
  rewrite rngl_add_sub.
  do 6 rewrite rngl_mul_1_l.
  unfold rngl_sub.
  rewrite Hop, rngl_add_0_l.
  rewrite rngl_div_1_r; [ | easy | easy ].
  rewrite rngl_div_1_r; [ | easy | easy ].
  easy.
}
*)

Theorem canon_permut_succ_values : ∀ n k σ σ',
  σ = vect_el (canon_permut (S n) k)
  → σ' = vect_el (canon_permut n (k mod fact n))
  → ∀ i,
    σ i =
    match i with
    | 0 => k / fact n
    | S i' => if σ' i' <? k / fact n then σ' i' else σ' i' + 1
    end.
Proof.
intros * Hσ Hσ' i.
destruct i; [ now subst σ | ].
subst σ; cbn - [ "<?" ].
subst σ'; cbn - [ "<?" ].
rewrite Nat.leb_antisym.
unfold Nat.b2n.
rewrite if_ltb_lt_dec.
rewrite negb_if.
rewrite if_ltb_lt_dec.
destruct (lt_dec _ _) as [H1| H1]; [ | easy ].
apply Nat.add_0_r.
Qed.

(* equality of both definitions of ε: ε and ε_ws *)

Theorem rngl_product_product_if : ∀ b e f,
  (Π (i = b, e), Π (j = b, e), if i <? j then f i j else 1)%F =
  (Π (i = b, e), Π (j = i + 1, e), f i j)%F.
Proof.
intros.
apply rngl_product_eq_compat.
intros i Hi.
rewrite (rngl_product_split i); [ | flia Hi ].
rewrite all_1_rngl_product_1; [ | easy | ]. 2: {
  intros j Hj.
  rewrite if_ltb_lt_dec.
  destruct (lt_dec i j) as [H| H]; [ flia Hj H | easy ].
}
rewrite rngl_mul_1_l.
apply rngl_product_eq_compat.
intros j Hj.
rewrite if_ltb_lt_dec.
destruct (lt_dec i j) as [H| H]; [ easy | flia Hj H ].
Qed.

Theorem rngl_sub_is_mul_sign_abs :
  rngl_has_opp = true →
  ∀ a b,
  (rngl_of_nat a - rngl_of_nat b)%F =
  (sign_diff a b * rngl_of_nat (abs_diff a b))%F.
Proof.
intros Hop *.
unfold sign_diff, abs_diff.
do 2 rewrite if_ltb_lt_dec.
destruct (lt_dec b a) as [Hba| Hba]. {
  rewrite rngl_mul_1_l.
  now apply rngl_of_nat_sub.
} {
  apply Nat.nlt_ge in Hba.
  destruct (Nat.eq_dec a b) as [Hab| Hab]. {
    subst b.
    rewrite rngl_add_opp_r, Nat.sub_diag; cbn.
    symmetry.
    apply rngl_mul_0_r.
  }
  rewrite <- rngl_opp_sub_distr; [ | easy ].
  rewrite rngl_of_nat_sub; [ | easy | flia Hba Hab ].
  rewrite rngl_mul_opp_l; [ | easy ].
  now rewrite rngl_mul_1_l.
}
Qed.

Theorem ε_ws_ε_fun :
  rngl_is_comm = true →
  rngl_has_opp = true →
  rngl_has_inv = true →
  rngl_has_1_neq_0 = true →
  rngl_is_integral = true →
  rngl_has_dec_eq = true →
  rngl_characteristic = 0 →
  ∀ σ n,
  is_permut_fun σ n
  → ε_fun σ n = ε_fun_ws σ n.
Proof.
intros Hic Hop Hin H10 Hit Hde Hch * Hp.
specialize rngl_opt_1_neq_0 as rngl_1_neq_0.
rewrite H10 in rngl_1_neq_0.
unfold ε_fun, ε_fun_ws, δ.
rewrite rngl_product_product_if.
rewrite rngl_product_product_if.
rewrite rngl_product_product_if.
rewrite <- rngl_product_div_distr; try easy. 2: {
  intros i Hi.
  erewrite rngl_product_eq_compat. 2: {
    intros j Hj.
    rewrite rngl_of_nat_sub; [ | easy | flia Hj ].
    easy.
  }
  cbn.
  destruct (Nat.eq_dec i n) as [Hein| Hein]. {
    subst i.
    rewrite rngl_product_empty; [ easy | flia ].
  }
  rewrite rngl_product_shift; [ | flia Hi Hein ].
  erewrite rngl_product_eq_compat. 2: {
    intros j Hj.
    replace (i + 1 + j - i) with (S j) by flia.
    easy.
  }
  cbn - [ rngl_of_nat ].
  erewrite <- rngl_product_succ_succ.
  replace (S (n - (i + 1))) with (n - i) by flia Hi Hein.
  rewrite rngl_product_rngl_of_nat.
  intros H.
  apply eq_rngl_of_nat_0 in H; [ | easy ].
  now apply fact_neq_0 in H.
}
erewrite rngl_product_eq_compat. 2: {
  intros i Hi.
  rewrite <- rngl_product_div_distr; try easy.
  intros j Hj.
  intros H.
  apply rngl_sub_move_0_r in H; [ | easy ].
  apply rngl_of_nat_inj in H; [ | easy ].
  flia Hj H.
}
cbn.
erewrite rngl_product_eq_compat. 2: {
  intros i Hi.
  erewrite rngl_product_eq_compat. 2: {
    intros j Hj.
    rewrite rngl_sub_is_mul_sign_abs; [ | easy ].
    rewrite rngl_sub_is_mul_sign_abs; [ | easy ].
    replace (sign_diff j i) with 1%F. 2: {
      unfold sign_diff.
      rewrite if_ltb_lt_dec.
      destruct (lt_dec i j) as [H| H]; [ easy | flia Hj H ].
    }
    rewrite rngl_mul_1_l.
    replace (rngl_of_nat (abs_diff j i)) with (rngl_of_nat (j - i)). 2: {
      unfold abs_diff.
      rewrite if_ltb_lt_dec.
      destruct (lt_dec i j) as [H| H]; [ easy | flia Hj H ].
    }
    easy.
  }
  easy.
}
cbn.
erewrite rngl_product_eq_compat. 2: {
  intros i Hi.
  erewrite rngl_product_eq_compat. 2: {
    intros j Hj.
    unfold rngl_div.
    rewrite Hin.
    rewrite <- rngl_mul_assoc.
    easy.
  }
  cbn.
  rewrite rngl_product_mul_distr; [ | easy ].
  easy.
}
cbn.
rewrite rngl_product_mul_distr; [ | easy ].
rewrite <- rngl_mul_1_r; f_equal.
erewrite rngl_product_eq_compat. 2: {
  intros i Hi.
  erewrite rngl_product_eq_compat. 2: {
    intros j Hj.
    rewrite fold_rngl_div; [ | easy ].
    easy.
  }
  cbn.
  rewrite rngl_product_div_distr; try easy.
  intros j Hj.
  intros H.
  apply eq_rngl_of_nat_0 in H; [ | easy ].
  flia Hj H.
}
cbn.
destruct (Nat.eq_dec n 0) as [Hnz| Hnz]. {
  subst n.
  rewrite rngl_product_empty; [ easy | flia ].
}
erewrite rngl_product_eq_compat. 2: {
  intros i Hi.
  replace n with (S (n - 1)) at 1 2 by flia Hnz.
  rewrite Nat.add_1_r at 1 2.
  rewrite rngl_product_succ_succ.
  rewrite rngl_product_succ_succ.
  erewrite rngl_product_eq_compat. 2: {
    intros j Hj.
    now rewrite Nat.sub_succ, Nat.sub_0_r.
  }
  cbn - [ "-" ].
  easy.
}
cbn - [ "-" ].
erewrite rngl_product_shift; [ | flia Hnz ].
erewrite rngl_product_eq_compat. 2: {
  intros i Hi.
  rewrite (Nat.add_comm 1).
  erewrite rngl_product_eq_compat. 2: {
    intros j Hj.
    rewrite Nat.add_sub.
    easy.
  }
  remember (iter_seq _ _ _ _) as x.
  erewrite rngl_product_eq_compat. 2: {
    intros j Hj.
    now rewrite Nat.add_1_r, Nat.sub_succ.
  }
  subst x.
  easy.
}
cbn.
rewrite rngl_product_div_distr; try easy. 2: {
  intros i Hi H.
  apply (rngl_product_opt_integral Hit H10) in H.
  destruct H as (j & Hj & Hji).
  apply eq_rngl_of_nat_0 in Hji; [ | easy ].
  flia Hj Hji.
}
apply eq_rngl_div_1; [ now left | | ]. {
  intros H.
  apply (rngl_product_opt_integral Hit H10) in H.
  destruct H as (i & Hi & H).
  apply (rngl_product_opt_integral Hit H10) in H.
  destruct H as (j & Hj & H).
  apply eq_rngl_of_nat_0 in H; [ | easy ].
  flia Hj H.
}
rewrite <- rngl_product_product_if; symmetry.
rewrite <- rngl_product_product_if; symmetry.
(* changt de var *)
rewrite rngl_product_change_var with (g := permut_fun_inv σ n) (h := σ). 2: {
  intros i Hi.
  destruct Hp as (Hp1, Hp2).
  rewrite fun_find_prop; [ easy | easy | flia Hi Hnz ].
}
rewrite Nat.sub_0_r.
rewrite <- Nat.sub_succ_l; [ | flia Hnz ].
rewrite Nat.sub_succ, Nat.sub_0_r.
erewrite rngl_product_list_eq_compat. 2: {
  intros i Hi.
  rewrite rngl_product_change_var with (g := permut_fun_inv σ n) (h := σ). 2: {
    intros j Hj.
    destruct Hp as (Hp1, Hp2).
    rewrite fun_find_prop; [ easy | easy | flia Hj Hnz ].
  }
  rewrite <- Nat.sub_succ_l; [ | flia Hnz ].
  rewrite Nat.sub_succ, Nat.sub_0_r.
  erewrite rngl_product_list_eq_compat. 2: {
    intros j Hj.
    apply in_map_iff in Hj.
    destruct Hj as (k & Hk & Hsk).
    apply in_seq in Hsk.
    rewrite fun_permut_fun_inv; [ | easy | ]. 2: {
      destruct Hp as (Hp1, Hp2).
      rewrite <- Hk.
      apply Hp1.
      flia Hsk Hi Hnz.
    }
    apply in_map_iff in Hi.
    destruct Hi as (l & Hl & Hsl).
    apply in_seq in Hsl.
    rewrite fun_permut_fun_inv; [ | easy | ]. 2: {
      destruct Hp as (Hp1, Hp2).
      rewrite <- Hl.
      apply Hp1.
      easy.
    }
    easy.
  }
  cbn - [ "-" "<?" ].
  easy.
}
cbn - [ "-" "<?" ].
rewrite Nat.sub_0_r.
rewrite rngl_product_list_permut with (l2 := seq 0 n); [ | easy | ]. 2: {
  now apply permut_fun_Permutation.
}
erewrite rngl_product_list_eq_compat. 2: {
  intros i Hi.
  rewrite rngl_product_change_list with (lb := seq 0 n); [ | easy | ]. 2: {
    now apply permut_fun_Permutation.
  }
  easy.
}
cbn - [ "<?" ].
rewrite product_product_if_permut; try easy; cycle 1. {
  now apply permut_fun_inv_is_permut.
} {
  intros.
  unfold abs_diff.
  do 2 rewrite if_ltb_lt_dec.
  destruct (lt_dec i j) as [Hij| Hij]. {
    destruct (lt_dec j i) as [Hji| Hji]; [ flia Hij Hji | easy ].
  } {
    destruct (lt_dec j i) as [Hji| Hji]; [ easy | ].
    now replace i with j by flia Hij Hji.
  }
} {
  intros * Hi Hj Hij H.
  apply eq_rngl_of_nat_0 in H; [ | easy ].
  unfold abs_diff in H.
  rewrite if_ltb_lt_dec in H.
  destruct (lt_dec i j) as [Hlij| Hlij]; flia Hij Hlij H.
}
rewrite rngl_product_seq_product; [ | easy ].
rewrite Nat.add_0_l.
erewrite rngl_product_eq_compat. 2: {
  intros i Hi.
  rewrite rngl_product_seq_product; [ | easy ].
  rewrite Nat.add_0_l.
  easy.
}
cbn - [ "<?" ].
unfold abs_diff.
apply rngl_product_eq_compat.
intros i Hi.
apply rngl_product_eq_compat.
intros j Hj.
do 3 rewrite if_ltb_lt_dec.
now destruct (lt_dec i j).
Qed.

Theorem ε_ws_ε :
  rngl_is_comm = true →
  rngl_has_opp = true →
  rngl_has_inv = true →
  rngl_has_1_neq_0 = true →
  rngl_is_integral = true →
  rngl_has_dec_eq = true →
  rngl_characteristic = 0 →
  ∀ n (p : vector n nat),
  is_permut p
  → ε p = ε_ws p.
Proof.
intros Hic Hop Hin H10 Hit Hde Hch *.
now apply ε_ws_ε_fun.
Qed.

...

(* equality of ε (canon_permut) and ε_canon_permut *)

Theorem ε_of_canon_permut_succ :
  rngl_is_comm = true →
  rngl_has_opp = true →
  rngl_has_inv = true →
  ∀ n k,
  k < fact (S n)
  → ε (canon_permut (S n) k) =
    (minus_one_pow (k / fact n) * ε (canon_permut n (k mod fact n)))%F.
Proof.
intros Hic Hop Hin * Hkn.
unfold ε, ε_fun.
(* use ε_ws *)
...
intros Hic Hop Hin * Hkn.
specialize rngl_opt_mul_comm as rngl_mul_comm.
rewrite Hic in rngl_mul_comm.
unfold ε, ε_fun; cbn - [ canon_permut ].
destruct (Nat.eq_dec n 0) as [Hnz| Hnz]. {
  subst n.
  apply Nat.lt_1_r in Hkn.
  subst k; cbn.
  unfold iter_seq, iter_list; cbn.
  now repeat rewrite rngl_mul_1_l.
}
remember (vect_el (canon_permut (S n) k)) as σ eqn:Hσ.
remember (vect_el (canon_permut n (k mod fact n))) as σ' eqn:Hσ'.
move σ' before σ.
specialize (canon_permut_succ_values Hσ Hσ') as Hσσ.
rewrite rngl_product_succ_succ.
rewrite rngl_product_succ_succ.
erewrite rngl_product_eq_compat. 2: {
  intros i Hi.
  rewrite rngl_product_succ_succ.
  rewrite Nat.sub_succ, Nat.sub_0_r.
  erewrite rngl_product_eq_compat. 2: {
    intros j Hj.
    rewrite Nat.sub_succ, Nat.sub_0_r.
    replace (δ (S i) _ _ _) with (δ i j (σ i) (σ j)) by easy.
    easy.
  }
  easy.
}
remember (iter_seq _ _ _ _) as x eqn:Hx.
erewrite rngl_product_eq_compat. 2: {
  intros i Hi.
  rewrite rngl_product_succ_succ.
  erewrite rngl_product_eq_compat. 2: {
    intros j Hj.
    replace (δ (S i) _ _ _) with (δ i j i j). 2: {
      unfold δ; cbn - [ "<?" ].
      rewrite rngl_add_comm.
      unfold rngl_sub; rewrite Hop.
      rewrite rngl_opp_add_distr; [ | easy ].
      unfold rngl_sub; rewrite Hop.
      rewrite (rngl_add_comm _ (-1)%F).
      rewrite <- rngl_add_assoc.
      rewrite (rngl_add_assoc 1%F).
      rewrite fold_rngl_sub; [ | easy ].
      rewrite fold_rngl_sub; [ | easy ].
      rewrite fold_rngl_sub; [ | easy ].
      rewrite rngl_add_opp_r.
      unfold rngl_sub; rewrite Hop.
      rewrite rngl_add_0_l.
      rewrite fold_rngl_sub; [ | easy ].
      easy.
    }
    easy.
  }
  easy.
}
subst x; symmetry.
rewrite rngl_product_shift; [ | flia Hnz ].
erewrite rngl_product_eq_compat. 2: {
  intros i Hi.
  rewrite rngl_product_shift; [ | flia Hnz ].
  erewrite rngl_product_eq_compat. 2: {
    intros j Hj.
    rewrite (Nat.add_comm _ i), Nat.add_sub.
    rewrite (Nat.add_comm _ j), Nat.add_sub.
    replace (δ (i + 1) _ _ _) with (δ i j (σ' i) (σ' j)). 2: {
      now do 2 rewrite Nat.add_1_r.
    }
    easy.
  }
  easy.
}
remember (Π (i = _, _), _)%F as x eqn:Hx.
rewrite rngl_product_shift; [ | flia Hnz ].
erewrite rngl_product_eq_compat. 2: {
  intros i Hi.
  rewrite rngl_product_shift; [ | flia Hnz ].
  erewrite rngl_product_eq_compat. 2: {
    intros j Hj.
    replace (δ (1 + i) _ _ _) with (δ i j i j). 2: {
      unfold δ.
      cbn - [ "<?" ].
      rewrite rngl_add_comm.
      unfold rngl_sub; rewrite Hop.
      rewrite rngl_opp_add_distr; [ | easy ].
      unfold rngl_sub; rewrite Hop.
      rewrite (rngl_add_comm _ (-1)%F).
      rewrite <- rngl_add_assoc.
      rewrite (rngl_add_assoc 1%F).
      rewrite fold_rngl_sub; [ | easy ].
      rewrite fold_rngl_sub; [ | easy ].
      rewrite fold_rngl_sub; [ | easy ].
      rewrite rngl_add_opp_r.
      unfold rngl_sub; rewrite Hop.
      rewrite rngl_add_0_l.
      rewrite fold_rngl_sub; [ | easy ].
      easy.
    }
    easy.
  }
  easy.
}
subst x; symmetry.
..
(**)
rewrite rngl_product_split_first; [ | easy | flia ].
rewrite rngl_product_split_first; [ | easy | flia ].
rewrite Nat.sub_diag.
unfold δ at 1.
rewrite if_ltb_lt_dec.
destruct (lt_dec 1 1) as [H| H]; [ flia H | clear H ].
rewrite rngl_mul_1_l.
erewrite rngl_product_eq_compat. 2: {
  intros j Hj.
  unfold δ.
  rewrite if_ltb_lt_dec.
  destruct (lt_dec 1 j) as [H| H]; [ clear H | flia Hj H ].
  remember (rngl_of_nat _) as x.
  rewrite Hσσ; subst x.
  easy.
}
cbn.
rewrite rngl_mul_comm.
erewrite rngl_product_eq_compat. 2: {
  intros i Hi.
  rewrite rngl_product_split_first; [ | easy | flia ].
  unfold δ at 1.
  rewrite if_ltb_lt_dec.
  destruct (lt_dec i 1) as [H| H]; [ flia H Hi | clear H ].
  rewrite rngl_mul_1_l.
  erewrite rngl_product_eq_compat. 2: {
    intros j Hj.
    rewrite Hσσ.
    replace (i - 1) with (S (i - 2)) by flia Hi.
    replace (j - 1) with (S (j - 2)) by flia Hj.
    rewrite Hσσ.
    easy.
  }
  easy.
}
cbn - [ "<?" ].
set (σ₀ := k / fact n) in Hσσ |-*.
unfold δ.
...
erewrite rngl_product_eq_compat. 2: {
  intros i Hi.
  erewrite rngl_product_eq_compat. 2: {
    intros j Hj.
    rewrite (@canon_permut_succ_values n k σ σ'); [ | easy | easy | flia Hi ].
    rewrite (@canon_permut_succ_values n k σ σ'); [ | easy | easy | flia Hj ].
    easy.
  }
  easy.
}
cbn - [ "<?" ].
rewrite rngl_product_split_first; [ | easy | flia ].
rewrite Nat.sub_diag.
rewrite rngl_product_split_first; [ | easy | flia ].
rewrite Nat.sub_diag.
unfold δ at 1.
unfold "<?" at 1, "<=?".
rewrite rngl_mul_1_l.
rewrite rngl_product_succ_succ.
erewrite rngl_product_eq_compat. 2: {
  intros i Hi.
  rewrite Nat.sub_succ, Nat.sub_0_r.
  unfold δ.
  rewrite if_ltb_lt_dec.
  destruct (lt_dec 1 (S i)) as [H| H]; [ clear H | flia Hi H ].
  replace i with (S (i - 1)) at 1 by flia Hi.
  easy.
}
cbn - [ "<?" ].
rewrite rngl_mul_comm.
unfold δ at 1.
rewrite rngl_product_succ_succ.
erewrite rngl_product_eq_compat. 2: {
  intros i Hi.
  replace (S i - 1) with (S (i - 1)) by flia Hi.
  rewrite rngl_product_succ_succ.
  rewrite rngl_product_split_first; [ | easy | flia ].
  rewrite if_ltb_lt_dec.
  destruct (lt_dec (S i) 1) as [H| H]; [ flia H | clear H ].
  rewrite rngl_mul_1_l.
  erewrite rngl_product_eq_compat. 2: {
    intros j Hj.
    rewrite Nat.sub_succ, Nat.sub_0_r.
    replace (S i <? S j) with (i <? j) by easy.
    remember (i <? j) as b.
    replace j with (S (j - 1)) at 1 by flia Hj.
    subst b.
    easy.
  }
  easy.
}
cbn - [ "<?" ].
...
}
rewrite rngl_product_split_last. {
remember (Π (i = _, _), _)%F as a eqn:Ha in |-*.
remember (Π (j = _, _), _)%F as b eqn:Hb in |-*.
remember (Π (i = _, _), _)%F as c eqn:Hc in |-*.
remember (Π (i = _, _), _)%F as d eqn:Hd in |-*.
remember (Π (i = _, _), _)%F as e eqn:He in |-*.
remember (Π (i = _, _), _)%F as f eqn:Hf in |-*.
move b before a; move c before b; move d before c.
move e before d; move f before e.
rewrite rngl_mul_mul_swap; [ | easy ].
unfold rngl_div.
rewrite Hin.
rewrite <- rngl_mul_assoc.
f_equal. 2: {
  subst b d e f.
...
intros * Hkn.
unfold ε, ε_fun; cbn.
rewrite rngl_product_shift; [ | flia ].
rewrite Nat.sub_succ, Nat.sub_0_r.
erewrite rngl_product_eq_compat. 2: {
  intros i Hi.
  rewrite rngl_product_shift; [ | flia ].
  rewrite Nat.sub_succ, Nat.sub_0_r.
  rewrite Nat.add_comm, Nat.add_sub.
  erewrite rngl_product_eq_compat. 2: {
    intros j Hj.
    rewrite (Nat.add_comm 1 j), Nat.add_sub.
    unfold δ.
    rewrite (Nat.add_comm i), (Nat.add_comm j).
    rewrite Nat_ltb_mono_l.
    easy.
  }
  easy.
}
cbn - [ "<?" ].
...
intros * Hkn.
unfold ε; cbn.
revert k Hkn.
induction n; intros. {
  apply Nat.lt_1_r in Hkn; subst k; cbn.
  rewrite rngl_mul_1_l.
  unfold ε_fun; cbn.
  unfold iter_seq, iter_list; cbn.
  now do 2 rewrite rngl_mul_1_l.
}
cbn - [ fact ].
...
*)

(* Proof that both definitions of determinants are equal *)

Theorem det_is_det_by_canon_permut :
  rngl_is_comm = true →
  rngl_has_inv = true ∨ rngl_has_no_inv_but_div = true →
  rngl_has_1_neq_0 = true →
  ∀ n (M : matrix n n T), determinant M = determinant' M.
Proof.
intros Hic Hin H10 *.
unfold determinant, determinant'.
destruct n; intros. {
  unfold iter_seq, iter_list.
  cbn; rewrite rngl_add_0_l.
  unfold ε, ε_fun, iter_seq, iter_list; cbn.
(*
  rewrite rngl_div_1_r; [ | easy | easy ].
*)
  symmetry; apply rngl_mul_1_l.
}
erewrite rngl_summation_eq_compat. 2: {
  intros i Hi.
  rewrite rngl_product_succ_succ.
  erewrite rngl_product_eq_compat. 2: {
    intros j Hj.
    now rewrite Nat.sub_succ, Nat.sub_0_r.
  }
  easy.
}
cbn - [ fact det_loop canon_permut ε ].
revert M.
induction n; intros. {
  cbn.
  unfold ε, ε_fun, iter_seq, iter_list; cbn.
  do 2 rewrite rngl_add_0_l.
  do 3 rewrite rngl_mul_1_l.
  rewrite rngl_div_1_r; [ | easy | easy ].
  rewrite rngl_mul_1_l.
  now rewrite rngl_mul_1_r.
}
remember (S n) as sn.
cbn - [ fact "mod" "/" canon_permut ]; subst sn.
erewrite rngl_summation_eq_compat. 2: {
  intros i Hi.
  now rewrite IHn.
}
cbn - [ fact "mod" "/" canon_permut ].
erewrite rngl_summation_eq_compat. 2: {
  intros i Hi.
  now rewrite rngl_mul_summation_distr_l.
}
cbn - [ fact "mod" "/" canon_permut ].
rewrite rngl_summation_summation_distr; [ | easy ].
rewrite <- Nat.sub_succ_l; [ | apply lt_O_fact ].
rewrite Nat.sub_succ, Nat.sub_0_r.
rewrite <- Nat_fact_succ.
symmetry.
erewrite rngl_summation_eq_compat. 2: {
  intros i Hi.
  rewrite rngl_product_split_first; [ | easy | flia ].
  rewrite rngl_product_succ_succ.
  easy.
}
cbn - [ fact "mod" "/" canon_permut ].
symmetry.
apply rngl_summation_eq_compat.
intros k Hk.
do 2 rewrite rngl_mul_assoc.
f_equal. 2: {
  apply rngl_product_eq_compat.
  intros i Hi.
  now rewrite Nat.add_1_r.
}
rewrite rngl_mul_mul_swap; [ | easy ].
symmetry.
specialize rngl_opt_mul_comm as rngl_mul_comm.
rewrite Hic in rngl_mul_comm.
f_equal.
...
apply ε_of_canon_permut_succ.
specialize (fact_neq_0 (S (S n))) as Hnz.
flia Hk Hnz.
...
(*
rewrite <- rngl_mul_assoc.
f_equal.
rewrite rngl_mul_assoc, rngl_mul_mul_swap; symmetry; [ | easy ].
rewrite rngl_mul_mul_swap; [ | easy ].
f_equal.
specialize rngl_opt_mul_comm as rngl_mul_comm.
rewrite Hic in rngl_mul_comm.
apply rngl_mul_comm.
*)
...
*)

(* multilinearity *)

Theorem determinant_multilinear :
  rngl_is_comm = true
  → ∀ n (M : matrix n n T) i a b U V,
    i < n
    → determinant (mat_repl_vect i M (a × U + b × V)%V) =
         (a * determinant (mat_repl_vect i M U) +
          b * determinant (mat_repl_vect i M V))%F.
Proof.
intros Hic * Hi.
rewrite det_is_det_by_canon_permut; [ | easy ].
rewrite det_is_det_by_canon_permut; [ | easy ].
rewrite det_is_det_by_canon_permut; [ | easy ].
unfold determinant'.
erewrite rngl_summation_eq_compat. 2: {
  intros k Hk.
  erewrite rngl_product_eq_compat. 2: {
    intros j Hj.
    now cbn.
  }
  easy.
}
cbn.
specialize rngl_opt_mul_comm as rngl_mul_comm.
rewrite Hic in rngl_mul_comm.
rewrite rngl_mul_summation_distr_l.
rewrite rngl_mul_summation_distr_l.
symmetry.
erewrite rngl_summation_eq_compat. 2: {
  intros k Hk.
  rewrite rngl_mul_assoc.
  now rewrite (rngl_mul_comm a).
}
rewrite rngl_add_comm.
erewrite rngl_summation_eq_compat. 2: {
  intros k Hk.
  rewrite rngl_mul_assoc.
  now rewrite (rngl_mul_comm b).
}
rewrite rngl_add_comm.
rewrite <- rngl_summation_add_distr; [ | easy ].
apply rngl_summation_eq_compat.
intros k Hk.
do 2 rewrite <- rngl_mul_assoc.
rewrite <- rngl_mul_add_distr_l.
f_equal.
assert (Hkn : k < fact n). {
  specialize (fact_neq_0 n) as Hnz.
  flia Hk Hnz.
}
specialize (canon_permut_surjective Hkn Hi) as Hp.
destruct Hp as (p & Hp & Hpp).
rewrite (rngl_product_split (p + 1)); [ | flia Hp ].
rewrite rngl_product_split_last; [ | flia ].
erewrite rngl_product_eq_compat. 2: {
  intros j Hj.
  replace (j - 1 - 1) with (j - 2) by flia.
  destruct (Nat.eq_dec (vect_el (canon_permut n k) (j - 2)) i) as [Hpj| Hpj]. {
    exfalso.
    rewrite <- Hpp in Hpj.
    apply canon_permut_injective in Hpj; [ | easy | flia Hp Hj | easy ].
    flia Hj Hpj.
  }
  easy.
}
rewrite (rngl_mul_comm (iter_seq _ _ _ _)).
rewrite rngl_add_comm.
rewrite (rngl_product_split (p + 1)); [ | flia Hp ].
rewrite rngl_product_split_last; [ | flia ].
erewrite rngl_product_eq_compat. 2: {
  intros j Hj.
  replace (j - 1 - 1) with (j - 2) by flia.
  destruct (Nat.eq_dec (vect_el (canon_permut n k) (j - 2)) i) as [Hpj| Hpj]. {
    exfalso.
    rewrite <- Hpp in Hpj.
    apply canon_permut_injective in Hpj; [ | easy | flia Hp Hj | easy ].
    flia Hj Hpj.
  }
  easy.
}
rewrite (rngl_mul_comm (iter_seq _ _ _ _)).
rewrite rngl_add_comm.
symmetry.
rewrite (rngl_product_split (p + 1)); [ | flia Hp ].
rewrite rngl_product_split_last; [ | flia ].
erewrite rngl_product_eq_compat. 2: {
  intros j Hj.
  replace (j - 1 - 1) with (j - 2) by flia.
  destruct (Nat.eq_dec (vect_el (canon_permut n k) (j - 2)) i) as [Hpj| Hpj]. {
    exfalso.
    rewrite <- Hpp in Hpj.
    apply canon_permut_injective in Hpj; [ | easy | flia Hp Hj | easy ].
    flia Hj Hpj.
  }
  easy.
}
rewrite (rngl_mul_comm (iter_seq _ _ _ _)).
rewrite Nat.add_sub.
rewrite Hpp.
destruct (Nat.eq_dec i i) as [H| H]; [ clear H | easy ].
do 4 rewrite rngl_mul_assoc.
remember
  (Π (i0 = 2, p + 1),
   mat_el M (i0 - 2) (vect_el (canon_permut n k) (i0 - 2)%nat))%F
  as q eqn:Hq.
rewrite (rngl_mul_mul_swap Hic _ _ q).
do 3 rewrite (rngl_mul_comm _ q).
do 5 rewrite <- rngl_mul_assoc.
rewrite <- rngl_mul_add_distr_l.
f_equal.
clear q Hq.
erewrite rngl_product_eq_compat. 2: {
  intros j Hj.
  destruct (Nat.eq_dec (vect_el (canon_permut n k) (j - 1)) i) as [Hpj| Hpj]. {
    rewrite <- Hpp in Hpj.
    apply canon_permut_injective in Hpj; [ | easy | flia Hp Hj | easy ].
    flia Hj Hpj.
  }
  easy.
}
symmetry.
erewrite rngl_product_eq_compat. 2: {
  intros j Hj.
  destruct (Nat.eq_dec (vect_el (canon_permut n k) (j - 1)) i) as [Hpj| Hpj]. {
    rewrite <- Hpp in Hpj.
    apply canon_permut_injective in Hpj; [ | easy | flia Hp Hj | easy ].
    flia Hj Hpj.
  }
  easy.
}
rewrite rngl_add_comm.
erewrite rngl_product_eq_compat. 2: {
  intros j Hj.
  destruct (Nat.eq_dec (vect_el (canon_permut n k) (j - 1)) i) as [Hpj| Hpj]. {
    rewrite <- Hpp in Hpj.
    apply canon_permut_injective in Hpj; [ | easy | flia Hp Hj | easy ].
    flia Hj Hpj.
  }
  easy.
}
cbn.
rewrite rngl_add_comm.
do 2 rewrite rngl_mul_assoc.
now rewrite <- rngl_mul_add_distr_r.
Qed.

(* compute the rank of a given permutation *)

Definition nat_of_canon_permut_sub_vect n (v : vector n nat) n' :=
  let d := vect_el v 0 in
  mk_vect n' (λ i, vect_el v (S i) - Nat.b2n (d <? vect_el v (S i))).

Fixpoint nat_of_canon_permut n (v : vector n nat) : nat :=
  match n with
  | 0 => 0
  | S n' =>
      let d := vect_el v 0 in
      d * fact n' +
      nat_of_canon_permut (nat_of_canon_permut_sub_vect v n')
  end.

Theorem Nat_b2n_upper_bound : ∀ b, Nat.b2n b ≤ 1.
Proof.
intros; destruct b; cbn; flia.
Qed.

Theorem vect_el_nat_of_canon_permut_ub : ∀ n (v : vector (S n) nat) i,
  (∀ i, i < S n → vect_el v i < S n)
  → (∀ i j, i < S n → j < S n → i ≠ j → vect_el v i ≠ vect_el v j)
  → i < n
  → vect_el (nat_of_canon_permut_sub_vect v n) i < n.
Proof.
intros * Hvn Hn Hin.
destruct n; [ easy | ].
cbn - [ "<?" ].
remember (vect_el v 0 <? vect_el v (S i)) as b eqn:Hb.
symmetry in Hb.
specialize (Hvn (S i)) as H1.
specialize (Hn 0 (S i) (Nat.lt_0_succ _)) as H2.
assert (H : S i < S (S n)) by flia Hin.
specialize (H1 H); specialize (H2 H); clear H.
destruct b; cbn; [ flia H1 | ].
rewrite Nat.sub_0_r.
apply Nat.ltb_ge in Hb.
destruct (Nat.eq_dec (vect_el v (S i)) (S n)) as [Hvi| Hvi]; [ | flia H1 Hvi ].
specialize (Hvn 0 (Nat.lt_0_succ _)) as H3.
flia Hb H1 H2 H3 Hvi.
Qed.

Theorem vect_el_nat_of_canon_permut_diff : ∀ n (v : vector (S n) nat) i j,
  (∀ i, i < S n → vect_el v i < S n)
  → (∀ i j, i < S n → j < S n → i ≠ j → vect_el v i ≠ vect_el v j)
  → i < n
  → j < n
  → i ≠ j
  → vect_el (nat_of_canon_permut_sub_vect v n) i ≠
    vect_el (nat_of_canon_permut_sub_vect v n) j.
Proof.
intros * Hvn Hn Hin Hjn Hij.
destruct n; [ easy | ].
cbn - [ "<?" ].
remember (vect_el v 0 <? vect_el v (S i)) as bi eqn:Hbi.
remember (vect_el v 0 <? vect_el v (S j)) as bj eqn:Hbj.
symmetry in Hbi, Hbj.
move bj before bi.
destruct bi; cbn. {
  apply Nat.ltb_lt in Hbi.
  destruct bj; cbn. {
    apply Nat.ltb_lt in Hbj.
    apply Nat.succ_lt_mono in Hin.
    apply Nat.succ_lt_mono in Hjn.
    specialize (Hn (S i) (S j) Hin Hjn) as Hs.
    assert (H : S i ≠ S j) by flia Hij.
    specialize (Hs H); clear H.
    flia Hbi Hbj Hs.
  } {
    apply Nat.ltb_ge in Hbj.
    apply Nat.succ_lt_mono in Hjn.
    specialize (Hn 0 (S j) (Nat.lt_0_succ _) Hjn) as H1.
    flia Hbi Hbj H1.
  }
} {
  apply Nat.ltb_ge in Hbi.
  destruct bj; cbn. {
    apply Nat.ltb_lt in Hbj.
    apply Nat.succ_lt_mono in Hin.
    specialize (Hn 0 (S i) (Nat.lt_0_succ _) Hin) as H1.
    flia Hbi Hbj H1.
  } {
    apply Nat.ltb_ge in Hbj.
    apply Nat.succ_lt_mono in Hin.
    apply Nat.succ_lt_mono in Hjn.
    specialize (Hn (S i) (S j) Hin Hjn) as Hs.
    assert (H : S i ≠ S j) by flia Hij.
    specialize (Hs H); clear H.
    flia Hbi Hbj Hs.
  }
}
Qed.

Theorem nat_of_canon_permut_upper_bound : ∀ n (v : vector n nat),
  (∀ i, i < n → vect_el v i < n)
  → (∀ i j, i < n → j < n → i ≠ j → vect_el v i ≠ vect_el v j)
  → nat_of_canon_permut v < fact n.
Proof.
intros * Hvn Hn.
revert v Hvn Hn.
induction n; intros; [ cbn; flia | ].
cbn.
rewrite Nat.add_comm.
apply Nat.add_lt_le_mono. {
  apply IHn. {
    intros i Hi.
    now apply vect_el_nat_of_canon_permut_ub.
  } {
    intros i j Hi Hj.
    now apply vect_el_nat_of_canon_permut_diff.
  }
}
apply Nat.mul_le_mono_r.
specialize (Hvn 0 (Nat.lt_0_succ _)).
flia Hvn.
Qed.

Theorem nat_of_canon_permut_permut : ∀ n k,
  k < fact n
  → nat_of_canon_permut (canon_permut n k) = k.
Proof.
intros * Hkn.
revert k Hkn.
induction n; intros; [ now apply Nat.lt_1_r in Hkn | cbn ].
specialize (Nat.div_mod k (fact n) (fact_neq_0 _)) as H1.
rewrite Nat.mul_comm in H1.
replace (k / fact n * fact n) with (k - k mod fact n) by flia H1.
rewrite <- Nat.add_sub_swap; [ | apply Nat.mod_le, fact_neq_0 ].
apply Nat.add_sub_eq_r; f_equal.
clear H1.
rewrite <- (IHn (k mod fact n)) at 1. 2: {
  apply Nat.mod_upper_bound, fact_neq_0.
}
f_equal.
apply vector_eq.
intros i Hi; cbn.
symmetry.
apply Nat.add_sub_eq_r.
f_equal.
remember (Nat.b2n (_ <=? _)) as b eqn:Hb.
rewrite Nat.add_comm.
symmetry in Hb.
destruct b. 2: {
  cbn.
  destruct b; [ easy | exfalso ].
  unfold Nat.b2n in Hb.
  destruct (k / fact n <=? _); flia Hb.
}
cbn.
remember (vect_el (canon_permut n _) i) as x eqn:Hx.
symmetry in Hx.
destruct x; [ easy | ].
unfold Nat.b2n in Hb |-*.
remember (k / fact n) as y eqn:Hy; symmetry in Hy.
remember (y <=? S x) as c eqn:Hc; symmetry in Hc.
destruct c; [ easy | clear Hb ].
apply Nat.leb_gt in Hc.
remember (y <=? x) as b eqn:Hb.
symmetry in Hb.
destruct b; [ | easy ].
apply Nat.leb_le in Hb.
flia Hb Hc.
Qed.

Theorem permut_nat_of_canon_permut : ∀ n v,
  (∀ i, i < n → vect_el v i < n)
  → (∀ i j, i < n → j < n → i ≠ j → vect_el v i ≠ vect_el v j)
  → canon_permut n (nat_of_canon_permut v) = v.
Proof.
intros * Hvn Hn.
revert v Hvn Hn.
induction n; intros; [ now apply vector_eq | ].
apply vector_eq.
intros j Hj; cbn.
destruct j. {
  cbn; clear Hj.
  rewrite Nat.div_add_l; [ | apply fact_neq_0 ].
  rewrite <- Nat.add_0_r; f_equal.
  apply Nat.div_small.
  apply nat_of_canon_permut_upper_bound. {
    intros i Hi.
    now apply vect_el_nat_of_canon_permut_ub.
  } {
    intros i j Hi Hj.
    now apply vect_el_nat_of_canon_permut_diff.
  }
}
cbn.
remember (nat_of_canon_permut (nat_of_canon_permut_sub_vect v n)) as k eqn:Hk.
symmetry in Hk.
rewrite Nat.div_add_l; [ | apply fact_neq_0 ].
rewrite Nat_mod_add_l_mul_r; [ | apply fact_neq_0 ].
assert (Hkn : k < fact n). {
  rewrite <- Hk.
  apply nat_of_canon_permut_upper_bound. {
    intros i Hi.
    now apply vect_el_nat_of_canon_permut_ub.
  } {
    intros i m Hi Hm.
    now apply vect_el_nat_of_canon_permut_diff.
  }
}
rewrite Nat.div_small; [ | easy ].
rewrite Nat.mod_small; [ | easy ].
rewrite Nat.add_0_r.
remember (vect_el v 0 <=? vect_el (canon_permut n k) j) as b eqn:Hb.
symmetry in Hb.
assert (H1 : ∀ i, i < n → vect_el (nat_of_canon_permut_sub_vect v n) i < n). {
  intros i Hi.
  now apply vect_el_nat_of_canon_permut_ub.
}
assert
(H2 : ∀ i j : nat,
    i < n
    → j < n
    → i ≠ j
    → vect_el (nat_of_canon_permut_sub_vect v n) i ≠
      vect_el (nat_of_canon_permut_sub_vect v n) j). {
  intros i m Hi Hm Him.
  now apply vect_el_nat_of_canon_permut_diff.
}
destruct b. {
  apply Nat.leb_le in Hb; cbn.
  rewrite <- Hk in Hb |-*.
  rewrite IHn in Hb |-*; [ | easy | easy | easy | easy ].
  cbn - [ "<?" ] in Hb |-*.
  remember (vect_el v 0 <? vect_el v (S j)) as b1 eqn:Hb1.
  symmetry in Hb1.
  destruct b1. {
    apply Nat.ltb_lt in Hb1; cbn.
    apply Nat.sub_add; flia Hb1.
  } {
    apply Nat.ltb_ge in Hb1; exfalso.
    cbn in Hb.
    rewrite Nat.sub_0_r in Hb.
    apply (Hn 0 (S j) (Nat.lt_0_succ _) Hj); [ easy | ].
    now apply Nat.le_antisymm.
  }
} {
  apply Nat.leb_gt in Hb; cbn.
  rewrite Nat.add_0_r.
  rewrite <- Hk in Hb |-*.
  remember (vect_el v 0 <? vect_el v (S j)) as b1 eqn:Hb1.
  symmetry in Hb1.
  destruct b1. {
    rewrite IHn in Hb; [ | easy | easy ].
    cbn - [ "<?" ] in Hb.
    rewrite Hb1 in Hb; cbn in Hb.
    apply Nat.ltb_lt in Hb1.
    flia Hb1 Hb.
  } {
    rewrite IHn; [ | easy | easy ].
    cbn - [ "<?" ].
    rewrite Hb1; cbn.
    apply Nat.sub_0_r.
  }
}
Qed.

(* list of terms in determinant' (determinant by sum of products of
   permutations *)

Definition determinant'_list {n} (M : matrix n n T) :=
  map (λ k,
    (ε_canon_permut n k *
     Π (i = 1, n), mat_el M (i - 1) (vect_el (canon_permut n k) (i - 1)%nat))%F)
    (seq 0 (fact n)).

Theorem determinant'_by_list : ∀ n (M : matrix n n T),
  determinant' M = (Σ (k = 0, fact n - 1), nth k (determinant'_list M) 0)%F.
Proof.
intros.
unfold determinant', determinant'_list.
apply rngl_summation_eq_compat; intros k Hk.
assert (Hkn : k < fact n). {
  specialize (fact_neq_0 n) as Hn.
  flia Hk Hn.
}
rewrite List_map_nth_in with (a := 0); [ | now rewrite seq_length ].
rewrite seq_nth; [ | easy ].
now rewrite Nat.add_0_l.
Qed.

...

Theorem rngl_summation_permut : ∀ n l1 l2,
  Permutation l1 l2
  → length l1 = n
  → length l2 = n
  → (Σ (i = 0, n - 1), nth i l1 0 = Σ (i = 0, n - 1), nth i l2 0)%F.
Proof.
intros * Hl H1 H2.
destruct n. {
  apply length_zero_iff_nil in H1.
  apply length_zero_iff_nil in H2.
  now subst l1 l2.
}
rewrite Nat.sub_succ, Nat.sub_0_r.
revert n H1 H2.
induction Hl; intros; [ easy | | | ]. {
  cbn in H1, H2.
  apply Nat.succ_inj in H1.
  apply Nat.succ_inj in H2.
  rewrite rngl_summation_split_first; [ symmetry | easy | flia ].
  rewrite rngl_summation_split_first; [ symmetry | easy | flia ].
  destruct n; [ easy | ].
  do 2 rewrite rngl_summation_succ_succ.
  now rewrite IHHl.
} {
  destruct n; [ easy | ].
  cbn in H1, H2.
  do 2 apply Nat.succ_inj in H1.
  do 2 apply Nat.succ_inj in H2.
  rewrite rngl_summation_split_first; [ symmetry | easy | flia ].
  rewrite rngl_summation_split_first; [ symmetry | easy | flia ].
  rewrite rngl_summation_split_first; [ symmetry | easy | flia ].
  rewrite rngl_summation_split_first; [ symmetry | easy | flia ].
  do 2 rewrite rngl_add_assoc.
  do 2 rewrite rngl_summation_succ_succ.
  f_equal; [ apply rngl_add_comm | ].
  apply rngl_summation_eq_compat.
  intros i Hi; cbn.
  destruct i; [ flia Hi | easy ].
} {
  specialize (Permutation_length Hl2) as H3.
  rewrite H2 in H3.
  rewrite IHHl1; [ | easy | easy ].
  now rewrite IHHl2.
}
Qed.

Theorem det_is_det_by_any_permut :
  rngl_is_comm = true
  → ∀ n (M : matrix n n T) l,
  Permutation l (determinant'_list M)
  → determinant M = (Σ (k = 0, fact n - 1), nth k l 0)%F.
Proof.
intros Hic * Hl.
rewrite det_is_det_by_canon_permut; [ | easy ].
rewrite determinant'_by_list.
apply rngl_summation_permut; [ now symmetry | | ]. {
  unfold determinant'_list.
  now rewrite map_length, seq_length.
} {
  apply Permutation_length in Hl.
  unfold determinant'_list in Hl.
  now rewrite map_length, seq_length in Hl.
}
Qed.

Definition swap_nat i j k :=
  if Nat.eq_dec k i then j
  else if Nat.eq_dec k j then i
  else k.

Definition vect_swap_elem n (v : vector n nat) i j :=
  mk_vect n (λ k, vect_el v (swap_nat i j k)).

(* i such that vect_el (permut n k) i = j *)

Definition canon_permut_swap_with_0 p n k :=
  vect_swap_elem (canon_permut n k) 0 p.

(* k' such that permut_swap_with_0 p n k = permut n k' *)

Definition canon_permut_nth_of_swap_with_0 (p n k : nat) :=
  nat_of_canon_permut (canon_permut_swap_with_0 p n k).

Definition canon_permut_swap_last (p q : nat) n k :=
  vect_swap_elem (vect_swap_elem (canon_permut n k) p (n - 2)) q (n - 1).

(* yet another definition of determinant *)

Definition determinant'' p q n (M : matrix n n T) :=
  (Σ (k = 0, fact n - 1), ε_canon_permut n k *
   Π (i = 1, n),
   mat_el M (i - 1) (vect_el (canon_permut_swap_last p q n k) (i - 1)%nat))%F.

Definition determinant''_list p q {n} (M : matrix n n T) :=
  map (λ k,
    (ε_canon_permut n k *
     Π (i = 1, n),
     mat_el M (i - 1) (vect_el (canon_permut_swap_last p q n k) (i - 1)%nat))%F)
    (seq 0 (fact n)).

Theorem determinant''_by_list : ∀ n p q (M : matrix n n T),
  determinant'' p q M =
    (Σ (k = 0, fact n - 1), nth k (determinant''_list p q M) 0)%F.
Proof.
intros.
unfold determinant'', determinant''_list.
apply rngl_summation_eq_compat; intros k Hk.
assert (Hkn : k < fact n). {
  specialize (fact_neq_0 n) as Hn.
  flia Hk Hn.
}
rewrite List_map_nth_in with (a := 0); [ | now rewrite seq_length ].
rewrite seq_nth; [ | easy ].
now rewrite Nat.add_0_l.
Qed.

(* perhaps rather prove is_permut (canon_permut n k) and
   use vect_el_permut_ub *)
Theorem vect_el_canon_permut_ub : ∀ n k i,
  k < fact n
  → i < n
  → vect_el (canon_permut n k) i < n.
Proof.
intros * Hkn Hin.
revert k i Hkn Hin.
induction n; intros; [ easy | cbn ].
unfold canon_permut_fun.
destruct i. {
  rewrite Nat_fact_succ, Nat.mul_comm in Hkn.
  apply Nat.div_lt_upper_bound; [ | easy ].
  apply fact_neq_0.
}
apply Nat.succ_lt_mono in Hin.
remember (k / fact n <=? vect_el (canon_permut n (k mod fact n)) i) as b eqn:Hb.
symmetry in Hb.
destruct b. {
  cbn; rewrite Nat.add_1_r.
  apply -> Nat.succ_lt_mono.
  apply IHn; [ | easy ].
  apply Nat.mod_upper_bound, fact_neq_0.
}
cbn; rewrite Nat.add_0_r.
apply Nat.leb_gt in Hb.
etransitivity; [ apply Hb | ].
rewrite Nat_fact_succ, Nat.mul_comm in Hkn.
apply Nat.div_lt_upper_bound; [ | easy ].
apply fact_neq_0.
Qed.

Theorem swap_nat_swap_nat : ∀ n p q j k,
  p < q < n
  → j < n
  → k < n
  → j ≠ k
  → swap_nat p (n - 2) (swap_nat q (n - 1) j) ≠
    swap_nat p (n - 2) (swap_nat q (n - 1) k).
Proof.
intros * (Hpq, Hqn) Hjn Hkn Hjk Hjke.
unfold swap_nat in Hjke.
destruct (Nat.eq_dec j q) as [H1| H1]. {
  subst j.
  destruct (Nat.eq_dec k q) as [H1| H1]; [ now subst k | ].
  clear H1.
  destruct (Nat.eq_dec (n - 1) p) as [H1| H1]. {
    subst p; flia Hpq Hqn.
  }
  destruct (Nat.eq_dec (n - 1) (n - 2)) as [H2| H2]. {
    destruct n; [ easy | ].
    destruct n; [ | flia H2 ].
    apply Nat.lt_1_r in Hqn; subst q.
    now apply Nat.lt_1_r in Hkn; subst k.
  }
  destruct (Nat.eq_dec k (n - 1)) as [H3| H3]. {
    subst k.
    destruct (Nat.eq_dec q p) as [H4| H4]; [ now subst q | ].
    destruct (Nat.eq_dec q (n - 2)) as [H5| H5]; [ now subst p | ].
    now subst q.
  }
  destruct (Nat.eq_dec k p) as [H4| H4]; [ easy | ].
  destruct (Nat.eq_dec k (n - 2)) as [H5| H5]; [ now subst p | ].
  now subst k.
} {
  destruct (Nat.eq_dec k q) as [H2| H2]. {
    subst k; clear Hkn H1.
    destruct (Nat.eq_dec j (n - 1)) as [H1| H1]. {
      subst j.
      destruct (Nat.eq_dec q p) as [H| H]; [ subst q; flia Hpq | ].
      clear H Hjn.
      destruct (Nat.eq_dec (n - 1) p) as [H1| H1]. {
        subst p; flia Hpq Hqn.
      }
      destruct (Nat.eq_dec q (n - 1)) as [H| H]; [ now subst q | ].
      clear H.
      destruct (Nat.eq_dec q (n - 2)) as [H2| H2]. {
        subst q.
        destruct (Nat.eq_dec (n - 1) (n - 2)) as [H| H]. {
          destruct n; [ easy | ].
          destruct n; [ | flia H ].
          flia Hpq.
        }
        now symmetry in Hjke.
      }
      destruct (Nat.eq_dec (n - 1) (n - 2)) as [H3| H3]. {
        subst q; flia Hpq.
      }
      now symmetry in Hjke.
    }
    destruct (Nat.eq_dec j p) as [H2| H2]. {
      subst j.
      destruct (Nat.eq_dec (n - 1) p) as [H3| H3]; [ now subst p | ].
      destruct (Nat.eq_dec (n - 1) (n - 2)) as [H2| H2]; [ now subst p | ].
      destruct n; [ easy | ].
      destruct n; [ flia H2 | flia Hjke ].
    }
    destruct (Nat.eq_dec j (n - 2)) as [H3| H3]. {
      subst j.
      destruct (Nat.eq_dec (n - 1) p) as [H3| H3]. {
        now subst p; symmetry in Hjke.
      }
      destruct (Nat.eq_dec (n - 1) (n - 2)) as [H4| H4]; [ | now subst p ].
      destruct n; [ easy | ].
      destruct n; [ easy | flia H4 ].
    }
    destruct (Nat.eq_dec (n - 1) p) as [H4| H4]; [ now subst j | ].
    destruct (Nat.eq_dec (n - 1) (n - 2)) as [H5| H5]; [ now subst j | easy ].
  }
  destruct (Nat.eq_dec j (n - 1)) as [H3| H3]. {
    subst j.
    destruct (Nat.eq_dec q p) as [H| H]; [ subst q; flia Hpq | clear H ].
    destruct (Nat.eq_dec k (n - 1)) as [H| H]; [ now subst k | clear H ].
    destruct (Nat.eq_dec q (n - 2)) as [H3| H3]. {
      subst q.
      destruct (Nat.eq_dec k p) as [H3| H3]; [ now subst k p | ].
      now destruct (Nat.eq_dec k (n - 2)); subst k.
    }
    destruct (Nat.eq_dec k p) as [H4| H4]; [ now subst k | ].
    destruct (Nat.eq_dec k (n - 2)) as [H5| H5]; [ subst k q; flia Hpq  | ].
    now subst k.
  }
  destruct (Nat.eq_dec k (n - 1)) as [H4| H4]; [ subst k | ]. {
    destruct (Nat.eq_dec j p) as [H4| H4]; [ subst j | ]. {
      destruct (Nat.eq_dec q p) as [H5| H5]; [ now subst q | ].
      now destruct (Nat.eq_dec q (n - 2)); subst q.
    }
    destruct (Nat.eq_dec q p) as [H5| H5]; [ subst q; flia Hpq | ].
    destruct (Nat.eq_dec j (n - 2)) as [H6| H6]; [ subst j | ]. {
      now destruct (Nat.eq_dec q (n - 2)); subst q.
    }
    now destruct (Nat.eq_dec q (n - 2)); subst q.
  }
  destruct (Nat.eq_dec j p) as [H5| H5]; [ subst j | ]. {
    destruct (Nat.eq_dec k p) as [H5| H5]; [ now subst k | ].
    destruct (Nat.eq_dec k (n - 2)) as [H6| H6]; [ now subst k | ].
    now subst k.
  }
  destruct (Nat.eq_dec k p) as [H6| H6]; [ subst k | ]. {
    destruct (Nat.eq_dec j (n - 2)) as [H6| H6]; [ now subst p | easy ].
  }
  destruct (Nat.eq_dec j (n - 2)) as [H7| H7]; [ subst j | ]. {
    now destruct (Nat.eq_dec k (n - 2)); subst k.
  }
  now destruct (Nat.eq_dec k (n - 2)); subst k.
}
Qed.

Theorem swap_nat_lt : ∀ i j k n,
  i < n
  → j < n
  → k < n
  → swap_nat i j k < n.
Proof.
intros * Hi Hj Hk.
unfold swap_nat.
destruct (Nat.eq_dec k i); [ easy | ].
now destruct (Nat.eq_dec k j).
Qed.

Theorem vect_swap_elem_same : ∀ n (v : vector n nat) i,
  vect_swap_elem v i i = v.
Proof.
intros.
apply vector_eq; cbn.
intros j Hj.
unfold swap_nat.
destruct (Nat.eq_dec j i); [ now subst i | easy ].
Qed.

Theorem permut_inv_permut : ∀ n (σ : vector n nat),
  is_permut σ
  → ∀ i, i < n
  → vect_el (permut_inv σ) (vect_el σ i) = i.
Proof.
intros * (_, Hp2) * Hin; cbn.
now apply fun_find_prop.
Qed.

Theorem permut_permut_inv : ∀ n (σ : vector n nat),
  is_permut σ
  → ∀ i, i < n
  → vect_el σ (vect_el (permut_inv σ) i) = i.
Proof.
intros * Hp * Hin; cbn.
now apply fun_permut_fun_inv.
Qed.

Theorem δ_shift : ∀ i j u v, δ (i + 1) (j + 1) u v = δ i j u v.
Proof.
intros.
unfold δ.
do 2 rewrite if_ltb_lt_dec.
destruct (lt_dec i j) as [Hij| Hij]. {
  destruct (lt_dec (i + 1) (j + 1)) as [Hij1| Hij1]; [ easy | ].
  flia Hij Hij1.
} {
  destruct (lt_dec (i + 1) (j + 1)) as [Hij1| Hij1]; [ | easy ].
  flia Hij Hij1.
}
Qed.

Theorem δ_shift_right :
  rngl_has_opp = true →
  ∀ i j u v, δ i j (u + 1) (v + 1) = δ i j u v.
Proof.
intros Hop *.
unfold δ.
do 2 rewrite if_ltb_lt_dec.
destruct (lt_dec i j) as [Hij| Hij]; [ | easy ].
setoid_rewrite Nat.add_comm; cbn.
rewrite rngl_add_comm.
specialize rngl_opt_add_sub as rngl_add_sub.
rewrite Hop in rngl_add_sub.
unfold rngl_sub.
rewrite Hop.
rewrite rngl_opp_add_distr; [ | easy ].
unfold rngl_sub.
rewrite Hop.
rewrite rngl_add_assoc.
rewrite rngl_add_add_swap.
rewrite <- (rngl_add_assoc (rngl_of_nat v)).
rewrite fold_rngl_sub; [ | easy ].
rewrite fold_rngl_sub; [ | easy ].
rewrite fold_rngl_sub; [ | easy ].
rewrite rngl_add_opp_r.
now rewrite rngl_add_0_r.
Qed.

Theorem permut_Permutation : ∀ n (σ : vector n nat),
  is_permut σ
  → Permutation (map (vect_el σ) (seq 0 n)) (seq 0 n).
Proof.
intros * Hp.
unfold is_permut in Hp.
remember (vect_el σ) as f.
now apply permut_fun_Permutation.
Qed.

Definition mat_swap_rows n i1 i2 (M : matrix n n T) :=
  mk_mat n n
    (λ i j,
     if Nat.eq_dec i i1 then mat_el M i2 j
     else if Nat.eq_dec i i2 then mat_el M i1 j
     else mat_el M i j).

Theorem glop :
  rngl_is_comm = true →
  rngl_has_inv = true ∨ rngl_has_no_inv_but_div = true →
  rngl_has_1_neq_0 = true →
  ∀ n (M : matrix n n T) p q,
  p ≠ q
  → p < n
  → q < n
  → determinant (mat_swap_rows p q M) = (- determinant M)%F.
Proof.
intros Hic Hiv H10 * Hpq Hp Hq.
rewrite det_is_det_by_canon_permut; [ | easy ].
unfold determinant'.
erewrite rngl_summation_eq_compat. 2: {
  intros i Hi.
...
  rewrite <- ε_canon_permut_ε_canon_permut; [ | easy | easy | ]. 2: {
    specialize (fact_neq_0 n) as Hnz.
    flia Hi Hnz.
  }
  easy.
}
...

(* If we add a row (column) of A multiplied by a scalar k to another
   row (column) of A, then the determinant will not change. *)
(* https://math.vanderbilt.edu/sapirmv/msapir/proofdet1.html *)
(* doing it only when the first row is 0; can be generalized later *)

Definition mat_add_row_mul_scal_row n (M : matrix n n T) i1 v i2 :=
  mk_mat n n
    (λ i j,
     if Nat.eq_dec i i1 then (mat_el M i1 j + v * mat_el M i2 j)%F
     else mat_el M i j).

(* *)

Definition mat_mul_row_by_scal n k (M : matrix n n T) s :=
  mk_mat n n
    (λ i j,
     if Nat.eq_dec i k then (s * mat_el M i j)%F else mat_el M i j).

(* If we multiply a row (column) of A by a number, the determinant of
   A will be multiplied by the same number. *)
(* https://math.vanderbilt.edu/sapirmv/msapir/proofdet1.html
   point 1 *)

(* Well, since my definition of the discriminant only covers the
   row 0, we can prove that only when i=0; this will able us to
   prove next theorems, swapping rows by going via row 0 *)

Theorem det_mul_row_0_by_scal :
  rngl_is_comm = true →
  ∀ n (A : matrix n n T) v,
  n ≠ 0
  → determinant (mat_mul_row_by_scal 0 A v) = (v * determinant A)%F.
Proof.
intros Hic * Hnz.
unfold determinant; cbn.
destruct n; [ easy | clear Hnz ].
cbn.
rewrite rngl_mul_summation_distr_l.
apply rngl_summation_eq_compat.
intros j Hj.
specialize rngl_opt_mul_comm as rngl_mul_comm.
rewrite Hic in rngl_mul_comm.
rewrite (rngl_mul_comm (minus_one_pow j)).
do 2 rewrite <- rngl_mul_assoc.
f_equal.
rewrite (rngl_mul_comm (mat_el A 0 j)).
do 2 rewrite <- rngl_mul_assoc.
f_equal.
rewrite rngl_mul_comm; f_equal.
f_equal.
apply matrix_eq; cbn.
rename j into k; rename Hj into Hk.
intros i j Hi Hj.
destruct (Nat.eq_dec (i + 1) 0) as [H| H]; [ flia H | easy ].
Qed.

(* If the i-th row (column) in A is a sum of the i-th row (column) of
   a matrix B and the i-th row (column) of a matrix C and all other
   rows in B and C are equal to the corresponding rows in A (that is B
   and C differ from A by one row only), then det(A)=det(B)+det(C). *)
(* https://math.vanderbilt.edu/sapirmv/msapir/proofdet1.html
   point 2 *)

(* Well, since my definition of the discriminant only covers the
   row 0, we can prove that only when i=0; this will able us to
   prove the next theorem, swapping rows by going via row 0 *)

Theorem det_sum_row_row : ∀ n (A B C : matrix n n T),
  n ≠ 0
  → (∀ j, mat_el A 0 j = (mat_el B 0 j + mat_el C 0 j)%F)
  → (∀ i j, i ≠ 0 → mat_el B i j = mat_el A i j)
  → (∀ i j, i ≠ 0 → mat_el C i j = mat_el A i j)
  → determinant A = (determinant B + determinant C)%F.
Proof.
intros * Hnz Hbc Hb Hc.
unfold determinant.
destruct n; [ easy | clear Hnz ].
cbn.
assert (Hab : ∀ j, subm A 0 j = subm B 0 j). {
  intros.
  apply matrix_eq; cbn.
  intros i j' Hi Hj'.
  destruct (lt_dec j' j); symmetry; apply Hb; flia.
}
assert (Hac : ∀ j, subm A 0 j = subm C 0 j). {
  intros.
  apply matrix_eq; cbn.
  intros i j' Hi Hj'.
  destruct (lt_dec j' j); symmetry; apply Hc; flia.
}
erewrite rngl_summation_eq_compat. 2: {
  intros j Hj.
  rewrite Hbc.
  rewrite rngl_mul_add_distr_l.
  rewrite rngl_mul_add_distr_r.
  rewrite Hab at 1.
  rewrite Hac at 1.
  easy.
}
cbn.
now apply rngl_summation_add_distr.
Qed.

(* If two rows (columns) in A are equal then det(A)=0. *)
(* https://math.vanderbilt.edu/sapirmv/msapir/proofdet1.html
   point 3 *)
(* doing it only when the first row is 0; can be generalized later *)

Definition δ_lt i k := Nat.b2n (i <? k).

Theorem subm_subm_swap : ∀ n (A : matrix n n T) i j k l,
  subm (subm A i j) k l =
  subm (subm A (k + δ_lt i k) (l + δ_lt j l)) (i - δ_lt k i) (j - δ_lt l j).
Proof.
intros.
apply matrix_eq; cbn.
intros i' j' Hi' Hj'.
f_equal. {
  do 2 rewrite <- Nat.add_assoc; f_equal.
  rewrite Nat.add_comm.
  unfold δ_lt.
  remember (k <=? i') as a eqn:Ha.
  remember (i <=? i' + Nat.b2n a) as b eqn:Hb.
  remember (i <? k) as c eqn:Hc.
  remember (k <? i) as d eqn:Hd.
  remember (i - Nat.b2n d <=? i') as e eqn:He.
  remember (k + Nat.b2n c <=? i' + Nat.b2n e) as f eqn:Hf.
  move b before a; move c before b; move d before c; move e before d.
  move f before e.
  symmetry in Ha, Hb, Hc, Hd, He, Hf.
  destruct a, b, d, e, f; cbn; try easy; exfalso. {
    apply Nat.leb_le in Ha; apply Nat.leb_le in Hb; apply Nat.leb_le in Hd.
    apply Nat.leb_le in He; apply Nat.leb_nle in Hf.
    destruct c; [ apply Nat.ltb_lt in Hc; flia Ha Hb Hc Hd He Hf | ].
    cbn in Hf.
    apply Nat.ltb_nlt in Hc; flia Ha Hb Hc Hd He Hf.
  } {
    apply Nat.leb_le in Ha; apply Nat.leb_le in Hb; apply Nat.leb_le in Hd.
    apply Nat.leb_nle in He; apply Nat.leb_le in Hf.
    destruct c; [ apply Nat.ltb_lt in Hc; flia Ha Hb Hc Hd He Hf | ].
    apply Nat.ltb_nlt in Hc; flia Ha Hb Hc Hd He Hf.
  } {
    apply Nat.leb_le in Ha; apply Nat.leb_le in Hb; apply Nat.leb_le in Hd.
    apply Nat.leb_nle in He; apply Nat.leb_nle in Hf.
    destruct c; [ apply Nat.ltb_lt in Hc; flia Ha Hb Hc Hd He Hf | ].
    apply Nat.ltb_nlt in Hc; flia Ha Hb Hc Hd He Hf.
  } {
    apply Nat.leb_le in Ha; apply Nat.leb_le in Hb; apply Nat.leb_nle in Hd.
    apply Nat.leb_le in He; apply Nat.leb_nle in Hf.
    destruct c; [ apply Nat.ltb_lt in Hc; flia Ha Hb Hc Hd He Hf | ].
    cbn in Hf.
    apply Nat.ltb_nlt in Hc; flia Ha Hb Hc Hd He Hf.
  } {
    apply Nat.leb_le in Ha; apply Nat.leb_le in Hb; apply Nat.leb_nle in Hd.
    apply Nat.leb_nle in He; apply Nat.leb_le in Hf.
    destruct c; [ apply Nat.ltb_lt in Hc; flia Ha Hb Hc Hd He Hf | ].
    apply Nat.ltb_nlt in Hc; flia Ha Hb Hc Hd He Hf.
  } {
    apply Nat.leb_le in Ha; apply Nat.leb_le in Hb; apply Nat.leb_nle in Hd.
    apply Nat.leb_nle in He; apply Nat.leb_nle in Hf.
    destruct c; [ apply Nat.ltb_lt in Hc; flia Ha Hb Hc Hd He Hf | ].
    apply Nat.ltb_nlt in Hc; flia Ha Hb Hc Hd He Hf.
  } {
    apply Nat.leb_le in Ha; apply Nat.leb_nle in Hb; apply Nat.leb_le in Hd.
    apply Nat.leb_le in He; apply Nat.leb_le in Hf.
    destruct c; [ apply Nat.ltb_lt in Hc; flia Ha Hb Hc Hd He Hf | ].
    apply Nat.ltb_nlt in Hc; flia Ha Hb Hc Hd He Hf.
  } {
    apply Nat.leb_le in Ha; apply Nat.leb_nle in Hb; apply Nat.leb_le in Hd.
    apply Nat.leb_nle in He; apply Nat.leb_nle in Hf.
    destruct c; [ apply Nat.ltb_lt in Hc; flia Ha Hb Hc Hd He Hf | ].
    apply Nat.ltb_nlt in Hc; flia Ha Hb Hc Hd He Hf.
  } {
    apply Nat.leb_le in Ha; apply Nat.leb_nle in Hb; apply Nat.leb_nle in Hd.
    apply Nat.leb_le in He; apply Nat.leb_le in Hf.
    destruct c; [ apply Nat.ltb_lt in Hc; flia Ha Hb Hc Hd He Hf | ].
    apply Nat.ltb_nlt in Hc; flia Ha Hb Hc Hd He Hf.
  } {
    apply Nat.leb_le in Ha; apply Nat.leb_nle in Hb; apply Nat.leb_nle in Hd.
    apply Nat.leb_nle in He; apply Nat.leb_nle in Hf.
    destruct c; [ apply Nat.ltb_lt in Hc; flia Ha Hb Hc Hd He Hf | ].
    apply Nat.ltb_nlt in Hc; flia Ha Hb Hc Hd He Hf.
  } {
    apply Nat.leb_nle in Ha; apply Nat.leb_le in Hb; apply Nat.leb_le in Hd.
    apply Nat.leb_le in He; apply Nat.leb_le in Hf.
    destruct c; [ apply Nat.ltb_lt in Hc; flia Ha Hb Hc Hd He Hf | ].
    cbn in He.
    apply Nat.ltb_nlt in Hc; flia Ha Hb Hc Hd He Hf.
  } {
    apply Nat.leb_nle in Ha; apply Nat.leb_le in Hb; apply Nat.leb_le in Hd.
    apply Nat.leb_nle in He; apply Nat.leb_nle in Hf.
    destruct c; [ apply Nat.ltb_lt in Hc; flia Ha Hb Hc Hd He Hf | ].
    cbn in Hb.
    apply Nat.ltb_nlt in Hc; flia Ha Hb Hc Hd He Hf.
  } {
    apply Nat.leb_nle in Ha; apply Nat.leb_le in Hb; apply Nat.leb_nle in Hd.
    apply Nat.leb_le in He; apply Nat.leb_le in Hf.
    destruct c; [ apply Nat.ltb_lt in Hc; flia Ha Hb Hc Hd He Hf | ].
    cbn in Hb.
    apply Nat.ltb_nlt in Hc; flia Ha Hb Hc Hd He Hf.
  } {
    apply Nat.leb_nle in Ha; apply Nat.leb_le in Hb; apply Nat.leb_nle in Hd.
    apply Nat.leb_nle in He; apply Nat.leb_nle in Hf.
    destruct c; [ apply Nat.ltb_lt in Hc; flia Ha Hb Hc Hd He Hf | ].
    apply Nat.ltb_nlt in Hc; flia Ha Hb Hc Hd He Hf.
  } {
    apply Nat.leb_nle in Ha; apply Nat.leb_nle in Hb; apply Nat.leb_le in Hd.
    apply Nat.leb_le in He; apply Nat.leb_le in Hf.
    destruct c; [ apply Nat.ltb_lt in Hc; flia Ha Hb Hc Hd He Hf | ].
    cbn in He.
    apply Nat.ltb_nlt in Hc; flia Ha Hb Hc Hd He Hf.
  } {
    apply Nat.leb_nle in Ha; apply Nat.leb_nle in Hb; apply Nat.leb_le in Hd.
    apply Nat.leb_le in He; apply Nat.leb_nle in Hf.
    destruct c; [ apply Nat.ltb_lt in Hc; flia Ha Hb Hc Hd He Hf | ].
    cbn in He.
    apply Nat.ltb_nlt in Hc; flia Ha Hb Hc Hd He Hf.
  } {
    apply Nat.leb_nle in Ha; apply Nat.leb_nle in Hb; apply Nat.leb_le in Hd.
    apply Nat.leb_nle in He; apply Nat.leb_le in Hf.
    destruct c; [ apply Nat.ltb_lt in Hc; flia Ha Hb Hc Hd He Hf | ].
    apply Nat.ltb_nlt in Hc; flia Ha Hb Hc Hd He Hf.
  } {
    apply Nat.leb_nle in Ha; apply Nat.leb_nle in Hb; apply Nat.leb_nle in Hd.
    apply Nat.leb_le in He; apply Nat.leb_le in Hf.
    destruct c; [ apply Nat.ltb_lt in Hc; flia Ha Hb Hc Hd He Hf | ].
    apply Nat.ltb_nlt in Hc; flia Ha Hb Hc Hd He Hf.
  } {
    apply Nat.leb_nle in Ha; apply Nat.leb_nle in Hb; apply Nat.leb_nle in Hd.
    apply Nat.leb_le in He; apply Nat.leb_nle in Hf.
    destruct c; [ apply Nat.ltb_lt in Hc; flia Ha Hb Hc Hd He Hf | ].
    apply Nat.ltb_nlt in Hc; flia Ha Hb Hc Hd He Hf.
  } {
    apply Nat.leb_nle in Ha; apply Nat.leb_nle in Hb; apply Nat.leb_nle in Hd.
    apply Nat.leb_nle in He; apply Nat.leb_le in Hf.
    destruct c; [ apply Nat.ltb_lt in Hc; flia Ha Hb Hc Hd He Hf | ].
    apply Nat.ltb_nlt in Hc; flia Ha Hb Hc Hd He Hf.
  }
} {
  do 2 rewrite <- Nat.add_assoc; f_equal.
  rewrite Nat.add_comm.
  unfold δ_lt.
  remember (l <=? j') as a eqn:Ha.
  remember (j <=? j' + Nat.b2n a) as b eqn:Hb.
  remember (j <? l) as c eqn:Hc.
  remember (l <? j) as d eqn:Hd.
  remember (j - Nat.b2n d <=? j') as e eqn:He.
  remember (l + Nat.b2n c <=? j' + Nat.b2n e) as f eqn:Hf.
  move b before a; move c before b; move d before c; move e before d.
  move f before e.
  symmetry in Ha, Hb, Hc, Hd, He, Hf.
  destruct a, b, d, e, f; cbn; try easy; exfalso. {
    apply Nat.leb_le in Ha; apply Nat.leb_le in Hb; apply Nat.leb_le in Hd.
    apply Nat.leb_le in He; apply Nat.leb_nle in Hf.
    destruct c; [ apply Nat.ltb_lt in Hc; flia Ha Hb Hc Hd He Hf | ].
    cbn in He, Hf.
    apply Nat.ltb_nlt in Hc; flia Ha Hb Hc Hd He Hf.
  } {
    apply Nat.leb_le in Ha; apply Nat.leb_le in Hb; apply Nat.leb_le in Hd.
    apply Nat.leb_nle in He; apply Nat.leb_le in Hf.
    destruct c; [ apply Nat.ltb_lt in Hc; flia Ha Hb Hc Hd He Hf | ].
    apply Nat.ltb_nlt in Hc; flia Ha Hb Hc Hd He Hf.
  } {
    apply Nat.leb_le in Ha; apply Nat.leb_le in Hb; apply Nat.leb_le in Hd.
    apply Nat.leb_nle in He; apply Nat.leb_nle in Hf.
    destruct c; [ apply Nat.ltb_lt in Hc; flia Ha Hb Hc Hd He Hf | ].
    apply Nat.ltb_nlt in Hc; flia Ha Hb Hc Hd He Hf.
  } {
    apply Nat.leb_le in Ha; apply Nat.leb_le in Hb; apply Nat.leb_nle in Hd.
    apply Nat.leb_le in He; apply Nat.leb_nle in Hf.
    destruct c; [ apply Nat.ltb_lt in Hc; flia Ha Hb Hc Hd He Hf | ].
    cbn in Hf.
    apply Nat.ltb_nlt in Hc; flia Ha Hb Hc Hd He Hf.
  } {
    apply Nat.leb_le in Ha; apply Nat.leb_le in Hb; apply Nat.leb_nle in Hd.
    apply Nat.leb_nle in He; apply Nat.leb_le in Hf.
    destruct c; [ apply Nat.ltb_lt in Hc; flia Ha Hb Hc Hd He Hf | ].
    apply Nat.ltb_nlt in Hc; flia Ha Hb Hc Hd He Hf.
  } {
    apply Nat.leb_le in Ha; apply Nat.leb_le in Hb; apply Nat.leb_nle in Hd.
    apply Nat.leb_nle in He; apply Nat.leb_nle in Hf.
    destruct c; [ apply Nat.ltb_lt in Hc; flia Ha Hb Hc Hd He Hf | ].
    apply Nat.ltb_nlt in Hc; flia Ha Hb Hc Hd He Hf.
  } {
    apply Nat.leb_le in Ha; apply Nat.leb_nle in Hb; apply Nat.leb_le in Hd.
    apply Nat.leb_le in He; apply Nat.leb_le in Hf.
    destruct c; [ apply Nat.ltb_lt in Hc; flia Ha Hb Hc Hd He Hf | ].
    apply Nat.ltb_nlt in Hc; flia Ha Hb Hc Hd He Hf.
  } {
    apply Nat.leb_le in Ha; apply Nat.leb_nle in Hb; apply Nat.leb_le in Hd.
    apply Nat.leb_nle in He; apply Nat.leb_nle in Hf.
    destruct c; [ apply Nat.ltb_lt in Hc; flia Ha Hb Hc Hd He Hf | ].
    apply Nat.ltb_nlt in Hc; cbn in Hc; flia Ha Hb Hc Hd He Hf.
  } {
    apply Nat.leb_le in Ha; apply Nat.leb_nle in Hb; apply Nat.leb_nle in Hd.
    apply Nat.leb_le in He; apply Nat.leb_le in Hf.
    destruct c; [ apply Nat.ltb_lt in Hc; flia Ha Hb Hc Hd He Hf | ].
    apply Nat.ltb_nlt in Hc; flia Ha Hb Hc Hd He Hf.
  } {
    apply Nat.leb_le in Ha; apply Nat.leb_nle in Hb; apply Nat.leb_nle in Hd.
    apply Nat.leb_nle in He; apply Nat.leb_nle in Hf.
    destruct c; [ apply Nat.ltb_lt in Hc; flia Ha Hb Hc Hd He Hf | ].
    apply Nat.ltb_nlt in Hc; flia Ha Hb Hc Hd He Hf.
  } {
    apply Nat.leb_nle in Ha; apply Nat.leb_le in Hb; apply Nat.leb_le in Hd.
    apply Nat.leb_le in He; apply Nat.leb_le in Hf.
    destruct c; [ apply Nat.ltb_lt in Hc; flia Ha Hb Hc Hd He Hf | ].
    cbn in He.
    apply Nat.ltb_nlt in Hc; flia Ha Hb Hc Hd He Hf.
  } {
    apply Nat.leb_nle in Ha; apply Nat.leb_le in Hb; apply Nat.leb_le in Hd.
    apply Nat.leb_nle in He; apply Nat.leb_nle in Hf.
    destruct c; [ apply Nat.ltb_lt in Hc; flia Ha Hb Hc Hd He Hf | ].
    cbn in Hb.
    apply Nat.ltb_nlt in Hc; flia Ha Hb Hc Hd He Hf.
  } {
    apply Nat.leb_nle in Ha; apply Nat.leb_le in Hb; apply Nat.leb_nle in Hd.
    apply Nat.leb_le in He; apply Nat.leb_le in Hf.
    destruct c; [ apply Nat.ltb_lt in Hc; flia Ha Hb Hc Hd He Hf | ].
    cbn in Hb.
    apply Nat.ltb_nlt in Hc; flia Ha Hb Hc Hd He Hf.
  } {
    apply Nat.leb_nle in Ha; apply Nat.leb_le in Hb; apply Nat.leb_nle in Hd.
    apply Nat.leb_nle in He; apply Nat.leb_nle in Hf.
    destruct c; [ apply Nat.ltb_lt in Hc; flia Ha Hb Hc Hd He Hf | ].
    apply Nat.ltb_nlt in Hc; flia Ha Hb Hc Hd He Hf.
  } {
    apply Nat.leb_nle in Ha; apply Nat.leb_nle in Hb; apply Nat.leb_le in Hd.
    apply Nat.leb_le in He; apply Nat.leb_le in Hf.
    destruct c; [ apply Nat.ltb_lt in Hc; flia Ha Hb Hc Hd He Hf | ].
    cbn in He.
    apply Nat.ltb_nlt in Hc; flia Ha Hb Hc Hd He Hf.
  } {
    apply Nat.leb_nle in Ha; apply Nat.leb_nle in Hb; apply Nat.leb_le in Hd.
    apply Nat.leb_le in He; apply Nat.leb_nle in Hf.
    destruct c; [ apply Nat.ltb_lt in Hc; flia Ha Hb Hc Hd He Hf | ].
    cbn in He.
    apply Nat.ltb_nlt in Hc; flia Ha Hb Hc Hd He Hf.
  } {
    apply Nat.leb_nle in Ha; apply Nat.leb_nle in Hb; apply Nat.leb_le in Hd.
    apply Nat.leb_nle in He; apply Nat.leb_le in Hf.
    destruct c; [ apply Nat.ltb_lt in Hc; flia Ha Hb Hc Hd He Hf | ].
    apply Nat.ltb_nlt in Hc; flia Ha Hb Hc Hd He Hf.
  } {
    apply Nat.leb_nle in Ha; apply Nat.leb_nle in Hb; apply Nat.leb_nle in Hd.
    apply Nat.leb_le in He; apply Nat.leb_le in Hf.
    destruct c; [ apply Nat.ltb_lt in Hc; flia Ha Hb Hc Hd He Hf | ].
    apply Nat.ltb_nlt in Hc; flia Ha Hb Hc Hd He Hf.
  } {
    apply Nat.leb_nle in Ha; apply Nat.leb_nle in Hb; apply Nat.leb_nle in Hd.
    apply Nat.leb_le in He; apply Nat.leb_nle in Hf.
    destruct c; [ apply Nat.ltb_lt in Hc; flia Ha Hb Hc Hd He Hf | ].
    apply Nat.ltb_nlt in Hc; flia Ha Hb Hc Hd He Hf.
  } {
    apply Nat.leb_nle in Ha; apply Nat.leb_nle in Hb; apply Nat.leb_nle in Hd.
    apply Nat.leb_nle in He; apply Nat.leb_le in Hf.
    destruct c; [ apply Nat.ltb_lt in Hc; flia Ha Hb Hc Hd He Hf | ].
    apply Nat.ltb_nlt in Hc; flia Ha Hb Hc Hd He Hf.
  }
}
Qed.

Theorem glop1 : ∀ n (A : matrix n n T) i j,
  subm (subm A i j) 0 0 = subm (subm A 0 0) (i - 1) (j - 1).
Proof.
intros.
rewrite subm_subm_swap.
unfold δ_lt.
now destruct i, j.
Qed.

Definition swap_in_permut n i j k := vect_swap_elem (canon_permut n k) i j.

(* comatrix *)

Definition comatrix {n} (M : matrix n n T) : matrix n n T :=
  {| mat_el i j := (minus_one_pow (i + j) * determinant (subm M i j))%F |}.

End a.

Arguments det_loop {T ro} {n}%nat M%M i%nat.
Arguments determinant {T ro n} M%M.
Arguments subm {T m n} M%M i%nat j%nat.

Arguments determinant {T ro} {n%nat} M%M.
Arguments det_loop {T ro} {n%nat} M%M i%nat.
Arguments det_from_row {T}%type {ro} {n}%nat M%M i%nat.
Arguments det_from_col {T}%type {ro} {n}%nat M%M j%nat.
Arguments comatrix {T}%type {ro} {n}%nat M%M.
