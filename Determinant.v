Set Nested Proofs Allowed.
Set Implicit Arguments.

Require Import Utf8 Arith Bool.
Require Import Permutation.
Import List List.ListNotations.

Require Import Misc RingLike MyVector Matrix PermutSeq.
Require Import RLsummation RLproduct.
Import matrix_Notations.

Definition list_of_fun {A} n (f : _ → A) := map f (seq 0 n).
Definition fun_of_list {A} (d : A) l i := nth i l d.

Section a.

Context {T : Type}.
Context (ro : ring_like_op T).
Context (rp : ring_like_prop T).

(* determinant *)

(*
   determinant n M recursively computes determinant

      0     n-1
      |     |
      v     v
     ---------    ---------   ---------   ---------
0    |x      |    | x     |   |  x    |   |   x   |
     | ......| -  |. .....| + |.. ....| - |... ...| + etc.
     | ......|    |. .....|   |.. ....|   |... ...|
n-1  | ......|    |. .....|   |.. ....|   |... ...|
     ---------    ---------   ---------   ---------

   each term is the term "x" multiplied by det (n-1) of
   the sub-matrix represented by the dots. The "x" goes through
   the first row.
*)

Fixpoint determinant n (M : matrix T) :=
  (match n with
   | 0 => λ _, 1%F
   | S n' =>
       λ M' : matrix T,
       ∑ (j = 0, n'),
       minus_one_pow j * mat_el M' 0 j * determinant n' (subm M' 0 j)
   end) M.

Arguments determinant n%nat M%M.

Theorem determinant_zero : ∀ (M : matrix T),
  determinant 0 M = 1%F.
Proof. easy. Qed.

Theorem determinant_succ : ∀ n (M : matrix T),
  determinant (S n) M =
     ∑ (j = 0, n), minus_one_pow j * mat_el M 0 j * determinant n (subm M 0 j).
Proof. easy. Qed.

Definition mat_permut_rows_fun (σ : nat → nat) (M : matrix T) :=
  mk_mat (map (λ i, nth (σ i) (mat_list_list M) []) (seq 0 (mat_nrows M))).

Definition mat_permut_rows (σ : vector nat) (M : matrix T) :=
  mat_permut_rows_fun (vect_nat_el σ) M.

(* the following versions of computing the determinant should
   (to be proven) be equivalent; perhaps could help for proving
   Cramer's rule of resolving equations *)

Definition det_from_row {n} (M : matrix T) i :=
  (minus_one_pow i *
   ∑ (j = 0, n),
     minus_one_pow j * mat_el M i j * determinant n (subm M i j))%F.

Definition det_from_col {n} (M : matrix T) j :=
  (minus_one_pow j *
   ∑ (i = 0, n - 1),
     minus_one_pow i * mat_el M i j * determinant n (subm M i j))%F.

(* Alternative version of the determinant: sum of product of the
   factors a_{i,σ(i)} where σ goes through all permutations of
   the naturals of the interval [0, n-1].
   The permutations generated are in the same order as the
   terms generated by the determinant defined by induction on
   the size of the matrix.
     The order happens to be the canonical (alphabetical) order.
   Example for n=3
     = [[0; 1; 2]; [0; 2; 1]; [1; 0; 2]; [1; 2; 0]; [2; 0; 1]; [2; 1; 0]]
   Having the same terms order, the proof of equality of both definitions
   of both determinants is easy.
   See PermutSeq.v *)

(* definition of determinant by sum of products involving all
   permutations *)

Definition determinant' n (M : matrix T) :=
  ∑ (k = 0, fact n - 1),
    ε n (vect_vect_nat_el (mk_canon_sym_gr_vect' n) k) *
    ∏ (i = 1, n),
    mat_el M (i - 1)
      (vect_nat_el (vect_vect_nat_el (mk_canon_sym_gr_vect' n) k) (i - 1)).

Arguments determinant' n%nat M%M.

(* Proof that both definitions of determinants are equal *)

Theorem det_is_det_by_canon_permut :
  rngl_is_comm = true →
  rngl_has_opp = true →
  rngl_has_inv = true →
  rngl_is_integral = true →
  rngl_has_1_neq_0 = true →
  rngl_has_dec_eq = true →
  rngl_characteristic = 0 →
  ∀ n (M : matrix T),
  is_square_matrix n M = true
  → determinant n M = determinant' n M.
Proof.
intros Hic Hop Hin Hit H10 Hde Hch * Hm.
unfold determinant'.
revert M Hm.
induction n; intros. {
  cbn.
  unfold ε, ε_fun, iter_seq, iter_list; cbn.
  rewrite rngl_add_0_l.
  rewrite rngl_mul_1_r.
  rewrite rngl_div_1_r; [ easy | now left | easy ].
}
rewrite determinant_succ.
destruct (Nat.eq_dec n 0) as [Hnz| Hnz]. {
  subst n; cbn.
  rewrite rngl_summation_only_one; cbn.
  rewrite rngl_summation_only_one; cbn.
  rewrite rngl_product_only_one; cbn.
  unfold ε, ε_fun; cbn.
  do 4 rewrite rngl_product_only_one; cbn.
  rewrite rngl_mul_1_r.
  rewrite rngl_div_1_r; [ easy | now left | easy ].
}
erewrite rngl_summation_eq_compat. 2: {
  intros i Hi.
  rewrite IHn. 2: {
(*lemme?*)
    apply is_sm_mat_iff.
    specialize (square_matrix_ncols _ Hm) as Hcm.
    split. {
      apply is_sm_mat_iff in Hm.
      destruct Hm as (Hr & Hcr & Hc).
      rewrite mat_nrows_subm; [ | flia Hr ].
      now rewrite Hr, Nat.sub_succ, Nat.sub_0_r.
    }
    split. {
      intros Hcs.
      rewrite mat_ncols_subm in Hcs; cycle 1. {
        now apply (@squ_mat_is_corr (S n)).
      } {
        apply is_sm_mat_iff in Hm.
        destruct Hm as (Hr & Hcr & Hc).
        rewrite Hr; flia Hnz.
      } {
        rewrite Hcm; flia Hnz.
      } {
        rewrite Hcm; flia Hi.
      }
      rewrite Hcm in Hcs; flia Hnz Hcs.
    } {
      intros l Hl.
      apply is_sm_mat_iff in Hm.
      destruct Hm as (Hr & Hcr & Hc).
      unfold subm in Hl.
      cbn - [ butn ] in Hl.
      apply in_map_iff in Hl.
      destruct Hl as (j & Hl & Hj); subst l.
      cbn in Hj.
      destruct M as (ll).
      cbn in Hr, Hj.
      destruct ll as [| l']; [ easy | ].
      cbn in Hr; apply Nat.succ_inj in Hr.
      cbn in Hcm.
      rewrite butn_length. {
        cbn in Hc.
        rewrite Hc; [ flia | now right ].
      }
      rewrite Hc; [ flia Hi | now right ].
    }
  }
...
intros Hic Hop Hin Hit H10 Hde Hch * Hm.
unfold determinant'.
destruct n; intros. {
  unfold iter_seq, iter_list.
  cbn; rewrite rngl_add_0_l.
  unfold ε, ε_fun, iter_seq, iter_list; cbn.
  rewrite rngl_div_1_r; [ | now left | easy ].
  symmetry; apply rngl_mul_1_l.
}
erewrite rngl_summation_eq_compat. 2: {
  intros i Hi.
  rewrite rngl_product_succ_succ.
  erewrite rngl_product_eq_compat. 2: {
    intros j Hj.
    now rewrite Nat.sub_succ, Nat.sub_0_r.
  }
  easy.
}
cbn - [ fact determinant mk_canon_sym_gr mk_canon_sym_gr_vect' ε ].
unfold vect_vect_nat_el, vect_nat_el.
unfold mk_canon_sym_gr_vect'.
cbn - [ determinant fact mk_canon_sym_gr seq ].
erewrite rngl_summation_eq_compat. 2: {
  intros i Hi.
  rewrite (List_map_nth' 0). 2: {
    rewrite seq_length.
    eapply le_lt_trans; [ apply Hi | ].
    apply Nat.sub_lt; [ | flia ].
    apply Nat.neq_0_lt_0, fact_neq_0.
  }
  cbn - [ fact mk_canon_sym_gr seq ].
  unfold ε, vect_nat_el.
  cbn - [ fact mk_canon_sym_gr seq ].
  easy.
}
cbn - [ fact mk_canon_sym_gr seq ].
symmetry.
erewrite rngl_summation_eq_compat. 2: {
  intros i Hi.
  rewrite seq_nth. 2: {
    eapply le_lt_trans; [ apply Hi | ].
    apply Nat.sub_lt; [ | flia ].
    apply Nat.neq_0_lt_0, fact_neq_0.
  }
  rewrite Nat.add_0_l.
  easy.
}
symmetry.
revert M Hm.
induction n; intros. {
  cbn.
  unfold ε_fun, iter_seq, iter_list; cbn.
  do 2 rewrite rngl_add_0_l.
  do 3 rewrite rngl_mul_1_l.
  rewrite rngl_div_1_r; [ | now left | easy ].
  rewrite rngl_mul_1_l.
  now rewrite rngl_mul_1_r.
}
(*1*)
erewrite rngl_summation_eq_compat. 2: {
  intros i Hi.
  cbn - [ subm ].
  rewrite IHn. 2: {
    apply is_sm_mat_iff.
    specialize (square_matrix_ncols _ Hm) as Hcm.
    split. {
      apply is_sm_mat_iff in Hm.
      destruct Hm as (Hr & Hcr & Hc).
      rewrite mat_nrows_subm; [ | flia Hr ].
      now rewrite Hr, Nat.sub_succ, Nat.sub_0_r.
    }
    split. {
      intros Hcs.
      rewrite mat_ncols_subm in Hcs; cycle 1. {
        now apply (@squ_mat_is_corr (S (S n))).
      } {
        apply is_sm_mat_iff in Hm.
        destruct Hm as (Hr & Hcr & Hc).
        rewrite Hr; flia.
      } {
        rewrite Hcm; flia.
      } {
        rewrite Hcm; flia Hi.
      }
      now rewrite Hcm in Hcs.
    } {
      intros l Hl.
      apply is_sm_mat_iff in Hm.
      destruct Hm as (Hr & Hcr & Hc).
      unfold subm in Hl.
      cbn - [ butn ] in Hl.
      apply in_map_iff in Hl.
      destruct Hl as (j & Hl & Hj); subst l.
      cbn in Hj.
      destruct M as (ll).
      cbn in Hr, Hj.
      destruct ll as [| l']; [ easy | ].
      cbn in Hr; apply Nat.succ_inj in Hr.
      cbn in Hcm.
      rewrite butn_length. {
        cbn in Hc.
        rewrite Hc; [ flia | now right ].
      }
      rewrite Hc; [ flia Hi | now right ].
    }
  }
  easy.
}
clear IHn.
cbn - [ fact "mod" "/" mk_canon_sym_gr_vect' subm seq ].
erewrite rngl_summation_eq_compat. 2: {
  intros i Hi.
  rewrite rngl_mul_summation_distr_l; [ | now left ].
  easy.
}
cbn - [ fact mk_canon_sym_gr_vect' subm seq ].
rewrite rngl_summation_summation_distr.
rewrite <- Nat.sub_succ_l; [ | apply Nat.neq_0_lt_0, fact_neq_0 ].
rewrite Nat.sub_succ, Nat.sub_0_r.
rewrite <- Nat_fact_succ.
apply rngl_summation_eq_compat.
intros k Hk.
(* elimination of "mat_el M 0 (k / (S n)!)" *)
symmetry.
rewrite rngl_product_split_first; [ | flia ].
rewrite (List_map_nth' 0); [ | rewrite seq_length; flia ].
rewrite seq_nth; [ | flia ].
rewrite Nat.add_0_l.
remember (sym_gr_fun (S n) _ _ _) as x eqn:Hx.
cbn - [ fact ] in Hx; subst x.
rewrite rngl_mul_comm; [ | easy ].
symmetry.
rewrite <- rngl_mul_assoc.
rewrite rngl_mul_comm; [ | easy ].
do 3 rewrite <- rngl_mul_assoc.
f_equal.
(* elimination done *)
(* separation factors "∏" and "ε_fun" *)
rewrite rngl_mul_comm; [ | easy ].
rewrite <- rngl_mul_assoc.
f_equal. {
  (* equality of the two "∏" *)
  rewrite (rngl_product_shift _ 1); [ | flia ].
  rewrite Nat.sub_succ, Nat.sub_0_r.
  apply rngl_product_eq_compat.
  intros i Hi.
  unfold mat_el.
  rewrite (List_map_nth' 0); [ | rewrite seq_length; flia Hi ].
  rewrite (List_map_nth' 0); [ | rewrite seq_length; flia Hi ].
  rewrite seq_nth; [ | flia Hi ].
  rewrite seq_nth; [ | flia Hi ].
  do 2 rewrite Nat.add_0_l.
  unfold subm.
  cbn - [ fact butn ].
  rewrite (List_map_nth' []). 2: {
    apply is_sm_mat_iff in Hm.
    destruct Hm as (Hr & Hcr & Hc).
    rewrite butn_length; rewrite fold_mat_nrows; flia Hr Hi.
  }
  cbn - [ fact subm butn ].
  remember (k mod (S n)!) as p eqn:Hp.
  remember (sym_gr_fun n (mk_canon_sym_gr n) p) as σ eqn:Hσ.
  remember (mk_canon_sym_gr n (p mod n!)) as σ' eqn:Hσ'.
  move σ' before σ.
  rewrite (sym_gr_succ_values Hσ Hσ').
  destruct i. {
    unfold butn at 2.
    rewrite firstn_O, app_nil_l.
    rewrite List_skipn_1.
    rewrite List_nth_tl.
    unfold Nat.b2n.
    rewrite if_leb_le_dec.
    destruct (le_dec (k / (S n)!) (p / n!)) as [Hkp| Hkp]. 2: {
      apply Nat.nle_gt in Hkp.
      rewrite Nat.add_0_r.
      now rewrite nth_butn_after.
    }
    now rewrite nth_butn_before.
  }
  rewrite if_ltb_lt_dec.
  destruct (lt_dec (σ' i) (p / n!)) as [Hσp| Hσp]. {
    unfold Nat.b2n.
    rewrite if_leb_le_dec.
    destruct (le_dec (k / (S n)!) (σ' i)) as [Hkn| Hkn]. {
      rewrite nth_butn_before; [ | easy ].
      rewrite nth_butn_before; [ | flia ].
      now rewrite (Nat.add_1_r (S i)).
    } {
      rewrite Nat.add_0_r.
      apply Nat.nle_gt in Hkn.
      rewrite nth_butn_after; [ | easy ].
      rewrite nth_butn_before; [ | flia ].
      now rewrite (Nat.add_1_r (S i)).
    }
  } {
    unfold Nat.b2n.
    rewrite if_leb_le_dec.
    destruct (le_dec (k / (S n)!) (σ' i + 1)) as [Hkn| Hkn]. {
      rewrite nth_butn_before; [ | easy ].
      rewrite nth_butn_before; [ | flia ].
      now rewrite (Nat.add_1_r (S i)).
    } {
      rewrite Nat.add_0_r.
      apply Nat.nle_gt in Hkn.
      rewrite nth_butn_after; [ | easy ].
      rewrite nth_butn_before; [ | flia ].
      now rewrite (Nat.add_1_r (S i)).
    }
  }
  (* end proof equality of the two "∏" *)
}
(* equality of the two "ε_fun" *)
symmetry.
Print mk_canon_sym_gr_vect'.
Print vect_el.
Print vect_vect_nat_el.
...
Theorem ε_of_sym_gr_permut_succ :
  ∀ n k,
  k < (S n)!
  → ε_fun (vect_nat_el (vect_vect_nat_el (mk_canon_sym_gr_vect' (S n)) k)) n =
    (minus_one_pow (k / n!) *
     ε_fun
       (vect_nat_el (vect_vect_nat_el (mk_canon_sym_gr_vect' n) (k mod n!))) n)%F.
Proof.
intros.
Admitted.
specialize (@ε_of_sym_gr_permut_succ (S n) k) as H1.
unfold vect_nat_el in H1.
unfold vect_vect_nat_el in H1.
cbn - [ vect_list fact ] in H1.
Print sym_gr_fun.
Print mk_canon_sym_gr.
Print mk_canon_sym_gr_vect'.
unfold mk_canon_sym_gr_vect' in H1.
cbn - [ fact ] in H1.
Search (map _ (seq _ _)).
...
Theorem ε_of_sym_gr_permut_succ :
  ∀ n k,
  k < (S n)!
  → ε n (vect_vect_nat_el (mk_canon_sym_gr_vect' (S n)) k) =
    (minus_one_pow (k / n!) *
     ε n (vect_vect_nat_el (mk_canon_sym_gr_vect' n) (k mod n!)))%F.
Proof.
...
apply ε_of_sym_gr_permut_succ; try easy.
Theorem ε_of_sym_gr_permut_succ :
  rngl_is_comm = true →
  rngl_has_opp = true →
  rngl_has_inv = true →
  rngl_has_1_neq_0 = true →
  rngl_is_integral = true →
  rngl_has_dec_eq = true →
  rngl_characteristic = 0 →
  ∀ n k,
  k < (S n)!
  → ε (vect_el (mk_canon_sym_gr_vect' (S n)) k) =
    (minus_one_pow (k / n!) *
     ε (vect_el (mk_canon_sym_gr_vect' n) (k mod n!)))%F.
...
(*
Print determinant.
Abort.
End a.
Require Import Zrl.
Require Import ZArith.
Open Scope Z_scope.
Compute (determinant Z_ring_like_op 3 (mat_of_list_list [[1;2;7];[4;3;6];[7;8;9]])).
Compute (determinant' Z_ring_like_op 3 (mat_of_list_list [[1;2;7];[4;3;6];[7;8;9]])).
*)
...
      unfold butn.
      rewrite skipn_all2. 2: {
      rewrite fold_corr_mat_ncols.
      rewrite Hp in Hkp.
...
Search (skipn _ _ = []).
Search (butn _ (nth _ _ _)).
Search (nth _ (nth _ _ _)).
rewrite fold_mat_el.
...
Search subm.
Search sym_gr_fun.
unfold sym_gr_fun.
cbn.
...1
  rewrite ε_ws_ε_fun; try easy. 2: {
    split. {
      intros i Hi.
      rewrite (List_map_nth' 0); [ | now rewrite seq_length ].
      rewrite seq_nth; [ cbn | easy ].
      unfold sym_gr_fun at 1.
      destruct i. {
        admit. (* devrait le faire, mais casse-couilles *)
      }
      remember (k mod (S n)!) as p eqn:Hp.
      remember (sym_gr_fun n (mk_canon_sym_gr n) p) as σ eqn:Hσ.
      remember (mk_canon_sym_gr n (p mod n!)) as σ' eqn:Hσ'.
      move σ' before σ.
      rewrite (sym_gr_succ_values Hσ Hσ').
      destruct i. {
        admit.
      }
      admit.
    } {
      admit.
    }
  }
  unfold ε_fun_ws.
...
Print ε_fun_ws.
...
cbn - [ fact mk_canon_sym_gr_vect' subm seq ].
...
rewrite rngl_summation_summation_exch'.
Search (∑ (_ = _, _), ∑ (_ = _, _), _).
...
      cbn in Hj.
      unfold mat_ncols in Hcm; cbn in Hcm.
      destruct ll as [| l']; [ easy | ].
      cbn in Hcm.
      rewrite butn_length.
...
        destruct Hm as (Hr & Hcr & Hc).
        split.
Search (mat_nrows (subm _ _ _)).
Search (mat_ncols (subm _ _ _)).
...
    Search (is_correct_matrix (subm _ _ _)).
Theorem subm_is_correct_matrix : ∀ (M : matrix T) i j,
  i < mat_nrows M
  → j < mat_ncols M
  → is_correct_matrix M
  → is_correct_matrix (subm M i j).
Proof.
intros * Hir Hjc Hm.
(* faut pas que M n'ait qu'une seule colonne, et donc avec j=0
   parce que subm M i j est alors formée de lignes vides *)
...
destruct Hm as (Hcr, Hc).
split. {
  rewrite mat_nrows_subm; [ | easy ].
  intros Hcs.
  unfold mat_ncols, subm in Hcs.
  cbn in Hcs.
  apply length_zero_iff_nil in Hcs.
  rewrite map_butn in Hcs.
  rewrite List_hd_nth_0 in Hcs.
Theorem nth_0_butn_0 : ∀ A (l : list A) d,  nth 0 (butn 0 l) d = nth 1 l d.
Proof. now intros; destruct l. Qed.
destruct i. {
  rewrite nth_0_butn_0 in Hcs.
  destruct M as (ll); cbn in *.
  destruct ll as [| l]; [ easy | ].
cbn in Hir, Hcr.
  destruct ll as [| l']; [ easy | exfalso ].
  cbn in Hcs, Hjc.
  cbn in Hc.
  destruct j. {
    specialize (Hc l' (or_intror (or_introl eq_refl))) as H1.
    destruct l'; [ cbn in H1; flia Hjc H1 | ].
    cbn in Hcs; subst l'; cbn in H1.
cbn in Hir, Hcr.
clear Hir.
destruct ll as [| l'']. {
...
Theorem nth_butn : ∀ A (l : list A) d i j,
  i < j
  → nth i (butn j l) d = nth i l d.
Admitted.

Search (butn _ _ = []).
  rewrite (List_map_nth' []) in Hcs. 2: {
    cbn in Hcs |-*.
    apply -> Nat.succ_lt_mono.
    clear Hir Hcr; cbn in Hjc.
  cbn in Hcs.
}
rewrite nth_butn in Hcs.
...
  unfold mat_ncols in Hcs.
  apply length_zero_iff_nil in Hcs.
  destruct M as (ll); cbn in *.
  destruct ll as [| l]; [ easy | cbn ].
  rewrite Nat.sub_0_r.
  unfold mat_nrows, mat_ncols in *; cbn in *.
...
  rewrite List_map_hd with (a := []) in Hcs. 2: {
    destruct i. {
      cbn in Hcs |-*.
      intros H; subst ll.
      cbn in *.
...
  cbn in Hcs.
  cbn in Hc.

Search (hd _ _ = []).
About mat_nrows_subm.
...
  rewrite mat_ncols_subm; [ | easy ].
Search (mat_ncols (subm _ _ _)).
  rewrite subm_ncols.
...
  rewrite IHn; [ easy | ].
  rewrite mat_nrows_subm; [ | rewrite Hr; flia ].
  now rewrite Hr, Nat.sub_succ, Nat.sub_0_r.
}
cbn - [ fact "mod" "/" mk_canon_sym_gr_vect' subm ].
erewrite rngl_summation_eq_compat. 2: {
  intros i Hi.
  rewrite rngl_mul_summation_distr_l; [ easy | now left ].
}
cbn - [ fact "mod" "/" mk_canon_sym_gr_vect' subm ].
rewrite rngl_summation_summation_distr; [ | easy ].
rewrite <- Nat.sub_succ_l; [ | apply lt_O_fact ].
rewrite Nat.sub_succ, Nat.sub_0_r.
rewrite <- Nat_fact_succ.
symmetry.
erewrite rngl_summation_eq_compat. 2: {
  intros i Hi.
  rewrite rngl_product_split_first; [ | flia ].
  rewrite rngl_product_succ_succ.
  easy.
}
cbn - [ fact "mod" "/" mk_canon_sym_gr_vect' subm ].
symmetry.
apply rngl_summation_eq_compat.
intros k Hk.
do 2 rewrite rngl_mul_assoc.
f_equal. 2: {
  apply rngl_product_eq_compat.
  intros i Hi.
  unfold mat_el.
  unfold subm.
  cbn - [ butn fact mk_canon_sym_gr_vect' ].
  unfold butn.
  rewrite firstn_O, app_nil_l.
  rewrite (List_map_nth' []). 2: {
    rewrite skipn_length.
    rewrite fold_mat_nrows, Hr.
    flia Hi.
  }
  unfold mk_canon_sym_gr_vect'.
  cbn - [ fact map skipn seq ].
  rewrite (List_map_nth' 0). 2: {
    rewrite seq_length.
    apply Nat.mod_upper_bound.
    apply fact_neq_0.
  }
  cbn - [ fact map skipn seq ].
  rewrite (List_map_nth' 0). 2: {
    rewrite seq_length.
    now apply -> Nat.succ_le_mono.
  }
  rewrite seq_nth. 2: {
    apply Nat.mod_upper_bound.
    apply fact_neq_0.
  }
  rewrite Nat.add_0_l.
  rewrite seq_nth; [ | now apply -> Nat.succ_le_mono ].
  rewrite Nat.add_0_l.
  rewrite (List_map_nth' 0). 2: {
    rewrite seq_length.
    eapply le_lt_trans; [ apply Hk | ].
    apply Nat.sub_lt; [ | flia ].
    apply Nat.neq_0_lt_0, fact_neq_0.
  }
  cbn - [ fact map skipn seq ].
  rewrite (List_map_nth' 0). 2: {
    rewrite seq_length.
    now do 2 apply -> Nat.succ_le_mono.
  }
  rewrite seq_nth. 2: {
    eapply le_lt_trans; [ apply Hk | ].
    apply Nat.sub_lt; [ | flia ].
    apply Nat.neq_0_lt_0, fact_neq_0.
  }
  rewrite Nat.add_0_l.
  rewrite seq_nth; [ | now do 2 apply -> Nat.succ_le_mono ].
  rewrite Nat.add_0_l.
  cbn - [ fact skipn ].
  rewrite app_nth1. 2: {
    rewrite firstn_length.
    rewrite List_skipn_1.
    rewrite List_nth_tl.
    rewrite fold_corr_mat_ncols.
3: {
rewrite Hr.
...
Search (length (tl _)).
rewrite app_nth2.
...
  now rewrite Nat.add_1_r.
}
rewrite rngl_mul_mul_swap; [ | easy ].
symmetry.
f_equal.
apply ε_of_sym_gr_permut_succ; try easy.
specialize (fact_neq_0 (S (S n))) as Hnz.
flia Hk Hnz.
Qed.

...

(* multilinearity *)

Theorem determinant_multilinear :
  rngl_is_comm = true →
  rngl_has_opp = true →
  rngl_has_inv = true →
  rngl_is_integral = true →
  rngl_has_1_neq_0 = true →
  rngl_has_dec_eq = true →
  rngl_characteristic = 0 →
  ∀ n (M : matrix n n T) i a b U V,
    i < n
    → determinant (mat_repl_vect i M (a × U + b × V)%V) =
         (a * determinant (mat_repl_vect i M U) +
          b * determinant (mat_repl_vect i M V))%F.
Proof.
intros Hic Hop Hin Hit H10 Hde Hch * Hi.
rewrite det_is_det_by_canon_permut; try easy.
rewrite det_is_det_by_canon_permut; try easy.
rewrite det_is_det_by_canon_permut; try easy.
unfold determinant'.
erewrite rngl_summation_eq_compat. 2: {
  intros k Hk.
  erewrite rngl_product_eq_compat. 2: {
    intros j Hj.
    now cbn - [ Nat.eq_dec ].
  }
  easy.
}
cbn - [ Nat.eq_dec ].
rewrite rngl_mul_summation_distr_l; [ | now left ].
rewrite rngl_mul_summation_distr_l; [ | now left ].
symmetry.
erewrite rngl_summation_eq_compat. 2: {
  intros k Hk.
  rewrite rngl_mul_assoc.
  now rewrite (rngl_mul_comm Hic a).
}
rewrite rngl_add_comm.
erewrite rngl_summation_eq_compat. 2: {
  intros k Hk.
  rewrite rngl_mul_assoc.
  now rewrite (rngl_mul_comm Hic b).
}
rewrite rngl_add_comm.
rewrite <- rngl_summation_add_distr; [ | easy ].
apply rngl_summation_eq_compat.
intros k Hk.
do 2 rewrite <- rngl_mul_assoc.
rewrite <- rngl_mul_add_distr_l.
f_equal.
assert (Hkn : k < fact n). {
  specialize (fact_neq_0 n) as Hnz.
  flia Hk Hnz.
}
specialize (sym_gr_surjective Hkn Hi) as Hp.
destruct Hp as (p & Hp & Hpp).
rewrite (rngl_product_split (p + 1)); [ | flia Hp ].
rewrite rngl_product_split_last; [ | flia ].
erewrite rngl_product_eq_compat. 2: {
  intros j Hj.
  replace (j - 1 - 1) with (j - 2) by flia.
  destruct (Nat.eq_dec (mk_canon_sym_gr n k (j - 2)) i) as [Hpj| Hpj]. {
    exfalso.
    rewrite <- Hpp in Hpj.
    apply permut_elem_injective in Hpj; [ | easy | flia Hp Hj | easy ].
    flia Hj Hpj.
  }
  easy.
}
rewrite (rngl_mul_comm Hic (iter_seq _ _ _ _)).
rewrite rngl_add_comm.
rewrite (rngl_product_split (p + 1)); [ | flia Hp ].
rewrite rngl_product_split_last; [ | flia ].
erewrite rngl_product_eq_compat. 2: {
  intros j Hj.
  replace (j - 1 - 1) with (j - 2) by flia.
  destruct (Nat.eq_dec (mk_canon_sym_gr n k (j - 2)) i) as [Hpj| Hpj]. {
    exfalso.
    rewrite <- Hpp in Hpj.
    apply permut_elem_injective in Hpj; [ | easy | flia Hp Hj | easy ].
    flia Hj Hpj.
  }
  easy.
}
rewrite (rngl_mul_comm Hic (iter_seq _ _ _ _)).
rewrite rngl_add_comm.
symmetry.
rewrite (rngl_product_split (p + 1)); [ | flia Hp ].
rewrite rngl_product_split_last; [ | flia ].
erewrite rngl_product_eq_compat. 2: {
  intros j Hj.
  replace (j - 1 - 1) with (j - 2) by flia.
  destruct (Nat.eq_dec (mk_canon_sym_gr n k (j - 2)) i) as [Hpj| Hpj]. {
    exfalso.
    rewrite <- Hpp in Hpj.
    apply permut_elem_injective in Hpj; [ | easy | flia Hp Hj | easy ].
    flia Hj Hpj.
  }
  easy.
}
rewrite (rngl_mul_comm Hic (iter_seq _ _ _ _)).
rewrite Nat.add_sub.
cbn in Hpp.
rewrite Hpp.
destruct (Nat.eq_dec i i) as [H| H]; [ clear H | easy ].
do 4 rewrite rngl_mul_assoc.
remember
  (∏ (i0 = 2, p + 1), mat_el M (i0 - 2) (mk_canon_sym_gr n k (i0 - 2)))
  as q eqn:Hq.
do 3 rewrite (rngl_mul_comm Hic _ q).
do 5 rewrite <- rngl_mul_assoc.
rewrite <- rngl_mul_add_distr_l.
f_equal.
clear q Hq.
erewrite rngl_product_eq_compat. 2: {
  intros j Hj.
  destruct (Nat.eq_dec (mk_canon_sym_gr n k (j - 1)) i) as [Hpj| Hpj]. {
    rewrite <- Hpp in Hpj.
    apply permut_elem_injective in Hpj; [ | easy | flia Hp Hj | easy ].
    flia Hj Hpj.
  }
  easy.
}
symmetry.
erewrite rngl_product_eq_compat. 2: {
  intros j Hj.
  destruct (Nat.eq_dec (mk_canon_sym_gr n k (j - 1)) i) as [Hpj| Hpj]. {
    rewrite <- Hpp in Hpj.
    apply permut_elem_injective in Hpj; [ | easy | flia Hp Hj | easy ].
    flia Hj Hpj.
  }
  easy.
}
rewrite rngl_add_comm.
erewrite rngl_product_eq_compat. 2: {
  intros j Hj.
  destruct (Nat.eq_dec (mk_canon_sym_gr n k (j - 1)) i) as [Hpj| Hpj]. {
    rewrite <- Hpp in Hpj.
    apply permut_elem_injective in Hpj; [ | easy | flia Hp Hj | easy ].
    flia Hj Hpj.
  }
  easy.
}
cbn.
rewrite rngl_add_comm.
do 2 rewrite rngl_mul_assoc.
now rewrite <- rngl_mul_add_distr_r.
Qed.

(* list of terms in determinant' (determinant by sum of products of
   permutations *)

Definition determinant'_list {n} (M : matrix n n T) :=
  map (λ k,
    (ε_permut n k *
     ∏ (i = 1, n),
     mat_el M (i - 1) (vect_el (vect_el (mk_canon_sym_gr_vect' n) k) (i - 1)%nat))%F)
    (seq 0 n!).

Arguments determinant'_list {n}%nat M%M.

Theorem determinant'_by_list :
  rngl_is_comm = true →
  rngl_has_opp = true →
  rngl_has_inv = true →
  rngl_has_1_neq_0 = true →
  rngl_is_integral = true →
  rngl_has_dec_eq = true →
  rngl_characteristic = 0 →
  ∀ n (M : matrix n n T),
  determinant' M = ∑ (k = 0, fact n - 1), nth k (determinant'_list M) 0.
Proof.
intros Hic Hop Hin H10 Hit Hde Hch *.
unfold determinant', determinant'_list.
apply rngl_summation_eq_compat; intros k Hk.
assert (Hkn : k < fact n). {
  specialize (fact_neq_0 n) as Hn.
  flia Hk Hn.
}
rewrite List_map_nth_in with (a := 0); [ | now rewrite seq_length ].
rewrite seq_nth; [ | easy ].
rewrite Nat.add_0_l.
f_equal.
now apply ε_of_permut_ε.
Qed.

Theorem det_is_det_by_any_permut :
  rngl_is_comm = true →
  rngl_has_opp = true →
  rngl_has_inv = true →
  rngl_is_integral = true →
  rngl_has_1_neq_0 = true →
  rngl_has_dec_eq = true →
  rngl_characteristic = 0 →
  ∀ n (M : matrix n n T) l,
  Permutation l (determinant'_list M)
  → determinant M = ∑ (k = 0, fact n - 1), nth k l 0.
Proof.
intros Hic Hop Hin Hit H10 Hde Hch * Hl.
rewrite det_is_det_by_canon_permut; try easy.
rewrite determinant'_by_list; try easy.
apply rngl_summation_permut; [ now symmetry | | ]. {
  unfold determinant'_list.
  now rewrite map_length, seq_length.
} {
  apply Permutation_length in Hl.
  unfold determinant'_list in Hl.
  now rewrite map_length, seq_length in Hl.
}
Qed.

(* yet another definition of determinant *)

Definition determinant'' p q n (M : matrix n n T) :=
  ∑ (k = 0, fact n - 1),
    ε_permut n k *
    ∏ (i = 1, n),
    mat_el M (i - 1) (vect_el (sym_gr_elem_swap_last p q n k) (i - 1)).

Definition determinant''_list p q {n} (M : matrix n n T) :=
  map (λ k,
    (ε_permut n k *
     ∏ (i = 1, n),
     mat_el M (i - 1) (vect_el (sym_gr_elem_swap_last p q n k) (i - 1)))%F)
    (seq 0 (fact n)).

Theorem determinant''_by_list : ∀ n p q (M : matrix n n T),
  determinant'' p q M =
    ∑ (k = 0, fact n - 1), nth k (determinant''_list p q M) 0.
Proof.
intros.
unfold determinant'', determinant''_list.
apply rngl_summation_eq_compat; intros k Hk.
assert (Hkn : k < fact n). {
  specialize (fact_neq_0 n) as Hn.
  flia Hk Hn.
}
rewrite List_map_nth_in with (a := 0); [ | now rewrite seq_length ].
rewrite seq_nth; [ | easy ].
now rewrite Nat.add_0_l.
Qed.

Definition mat_swap_rows n i1 i2 (M : matrix n n T) :=
  mk_mat n n
    (λ i j,
     if Nat.eq_dec i i1 then mat_el M i2 j
     else if Nat.eq_dec i i2 then mat_el M i1 j
     else mat_el M i j).

Theorem determinant_alternating :
  rngl_is_comm = true →
  rngl_has_opp = true →
  rngl_has_inv = true →
  rngl_is_integral = true →
  rngl_has_1_neq_0 = true →
  rngl_has_dec_eq = true →
  rngl_characteristic = 0 →
  ∀ n (M : matrix n n T) p q,
  p ≠ q
  → p < n
  → q < n
  → determinant (mat_swap_rows p q M) = (- determinant M)%F.
Proof.
intros Hic Hop Hin Hit H10 Hde Hch * Hpq Hp Hq.
rewrite det_is_det_by_canon_permut; try easy.
unfold determinant'.
erewrite rngl_summation_eq_compat. 2: {
  intros k Hk.
  rewrite rngl_product_shift; [ | flia Hp ].
  erewrite rngl_product_eq_compat. 2: {
    intros i Hi.
    now rewrite Nat.add_comm, Nat.add_sub.
  }
  easy.
}
cbn - [ mat_swap_rows ].
erewrite rngl_summation_eq_compat. 2: {
  intros k Hk.
  rewrite rngl_product_change_var with
    (g := transposition p q) (h := transposition p q). 2: {
    intros i Hi.
    apply transposition_involutive.
  }
  rewrite Nat.sub_0_r.
  rewrite <- Nat.sub_succ_l; [ | flia Hp ].
  rewrite Nat.sub_succ, Nat.sub_0_r.
  easy.
}
cbn - [ mat_swap_rows ].
erewrite rngl_summation_eq_compat. 2: {
  intros k Hk.
  rewrite rngl_product_list_permut with (l2 := seq 0 n); [ | easy | ]. 2: {
    apply permut_fun_Permutation.
    now apply transposition_is_permut.
  }
  easy.
}
cbn - [ mat_swap_rows ].
erewrite rngl_summation_eq_compat. 2: {
  intros k Hk.
  erewrite rngl_product_list_eq_compat. 2: {
    intros i Hi.
    replace (mat_el _ _ _) with
      (mat_el M i (vect_el (vect_el (mk_canon_sym_gr_vect' n) k) (transposition p q i))). 2: {
      cbn.
      unfold transposition.
      do 2 rewrite if_eqb_eq_dec.
      destruct (Nat.eq_dec i p) as [Hip| Hip]. {
        subst i.
        apply Nat.neq_sym in Hpq.
        destruct (Nat.eq_dec q p) as [Hqp| Hqp]; [ easy | ].
        now destruct (Nat.eq_dec q q).
      }
      destruct (Nat.eq_dec i q) as [Hiq| Hiq]. {
        subst i.
        apply Nat.neq_sym in Hpq.
        now destruct (Nat.eq_dec p p).
      }
      destruct (Nat.eq_dec i p) as [H| H]; [ easy | clear H ].
      destruct (Nat.eq_dec i q) as [H| H]; [ easy | clear H ].
      easy.
    }
    easy.
  }
  easy.
}
cbn - [ mat_swap_rows ].
set (f := λ k, vect_swap_elem (vect_el (mk_canon_sym_gr_vect' n) k) p q).
erewrite rngl_summation_eq_compat. 2: {
  intros k Hk.
  assert (Hkn : k < n!). {
    specialize (fact_neq_0 n) as Hn.
    flia Hk Hn.
  }
  erewrite rngl_product_seq_product; [ | flia Hp ].
  rewrite Nat.add_0_l.
  erewrite rngl_product_eq_compat. 2: {
    intros i Hi.
    now replace (mk_canon_sym_gr _ _ _) with (vect_el (f k) i).
  }
  cbn - [ f ].
  replace ({| vect_el := mk_canon_sym_gr n k |}) with
    (mk_vect n (λ i, vect_el (f k) (transposition p q i))). 2: {
    apply vector_eq.
    intros i Hi; cbn.
    now rewrite transposition_involutive.
  }
  replace (mk_vect n (λ i, vect_el (f k) (transposition p q i))) with
    (f k ° mk_vect n (transposition p q)) by easy.
  rewrite signature_comp; try easy. {
    subst f; cbn.
    split; cbn. {
      intros i Hi.
      apply permut_ub; [ now apply sym_gr_elem_is_permut | ].
      now apply transposition_lt.
    } {
      intros * Hi Hj Hij.
      apply permut_elem_injective in Hij; [ | easy | | ]; cycle 1. {
        now apply transposition_lt.
      } {
        now apply transposition_lt.
      }
      now apply transposition_injective in Hij.
    }
  } {
    split; cbn. {
      intros i Hi.
      now apply transposition_lt.
    } {
      intros * Hi Hj Hij.
      now apply transposition_injective in Hij.
    }
  }
}
cbn - [ f ].
erewrite rngl_summation_eq_compat. 2: {
  intros k (_, Hk).
  rewrite (rngl_mul_comm Hic (ε (f k))).
  rewrite <- rngl_mul_assoc.
  now rewrite transposition_signature.
}
cbn - [ f ].
rewrite <- rngl_mul_summation_distr_l; [ | now left ].
rewrite rngl_mul_opp_l; [ | easy ].
f_equal.
rewrite rngl_mul_1_l.
symmetry.
set (g := λ k, rank_of_permut_in_sym_gr_vect (f k)).
rewrite rngl_summation_change_var with (g0 := g) (h := g). 2: {
  intros k (_, Hk).
  assert (Hkn : k < n!). {
    specialize (fact_neq_0 n) as Hn.
    flia Hk Hn.
  }
  unfold g, f.
  unfold vect_swap_elem; cbn.
  unfold rank_of_permut_in_sym_gr_vect; cbn.
  rewrite permut_in_sym_gr_of_its_rank. 2: {
    apply vect_swap_elem_is_permut; [ easy | easy | ].
    now apply sym_gr_elem_is_permut.
  }
...
  rewrite transposition_involutive.
...
  rewrite vect_swap_elem_involutive.
  now apply rank_of_permut_of_rank.
}
rewrite Nat.sub_0_r.
rewrite <- Nat.sub_succ_l; [ | apply Nat.neq_0_lt_0, fact_neq_0 ].
rewrite Nat.sub_succ, Nat.sub_0_r.
rewrite rngl_summation_list_permut with (l2 := seq 0 n!); [ | easy | ]. 2: {
  apply permut_fun_Permutation.
  unfold g, f.
  split. {
    intros i Hi.
    apply rank_of_permut_upper_bound.
    apply vect_swap_elem_is_permut; [ easy | easy | ].
    now apply sym_gr_elem_is_permut.
  } {
    intros * Hi Hj Hij.
    apply rank_of_permut_injective in Hij; cycle 1. {
      apply vect_swap_elem_is_permut; [ easy | easy | ].
      now apply sym_gr_elem_is_permut.
    } {
      apply vect_swap_elem_is_permut; [ easy | easy | ].
      now apply sym_gr_elem_is_permut.
    }
    apply vect_swap_elem_injective in Hij.
    cbn in Hij.
    injection Hij; clear Hij; intros Hij.
    now apply sym_gr_elem_injective in Hij.
  }
}
erewrite rngl_summation_list_eq_compat. 2: {
  intros k Hk.
  assert (Hkn : k < n!). {
    apply in_seq in Hk.
    specialize (fact_neq_0 n) as Hn.
    flia Hk Hn.
  }
  unfold g, f.
  rewrite permut_in_sym_gr_of_its_rank. 2: {
    apply vect_swap_elem_is_permut; [ easy | easy | ].
    now apply sym_gr_elem_is_permut.
  }
  rewrite vect_swap_elem_involutive.
  easy.
}
rewrite det_is_det_by_canon_permut; try easy.
unfold determinant'.
rewrite rngl_summation_seq_summation; [ | apply fact_neq_0 ].
rewrite Nat.add_0_l.
apply rngl_summation_eq_compat.
intros k Hk; f_equal.
rewrite rngl_product_shift; [ | flia Hp ].
apply rngl_product_eq_compat.
intros i Hi.
now rewrite Nat.add_comm, Nat.add_sub.
Qed.

Theorem determinant_same_rows :
  rngl_is_comm = true →
  rngl_has_opp = true →
  rngl_has_inv = true →
  rngl_is_integral = true →
  rngl_has_1_neq_0 = true →
  rngl_has_dec_eq = true →
  rngl_characteristic = 0 →
  ∀ n (M : matrix n n T) p q,
  p ≠ q
  → p < n
  → q < n
  → (∀ j, mat_el M p j = mat_el M q j)
  → determinant M = 0%F.
Proof.
intros Hic Hop Hin Hit H10 Hde Hch * Hpq Hpn Hqn Hjpq.
assert (HM : determinant M = (- determinant M)%F). {
  rewrite <- determinant_alternating with (p := p) (q := q); try easy.
  f_equal.
  apply matrix_eq.
  intros i j Hi Hj.
  cbn.
  destruct (Nat.eq_dec i p) as [Hip| Hip]; [ subst i; apply Hjpq | ].
  destruct (Nat.eq_dec i q) as [Hiq| Hiq]; [ symmetry; subst i; apply Hjpq | ].
  easy.
}
apply rngl_add_move_0_r in HM; [ | easy ].
apply eq_rngl_add_same_0 in HM; try easy; [ now left | ].
apply orb_true_iff.
now left.
Qed.

(* transpositions list of permutation *)

Fixpoint first_non_fixpoint it i σ :=
  match it with
  | 0 => None
  | S it' => if i =? σ i then first_non_fixpoint it' (i + 1) σ else Some i
  end.

Fixpoint tlopf_loop it n (σ : nat → nat) :=
  match it with
  | 0 => []
  | S it' =>
      match first_non_fixpoint n 0 σ with
      | None => []
      | Some i =>
          let σ' := comp (transposition i (σ i)) σ in
          (i, σ i) :: tlopf_loop it' n σ'
      end
  end.

Definition transp_list_of_permut_fun n (σ : nat → nat) := tlopf_loop n n σ.

Definition transp_list_of_permut {n} (σ : vector n nat) :=
  transp_list_of_permut_fun n (vect_el σ).

Theorem first_non_fixpoint_Some_iff : ∀ σ it i j,
  first_non_fixpoint it i σ = Some j
  ↔ i ≤ j ∧ j - i < it ∧ (∀ k, i ≤ k < j → σ k = k) ∧ σ j ≠ j.
Proof.
intros.
split. {
  intros Hs.
  revert σ i j Hs.
  induction it; intros; [ easy | cbn in Hs ].
  rewrite if_eqb_eq_dec in Hs.
  destruct (Nat.eq_dec i (σ i)) as [Hii| Hii]. {
    specialize (IHit σ (i + 1) j Hs) as (H1 & H2 & H3 & H4).
    split; [ flia H1 | ].
    split; [ flia H2 | ].
    split; [ | easy ].
    intros k Hk.
    destruct (Nat.eq_dec i k) as [Hik| Hik]; [ now subst k | ].
    apply H3; flia Hk Hik.
  } {
    injection Hs; clear Hs; intros; subst j.
    split; [ flia | ].
    split; [ flia | ].
    split; [ | now apply Nat.neq_sym ].
    intros k Hk; flia Hk.
  }
} {
  intros (Hij & Hji & Hj & Hjj).
  revert i j Hij Hji Hj Hjj.
  induction it; intros; [ easy | cbn ].
  rewrite if_eqb_eq_dec.
  destruct (Nat.eq_dec i (σ i)) as [Hii| Hii]. {
    assert (Heij : i ≠ j) by now intros H; symmetry in Hii; subst i.
    apply IHit; [ flia Hij Hji Heij | flia Hij Hji Heij | | easy ].
    intros k Hk.
    apply Hj.
    flia Hk.
  }
  destruct (Nat.eq_dec i j) as [Heij| Heij]; [ congruence | exfalso ].
  assert (H : i ≤ i < j) by flia Hij Heij.
  specialize (Hj _ H) as H1.
  now symmetry in H1.
}
Qed.

Theorem first_non_fixpoint_None_if : ∀ σ it i,
  first_non_fixpoint it i σ = None
  → ∀ k, i ≤ k < i + it → k = σ k.
Proof.
intros * Hs k Hik.
revert σ i k Hik Hs.
induction it; intros; [ flia Hik | ].
cbn in Hs.
rewrite if_eqb_eq_dec in Hs.
destruct (Nat.eq_dec i (σ i)) as [H1| H1]; [ | easy ].
destruct (Nat.eq_dec i k) as [H2| H2]; [ now subst i | ].
eapply IHit; [ | apply Hs ].
flia Hik H2.
Qed.

Fixpoint nb_good_loop it i σ :=
  match it with
  | 0 => 0
  | S it' => Nat.b2n (σ i =? i) + nb_good_loop it' (i + 1) σ
  end.

Definition nb_good n σ := nb_good_loop n 0 σ.

Theorem nb_good_loop_comp_transp : ∀ n it σ i k,
  is_permut σ n
  → k < i ≤ n
  → σ k < i
  → n = i + it
  → nb_good_loop it i (comp (transposition k (σ k)) σ) =
    nb_good_loop it i σ.
Proof.
intros * Hp Hkin Hski Hnit.
revert i k Hkin Hski Hnit.
induction it; intros; [ easy | cbn ].
replace (i + S it) with (i + 1 + it) in Hnit by flia.
unfold comp at 1, transposition at 1, Nat.b2n.
do 4 rewrite if_eqb_eq_dec.
destruct (Nat.eq_dec (σ i) k) as [Hsik| Hsik]. {
  rewrite Hsik.
  destruct (Nat.eq_dec k i) as [H| H]; [ flia Hkin H | clear H ].
  rewrite Nat.add_0_l.
  destruct (Nat.eq_dec (σ k) i) as [H| H]; [ flia Hski H | clear H ].
  rewrite Nat.add_0_l.
  apply IHit; try easy; [ | flia Hski ].
  split; [ flia Hkin | ].
  flia Hnit.
}
destruct (Nat.eq_dec (σ i) (σ k)) as [Hsisk| Hsisk]. {
  apply Hp in Hsisk; [ flia Hkin Hsisk | | flia Hkin ].
  flia Hnit.
}
f_equal.
apply IHit; [ | flia Hski | easy ].
split; [ flia Hkin | flia Hnit ].
Qed.

Theorem comp_transp_permut_id : ∀ n σ i j k,
  is_permut σ n
  → i < k
  → k < j < n
  → σ k = i
  → comp (transposition i (σ i)) σ j = σ j.
Proof.
intros * Hp Hikn Hkp Hski.
unfold comp, transposition.
do 2 rewrite if_eqb_eq_dec.
destruct (Nat.eq_dec (σ j) i) as [Hsji| Hsji]. {
  exfalso.
  rewrite <- Hski in Hsji.
  apply Hp in Hsji; [ flia Hkp Hsji | easy | flia Hkp ].
}
destruct (Nat.eq_dec (σ j) (σ i)) as [Hspi| Hspi]; [ | easy ].
apply Hp in Hspi; [ | easy | flia Hikn Hkp ].
flia Hikn Hkp Hspi.
Qed.

Theorem nb_good_loop_comp_transp_permit_id : ∀ n it σ i k,
  is_permut σ n
  → i < n
  → k < n
  → n = k + it
  → (∀ j, k ≤ j → comp (transposition i (σ i)) σ j = σ j)
  → nb_good_loop it k (comp (transposition i (σ i)) σ) =
    nb_good_loop it k σ.
Proof.
intros * Hp Hin Hkn Hnit Hj.
revert i k Hin Hkn Hj Hnit.
induction it; intros; [ easy | cbn ].
unfold comp at 1, transposition at 1, Nat.b2n.
do 4 rewrite if_eqb_eq_dec.
destruct (Nat.eq_dec (σ k) i) as [Hski| Hski]. {
  rewrite Hski.
  destruct (Nat.eq_dec i k) as [Hik| Hik]. {
    move Hik at top; subst k.
    rewrite Hski.
    rewrite <- if_eqb_eq_dec, Nat.eqb_refl.
    f_equal.
    clear.
    remember (i + 1) as k eqn:Hk; clear Hk.
    revert i k.
    induction it; intros; [ easy | cbn ].
    unfold comp at 1, transposition at 1, Nat.b2n.
    do 4 rewrite if_eqb_eq_dec.
    destruct (Nat.eq_dec (σ k) i) as [Hki| Hki]. {
      rewrite Hki.
      now rewrite IHit.
    }
    now rewrite IHit.
  }
  destruct (Nat.eq_dec (σ i) k) as [Hsik| Hsik]. {
    exfalso.
    specialize (Hj k (le_refl _)).
    unfold comp, transposition in Hj.
    rewrite Hski, Nat.eqb_refl in Hj.
    apply Hik, Hp; [ easy | easy | congruence ].
  }
  f_equal.
  specialize (Hj k (le_refl _)).
  unfold comp, transposition in Hj.
  rewrite Hski, Nat.eqb_refl in Hj.
  rewrite <- Hj in Hski.
  apply Hp in Hski; [ congruence | easy | easy ].
}
destruct (Nat.eq_dec (σ k) (σ i)) as [Hsksi| Hsksi]. {
  apply Hp in Hsksi; [ | easy | easy ].
  subst k.
  rewrite <- if_eqb_eq_dec, Nat.eqb_refl.
  destruct (Nat.eq_dec (σ i) i) as [H| H]; [ easy | clear H ].
  specialize (Hj i (le_refl _)).
  unfold comp, transposition in Hj.
  rewrite if_eqb_eq_dec in Hj.
  destruct (Nat.eq_dec (σ i) i) as [H| H]; [ easy | clear H ].
  rewrite Nat.eqb_refl in Hj.
  congruence.
}
f_equal.
destruct (Nat.eq_dec (k + 1) n) as [Hk1n| Hk1n]. {
  destruct it; [ easy | ].
  flia Hnit Hk1n.
}
rewrite IHit; [ easy | easy | flia Hkn Hk1n | | flia Hnit ].
intros j Hkj.
apply Hj; flia Hkj.
Qed.

Theorem nb_good_loop_comp_transp2 : ∀ n it σ i,
  is_permut σ n
  → (∀ k, k < i → σ k = k)
  → σ i ≠ i
  → σ (σ i) ≠ i
  → σ (σ i) ≠ σ i
  → n = i + 1 + it
  → nb_good_loop it (i + 1) (comp (transposition i (σ i)) σ) =
    nb_good_loop it (i + 1) σ.
Proof.
intros * Hp Hi Hsii Hssii Hssisi Hnit.
remember (σ i) as j eqn:Hj; symmetry in Hj.
remember (permut_fun_inv σ n i) as k eqn:Hk.
assert (Hkd : σ k = i). {
  subst k.
  apply fun_permut_fun_inv; [ easy | flia Hnit ].
}
assert (Hik : i < k). {
  assert (H1 : i ≤ k). {
    apply Nat.nlt_ge; intros H.
    apply Hi in H.
    rewrite Hkd in H; move H at top; subst k.
    congruence.
  }
  destruct (Nat.eq_dec i k) as [Hik| Hik]; [ | flia Hik H1 ].
  move Hik at top; subst k.
  congruence.
}
assert (Hjk : j ≠ k). {
  now intros H; move H at top; subst k.
}
assert (Hij : i < j). {
  apply Nat.nle_gt; intros H.
  assert (H' : j < i) by flia Hsii H.
  now apply Hi in H'.
}
assert (Hkn : k < n). {
  rewrite Hk.
  apply permut_ub; [ | flia Hnit ].
  now apply permut_fun_inv_is_permut.
}
clear Hk.
clear Hi.
clear Hj.
clear Hsii.
clear Hssii.
remember (i + 1) as p eqn:Hp'.
assert (Hip : i < p) by flia Hp'.
clear Hp'.
revert i j k p Hssisi Hnit Hkd Hik Hjk Hij Hip Hkn.
induction it; intros; [ easy | cbn ].
replace (p + S it) with (p + 1 + it) in Hnit by flia.
unfold comp at 1, transposition at 1, Nat.b2n.
do 4 rewrite if_eqb_eq_dec.
destruct (Nat.eq_dec (σ p) i) as [Hspi| Hspi]. {
  rewrite Hspi.
  rewrite <- Hkd in Hspi.
  apply Hp in Hspi; [ | flia Hnit | easy ].
  move Hspi at top; subst p.
  destruct (Nat.eq_dec j k) as [H| H]; [ easy | clear H ].
  destruct (Nat.eq_dec i k) as [H| H]; [ flia Hip H | clear H ].
  cbn.
  apply IHit with (k := k); try easy; flia Hip.
}
destruct (Nat.eq_dec (σ p) j) as [Hspj| Hspj]. {
  rewrite Hspj.
  destruct (Nat.eq_dec i p) as [H| H]; [ flia Hip H | clear H ].
  destruct (Nat.eq_dec j p) as [Hjp| Hjp]. {
    now move Hjp at top; subst p.
  }
  cbn.
  apply IHit with (k := k); try easy; flia Hip.
}
f_equal.
apply IHit with (k := k); try easy; flia Hip.
Qed.

Theorem nb_good_loop_comp_transp' : ∀ n it σ i d,
  is_permut σ n
  → i < n
  → d ≠ 0
  → (∀ k, k < i → σ k = k)
  → (∀ k, k < d → σ (i + k) ≠ i)
  → σ (σ i) = i
  → n = i + d + it
  → nb_good_loop it (i + d) (comp (transposition i (σ i)) σ) =
     nb_good_loop it (i + d) σ + 1.
Proof.
intros * Hp Hin Hdz Hskk Hsii Hssi Hnit.
revert i d Hin Hdz Hskk Hsii Hssi Hnit.
induction it; intros; cbn. {
  exfalso.
  destruct Hp as (Hp1, Hp2).
  rewrite Nat.add_0_r in Hnit.
  specialize (Hp1 i Hin) as H1.
  clear - d Hin Hnit Hsii Hskk Hssi H1.
  assert (Hisi : i ≤ σ i). {
    apply Nat.nlt_ge; intros H2.
    specialize (Hskk (σ i) H2) as H3.
    flia Hssi H2 H3.
  }
  specialize (Hsii (σ i - i)) as H2.
  assert (H : σ i - i < d). {
    apply Nat.add_lt_mono_r with (p := i).
    rewrite (Nat.add_comm d), <- Hnit.
    now rewrite Nat.sub_add.
  }
  specialize (H2 H); clear H.
  rewrite Nat.add_sub_assoc in H2; [ | easy ].
  now rewrite Nat.add_comm, Nat.add_sub in H2.
}
replace (i + d + S it) with (i + d + 1 + it) in Hnit by flia.
unfold comp at 1, transposition at 1, Nat.b2n.
do 4 rewrite if_eqb_eq_dec.
destruct (Nat.eq_dec (σ (i + d)) i) as [Hsi2i| Hsi2i]. {
  rewrite Hsi2i.
  destruct (Nat.eq_dec (σ i) (i + d)) as [Hsiid| Hsiid]. {
    destruct (Nat.eq_dec i (i + d)) as [H| H]; [ flia Hdz H | clear H ].
    rewrite Nat.add_0_l, Nat.add_comm; f_equal.
    apply nb_good_loop_comp_transp with (n := n); [ easy | | | easy ]. {
      flia Hnit.
    }
    flia Hsiid.
  }
  destruct (Nat.eq_dec i (i + d)) as [H| H]; [ flia Hdz H | clear H ].
  rewrite <- Nat.add_assoc; cbn.
  replace (i + d + 1 + it) with (i + (d + 1) + it) in Hnit by flia.
  rewrite <- Hssi in Hsi2i at 2.
  apply Nat.neq_sym in Hsiid.
  apply Hp in Hsi2i; [ easy | flia Hnit | ].
  now apply Hp.
}
destruct (Nat.eq_dec (σ (i + d)) (σ i)) as [Hsidsi| Hsidsi]. {
  apply Hp in Hsidsi; [ | flia Hnit | easy ].
  flia Hdz Hsidsi.
}
rewrite <- (Nat.add_assoc (if Nat.eq_dec _ _ then _ else _)).
f_equal.
rewrite <- Nat.add_assoc.
replace (i + d + 1 + it) with (i + (d + 1) + it) in Hnit by flia.
apply IHit; try easy; [ flia | ].
intros k Hk.
destruct (Nat.eq_dec k d) as [Hkd| Hkd]; [ now subst k | ].
apply Hsii.
flia Hk Hkd.
Qed.

Theorem nb_good_loop_comp_transp_eq : ∀ it n σ i k,
  is_permut σ n
  → first_non_fixpoint n 0 σ = Some i
  → k ≤ i
  → n = k + it
  → nb_good_loop it k (comp (transposition i (σ i)) σ) =
    nb_good_loop it k σ + 1 + Nat.b2n (σ (σ i) =? i).
Proof.
intros * Hp Hi Hki Hnit.
apply first_non_fixpoint_Some_iff in Hi.
rewrite Nat.sub_0_r in Hi.
destruct Hi as (_ & Hin & Hi & Hsii).
revert i k Hin Hi Hsii Hki Hnit.
induction it; intros; cbn. {
  flia Hin Hki Hnit.
}
replace (k + S it) with (k + 1 + it) in Hnit by flia.
unfold comp at 1, transposition at 1, Nat.b2n.
do 5 rewrite if_eqb_eq_dec.
destruct (Nat.eq_dec (σ k) i) as [Hski| Hski]. {
  destruct (Nat.eq_dec k i) as [Heki| Heki]; [ congruence | ].
  assert (H : 0 ≤ k < i) by flia Hki Heki.
  specialize (Hi _ H); clear H.
  congruence.
}
destruct (Nat.eq_dec (σ k) (σ i)) as [Hsksi| Hsksi]. {
  apply Hp in Hsksi; [ | flia Hnit | easy ].
  move Hsksi at top; subst k.
  rewrite <- if_eqb_eq_dec, Nat.eqb_refl.
  clear Hski Hki.
  destruct (Nat.eq_dec (σ i) i) as [H| H]; [ easy | clear H ].
  rewrite Nat.add_0_l.
  destruct (Nat.eq_dec (σ (σ i)) i) as [Hssii| Hssii]. {
    rewrite Nat.add_comm; f_equal.
    apply nb_good_loop_comp_transp' with (n := n); try easy. {
      intros k Hk.
      apply Hi.
      split; [ flia | easy ].
    }
    intros k Hk.
    destruct k; [ | flia Hk ].
    now rewrite Nat.add_0_r.
  }
  rewrite Nat.add_comm, Nat.add_0_r; f_equal.
  destruct (Nat.eq_dec (σ (σ i)) (σ i)) as [Hssisi| Hssisi]. {
    apply Hp in Hssisi; [ easy | | easy ].
    now apply Hp.
  }
  apply nb_good_loop_comp_transp2 with (n := n); try easy.
  intros k Hk.
  apply Hi; flia Hk.
}
do 2 rewrite <- Nat.add_assoc.
f_equal.
destruct (Nat.eq_dec k i) as [Hk1i| Hk1i]. {
  now move Hk1i at top; subst k.
}
rewrite IHit; try easy; [ | flia Hki Hk1i ].
unfold Nat.b2n.
rewrite if_eqb_eq_dec.
symmetry.
apply Nat.add_assoc.
Qed.

Theorem first_non_fixpoint_enough_iter : ∀ n m σ i j,
  n ≤ m
  → first_non_fixpoint n i σ = Some j
  → first_non_fixpoint m i σ = Some j.
Proof.
intros * Hnm Hij.
revert i j n σ Hnm Hij.
induction m; intros; cbn. {
  now apply Nat.le_0_r in Hnm; subst n.
}
rewrite if_eqb_eq_dec.
destruct (Nat.eq_dec i (σ i)) as [Hii| Hii]. {
  destruct n; [ easy | ].
  cbn in Hij.
  rewrite <- Hii, Nat.eqb_refl in Hij.
  apply Nat.succ_le_mono in Hnm.
  now apply IHm with (n := n).
}
apply first_non_fixpoint_Some_iff in Hij.
destruct Hij as (Hij & Hjin & Hikj & Hjj).
destruct (Nat.eq_dec i j) as [H1| H1]; [ now subst i | ].
exfalso; apply Hii; symmetry.
apply Hikj.
split; [ flia | flia Hij H1 ].
Qed.

(* If we add a row (column) of A multiplied by a scalar k to another
   row (column) of A, then the determinant will not change. *)
(* https://math.vanderbilt.edu/sapirmv/msapir/proofdet1.html *)
(* doing it only when the first row is 0; can be generalized later *)

Definition mat_add_row_mul_scal_row n (M : matrix n n T) i1 v i2 :=
  mk_mat n n
    (λ i j,
     if Nat.eq_dec i i1 then (mat_el M i1 j + v * mat_el M i2 j)%F
     else mat_el M i j).

(* *)

Definition mat_mul_row_by_scal n k (M : matrix n n T) s :=
  mk_mat n n
    (λ i j,
     if Nat.eq_dec i k then (s * mat_el M i j)%F else mat_el M i j).

(* If we multiply a row (column) of A by a number, the determinant of
   A will be multiplied by the same number. *)
(* https://math.vanderbilt.edu/sapirmv/msapir/proofdet1.html
   point 1 *)

(* Well, since my definition of the determinant only covers the
   row 0, we can prove that only when i=0; this will able us to
   prove next theorems, swapping rows by going via row 0 *)

Theorem det_mul_row_0_by_scal :
  rngl_has_opp = true ∨ rngl_has_sous = true →
  rngl_is_comm = true →
  ∀ n (A : matrix n n T) v,
  n ≠ 0
  → determinant (mat_mul_row_by_scal 0 A v) = (v * determinant A)%F.
Proof.
intros Hom Hic * Hnz.
unfold determinant; cbn.
destruct n; [ easy | clear Hnz ].
cbn.
rewrite rngl_mul_summation_distr_l; [ | easy ].
apply rngl_summation_eq_compat.
intros j Hj.
rewrite (rngl_mul_comm Hic (minus_one_pow j)).
do 2 rewrite <- rngl_mul_assoc.
f_equal.
rewrite (rngl_mul_comm Hic (mat_el A 0 j)).
do 2 rewrite <- rngl_mul_assoc.
f_equal.
rewrite rngl_mul_comm; [ f_equal | easy ].
f_equal.
apply matrix_eq; cbn.
rename j into k; rename Hj into Hk.
intros i j Hi Hj.
destruct (Nat.eq_dec (i + 1) 0) as [H| H]; [ flia H | easy ].
Qed.

(* If the i-th row (column) in A is a sum of the i-th row (column) of
   a matrix B and the i-th row (column) of a matrix C and all other
   rows in B and C are equal to the corresponding rows in A (that is B
   and C differ from A by one row only), then det(A)=det(B)+det(C). *)
(* https://math.vanderbilt.edu/sapirmv/msapir/proofdet1.html
   point 2 *)

(* Well, since my definition of the discriminant only covers the
   row 0, we can prove that only when i=0; this will able us to
   prove the next theorem, swapping rows by going via row 0 *)

Theorem det_sum_row_row : ∀ n (A B C : matrix n n T),
  n ≠ 0
  → (∀ j, mat_el A 0 j = (mat_el B 0 j + mat_el C 0 j)%F)
  → (∀ i j, i ≠ 0 → mat_el B i j = mat_el A i j)
  → (∀ i j, i ≠ 0 → mat_el C i j = mat_el A i j)
  → determinant A = (determinant B + determinant C)%F.
Proof.
intros * Hnz Hbc Hb Hc.
unfold determinant.
destruct n; [ easy | clear Hnz ].
cbn.
assert (Hab : ∀ j, subm A 0 j = subm B 0 j). {
  intros.
  apply matrix_eq; cbn.
  intros i j' Hi Hj'.
  destruct (lt_dec j' j); symmetry; apply Hb; flia.
}
assert (Hac : ∀ j, subm A 0 j = subm C 0 j). {
  intros.
  apply matrix_eq; cbn.
  intros i j' Hi Hj'.
  destruct (lt_dec j' j); symmetry; apply Hc; flia.
}
erewrite rngl_summation_eq_compat. 2: {
  intros j Hj.
  rewrite Hbc.
  rewrite rngl_mul_add_distr_l.
  rewrite rngl_mul_add_distr_r.
  rewrite Hab at 1.
  rewrite Hac at 1.
  easy.
}
cbn.
now apply rngl_summation_add_distr.
Qed.

(* If two rows (columns) in A are equal then det(A)=0. *)
(* https://math.vanderbilt.edu/sapirmv/msapir/proofdet1.html
   point 3 *)
(* doing it only when the first row is 0; can be generalized later *)

Definition δ_lt i k := Nat.b2n (i <? k).

Theorem subm_subm_swap : ∀ n (A : matrix (S n) (S n) T) i j k l,
  subm (subm A i j) k l =
  subm (subm A (k + δ_lt i k) (l + δ_lt j l)) (i - δ_lt k i) (j - δ_lt l j).
Proof.
intros.
apply matrix_eq; cbn.
intros i' j' Hi' Hj'.
f_equal. {
  do 2 rewrite <- Nat.add_assoc; f_equal.
  rewrite Nat.add_comm.
  unfold δ_lt.
  remember (k <=? i') as a eqn:Ha.
  remember (i <=? i' + Nat.b2n a) as b eqn:Hb.
  remember (i <? k) as c eqn:Hc.
  remember (k <? i) as d eqn:Hd.
  remember (i - Nat.b2n d <=? i') as e eqn:He.
  remember (k + Nat.b2n c <=? i' + Nat.b2n e) as f eqn:Hf.
  move b before a; move c before b; move d before c; move e before d.
  move f before e.
  symmetry in Ha, Hb, Hc, Hd, He, Hf.
  destruct a, b, d, e, f; cbn; try easy; exfalso. {
    apply Nat.leb_le in Ha; apply Nat.leb_le in Hb; apply Nat.leb_le in Hd.
    apply Nat.leb_le in He; apply Nat.leb_nle in Hf.
    destruct c; [ apply Nat.ltb_lt in Hc; flia Ha Hb Hc Hd He Hf | ].
    cbn in Hf.
    apply Nat.ltb_nlt in Hc; flia Ha Hb Hc Hd He Hf.
  } {
    apply Nat.leb_le in Ha; apply Nat.leb_le in Hb; apply Nat.leb_le in Hd.
    apply Nat.leb_nle in He; apply Nat.leb_le in Hf.
    destruct c; [ apply Nat.ltb_lt in Hc; flia Ha Hb Hc Hd He Hf | ].
    apply Nat.ltb_nlt in Hc; flia Ha Hb Hc Hd He Hf.
  } {
    apply Nat.leb_le in Ha; apply Nat.leb_le in Hb; apply Nat.leb_le in Hd.
    apply Nat.leb_nle in He; apply Nat.leb_nle in Hf.
    destruct c; [ apply Nat.ltb_lt in Hc; flia Ha Hb Hc Hd He Hf | ].
    apply Nat.ltb_nlt in Hc; flia Ha Hb Hc Hd He Hf.
  } {
    apply Nat.leb_le in Ha; apply Nat.leb_le in Hb; apply Nat.leb_nle in Hd.
    apply Nat.leb_le in He; apply Nat.leb_nle in Hf.
    destruct c; [ apply Nat.ltb_lt in Hc; flia Ha Hb Hc Hd He Hf | ].
    cbn in Hf.
    apply Nat.ltb_nlt in Hc; flia Ha Hb Hc Hd He Hf.
  } {
    apply Nat.leb_le in Ha; apply Nat.leb_le in Hb; apply Nat.leb_nle in Hd.
    apply Nat.leb_nle in He; apply Nat.leb_le in Hf.
    destruct c; [ apply Nat.ltb_lt in Hc; flia Ha Hb Hc Hd He Hf | ].
    apply Nat.ltb_nlt in Hc; flia Ha Hb Hc Hd He Hf.
  } {
    apply Nat.leb_le in Ha; apply Nat.leb_le in Hb; apply Nat.leb_nle in Hd.
    apply Nat.leb_nle in He; apply Nat.leb_nle in Hf.
    destruct c; [ apply Nat.ltb_lt in Hc; flia Ha Hb Hc Hd He Hf | ].
    apply Nat.ltb_nlt in Hc; flia Ha Hb Hc Hd He Hf.
  } {
    apply Nat.leb_le in Ha; apply Nat.leb_nle in Hb; apply Nat.leb_le in Hd.
    apply Nat.leb_le in He; apply Nat.leb_le in Hf.
    destruct c; [ apply Nat.ltb_lt in Hc; flia Ha Hb Hc Hd He Hf | ].
    apply Nat.ltb_nlt in Hc; flia Ha Hb Hc Hd He Hf.
  } {
    apply Nat.leb_le in Ha; apply Nat.leb_nle in Hb; apply Nat.leb_le in Hd.
    apply Nat.leb_nle in He; apply Nat.leb_nle in Hf.
    destruct c; [ apply Nat.ltb_lt in Hc; flia Ha Hb Hc Hd He Hf | ].
    apply Nat.ltb_nlt in Hc; flia Ha Hb Hc Hd He Hf.
  } {
    apply Nat.leb_le in Ha; apply Nat.leb_nle in Hb; apply Nat.leb_nle in Hd.
    apply Nat.leb_le in He; apply Nat.leb_le in Hf.
    destruct c; [ apply Nat.ltb_lt in Hc; flia Ha Hb Hc Hd He Hf | ].
    apply Nat.ltb_nlt in Hc; flia Ha Hb Hc Hd He Hf.
  } {
    apply Nat.leb_le in Ha; apply Nat.leb_nle in Hb; apply Nat.leb_nle in Hd.
    apply Nat.leb_nle in He; apply Nat.leb_nle in Hf.
    destruct c; [ apply Nat.ltb_lt in Hc; flia Ha Hb Hc Hd He Hf | ].
    apply Nat.ltb_nlt in Hc; flia Ha Hb Hc Hd He Hf.
  } {
    apply Nat.leb_nle in Ha; apply Nat.leb_le in Hb; apply Nat.leb_le in Hd.
    apply Nat.leb_le in He; apply Nat.leb_le in Hf.
    destruct c; [ apply Nat.ltb_lt in Hc; flia Ha Hb Hc Hd He Hf | ].
    cbn in He.
    apply Nat.ltb_nlt in Hc; flia Ha Hb Hc Hd He Hf.
  } {
    apply Nat.leb_nle in Ha; apply Nat.leb_le in Hb; apply Nat.leb_le in Hd.
    apply Nat.leb_nle in He; apply Nat.leb_nle in Hf.
    destruct c; [ apply Nat.ltb_lt in Hc; flia Ha Hb Hc Hd He Hf | ].
    cbn in Hb.
    apply Nat.ltb_nlt in Hc; flia Ha Hb Hc Hd He Hf.
  } {
    apply Nat.leb_nle in Ha; apply Nat.leb_le in Hb; apply Nat.leb_nle in Hd.
    apply Nat.leb_le in He; apply Nat.leb_le in Hf.
    destruct c; [ apply Nat.ltb_lt in Hc; flia Ha Hb Hc Hd He Hf | ].
    cbn in Hb.
    apply Nat.ltb_nlt in Hc; flia Ha Hb Hc Hd He Hf.
  } {
    apply Nat.leb_nle in Ha; apply Nat.leb_le in Hb; apply Nat.leb_nle in Hd.
    apply Nat.leb_nle in He; apply Nat.leb_nle in Hf.
    destruct c; [ apply Nat.ltb_lt in Hc; flia Ha Hb Hc Hd He Hf | ].
    apply Nat.ltb_nlt in Hc; flia Ha Hb Hc Hd He Hf.
  } {
    apply Nat.leb_nle in Ha; apply Nat.leb_nle in Hb; apply Nat.leb_le in Hd.
    apply Nat.leb_le in He; apply Nat.leb_le in Hf.
    destruct c; [ apply Nat.ltb_lt in Hc; flia Ha Hb Hc Hd He Hf | ].
    cbn in He.
    apply Nat.ltb_nlt in Hc; flia Ha Hb Hc Hd He Hf.
  } {
    apply Nat.leb_nle in Ha; apply Nat.leb_nle in Hb; apply Nat.leb_le in Hd.
    apply Nat.leb_le in He; apply Nat.leb_nle in Hf.
    destruct c; [ apply Nat.ltb_lt in Hc; flia Ha Hb Hc Hd He Hf | ].
    cbn in He.
    apply Nat.ltb_nlt in Hc; flia Ha Hb Hc Hd He Hf.
  } {
    apply Nat.leb_nle in Ha; apply Nat.leb_nle in Hb; apply Nat.leb_le in Hd.
    apply Nat.leb_nle in He; apply Nat.leb_le in Hf.
    destruct c; [ apply Nat.ltb_lt in Hc; flia Ha Hb Hc Hd He Hf | ].
    apply Nat.ltb_nlt in Hc; flia Ha Hb Hc Hd He Hf.
  } {
    apply Nat.leb_nle in Ha; apply Nat.leb_nle in Hb; apply Nat.leb_nle in Hd.
    apply Nat.leb_le in He; apply Nat.leb_le in Hf.
    destruct c; [ apply Nat.ltb_lt in Hc; flia Ha Hb Hc Hd He Hf | ].
    apply Nat.ltb_nlt in Hc; flia Ha Hb Hc Hd He Hf.
  } {
    apply Nat.leb_nle in Ha; apply Nat.leb_nle in Hb; apply Nat.leb_nle in Hd.
    apply Nat.leb_le in He; apply Nat.leb_nle in Hf.
    destruct c; [ apply Nat.ltb_lt in Hc; flia Ha Hb Hc Hd He Hf | ].
    apply Nat.ltb_nlt in Hc; flia Ha Hb Hc Hd He Hf.
  } {
    apply Nat.leb_nle in Ha; apply Nat.leb_nle in Hb; apply Nat.leb_nle in Hd.
    apply Nat.leb_nle in He; apply Nat.leb_le in Hf.
    destruct c; [ apply Nat.ltb_lt in Hc; flia Ha Hb Hc Hd He Hf | ].
    apply Nat.ltb_nlt in Hc; flia Ha Hb Hc Hd He Hf.
  }
} {
  do 2 rewrite <- Nat.add_assoc; f_equal.
  rewrite Nat.add_comm.
  unfold δ_lt.
  remember (l <=? j') as a eqn:Ha.
  remember (j <=? j' + Nat.b2n a) as b eqn:Hb.
  remember (j <? l) as c eqn:Hc.
  remember (l <? j) as d eqn:Hd.
  remember (j - Nat.b2n d <=? j') as e eqn:He.
  remember (l + Nat.b2n c <=? j' + Nat.b2n e) as f eqn:Hf.
  move b before a; move c before b; move d before c; move e before d.
  move f before e.
  symmetry in Ha, Hb, Hc, Hd, He, Hf.
  destruct a, b, d, e, f; cbn; try easy; exfalso. {
    apply Nat.leb_le in Ha; apply Nat.leb_le in Hb; apply Nat.leb_le in Hd.
    apply Nat.leb_le in He; apply Nat.leb_nle in Hf.
    destruct c; [ apply Nat.ltb_lt in Hc; flia Ha Hb Hc Hd He Hf | ].
    cbn in He, Hf.
    apply Nat.ltb_nlt in Hc; flia Ha Hb Hc Hd He Hf.
  } {
    apply Nat.leb_le in Ha; apply Nat.leb_le in Hb; apply Nat.leb_le in Hd.
    apply Nat.leb_nle in He; apply Nat.leb_le in Hf.
    destruct c; [ apply Nat.ltb_lt in Hc; flia Ha Hb Hc Hd He Hf | ].
    apply Nat.ltb_nlt in Hc; flia Ha Hb Hc Hd He Hf.
  } {
    apply Nat.leb_le in Ha; apply Nat.leb_le in Hb; apply Nat.leb_le in Hd.
    apply Nat.leb_nle in He; apply Nat.leb_nle in Hf.
    destruct c; [ apply Nat.ltb_lt in Hc; flia Ha Hb Hc Hd He Hf | ].
    apply Nat.ltb_nlt in Hc; flia Ha Hb Hc Hd He Hf.
  } {
    apply Nat.leb_le in Ha; apply Nat.leb_le in Hb; apply Nat.leb_nle in Hd.
    apply Nat.leb_le in He; apply Nat.leb_nle in Hf.
    destruct c; [ apply Nat.ltb_lt in Hc; flia Ha Hb Hc Hd He Hf | ].
    cbn in Hf.
    apply Nat.ltb_nlt in Hc; flia Ha Hb Hc Hd He Hf.
  } {
    apply Nat.leb_le in Ha; apply Nat.leb_le in Hb; apply Nat.leb_nle in Hd.
    apply Nat.leb_nle in He; apply Nat.leb_le in Hf.
    destruct c; [ apply Nat.ltb_lt in Hc; flia Ha Hb Hc Hd He Hf | ].
    apply Nat.ltb_nlt in Hc; flia Ha Hb Hc Hd He Hf.
  } {
    apply Nat.leb_le in Ha; apply Nat.leb_le in Hb; apply Nat.leb_nle in Hd.
    apply Nat.leb_nle in He; apply Nat.leb_nle in Hf.
    destruct c; [ apply Nat.ltb_lt in Hc; flia Ha Hb Hc Hd He Hf | ].
    apply Nat.ltb_nlt in Hc; flia Ha Hb Hc Hd He Hf.
  } {
    apply Nat.leb_le in Ha; apply Nat.leb_nle in Hb; apply Nat.leb_le in Hd.
    apply Nat.leb_le in He; apply Nat.leb_le in Hf.
    destruct c; [ apply Nat.ltb_lt in Hc; flia Ha Hb Hc Hd He Hf | ].
    apply Nat.ltb_nlt in Hc; flia Ha Hb Hc Hd He Hf.
  } {
    apply Nat.leb_le in Ha; apply Nat.leb_nle in Hb; apply Nat.leb_le in Hd.
    apply Nat.leb_nle in He; apply Nat.leb_nle in Hf.
    destruct c; [ apply Nat.ltb_lt in Hc; flia Ha Hb Hc Hd He Hf | ].
    apply Nat.ltb_nlt in Hc; cbn in Hc; flia Ha Hb Hc Hd He Hf.
  } {
    apply Nat.leb_le in Ha; apply Nat.leb_nle in Hb; apply Nat.leb_nle in Hd.
    apply Nat.leb_le in He; apply Nat.leb_le in Hf.
    destruct c; [ apply Nat.ltb_lt in Hc; flia Ha Hb Hc Hd He Hf | ].
    apply Nat.ltb_nlt in Hc; flia Ha Hb Hc Hd He Hf.
  } {
    apply Nat.leb_le in Ha; apply Nat.leb_nle in Hb; apply Nat.leb_nle in Hd.
    apply Nat.leb_nle in He; apply Nat.leb_nle in Hf.
    destruct c; [ apply Nat.ltb_lt in Hc; flia Ha Hb Hc Hd He Hf | ].
    apply Nat.ltb_nlt in Hc; flia Ha Hb Hc Hd He Hf.
  } {
    apply Nat.leb_nle in Ha; apply Nat.leb_le in Hb; apply Nat.leb_le in Hd.
    apply Nat.leb_le in He; apply Nat.leb_le in Hf.
    destruct c; [ apply Nat.ltb_lt in Hc; flia Ha Hb Hc Hd He Hf | ].
    cbn in He.
    apply Nat.ltb_nlt in Hc; flia Ha Hb Hc Hd He Hf.
  } {
    apply Nat.leb_nle in Ha; apply Nat.leb_le in Hb; apply Nat.leb_le in Hd.
    apply Nat.leb_nle in He; apply Nat.leb_nle in Hf.
    destruct c; [ apply Nat.ltb_lt in Hc; flia Ha Hb Hc Hd He Hf | ].
    cbn in Hb.
    apply Nat.ltb_nlt in Hc; flia Ha Hb Hc Hd He Hf.
  } {
    apply Nat.leb_nle in Ha; apply Nat.leb_le in Hb; apply Nat.leb_nle in Hd.
    apply Nat.leb_le in He; apply Nat.leb_le in Hf.
    destruct c; [ apply Nat.ltb_lt in Hc; flia Ha Hb Hc Hd He Hf | ].
    cbn in Hb.
    apply Nat.ltb_nlt in Hc; flia Ha Hb Hc Hd He Hf.
  } {
    apply Nat.leb_nle in Ha; apply Nat.leb_le in Hb; apply Nat.leb_nle in Hd.
    apply Nat.leb_nle in He; apply Nat.leb_nle in Hf.
    destruct c; [ apply Nat.ltb_lt in Hc; flia Ha Hb Hc Hd He Hf | ].
    apply Nat.ltb_nlt in Hc; flia Ha Hb Hc Hd He Hf.
  } {
    apply Nat.leb_nle in Ha; apply Nat.leb_nle in Hb; apply Nat.leb_le in Hd.
    apply Nat.leb_le in He; apply Nat.leb_le in Hf.
    destruct c; [ apply Nat.ltb_lt in Hc; flia Ha Hb Hc Hd He Hf | ].
    cbn in He.
    apply Nat.ltb_nlt in Hc; flia Ha Hb Hc Hd He Hf.
  } {
    apply Nat.leb_nle in Ha; apply Nat.leb_nle in Hb; apply Nat.leb_le in Hd.
    apply Nat.leb_le in He; apply Nat.leb_nle in Hf.
    destruct c; [ apply Nat.ltb_lt in Hc; flia Ha Hb Hc Hd He Hf | ].
    cbn in He.
    apply Nat.ltb_nlt in Hc; flia Ha Hb Hc Hd He Hf.
  } {
    apply Nat.leb_nle in Ha; apply Nat.leb_nle in Hb; apply Nat.leb_le in Hd.
    apply Nat.leb_nle in He; apply Nat.leb_le in Hf.
    destruct c; [ apply Nat.ltb_lt in Hc; flia Ha Hb Hc Hd He Hf | ].
    apply Nat.ltb_nlt in Hc; flia Ha Hb Hc Hd He Hf.
  } {
    apply Nat.leb_nle in Ha; apply Nat.leb_nle in Hb; apply Nat.leb_nle in Hd.
    apply Nat.leb_le in He; apply Nat.leb_le in Hf.
    destruct c; [ apply Nat.ltb_lt in Hc; flia Ha Hb Hc Hd He Hf | ].
    apply Nat.ltb_nlt in Hc; flia Ha Hb Hc Hd He Hf.
  } {
    apply Nat.leb_nle in Ha; apply Nat.leb_nle in Hb; apply Nat.leb_nle in Hd.
    apply Nat.leb_le in He; apply Nat.leb_nle in Hf.
    destruct c; [ apply Nat.ltb_lt in Hc; flia Ha Hb Hc Hd He Hf | ].
    apply Nat.ltb_nlt in Hc; flia Ha Hb Hc Hd He Hf.
  } {
    apply Nat.leb_nle in Ha; apply Nat.leb_nle in Hb; apply Nat.leb_nle in Hd.
    apply Nat.leb_nle in He; apply Nat.leb_le in Hf.
    destruct c; [ apply Nat.ltb_lt in Hc; flia Ha Hb Hc Hd He Hf | ].
    apply Nat.ltb_nlt in Hc; flia Ha Hb Hc Hd He Hf.
  }
}
Qed.

Definition swap_in_permut n i j k :=
  vect_swap_elem (vect_el (mk_canon_sym_gr_vect' n) k) i j.

(* comatrix *)

Definition comatrix {n} (M : matrix n n T) : matrix n n T :=
  {| mat_el i j := (minus_one_pow (i + j) * determinant (subm M i j))%F |}.

Theorem mat_swap_same_rows : ∀ n (M : matrix n n T) i,
  mat_swap_rows i i M = M.
Proof.
intros.
rename i into k.
apply matrix_eq.
intros i j Hi Hj.
unfold mat_swap_rows; cbn.
destruct (Nat.eq_dec i k); [ now subst i | easy ].
Qed.

Theorem mat_swap_rows_comm : ∀ n (M : matrix n n T) p q,
  mat_swap_rows p q M = mat_swap_rows q p M.
Proof.
intros.
apply matrix_eq.
intros i j Hi Hj; cbn.
now destruct (Nat.eq_dec i p), (Nat.eq_dec i q); subst.
Qed.

Theorem subm_mat_swap_rows_lt : ∀ n (M : matrix n n T) p q r j,
  p < r
  → q < r
  → subm (mat_swap_rows p q M) r j = mat_swap_rows p q (subm M r j).
Proof.
intros * Hp Hq.
apply matrix_eq.
rename j into k.
intros i j Hi Hj; cbn.
destruct (Nat.eq_dec (i + Nat.b2n (r <=? i)) p) as [H1| H1]. {
  remember (r <=? i) as b eqn:Hb1; symmetry in Hb1.
  destruct b; cbn in H1. {
    apply Nat.leb_le in Hb1.
    flia Hp Hb1 H1.
  }
  apply Nat.leb_nle in Hb1.
  rewrite Nat.add_0_r in H1; subst i; clear Hb1.
  rewrite <- if_eqb_eq_dec, Nat.eqb_refl.
  remember (r <=? q) as b eqn:Hb1; symmetry in Hb1.
  destruct b; cbn. {
    apply Nat.leb_le in Hb1; flia Hq Hb1.
  }
  now rewrite Nat.add_0_r.
}
destruct (Nat.eq_dec (i + Nat.b2n (r <=? i)) q) as [H2| H2]. {
  remember (r <=? i) as b eqn:Hb1; symmetry in Hb1.
  destruct b; cbn in H2. {
    apply Nat.leb_le in Hb1.
    flia Hq Hb1 H2.
  }
  cbn in H1; rewrite Nat.add_0_r in H1, H2.
  subst i; clear Hb1.
  rewrite <- (if_eqb_eq_dec q q), Nat.eqb_refl.
  destruct (Nat.eq_dec q p) as [H| H]; [ easy | clear H ].
  remember (r <=? p) as b eqn:Hb1; symmetry in Hb1.
  destruct b; [ | now rewrite Nat.add_0_r ].
  apply Nat.leb_le in Hb1.
  flia Hp Hb1.
}
destruct (Nat.eq_dec i p) as [H3| H3]. {
  subst i.
  apply Nat.nle_gt, Nat.leb_nle in Hp.
  rewrite Hp in H1; cbn in H1.
  now rewrite Nat.add_0_r in H1.
}
destruct (Nat.eq_dec i q) as [H4| H4]. {
  subst i.
  apply Nat.nle_gt, Nat.leb_nle in Hq.
  rewrite Hq in H2; cbn in H2.
  now rewrite Nat.add_0_r in H2.
}
easy.
Qed.

Theorem mat_el_mat_swap_rows : ∀ n (M : matrix n n T) p q j,
  mat_el (mat_swap_rows p q M) q j = mat_el M p j.
Proof.
intros.
cbn.
destruct (Nat.eq_dec q p) as [Hqp| Hqp]; [ now subst q | ].
now rewrite <- if_eqb_eq_dec, Nat.eqb_refl.
Qed.

Theorem mat_el_circ_rot_rows_succ_1 : ∀ n (M : matrix n n T) i j p q,
  p + q < i
  → mat_el M i j =
    mat_el (fold_left (λ M' k, mat_swap_rows k (k + 1) M') (seq p q) M)
      i j.
Proof.
intros * Hpi.
induction q; [ easy | ].
rewrite seq_S; cbn.
rewrite fold_left_app; cbn.
destruct (Nat.eq_dec i (p + q)) as [Hip| Hip]; [ flia Hpi Hip | ].
destruct (Nat.eq_dec i (p + q + 1)) as [Hip1| Hip1]; [ flia Hpi Hip1 | ].
apply IHq.
flia Hpi Hip.
Qed.

Theorem mat_el_circ_rot_rows : ∀ n (M : matrix n n T) i j,
  mat_el M 0 j =
    mat_el (fold_left (λ M' k, mat_swap_rows k (k + 1) M') (seq 0 i) M) i j.
Proof.
intros.
induction i; [ easy | ].
rewrite seq_S.
rewrite fold_left_app.
cbn - [ mat_swap_rows ].
rewrite Nat.add_1_r.
rewrite mat_el_mat_swap_rows.
apply IHi.
Qed.

Theorem mat_el_circ_rot_rows_outside : ∀ n (M : matrix n n T) i j p q,
  i < p
  → mat_el M i j =
    mat_el (fold_left (λ M' k, mat_swap_rows k (k + 1) M')
      (seq p q) M) i j.
Proof.
intros * Hip.
induction q; [ easy | ].
rewrite seq_S; cbn.
rewrite fold_left_app; cbn.
destruct (Nat.eq_dec i (p + q)) as [Hipq| Hipq]; [ flia Hip Hipq | ].
destruct (Nat.eq_dec i (p + q + 1)) as [Hip1| Hip1]; [ flia Hip Hip1 | ].
apply IHq.
Qed.

Theorem mat_el_circ_rot_rows_succ : ∀ n (M : matrix n n T) i j p,
  i + 1 ≠ p
  → mat_el M (i + 1) j =
    mat_el
      (fold_left (λ (M' : matrix n n T) (k : nat), mat_swap_rows k (k + 1) M')
         (seq 0 (p - 1)) M) (i + Nat.b2n (p <=? i)) j.
Proof.
intros * Hi1p.
destruct (le_dec p i) as [Hpi| Hpi]. {
  apply Nat.leb_le in Hpi; rewrite Hpi.
  apply mat_el_circ_rot_rows_succ_1.
  apply Nat.leb_le in Hpi; cbn; flia Hpi.
}
apply Nat.leb_nle in Hpi; rewrite Hpi; cbn.
rewrite Nat.add_0_r.
apply Nat.leb_nle in Hpi.
apply Nat.nle_gt in Hpi.
replace (p - 1) with (i + (p - i - 1)) by flia Hpi.
rewrite seq_app, fold_left_app; cbn.
rewrite mat_el_circ_rot_rows_succ_1 with (p := 0) (q := i); [ | flia ].
remember (fold_left (λ M' k, mat_swap_rows k (k + 1) M') (seq 0 i) M)
  as A eqn:HA.
replace (p - i - 1) with (S (p - i - 2)) by flia Hi1p Hpi.
rewrite <- cons_seq; cbn.
rewrite <- mat_el_mat_swap_rows with (q := i).
rewrite mat_swap_rows_comm.
remember (mat_swap_rows i (i + 1) A) as B eqn:HB.
apply mat_el_circ_rot_rows_outside; flia.
Qed.

Theorem subm_mat_swap_rows_succ_succ : ∀ n (M : matrix n n T) i j,
  subm (mat_swap_rows (i + 1) (i + 2) (mat_swap_rows i (i + 1) M)) (S i) j =
  subm (mat_swap_rows i (i + 1) M) (S (S i)) j.
Proof.
intros.
apply matrix_eq.
rename i into p; rename j into q.
intros i j Hi Hj.
cbn - [ "<=?" ].
destruct (Nat.eq_dec (p + 2) p) as [H| H]; [ flia H | clear H ].
destruct (Nat.eq_dec (p + 2) (p + 1)) as [H| H]; [ flia H | clear H ].
destruct (Nat.eq_dec (p + 1) (p + 1)) as [H| H]; [ clear H | easy ].
destruct (Nat.eq_dec (p + 1) p) as [H| H]; [ flia H | clear H ].
destruct (le_dec (S p) i) as [Hspi| Hspi]. {
  apply Nat.leb_le in Hspi; rewrite Hspi; cbn - [ "<=?" ].
  apply Nat.leb_le in Hspi.
  destruct (Nat.eq_dec (i + 1) (p + 1)) as [Hip| Hip]; [ flia Hspi Hip | ].
  destruct (Nat.eq_dec (i + 1) (p + 2)) as [Hip2| Hip2]. {
    destruct (le_dec (S (S p)) i) as [Hsspi| Hsspi]; [ flia Hsspi Hip2 | ].
    apply Nat.leb_nle in Hsspi; rewrite Hsspi; cbn.
    rewrite Nat.add_0_r.
    destruct (Nat.eq_dec i p) as [H| H]; [ flia H Hip2 | clear H ].
    destruct (Nat.eq_dec i (p + 1)) as [H| H]; [ clear H | flia Hip2 H ].
    easy.
  }
  destruct (Nat.eq_dec (i + 1) p) as [H| H]; [ flia Hspi H | clear H ].
  destruct (le_dec (S (S p)) i) as [Hsspi| Hsspi]. {
    apply Nat.leb_le in Hsspi; rewrite Hsspi; cbn.
    apply Nat.leb_le in Hsspi.
    destruct (Nat.eq_dec (i + 1) p) as [H| H]; [ flia H Hsspi | clear H ].
    destruct (Nat.eq_dec (i + 1) (p + 1)) as [H| H]; [ flia H Hspi | easy ].
  }
  flia Hspi Hip2 Hsspi.
}
apply Nat.leb_nle in Hspi; rewrite Hspi; cbn - [ "<=?" ].
apply Nat.leb_nle in Hspi.
rewrite Nat.add_0_r.
destruct (Nat.eq_dec i (p + 1)) as [H| H]; [ flia H Hspi | clear H ].
destruct (Nat.eq_dec i (p + 2)) as [H| H]; [ flia H Hspi | clear H ].
destruct (Nat.eq_dec i p) as [Hip| Hip]. {
  subst p.
  destruct (le_dec (S (S i)) i) as [Hssi| Hssi]; [ flia Hssi | ].
  apply Nat.leb_nle in Hssi; rewrite Hssi; cbn.
  rewrite Nat.add_0_r.
  now rewrite <- if_eqb_eq_dec, Nat.eqb_refl.
}
destruct (le_dec (S (S p)) i) as [Hsspi| Hsspi]; [ flia Hspi Hsspi | ].
apply Nat.leb_nle in Hsspi; rewrite Hsspi; cbn.
apply Nat.leb_nle in Hsspi.
rewrite Nat.add_0_r.
destruct (Nat.eq_dec i p) as [H| H]; [ flia H Hip | clear H ].
destruct (Nat.eq_dec i (p + 1)) as [H| H]; [ flia H Hspi | easy ].
Qed.

Theorem subm_mat_swap_rows_circ : ∀ n (M : matrix n n T) p q,
  subm (mat_swap_rows 0 p M) 0 q =
  subm (fold_left (λ M' k, mat_swap_rows k (k + 1) M') (seq 0 (p - 1)) M) p q.
Proof.
intros.
apply matrix_eq.
intros i j Hi Hj.
cbn.
destruct (Nat.eq_dec (i + 1) 0) as [H| H]; [ flia H | clear H ].
remember (j + Nat.b2n (q <=? j)) as k eqn:Hk.
assert (H : k < n). {
  destruct (le_dec q j) as [Hqj| Hqj]. {
    apply Nat.leb_le in Hqj; rewrite Hqj in Hk.
    cbn in Hk.
    flia Hj Hk.
  } {
    apply Nat.leb_nle in Hqj; rewrite Hqj in Hk.
    cbn in Hk.
    flia Hj Hk.
  }
}
clear q j Hj Hk.
rename k into j; move j before i.
rename H into Hj.
destruct (Nat.eq_dec (i + 1) p) as [Hip| Hip]. {
  subst p.
  rewrite Nat.add_sub.
  assert (H : ¬ (i + 1 ≤ i)) by flia.
  apply Nat.leb_nle in H; rewrite H; clear H; cbn.
  rewrite Nat.add_0_r.
  apply mat_el_circ_rot_rows.
} {
  now apply mat_el_circ_rot_rows_succ.
}
Qed.

Theorem mat_swap_rows_fold_left : ∀ n (M : matrix n n T) i,
  mat_swap_rows i (S i)
    (fold_left (λ M' k, mat_swap_rows k (k + 1) M') (seq 0 i) M) =
   fold_left (λ M' k, mat_swap_rows k (k + 1) M') (seq 0 (S i)) M.
Proof.
intros.
rewrite seq_S; cbn.
rewrite fold_left_app; cbn.
now rewrite Nat.add_1_r.
Qed.

Theorem subm_fold_left_lt : ∀ n (M : matrix n n T) i j m,
  m < i
  → subm
      (fold_left (λ M' k, mat_swap_rows k (k + 1) M')
         (seq 0 m) M) i j =
    fold_left
      (λ M' k, mat_swap_rows k (k + 1) M')
      (seq 0 m) (subm M i j).
Proof.
intros * Hmi.
revert i Hmi.
induction m; intros; [ easy | ].
rewrite seq_S; cbn.
do 2 rewrite fold_left_app; cbn.
rewrite <- IHm; [ | flia Hmi ].
apply subm_mat_swap_rows_lt; flia Hmi.
Qed.

Theorem determinant_circular_shift_rows :
  rngl_is_comm = true →
  rngl_has_opp = true →
  rngl_has_inv = true →
  rngl_is_integral = true →
  rngl_has_1_neq_0 = true →
  rngl_has_dec_eq = true →
  rngl_characteristic = 0 →
  ∀ n (M : matrix n n T) i,
  i < n
  → determinant (fold_left (λ M' k, mat_swap_rows k (k + 1) M') (seq 0 i) M) =
    (minus_one_pow i * determinant M)%F.
Proof.
intros Hic Hop Hiv Hit H10 Hde Hch * Hin.
revert M.
induction i; intros; [ now cbn; rewrite rngl_mul_1_l | ].
assert (H : i < n) by flia Hin.
specialize (IHi H); clear H.
rewrite seq_S; cbn.
rewrite fold_left_app; cbn.
rewrite determinant_alternating; try easy; [ | flia | flia Hin | flia Hin ].
rewrite IHi.
rewrite minus_one_pow_succ; [ | easy ].
now rewrite rngl_mul_opp_l.
Qed.

Theorem determinant_subm_mat_swap_rows_0_i :
  rngl_is_comm = true →
  rngl_has_opp = true →
  rngl_has_inv = true →
  rngl_is_integral = true →
  rngl_has_1_neq_0 = true →
  rngl_has_dec_eq = true →
  rngl_characteristic = 0 →
  ∀ n (M : matrix n n T) i j,
  0 < i < n
  → determinant (subm (mat_swap_rows 0 i M) 0 j) =
    (- minus_one_pow i * determinant (subm M i j))%F.
Proof.
intros Hic Hop Hiv Hit H10 Hde Hch * (Hiz, Hin).
rewrite subm_mat_swap_rows_circ.
destruct i; [ flia Hiz | ].
rewrite minus_one_pow_succ; [ | easy ].
rewrite rngl_opp_involutive; [ | easy ].
rewrite Nat.sub_succ, Nat.sub_0_r.
rewrite subm_fold_left_lt; [ | flia ].
remember (subm M (S i) j) as A eqn:HA.
apply determinant_circular_shift_rows; try easy.
flia Hin.
Qed.

(* Laplace formulas *)

Theorem laplace_formula_on_rows :
  rngl_is_comm = true →
  rngl_has_opp = true →
  rngl_has_inv = true →
  rngl_is_integral = true →
  rngl_has_1_neq_0 = true →
  rngl_has_dec_eq = true →
  rngl_characteristic = 0 →
  ∀ n (M : matrix n n T) i,
  i < n
  → determinant M = ∑ (j = 0, n - 1), mat_el M i j * mat_el (comatrix M) i j.
Proof.
intros Hic Hop Hin Hit H10 Hde Hch * Hlin.
destruct (Nat.eq_dec i 0) as [Hiz| Hiz]. {
  subst i.
  destruct n; [ easy | cbn ].
  rewrite Nat.sub_0_r at 1.
  symmetry.
  apply rngl_summation_eq_compat.
  intros j Hj.
  rewrite rngl_mul_comm; [ | easy ].
  now rewrite rngl_mul_mul_swap.
}
move i before n.
move Hiz after Hlin.
destruct n; [ easy | cbn ].
rewrite Nat.sub_0_r at 1.
symmetry.
erewrite rngl_summation_eq_compat. 2: {
  intros j Hj.
  rewrite rngl_mul_comm; [ | easy ].
  rewrite rngl_mul_mul_swap; [ | easy ].
  easy.
}
cbn.
rename i into p.
remember (mat_swap_rows 0 p M) as M'.
erewrite rngl_summation_eq_compat. 2: {
  intros j Hj.
  rewrite rngl_mul_mul_swap; [ | easy ].
  rewrite Nat.add_comm.
  rewrite minus_one_pow_add_r; [ | easy | easy ].
  do 2 rewrite <- rngl_mul_assoc.
  rewrite rngl_mul_comm; [ | easy ].
  rewrite rngl_mul_assoc.
  remember (minus_one_pow p * _)%F as x eqn:Hx.
  rewrite <- rngl_opp_involutive in Hx; [ | easy ].
  rewrite <- rngl_mul_opp_l in Hx; [ | easy ].
  specialize determinant_subm_mat_swap_rows_0_i as H1.
  specialize (H1 Hic Hop Hin Hit H10 Hde Hch).
  specialize (H1 _ M p j).
  cbn in H1.
  rewrite <- H1 in Hx; [ | flia Hiz Hlin ].
  subst x; clear H1.
  rewrite rngl_mul_comm; [ | easy ].
  rewrite rngl_mul_assoc, rngl_mul_mul_swap; [ | easy ].
  replace (mat_el M p j) with (mat_el (mat_swap_rows 0 p M) 0 j) by easy.
  rewrite <- HeqM'.
  rewrite rngl_mul_opp_r; [ | easy ].
  easy.
}
cbn.
rewrite <- rngl_opp_summation; [ | easy | easy ].
do 2 rewrite <- determinant_succ.
subst M'.
rewrite <- rngl_opp_involutive; [ | easy ].
f_equal.
apply determinant_alternating; try easy; [ flia Hiz | flia ].
Qed.

Theorem rngl_product_fun_permut :
  rngl_is_comm = true →
  ∀ n (σ : vector n nat) (f : nat → T),
  n ≠ 0
  → is_permut_vect σ
  → ∏ (i = 0, n - 1), f (vect_el σ i) = ∏ (i = 0, n - 1), f i.
Proof.
intros Hic * Hnz Hσ.
destruct n; [ easy | clear Hnz ].
rewrite Nat.sub_succ, Nat.sub_0_r.
destruct Hσ as (H1, H2).
induction n; cbn. {
  rewrite rngl_product_only_one.
  rewrite rngl_product_only_one.
  specialize (H1 0 Nat.lt_0_1) as H3.
  apply Nat.lt_1_r in H3.
  now rewrite H3.
}
set (g := λ i, if lt_dec i (vect_el (permut_inv σ) (S n)) then i else i + 1).
set (σ' := mk_vect (S n) (λ i, vect_el σ (g i))).
specialize (IHn σ').
assert (H : ∀ i : nat, i < S n → vect_el σ' i < S n). {
  intros i Hi.
  unfold σ'; cbn.
  unfold g; cbn.
  destruct (Nat.eq_dec (vect_el σ (S n)) (S n)) as [Hσn| Hσn]. {
    destruct (lt_dec i (S n)) as [H| H]; [ clear H | flia Hi H ].
    specialize (H1 i).
    assert (H : i < S (S n)) by flia Hi.
    specialize (H1 H); clear H.
    destruct (Nat.eq_dec (vect_el σ i) (S n)) as [Hσ| Hσ]; [ | flia H1 Hσ ].
    rewrite <- Hσn in Hσ.
    apply H2 in Hσ; [ flia Hi Hσ | flia Hi | flia ].
  }
  destruct (Nat.eq_dec (vect_el σ n) (S n)) as [Hσs| Hσs]. {
    destruct (lt_dec i n) as [Hin| Hin]. {
      specialize (H1 i).
      assert (H : i < S (S n)) by flia Hi.
      specialize (H1 H); clear H.
      destruct (Nat.eq_dec (vect_el σ i) (S n)) as [Hσ| Hσ]; [ | flia H1 Hσ ].
      rewrite <- Hσs in Hσ.
      apply H2 in Hσ; [ flia Hin Hσ | flia Hi | flia ].
    }
    replace i with n by flia Hi Hin.
    rewrite Nat.add_1_r.
    specialize (H1 (S n) (Nat.lt_succ_diag_r (S n))).
    flia H1 Hσn.
  }
  destruct (lt_dec i (permut_fun_inv (vect_el σ) n (S n))) as [H3| H3]. {
    destruct (Nat.eq_dec (vect_el σ i) (S n)) as [H4| H4]. {
      exfalso.
      rewrite <- H4 in H3 at 2.
      rewrite permut_fun_inv_fun' in H3; [ flia H3 | | ]. 2: {
        destruct (Nat.eq_dec i n) as [H5| H5]; [ now subst i | ].
        flia Hi H5.
      }
      intros j k Hj Hk Hjk.
      apply H2; [ flia Hj | flia Hk | easy ].
    }
    specialize (H1 i).
    assert (H : i < S (S n)) by flia Hi.
    specialize (H1 H); clear H.
    flia H1 H4.
  }
  rewrite Nat.add_1_r.
  specialize (H1 (S i)).
  assert (H : S i < S (S n)) by flia Hi.
  specialize (H1 H); clear H.
  destruct (Nat.eq_dec (vect_el σ (S i)) (S n)) as [H4| H4]. {
    exfalso.
    rewrite <- H4 in H3 at 2.
    rewrite permut_fun_inv_fun' in H3; [ flia H3 | | ]. 2: {
      destruct (Nat.eq_dec i n) as [H5| H5]; [ now subst i | ].
      destruct (Nat.eq_dec (S i) n) as [H6| H6]. {
        now rewrite H6 in H4.
      }
      flia Hi H5 H6.
    }
    intros j k Hj Hk Hjk.
    apply H2; [ flia Hj | flia Hk | easy ].
  }
  flia H1 H4.
}
specialize (IHn H); clear H.
assert (H : ∀ i j, i < S n → j < S n → vect_el σ' i = vect_el σ' j → i = j). {
  intros i j Hi Hj Hij; cbn in Hij.
  unfold g in Hij; cbn in Hij.
  destruct (Nat.eq_dec (vect_el σ (S n)) (S n)) as [H3| H3]. {
    destruct (lt_dec i (S n)) as [H| H]; [ clear H | flia Hi H ].
    destruct (lt_dec j (S n)) as [H| H]; [ clear H | flia Hj H ].
    apply H2; [ flia Hi | flia Hj | easy ].
  }
  destruct (Nat.eq_dec (vect_el σ n) (S n)) as [H4| H4]. {
    destruct (lt_dec i n) as [Hin| Hin]. {
      destruct (lt_dec j n) as [Hjn| Hjn]. {
        apply H2; [ flia Hi | flia Hj | easy ].
      }
      replace j with n in Hij by flia Hj Hjn.
      rewrite Nat.add_1_r in Hij.
      rewrite <- Hij in H3.
      apply H2 in Hij; [ flia Hin Hij | flia Hi | flia ].
    }
    replace i with n in Hij |-* by flia Hi Hin.
    rewrite Nat.add_1_r in Hij.
    destruct (lt_dec j n) as [Hjn| Hjn]. {
      apply H2 in Hij; [ flia Hjn Hij | flia | flia Hjn ].
    }
    now replace j with n by flia Hj Hjn.
  }
  remember (permut_fun_inv (vect_el σ) n (S n)) as k eqn:Hk.
  destruct (lt_dec i k) as [H5| H5]. {
    destruct (lt_dec j k) as [H6| H6]. {
      apply H2; [ flia Hi | flia Hj | easy ].
    }
    apply H2 in Hij; [ | flia Hi | flia Hj ].
    flia H5 H6 Hij.
  }
  destruct (lt_dec j k) as [H6| H6]. {
    apply H2 in Hij; [ | flia Hi | flia Hj ].
    flia H5 H6 Hij.
  }
  apply H2 in Hij; [ | flia Hi | flia Hj ].
  flia Hij.
}
specialize (IHn H); clear H.
remember (vect_el (permut_inv σ) (S n)) as k eqn:Hk.
destruct (Nat.eq_dec k (S n)) as [Hksn| Hksn]. {
  erewrite rngl_product_eq_compat in IHn. 2: {
    intros i Hi.
    unfold σ', g; cbn.
    destruct (lt_dec i k) as [H| H]; [ easy | flia Hksn Hi H ].
  }
  cbn in IHn.
  rewrite rngl_product_split_last; [ | flia ].
  rewrite rngl_product_succ_succ' with (g0 := λ i, f (vect_el σ i)).
  symmetry.
  rewrite rngl_product_split_last; [ | flia ].
  rewrite rngl_product_succ_succ'.
  symmetry.
  rewrite IHn; f_equal; f_equal.
  rewrite <- Hksn at 2.
  rewrite Hk.
  unfold permut_inv.
  cbn - [ permut_fun_inv ].
  rewrite fun_permut_fun_inv; [ easy | easy | flia ].
}
specialize permut_inv_is_permut as H3.
specialize (H3 _ σ).
assert (H : is_permut_vect σ) by easy.
specialize (H3 H); clear H.
rewrite rngl_product_split with (j := k) in IHn. 2: {
  split; [ flia | ].
  destruct H3 as (H3, H4).
  apply -> Nat.succ_le_mono.
  specialize (H3 (S n)) as H5.
  assert (H : S n < S (S n)) by flia.
  specialize (H5 H); clear H.
  rewrite <- Hk in H5.
  flia Hksn H5.
}
rewrite rngl_product_split_last in IHn; [ | flia ].
destruct (Nat.eq_dec k 0) as [Hkz| Hkz]. {
  move Hkz at top; subst k.
  rewrite rngl_product_empty in IHn; [ | flia ].
  rewrite rngl_mul_1_l, Nat.add_0_l in IHn.
  unfold σ' in IHn at 1.
  cbn in IHn.
  symmetry.
  rewrite rngl_product_split_last; [ | flia ].
  rewrite rngl_product_succ_succ'.
  rewrite <- IHn.
  symmetry.
  rewrite rngl_product_split_first; [ | flia ].
  rewrite Hk at 1.
  unfold permut_inv.
  cbn - [ permut_fun_inv ].
  rewrite fun_permut_fun_inv; [ | easy | flia ].
  rewrite rngl_mul_comm; [ | easy ].
  f_equal.
  rewrite rngl_product_succ_succ.
  rewrite rngl_product_split_first; [ | flia ].
  f_equal.
  apply rngl_product_eq_compat.
  now intros; rewrite Nat.add_1_r.
}
erewrite rngl_product_eq_compat in IHn. 2: {
  intros i Hi.
  unfold σ'; cbn.
  unfold g.
  destruct (lt_dec (i - 1) k) as [H| H]; [ | flia Hi H ].
  easy.
}
cbn in IHn.
destruct k; [ easy | clear Hkz ].
rewrite rngl_product_succ_succ' with (g0 := λ i, f (vect_el σ i)) in IHn.
unfold g in IHn.
destruct (lt_dec (S k) (S k)) as [H| H]; [ flia H | clear H ].
erewrite rngl_product_eq_compat with (b := S k + 1) in IHn. 2: {
  intros i Hi.
  destruct (lt_dec i (S k)) as [H| H]; [ flia Hi H | easy ].
}
cbn in IHn.
rewrite rngl_mul_mul_swap in IHn; [ | easy ].
symmetry.
rewrite rngl_product_split_last; [ | flia ].
rewrite rngl_product_succ_succ'.
rewrite <- IHn.
symmetry.
rewrite rngl_product_split with (j := k). 2: {
  split; [ flia | ].
  destruct H3 as (H3, H4).
  rewrite Hk.
  apply Nat.lt_le_incl.
  apply H3; flia.
}
do 2 rewrite <- rngl_mul_assoc.
f_equal.
rewrite rngl_product_split_last. 2: {
  rewrite Nat.add_1_r.
  rewrite Hk.
  destruct H3 as (H3, H4).
  apply Nat.lt_succ_r.
  apply H3; flia.
}
rewrite rngl_product_succ_succ' with (g0 := λ i, f (vect_el σ i)).
rewrite rngl_product_split_first. 2: {
  rewrite Nat.add_1_r.
  rewrite Hk.
  destruct H3 as (H3, H4).
  specialize (H3 (S n) (Nat.lt_succ_diag_r _)).
  destruct (Nat.eq_dec (vect_el (permut_inv σ) (S n)) (S n)) as [H5| H5]. {
    flia Hk Hksn H5.
  }
  flia H3 H5.
}
replace (vect_el σ (k + 1)) with (S n). 2: {
  rewrite Nat.add_1_r.
  rewrite Hk.
  unfold permut_inv.
  cbn - [ permut_fun_inv ].
  rewrite fun_permut_fun_inv; [ easy | easy | flia ].
}
rewrite <- rngl_mul_assoc.
rewrite rngl_mul_comm; [ | easy ].
rewrite rngl_mul_assoc.
f_equal.
destruct (Nat.eq_dec (vect_el (permut_inv σ) (S n)) n) as [H7| H7]. {
  rewrite H7 in Hk.
  rewrite Nat.add_1_r.
  rewrite Hk.
  rewrite rngl_product_empty; [ | flia ].
  rewrite rngl_product_empty; [ | flia ].
  easy.
}
assert (Hkn : S (k + 1) ≤ n). {
  rewrite Nat.add_1_r.
  rewrite Hk.
  destruct H3 as (H3, H4).
  apply Nat.le_succ_l.
  specialize (H3 (S n) (Nat.lt_succ_diag_r _)) as H5.
  destruct (Nat.eq_dec (vect_el (permut_inv σ) (S n)) (S n)) as [H6| H6]. {
    flia Hk Hksn H6.
  }
  flia H5 H6 H7.
}
rewrite rngl_product_split_first; [ | easy ].
rewrite <- rngl_mul_assoc.
rewrite rngl_mul_comm; [ | easy ].
f_equal.
symmetry.
rewrite rngl_product_split_last; [ | easy ].
do 2 rewrite Nat.add_1_r.
f_equal.
apply rngl_product_eq_compat.
intros i Hi.
rewrite Nat.sub_add; [ easy | flia Hi ].
Qed.

Theorem permut_comp_assoc : ∀ n (f g h : vector n nat),
  (f ° (g ° h) = (f ° g) ° h)%F.
Proof. easy. Qed.

Theorem comp_permut_inv_r : ∀ n f,
  is_permut_vect f
  → (f ° permut_inv f = mk_vect n id).
Proof.
intros * Hf.
apply vector_eq; cbn.
intros i Hi.
unfold comp.
now apply fun_permut_fun_inv.
Qed.

Theorem comp_id_l : ∀ A B (f : A → B), comp id f = f.
Proof. easy. Qed.

Fixpoint vect_eqb_loop A n (eqb : A → A → bool) (u v : vector n A) i :=
  match i with
  | 0 => true
  | S i' =>
      if eqb (vect_el u i') (vect_el v i') then vect_eqb_loop eqb u v i'
      else false
  end.

Definition vect_eqb A n (eqb : A → A → bool) (u v : vector n A) : bool :=
  vect_eqb_loop eqb u v n.

Fixpoint vect_find_loop A n (f : A → bool) (u : vector n A) i :=
  match i with
  | 0 => 0
  | S i' => if f (vect_el u i') then i else vect_find_loop f u i'
  end.

(* 0 => not found ; S n => found at position n *)
Definition vect_find A n (f : A → bool) (u : vector n A) : nat :=
  vect_find_loop f u n.

Theorem sym_gr_surj : ∀ n (σ : vector n! _) p,
  n ≠ 0
  → is_sym_gr_vect σ
  → is_permut_vect p
  → { i | i < n! ∧ vect_el σ i = p }.
Proof.
intros * Hnz Hσ Hp.
destruct Hσ as (H1, H2).
destruct Hp as (H3, H4).
exists (vect_find (vect_eqb Nat.eqb p) σ - 1).
split. {
  unfold vect_find.
...
Print is_sym_gr.
Print Module Pigeonhole.
Check find.
Print vector_eq.
Search (vector _ _ → vector _ _ → bool).
Search (vector _ _ → vector _ _ → _).
...
Check (permut_fun_inv (λ k, vect_el (vect_el σ k) n)).
Print permut_fun_inv.
Check (λ k, vect_el (vect_el σ k)).
Print permut_fun_inv.
Print permut_fun_inv'.
Print is_permut_fun.
Search permut_fun_inv.
...
unfold is_permut in H2.
Print permut_fun_inv'.
permut_fun = vect_el σ
exists (permut_fun_inv n
...

Theorem glop : ∀ n (σ σ' : vector n! _),
  n ≠ 0
  → is_sym_gr σ
  → is_sym_gr σ'
  → { σ'' : vector n! _ |
      is_sym_gr σ'' ∧ ∀ i, vect_el σ i ° vect_el σ'' i = vect_el σ' i }.
Proof.
intros * Hnz Hσ Hσ'.
destruct Hσ as (H1, H2).
destruct Hσ' as (H3, H4).
...

Theorem fun_betw_sym_gr : ∀ n (σ σ' : vector n! _),
  n ≠ 0
  → is_sym_gr σ
  → is_sym_gr σ'
  → { f | ∀ i, i < n! → vect_el σ (f i) = vect_el σ' i }.
Proof.
intros * Hnz Hσ Hσ'.
destruct n; [ easy | clear Hnz ].
destruct Hσ as (H1, H2).
destruct Hσ' as (H3, H4).
assert (Hσp : ∀ p, is_permut p → { i | vect_el σ i = p }). {
  intros p Hp.
...
intros * Hnz Hσ Hσ'.
destruct n; [ easy | clear Hnz ].
induction n. {
  cbn.
  exists (λ i, i).
  intros i Hi.
  apply vector_eq.
  intros j Hj.
  apply Nat.lt_1_r in Hi.
  apply Nat.lt_1_r in Hj.
  subst i j.
  destruct Hσ as (H1, H2).
  destruct Hσ' as (H3, H4).
  specialize (H2 0 Nat.lt_0_1).
  destruct H2 as (H2, H2').
  specialize (H2 0 Nat.lt_0_1).
  apply Nat.lt_1_r in H2.
  specialize (H4 0 Nat.lt_0_1).
  destruct H4 as (H4, H4').
  specialize (H4 0 Nat.lt_0_1).
  apply Nat.lt_1_r in H4.
  cbn in H2, H4.
  congruence.
}
Check (mk_vect (S n)! (λ i, vect_el σ (i / (S n)!))).
assert (∀ i, i < S (S n)! → IHn (
...
specialize (IHn (mk_vect (S n)! (λ i, let j := i / (S n)! in
...
intros * Hσ Hσ'.
destruct Hσ as (H1, H2).
destruct Hσ' as (H3, H4).
...
*)

Theorem det_by_any_sym_gr :
  rngl_is_comm = true →
  rngl_has_opp = true →
  rngl_has_inv = true →
  rngl_is_integral = true →
  rngl_has_1_neq_0 = true →
  rngl_has_dec_eq = true →
  rngl_characteristic = 0 →
  ∀ n (M : matrix n n T) (σ : vector n! (vector n nat)),
  n ≠ 0
  → is_sym_gr σ
  → determinant M =
    ∑ (k = 0, n! - 1),
    ε (vect_el σ k) *
    ∏ (i = 1, n), mat_el M (i - 1) (vect_el (vect_el σ k) (i - 1)).
Proof.
intros Hic Hop Hiv Hit H10 Hed Hch * Hnz Hσ.
rewrite det_is_det_by_canon_permut; try easy.
unfold determinant'.
remember (mk_canon_sym_gr n) as σ' eqn:Hσ'.
specialize rngl_summation_change_var as H1.
specialize (H1 nat 0 (n! - 1)).
set
  (f := λ k,
   (ε (vect_el σ' k) *
    ∏ (i = 1, n), mat_el M (i - 1) (vect_el (vect_el σ' k) (i - 1)))%F).
specialize (H1 f).
unfold f in H1.
...
specialize fun_betw_sym_gr as H2.
specialize (H2 n (mk_canon_sym_gr n) σ).
specialize (H2 Hnz (canon_sym_gr_prop n) Hσ).
rewrite <- Hσ' in H2.
destruct H2 as (g, Hg).
...
assert (Hh : ∃ h, ∀ i, i < n! → g (h i) = i).
admit.
destruct Hh as (h, Hh).
rewrite H1 with (g := g) (h := h).
...
assert (H : ∀ i, i < n! → h (g i) = i). {
  intros i Hi.
  destruct Hσ as (H2, H3).
...
assert (H : ∀ i, i < n! → h i < n!). {
  intros i Hi.
...
rngl_summation_list_permut:
  ∀ (T : Type) (ro : ring_like_op T),
    ring_like_prop T
    → ∀ (A : Type) (l1 l2 : list A) (f : A → T), Permutation l1 l2 → ∑ (i ∈ l1), f i = ∑ (i ∈ l2), f i
...
rngl_summation_list_change_var:
  ∀ (T : Type) (ro : ring_like_op T) (A B : Type) (f : A → B) (g : B → T) (l : list A),
    ∑ (i ∈ l), g (f i) = ∑ (j ∈ map f l), g j
Search (∑ (_ ∈ _), _ = ∑ (_ ∈ _), _).
...
rngl_summation_list_permut:
  ∀ (T : Type) (ro : ring_like_op T),
    ring_like_prop T
    → ∀ (A : Type) (l1 l2 : list A) (f : A → T), Permutation l1 l2 → ∑ (i ∈ l1), f i = ∑ (i ∈ l2), f i
rngl_summation_permut:
  ∀ (T : Type) (ro : ring_like_op T),
    ring_like_prop T
    → ∀ (n : nat) (l1 l2 : list T),
        Permutation l1 l2
        → length l1 = n → length l2 = n → ∑ (i = 0, n - 1), nth i l1 0 = ∑ (i = 0, n - 1), nth i l2 0
...
specialize (glop (canon_sym_gr_prop n) Hσ) as H1.
destruct H1 as (f, Hf).
erewrite rngl_summation_eq_compat. 2: {
  intros k Hk.
  specialize (Hf k).
  assert (H : k < n!). {
    specialize (fact_neq_0 n) as H.
    flia Hk H.
  }
  specialize (Hf H); clear H.
  rewrite Hf.
  easy.
}
cbn.
induction n; [ easy | ].
destruct n. {
  cbn.
  do 2 rewrite rngl_summation_only_one.
  do 2 rewrite rngl_product_only_one.
  cbn.
  specialize (Hf 0 Nat.lt_0_1).
  cbn in Hf.
  rewrite <- Hf; cbn.
  destruct Hσ as (H1, H2).
  specialize (H2 0 Nat.lt_0_1).
  unfold is_permut in H2.
  destruct H2 as (H2, H3).
  specialize (H2 0 Nat.lt_0_1).
  apply Nat.lt_1_r in H2.
  cbn in H2; cbn.
  now rewrite H2.
}
destruct n. {
  cbn.
  unfold iter_seq, iter_list.
  cbn.
  do 2 rewrite rngl_add_0_l.
  do 4 rewrite rngl_mul_1_l.
  specialize (Hf 0 Nat.lt_0_2) as H1.
  specialize (Hf 1 Nat.lt_1_2) as H2.
  cbn in H1, H2; cbn.
  rewrite <- H1, <- H2; cbn.
  rewrite ε_ws_ε; try easy.
  rewrite ε_ws_ε; try easy.
  rewrite ε_ws_ε; try easy.
  rewrite ε_ws_ε; try easy.
  unfold ε_ws; cbn.
  unfold ε_fun_ws; cbn.
  unfold iter_seq, iter_list; cbn.
  repeat rewrite rngl_mul_1_l.
  repeat rewrite rngl_mul_1_r.
  unfold sign_diff.
....
rngl_summation_permut:
  ∀ (T : Type) (ro : ring_like_op T),
    ring_like_prop T
    → ∀ (n : nat) (l1 l2 : list T),
        Permutation l1 l2
        → length l1 = n → length l2 = n → ∑ (i = 0, n - 1), nth i l1 0 = ∑ (i = 0, n - 1), nth i l2 0
...
*)

Theorem det_any_permut :
  rngl_has_opp = true →
  rngl_has_inv = true →
  rngl_is_comm = true →
  rngl_has_dec_eq = true →
  rngl_has_1_neq_0 = true →
  rngl_is_integral = true →
  rngl_characteristic = 0 →
  ∀ n (M : matrix n n T) (σ : vector n nat),
  n ≠ 0
  → is_permut σ
  → determinant M =
    (∑ (μ ∈ list_of_vect (mk_canon_sym_gr n)), ε μ * ε σ *
     ∏ (k = 0, n - 1), mat_el M (vect_el σ k) (vect_el μ k))%F.
Proof.
intros Hop Hiv Hic Hde H10 Hit Hch * Hnz Hσ.
unfold is_permut in Hσ.
destruct Hσ as (Hσ_lt, Hσ_inj).
erewrite rngl_summation_list_eq_compat. 2: {
  intros μ Hμ.
  remember (μ ° permut_inv σ) as ν eqn:Hν.
  assert (Hσν : ν ° σ = μ). {
    rewrite Hν.
    rewrite <- permut_comp_assoc.
    apply vector_eq.
    intros i Hi; cbn.
    unfold comp.
    now rewrite permut_fun_inv_fun.
  }
  subst ν.
  rewrite <- Hσν at 1.
  assert (Hpμ : is_permut μ). {
    unfold mk_canon_sym_gr in Hμ.
    apply in_map_iff in Hμ.
    destruct Hμ as (i & Hi & His).
    rewrite <- Hi.
    apply in_seq in His.
    now apply sym_gr_elem_is_permut.
  }
  rewrite signature_comp;
    [ | easy | easy | easy | easy | easy | easy | easy | | easy ]. 2: {
    apply is_permut_comp; [ easy | now apply permut_inv_is_permut ].
  }
  rewrite rngl_mul_comm; [ | easy ].
  rewrite <- rngl_mul_assoc.
  rewrite ε_square;
    [ | easy | easy | easy | easy | easy | easy | easy | easy ].
  rewrite rngl_mul_1_r.
  erewrite rngl_product_eq_compat. 2: {
    intros i Hi.
    rewrite <- Hσν at 1.
    easy.
  }
  easy.
}
cbn - [ "°" ].
unfold list_of_vect.
rewrite <- rngl_summation_list_change_var.
rewrite rngl_summation_seq_summation; [ | apply fact_neq_0 ].
rewrite Nat.add_0_l.
(*1*)
set (ν := λ i, vect_el (mk_canon_sym_gr n) i ° permut_inv σ).
erewrite rngl_summation_eq_compat. 2: {
  intros i Hi.
  rewrite rngl_mul_comm; [ | easy ].
  replace (vect_el (mk_canon_sym_gr n) i ° permut_inv σ) with (ν i) by easy.
  unfold "°".
  unfold comp.
  easy.
}
cbn - [ ν ].
erewrite rngl_summation_eq_compat. 2: {
  intros i Hi.
  now rewrite rngl_product_fun_permut with
    (f := λ j, mat_el M j (vect_el (ν i) j)).
}
cbn - [ ν ].
assert (Hν : is_sym_gr (mk_vect n! ν)). {
...
}
apply (det_by_any_sym_gr M Hν).
...1
remember
  (map
     (λ i, ε (canon_permut n i ° permut_inv σ) *
      ∏ (i0 = 0, n - 1),
      mat_el M (vect_el σ i0)
       (vect_el ((canon_permut n i ° permut_inv σ) ° σ) i0))%F
  (seq 0 n!)) as d eqn:Hd.
enough (H : determinant M = ∑ (i = 0, n! - 1), nth i d 0). {
  rewrite Hd in H.
  erewrite rngl_summation_eq_compat in H. 2: {
    intros i Hi.
    rewrite List_map_nth_in with (a := 0).
    easy.
    rewrite seq_length.
    specialize (fact_neq_0 n) as H1.
    flia Hi H1.
  }
  cbn in H.
  rewrite H.
  apply rngl_summation_eq_compat.
  intros i Hi.
  rewrite rngl_mul_comm; [ | easy ].
  f_equal. 2: {
    f_equal; f_equal.
    rewrite seq_nth; [ easy | ].
    specialize (fact_neq_0 n) as H1.
    flia Hi H1.
  }
  apply rngl_product_eq_compat.
  intros j Hj.
  f_equal.
  cbn.
  rewrite seq_nth; [ easy | ].
  specialize (fact_neq_0 n) as H1.
  flia Hi H1.
}
apply det_is_det_by_any_permut; try easy.
unfold determinant'_list.
set (f := λ i, canon_permut n i ° permut_inv σ).
erewrite map_ext_in in Hd. 2: {
  intros i Hi.
  replace (canon_permut n i ° permut_inv σ) with (f i) by easy.
  easy.
}
erewrite map_ext_in. 2: {
  intros i Hi.
  replace n with (S (n - 1)) at 2 by flia Hnz.
  rewrite rngl_product_succ_succ.
  erewrite rngl_product_eq_compat. 2: {
    intros j Hj.
    now rewrite Nat.sub_succ, Nat.sub_0_r.
  }
  rewrite <- ε_of_canon_permut_ε; try easy.
  apply in_seq in Hi; flia Hi.
}
remember (canon_permut n) as g eqn:Hg.
subst d.
erewrite map_ext_in. 2: {
  intros i Hi.
  unfold "°".
  cbn - [ f ].
  unfold comp.
  easy.
}
erewrite map_ext_in. 2: {
  intros i Hi.
  now rewrite rngl_product_fun_permut with
    (f := λ j, mat_el M j (vect_el (f i) j)).
}
...
Search (Permutation (map _ _)).
Print determinant'.
Search determinant.
...
(*
intros * Hnz Hσ Hg.
unfold iter_seq.
Theorem glop : ∀ d len f g,
  ∏ (i = 0, len - 1), nth i (list_of_fun len f) d =
  ∏ (i = 0, len - 1), nth i (list_of_fun len g) d
  → ∏ (i = 0, len - 1), f i = ∏ (i = 0, len - 1), g i.
...
apply (glop 0%F).
apply rngl_product_permut.
...
*)
intros * Hnz Hσ Hg.
destruct n; [ easy | clear Hnz ].
rewrite Nat.sub_succ, Nat.sub_0_r.
unfold is_permut in Hσ.
remember (vect_el σ) as u eqn:Hu; clear σ Hu.
destruct Hσ as (H1, H2).
...
induction n; cbn. {
  rewrite rngl_product_only_one; [ | easy ].
  rewrite rngl_product_only_one; [ | easy ].
  specialize (H1 0 Nat.lt_0_1) as H3.
  specialize (Hg 0 Nat.lt_0_1) as H4.
  apply Nat.lt_1_r in H3.
  apply Nat.lt_1_r in H4.
  now rewrite H3, H4, H3.
}
destruct (Nat.eq_dec (s (S n)) (S n)) as [Hsn| Hsn]. {
  assert (H : ∀ i : nat, i < S n → s i < S n). {
    intros i Hi.
    specialize (H1 i) as H3.
    assert (H : i < S (S n)) by flia Hi.
    specialize (H3 H).
    specialize (H2 _ (S n) H) as H4; clear H.
    destruct (Nat.eq_dec (s i) (s (S n))) as [Hisn| Hsin]. {
      assert (H' : S n < S (S n)) by flia.
      specialize (H4 H' Hisn).
      subst i; flia Hi.
    }
    flia Hsn H3 Hsin.
  }
  specialize (IHn H); clear H.
  assert (H : ∀ i j : nat, i < S n → j < S n → s i = s j → i = j). {
    intros i j Hi Hj Hij.
    apply H2; [ flia Hi | flia Hj | easy ].
  }
  specialize (IHn H); clear H.
  assert (H : ∀ i : nat, i < S n → g i < S n). {
    intros i Hi.
...
(*
...
rewrite rngl_product_split_last; [ | flia ].
rewrite rngl_product_succ_succ.
symmetry.
rewrite rngl_product_split_last; [ | flia ].
rewrite rngl_product_succ_succ.
symmetry.
...
Search (∏ (_ = _, _), _ = ∏ (_ = _, _), _).
...
*)
erewrite map_ext_in. 2: {
  intros i Hi.
  rewrite glop.
  easy.
}
...
etransitivity. {
...
  apply Permutation_map with (l' := map f (seq 0 n!)).
Search (Permutation (map _ _)).
Print canon_permut_inv.
Search canon_permut_inv.
Check (map (canon_permut_inv n) (seq 0 n!)).
Check ε.
  apply Permutation_map with (l' := map (canon_permut_inv n ° permut_inv σ ° canon_permut n) (seq 0 n!)).
  apply Permutation_map with (l' := map (λ i, vect_el (permut_inv σ) i) (seq 0 n!)).
f = canon_permut_inv n ° permut_inv σ ° canon_permut n
...
}
rewrite map_map.
...
Search (map _ _ = map _ _).
...
map_map: ∀ (A B C : Type) (f : A → B) (g : B → C) (l : list A), map g (map f l) = map (λ x : A, g (f x)) l
...
permut_inv σ ° canon_permut n i = canon_permut n (f i)
...
f = canon_permut_inv n ° permut_inv σ ° canon_permut n

...
  ============================
  Permutation
    (map
       (λ i : nat,
          (ε (permut_inv σ ° canon_permut n i) *
           ∏ (i0 = 0, n - 1), mat_el M (vect_el σ i0) (vect_el (σ ° (permut_inv σ ° canon_permut n i)) i0))%F)
       (seq 0 n!))
    (map (λ k : nat, (ε_canon_permut n k * ∏ (i = 1, n), mat_el M (i - 1) (vect_el (canon_permut n k) (i - 1)))%F)
       (seq 0 n!))
...
apply det_is_det_by_any_permut.
...3
rewrite det_is_det_by_canon_permut; try easy.
unfold determinant'.
Search determinant'.

...2
rewrite rngl_summation_list_change_var with
  (f := λ i, permut_inv σ ° i)
  (g :=
     λ k,
     (ε k * ∏ (i = 0, n - 1), mat_el M (vect_el σ i) (vect_el (σ ° k) i))%F).
unfold mk_canon_sym_gr.
rewrite map_map.
rewrite det_is_det_by_canon_permut; try easy.
unfold determinant'.
(*1*)
Search (∑ (_ ∈ map _ _), _).
...1
rewrite rngl_summation_map_seq.
rewrite rngl_summation_seq_summation; [ | apply fact_neq_0 ].
rewrite Nat.add_0_l.
...
cbn.
rewrite det_is_det_by_canon_permut; try easy.
unfold determinant'.
unfold mk_canon_sym_gr.
rewrite rngl_summation_map_seq.
rewrite rngl_summation_seq_summation; [ | apply fact_neq_0 ].
rewrite Nat.add_0_l.
remember (canon_permut n) as μ eqn:Hμ.
symmetry.
erewrite rngl_summation_eq_compat. 2: {
  intros i Hi.
  rewrite <- rngl_product_succ_succ'.
  replace (S (n - 1)) with n by flia Hnz.
  easy.
}
symmetry.
...
  Hμ : μ = canon_permut n
  ============================
  ∑ (k = 0, n! - 1), ε (μ k) * ∏ (i = 1, n), mat_el M (i - 1) (vect_el (μ k) (i - 1)) =
  ∑ (i = 0, n! - 1),
  ε (permut_inv σ ° μ i) *
  ∏ (i0 = 1, n),
  mat_el M (vect_el σ (i0 - 1))
    (comp (vect_el σ) (comp (permut_fun_inv (vect_el σ) n) (vect_el (μ i))) (i0 - 1)%nat)
...
apply rngl_summation_eq_compat.
intros i Hi.
symmetry.
rewrite rngl_mul_comm; [ | easy ].
rewrite <- rngl_mul_assoc.
f_equal.
rewrite <- rngl_product_succ_succ'.
replace (S (n - 1)) with n by flia Hnz.
rewrite rngl_product_shift; [ | now apply Nat.neq_0_lt_0 ].
symmetry.
rewrite rngl_product_shift; [ | now apply Nat.neq_0_lt_0 ].
erewrite rngl_product_eq_compat. 2: {
  intros j Hj.
  now rewrite Nat.add_comm, Nat.add_sub.
}
symmetry.
erewrite rngl_product_eq_compat. 2: {
  intros j Hj.
  now rewrite Nat.add_comm, Nat.add_sub.
}
symmetry.
...
Search (_ * _ = 1)%F.
rngl_mul_move_1_r:
  ∀ (T : Type) (ro : ring_like_op T),
    ring_like_prop T → rngl_has_inv = true → ∀ a b : T, b ≠ 0%F → (a * b)%F = 1%F ↔ a = b⁻¹%F
...

rewrite ε_ws_ε.
unfold ε_ws.
unfold ε_fun_ws.
unfold sign_diff.

...
unfold ε, ε_fun.
unfold δ.
Search ε.
Print ε_ws.
Print ε_fun_ws.
...
  rewrite <- signature_comp;
    [ | easy | easy | easy | easy | easy | easy | easy | easy | easy ].
  unfold ε at 2.
  unfold ε_fun.
  cbn.
...
rewrite <- signature_comp_fun.
Search (ε _ * ε _)%F.
...
   apply is_permut_permut_inv.
...
  rewrite <- rngl_product_succ_succ'.
  replace (S (n - 1)) with n by flia Hnz.
  erewrite rngl_product_eq_compat. 2: {
    intros i Hi.
    rewrite <- Hσν at 1.
    rewrite permut_comp_assoc.
    rewrite comp_permut_inv_r; [ cbn | easy ].
    unfold id.
    easy.
  }
  cbn.
  rewrite permut_comp_assoc.
  rewrite comp_permut_inv_r; [ | easy ].
  unfold ε at 1; cbn.
  rewrite comp_id_l.
  replace (ε_fun (vect_el μ) n) with (ε μ) by easy.
  rewrite rngl_mul_mul_swap, rngl_mul_comm; [ | easy | easy ].
  easy.
}
cbn.
rewrite <- rngl_mul_summation_list_distr_l; [ | easy ].
unfold mk_canon_sym_gr.
rewrite rngl_summation_map_seq.
rewrite rngl_summation_seq_summation; [ | apply fact_neq_0 ].
cbn.
Print determinant'.
...
erewrite rngl_summation_eq_compat. 2: {
  intros k Hk.
Print determinant'.
...
  erewrite rngl_product_eq_compat. 2: {
    intros i Hi.
...

replace (n!) with (S (n! - 1) - 0).
remember (λ v : nat, canon_permut n v) as h eqn:Hh.
remember 0 as b eqn:Hb.
rewrite Hb at 2.
remember (n! - 1) as e eqn:He.
Check rngl_summation_change_var.
...
Search (∑ (_ ∈ map _ _), _)%F.
rewrite <- rngl_summation_change_var.
Print determinant'.
...

Theorem determinant_transp :
  rngl_is_comm = true →
  rngl_has_opp = true →
  rngl_has_inv = true →
  rngl_is_integral = true →
  rngl_has_1_neq_0 = true →
  rngl_has_dec_eq = true →
  rngl_characteristic = 0 →
  ∀ n (M : matrix n n T), determinant M⁺ = determinant M.
Proof.
intros Hic Hop Hiv Hit H10 Hde Hch *.
rewrite det_is_det_by_canon_permut; try easy.
rewrite determinant'_by_list; try easy.
symmetry.
rewrite det_is_det_by_canon_permut; try easy.
rewrite determinant'_by_list; try easy.
apply rngl_summation_permut; cycle 1. {
  unfold determinant'_list.
  now rewrite map_length, seq_length.
} {
  unfold determinant'_list.
  now rewrite map_length, seq_length.
}
unfold determinant'_list.
cbn.
erewrite map_ext_in. 2: {
  intros m Hm.
  apply in_seq in Hm.
  now rewrite <- ε_of_canon_permut_ε.
}
symmetry.
erewrite map_ext_in. 2: {
  intros m Hm.
  apply in_seq in Hm.
  now rewrite <- ε_of_canon_permut_ε.
}
symmetry.
remember (canon_permut n) as f eqn:Hf.
...
look at
https://proofwiki.org/wiki/Permutation_of_Determinant_Indices
...
Search canon_permut.
Print FinFun.Injective.
Print FinFun.Surjective.
Print Module FinFun.
Print FinFun.Finite.
Print FinFun.Full.
Definition is_symmetric_group n (f : nat → vector n nat) :=
  FinFun.Injective nat {
...
Definition is_symmetric_group n (f : nat → vector n nat) :=
  (∀ i j, i < n! → j < n! → f i = f j → i = j) ∧
  (∀ v, ∃ i, i < n! ∧ f i = v).
...
Theorem glop : ∀ n (M : matrix n n T) (f g : nat → vector n nat),
  is_symmetric_group f
  → is_symmetric_group f
  → determinant M =
      (∑ (i = 1, n!), ε (f i) * ε (g i) *
       ∏ (j = 1, n), mat_el M (vect_el (f i) j) (vect_el (g i) j))%F.
...
Check determinant_multilinear.
About nat_bijection_Permutation.
Search (Permutation (map _ _)).
Search determinant'_list.
Search canon_permut.
...
Print FinFun.Injective.
Print FinFun.Surjective.
Search FinFun.Surjective.
Theorem glop : ∀ A B (f g : A → B) l,
  FinFun.Injective f
  → FinFun.Injective g
  → FinFun.Surjective f
  → FinFun.Surjective g
  → Permutation (map f l) (map g l).
Proof.
intros * Hif Hig Hsf Hsg.
unfold FinFun.Injective in Hif, Hig.
unfold FinFun.Surjective in Hsf, Hsg.
induction l as [| x]; [ easy | ].
cbn.
Search Permutation (_ :: _).
...
destruct n; [ easy | ].
destruct n. {
  now subst f; unfold iter_seq, iter_list; cbn.
}
destruct n. {
  subst f; unfold iter_seq, iter_list; cbn.
  repeat rewrite rngl_mul_1_l.
  rewrite rngl_mul_1_r.
  rewrite (rngl_mul_comm Hic (mat_el M 0 1)).
  easy.
}
...
cbn in Hf.
subst f.
remember (S n) as sn; cbn; subst sn.
Print canon_permut_fun.
...
apply det_is_det_by_any_permut; try easy.
unfold determinant'_list.
Search determinant'_list.
Search (Permutation (map _ _)).
About nat_bijection_Permutation.
etransitivity. {
About permut_fun_Permutation.
...
Search Permutation.
apply nat_bijection_Permutation.
Check Permutation_map.
Check Permutation_trans.
...
permut_fun_Permutation: ∀ (f : nat → nat) (n : nat), is_permut_fun f n → Permutation (map f (seq 0 n)) (seq 0 n)

cbn.
transitivity (seq 0 n!).
Check Permutation_trans.

Search (Permutation (map _ _)).
apply Permutation_trans with (l' := seq 0 n!).
eapply Permutation_trans. {
apply permut_fun_Permutation.
...
intros Hic Hop Hiv Hit H10 Hde Hch *.
rewrite det_is_det_by_canon_permut; try easy.
unfold determinant'.
symmetry.
rewrite det_is_det_by_canon_permut; try easy.
unfold determinant'.
cbn.
Search determinant'.
...
intros Hic Hop Hin Hit H10 Hde Hch * Hlin.
intros.
...

Theorem laplace_formula_on_cols :
  rngl_is_comm = true →
  rngl_has_opp = true →
  rngl_has_inv = true →
  rngl_is_integral = true →
  rngl_has_1_neq_0 = true →
  rngl_has_dec_eq = true →
  rngl_characteristic = 0 →
  ∀ n (M : matrix n n T) j,
  j < n
  → determinant M = ∑ (i = 0, n - 1), mat_el M i j * mat_el (comatrix M) i j.
Proof.
intros Hic Hop Hin Hit H10 Hde Hch * Hlin.
...
Check determinant_transp.
...

Theorem mat_swap_rows_involutive : ∀ n (M : matrix n n T) i j,
  mat_swap_rows i j (mat_swap_rows i j M) = M.
Proof.
intros.
apply matrix_eq.
intros p q Hp Hq; cbn.
destruct (Nat.eq_dec p i) as [Hpi| Hpi]. {
  subst p.
  destruct (Nat.eq_dec j i) as [Hji| Hji]; [ now subst j | ].
  now rewrite <- (if_eqb_eq_dec j), Nat.eqb_refl.
}
destruct (Nat.eq_dec p j) as [Hpj| Hpj]; [ | easy ].
subst p.
now rewrite <- (if_eqb_eq_dec i), Nat.eqb_refl.
Qed.

(*
The following two theorems, "determinant_with_row" and determinant_with_bad_row
have some similitudes.
  The theorem "determinant_with_row" says that we can compute the determinant
by going through any row (not necessarily the 0th one). Here, row "i".
  The theorem "determinant_with_bad_row" says that if we go through another
row "k" different from "i", the same formula (where "M i j" is replaced
with "M k j") returns 0. It is what I call a "bad determinant formula".

determinant_with_row
  ∀ (i n : nat) (M : matrix (S n) (S n) T),
  i ≤ n
  → ∑ (j = 0, n), minus_one_pow (i + j) * M i j * det (subm M i j) = det M

determinant_with_bad_row
  ∀ (i k n : nat) (M : matrix (S n) (S n) T),
  i ≤ n → k ≤ n → i ≠ k
  → ∑ (j = 0, n), minus_one_pow (i + j) * M k j * det (subm M i j) = 0%F

Isn't it strange? (or beautiful?)
*)

Theorem determinant_with_row :
  rngl_is_comm = true →
  rngl_has_opp = true →
  rngl_has_inv = true →
  rngl_is_integral = true →
  rngl_has_1_neq_0 = true →
  rngl_has_dec_eq = true →
  rngl_characteristic = 0 →
  ∀ i n (M : matrix (S n) (S n) T),
  i ≤ n
  → ∑ (j = 0, n),
    minus_one_pow (i + j) * mat_el M i j * determinant (subm M i j) =
    determinant M.
Proof.
intros Hic Hop Hiv Hit H10 Hde Hch * Hin.
symmetry.
destruct (Nat.eq_dec i 0) as [Hiz| Hiz]; [ now subst i | ].
apply rngl_opp_inj; [ easy | ].
rewrite <- determinant_alternating with (p := 0) (q := i); try easy;
  [ | flia Hiz | flia | flia Hin ].
rewrite determinant_succ at 1.
erewrite rngl_summation_eq_compat. 2: {
  intros j Hj.
  rewrite mat_swap_rows_comm.
  rewrite mat_el_mat_swap_rows.
  easy.
}
rewrite rngl_opp_summation; [ | easy | easy ].
apply rngl_summation_eq_compat.
intros j Hj.
rewrite <- rngl_mul_assoc; symmetry.
rewrite <- rngl_mul_opp_r; [ | easy ].
rewrite (Nat.add_comm i j).
rewrite minus_one_pow_add_r; [ | easy | easy ].
do 2 rewrite <- rngl_mul_assoc.
f_equal.
rewrite rngl_mul_comm; [ | easy ].
rewrite <- rngl_mul_assoc.
f_equal.
rewrite rngl_mul_opp_l, <- rngl_mul_opp_r; [ | easy | easy ].
rewrite rngl_mul_comm; [ | easy ].
symmetry.
rewrite mat_swap_rows_comm.
apply determinant_subm_mat_swap_rows_0_i; try easy.
flia Hiz Hin.
Qed.

Theorem determinant_with_bad_row :
  rngl_is_comm = true →
  rngl_has_opp = true →
  rngl_has_inv = true →
  rngl_is_integral = true →
  rngl_has_1_neq_0 = true →
  rngl_has_dec_eq = true →
  rngl_characteristic = 0 →
  ∀ i k n (M : matrix (S n) (S n) T),
  i ≤ n
  → k ≤ n
  → i ≠ k
  → ∑ (j = 0, n),
    minus_one_pow (i + j) * mat_el M k j * determinant (subm M i j) = 0%F.
Proof.
intros Hic Hop Hiv Hit H10 Hde Hch.
intros * Hi Hk Hik.
remember
  (mk_mat (S n) (S n) (λ p q, mat_el M (if Nat.eq_dec p i then k else p) q))
  as A eqn:HA.
assert (H1 : determinant A = 0%F). {
  subst A.
  apply Nat.lt_succ_r in Hi.
  apply Nat.lt_succ_r in Hk.
  apply determinant_same_rows with (p := i) (q := k); try easy.
  intros j.
  cbn.
  rewrite <- (if_eqb_eq_dec i), Nat.eqb_refl.
  now destruct (Nat.eq_dec k i).
}
rewrite <- determinant_with_row with (i := i) in H1; try easy.
rewrite <- H1 at 2.
apply rngl_summation_eq_compat.
intros j Hj.
do 2 rewrite <- rngl_mul_assoc.
f_equal; f_equal. {
  rewrite HA; cbn.
  now rewrite <- if_eqb_eq_dec, Nat.eqb_refl.
}
f_equal.
rewrite HA.
apply matrix_eq.
intros p q Hp Hq; cbn.
destruct (Nat.eq_dec (p + Nat.b2n (i <=? p)) i) as [Hpi| Hpi]; [ | easy ].
destruct (le_dec i p) as [Hip| Hip]. {
  apply Nat.leb_le in Hip.
  rewrite Hip in Hpi.
  cbn in Hpi.
  apply Nat.leb_le in Hip.
  flia Hpi Hip.
} {
  apply Nat.leb_nle in Hip.
  rewrite Hip in Hpi.
  cbn in Hpi.
  apply Nat.leb_nle in Hip.
  flia Hpi Hip.
}
Qed.

Theorem matrix_comatrix_mul :
  rngl_is_comm = true →
  rngl_has_opp = true →
  rngl_has_inv = true →
  rngl_is_integral = true →
  rngl_has_1_neq_0 = true →
  rngl_has_dec_eq = true →
  rngl_characteristic = 0 →
  ∀ n (M : matrix n n T),
  (M * (comatrix M)⁺ = determinant M × mI n)%M.
Proof.
intros Hic Hop Hiv Hit H10 Hde Hch *.
apply matrix_eq.
intros i j Hi Hj.
rewrite laplace_formula_on_rows with (i := i); try easy; cbn.
destruct (Nat.eq_dec i j) as [Hij| Hij]. {
  subst j.
  now rewrite rngl_mul_1_r.
}
rewrite rngl_mul_0_r; [ | now left ].
destruct n; [ easy | ].
rewrite Nat.sub_succ at 1.
rewrite Nat.sub_0_r.
erewrite rngl_summation_eq_compat. 2: {
  intros k Hk.
  rewrite rngl_mul_comm; [ | easy ].
  rewrite rngl_mul_mul_swap; [ | easy ].
  easy.
}
cbn.
apply -> Nat.lt_succ_r in Hi.
apply -> Nat.lt_succ_r in Hj.
apply Nat.neq_sym in Hij.
now apply determinant_with_bad_row.
Qed.

Theorem comatrix_matrix_mul :
  rngl_is_comm = true →
  rngl_has_opp = true →
  rngl_has_inv = true →
  rngl_is_integral = true →
  rngl_has_1_neq_0 = true →
  rngl_has_dec_eq = true →
  rngl_characteristic = 0 →
  ∀ n (M : matrix n n T),
  ((comatrix M)⁺ * M = determinant M × mI n)%M.
Proof.
intros Hic Hop Hiv Hit H10 Hde Hch *.
apply matrix_eq.
intros i j Hi Hj.
rewrite laplace_formula_on_cols with (j := j); try easy; cbn.
destruct (Nat.eq_dec i j) as [Hij| Hij]. {
  subst i.
  rewrite rngl_mul_1_r.
  apply rngl_summation_eq_compat.
  intros k Hk.
  rewrite rngl_mul_mul_swap; [ | easy ].
  rewrite rngl_mul_assoc.
  f_equal.
  now apply rngl_mul_comm.
}
rewrite rngl_mul_0_r; [ | now left ].
...
destruct n; [ easy | ].
rewrite Nat.sub_succ at 1.
rewrite Nat.sub_0_r.
erewrite rngl_summation_eq_compat. 2: {
  intros k Hk.
  rewrite rngl_mul_comm; [ | easy ].
  rewrite rngl_mul_mul_swap; [ | easy ].
  easy.
}
cbn.
apply -> Nat.lt_succ_r in Hi.
apply -> Nat.lt_succ_r in Hj.
apply Nat.neq_sym in Hij.
now apply determinant_with_bad_row.
Qed.

Definition mat_inv n (M : matrix n n T) :=
  ((determinant M)⁻¹ × (comatrix M)⁺)%M.

Theorem matrix_right_inv :
  rngl_is_comm = true →
  rngl_has_opp = true →
  rngl_has_inv = true →
  rngl_is_integral = true →
  rngl_has_1_neq_0 = true →
  rngl_has_dec_eq = true →
  rngl_characteristic = 0 →
  ∀ n (M : matrix n n T),
  determinant M ≠ 0%F → (M * mat_inv M = mI n)%M.
Proof.
intros Hic Hop Hiv Hit H10 Hde Hch *.
intros Hdz.
unfold mat_inv.
rewrite mat_mul_mul_scal_l; [ | easy | easy ].
rewrite matrix_comatrix_mul; try easy.
rewrite mat_mul_scal_l_mul_assoc; [ | easy ].
rewrite rngl_mul_inv_l; [ | easy | easy ].
now apply mat_mul_scal_1_l.
Qed.

Theorem matrix_left_inv :
  rngl_is_comm = true →
  rngl_has_opp = true →
  rngl_has_inv = true →
  rngl_is_integral = true →
  rngl_has_1_neq_0 = true →
  rngl_has_dec_eq = true →
  rngl_characteristic = 0 →
  ∀ n (M : matrix n n T),
  determinant M ≠ 0%F → (mat_inv M * M = mI n)%M.
Proof.
intros Hic Hop Hiv Hit H10 Hde Hch *.
intros Hdz.
unfold mat_inv.
rewrite mat_mul_scal_l_mul; [ | easy ].
...
rewrite matrix_comatrix_mul; try easy.
rewrite mat_mul_scal_l_mul_assoc; [ | easy ].
rewrite rngl_mul_inv_l; [ | easy | easy ].
now apply mat_mul_scal_1_l.
...

End a.

Arguments determinant {T ro} {n%nat} M%M.
Arguments det_from_row {T}%type {ro} {n}%nat M%M i%nat.
Arguments det_from_col {T}%type {ro} {n}%nat M%M j%nat.
Arguments comatrix {T}%type {ro} {n}%nat M%M.
Arguments subm {T m n} M%M i%nat j%nat.
