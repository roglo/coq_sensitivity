Set Nested Proofs Allowed.
Set Implicit Arguments.

Require Import Utf8 Arith Bool.
Require Import Permutation.
Import List List.ListNotations.

Require Import Misc RingLike MyVector Matrix PermutSeq.
Require Import RLsummation RLproduct.
Import matrix_Notations.

Definition list_of_fun {A} n (f : _ → A) := map f (seq 0 n).
Definition fun_of_list {A} (d : A) l i := nth i l d.

Section a.

Context {T : Type}.
Context (ro : ring_like_op T).
Context (rp : ring_like_prop T).

(* determinant *)

(*
   determinant n M recursively computes determinant

      0     n-1
      |     |
      v     v
     ---------    ---------   ---------   ---------
0    |x      |    | x     |   |  x    |   |   x   |
     | ......| -  |. .....| + |.. ....| - |... ...| + etc.
     | ......|    |. .....|   |.. ....|   |... ...|
n-1  | ......|    |. .....|   |.. ....|   |... ...|
     ---------    ---------   ---------   ---------

   each term is the term "x" multiplied by det (n-1) of
   the sub-matrix represented by the dots. The "x" goes through
   the first row.
*)

Fixpoint determinant n (M : matrix T) :=
  (match n with
   | 0 => λ _, 1%F
   | S n' =>
       λ M' : matrix T,
       ∑ (j = 0, n'),
       minus_one_pow j * mat_el M' 0 j * determinant n' (subm M' 0 j)
   end) M.

Arguments determinant n%nat M%M.

Theorem determinant_zero : ∀ (M : matrix T),
  determinant 0 M = 1%F.
Proof. easy. Qed.

Theorem determinant_succ : ∀ n (M : matrix T),
  determinant (S n) M =
     ∑ (j = 0, n), minus_one_pow j * mat_el M 0 j * determinant n (subm M 0 j).
Proof. easy. Qed.

Definition mat_permut_rows_fun (σ : nat → nat) (M : matrix T) :=
  mk_mat (map (λ i, nth (σ i) (mat_list_list M) []) (seq 0 (mat_nrows M))).

...
(* replace vect_nat_el with vect_el 0 *)

Definition mat_permut_rows (σ : vector nat) (M : matrix T) :=
  mat_permut_rows_fun (vect_nat_el σ) M.

(* the following versions of computing the determinant should
   (to be proven) be equivalent; perhaps could help for proving
   Cramer's rule of resolving equations *)

Definition det_from_row {n} (M : matrix T) i :=
  (minus_one_pow i *
   ∑ (j = 0, n),
     minus_one_pow j * mat_el M i j * determinant n (subm M i j))%F.

Definition det_from_col {n} (M : matrix T) j :=
  (minus_one_pow j *
   ∑ (i = 0, n - 1),
     minus_one_pow i * mat_el M i j * determinant n (subm M i j))%F.

(* Alternative version of the determinant: sum of product of the
   factors a_{i,σ(i)} where σ goes through all permutations of
   the naturals of the interval [0, n-1].
   The permutations generated are in the same order as the
   terms generated by the determinant defined by induction on
   the size of the matrix.
     The order happens to be the canonical (alphabetical) order.
   Example for n=3
     = [[0; 1; 2]; [0; 2; 1]; [1; 0; 2]; [1; 2; 0]; [2; 0; 1]; [2; 1; 0]]
   Having the same terms order, the proof of equality of both definitions
   of both determinants is easy.
   See PermutSeq.v *)

(* definition of determinant by sum of products involving all
   permutations *)

Definition determinant' n (M : matrix T) :=
  ∑ (k = 0, fact n - 1),
    ε n (vect_vect_nat_el (mk_canon_sym_gr_vect n) k) *
    ∏ (i = 1, n),
    mat_el M (i - 1)
      (vect_nat_el (vect_vect_nat_el (mk_canon_sym_gr_vect n) k) (i - 1)).

Arguments determinant' n%nat M%M.

(* Proof that both definitions of determinants are equal *)

Theorem det_is_det_by_canon_permut :
  rngl_is_comm = true →
  rngl_has_opp = true →
  rngl_has_inv = true →
  rngl_is_integral = true →
  rngl_has_1_neq_0 = true →
  rngl_has_dec_eq = true →
  rngl_characteristic = 0 →
  ∀ n (M : matrix T),
  is_square_matrix n M = true
  → determinant n M = determinant' n M.
Proof.
intros Hic Hop Hin Hit H10 Hde Hch * Hm.
unfold determinant'.
revert M Hm.
induction n; intros. {
  cbn.
  unfold ε, ε_fun, iter_seq, iter_list; cbn.
  rewrite rngl_add_0_l.
  rewrite rngl_mul_1_r.
  rewrite rngl_div_1_r; [ easy | now left | easy ].
}
rewrite determinant_succ.
destruct (Nat.eq_dec n 0) as [Hnz| Hnz]. {
  subst n; cbn.
  rewrite rngl_summation_only_one; cbn.
  rewrite rngl_summation_only_one; cbn.
  rewrite rngl_product_only_one; cbn.
  unfold ε, ε_fun; cbn.
  do 4 rewrite rngl_product_only_one; cbn.
  rewrite rngl_mul_1_r.
  rewrite rngl_div_1_r; [ easy | now left | easy ].
}
erewrite rngl_summation_eq_compat. 2: {
  intros i Hi.
  rewrite IHn. 2: {
    apply is_squ_mat_subm; [ easy | flia | easy | easy ].
  }
  easy.
}
cbn - [ vect_vect_nat_el mat_el fact ].
clear IHn.
erewrite rngl_summation_eq_compat. 2: {
  intros i Hi.
  rewrite rngl_mul_summation_distr_l; [ | now left ].
  easy.
}
cbn - [ vect_vect_nat_el mat_el fact ].
rewrite rngl_summation_summation_distr.
rewrite <- Nat.sub_succ_l; [ | apply Nat.neq_0_lt_0, fact_neq_0 ].
rewrite Nat_sub_succ_1.
rewrite <- Nat_fact_succ.
apply rngl_summation_eq_compat.
intros k Hk.
(* elimination of "mat_el M 0 (k / (n!)" *)
symmetry.
rewrite rngl_product_split_first; [ | flia ].
cbn - [ vect_vect_nat_el mat_el fact ].
remember (mat_el M 0 _) as x eqn:Hx.
cbn - [ fact ] in Hx.
assert (Hksn : k < (S n)!). {
  eapply le_lt_trans; [ apply Hk | ].
  apply Nat.sub_lt; [ | flia ].
  apply Nat.neq_0_lt_0, fact_neq_0.
}
rewrite (List_map_nth' 0) in Hx; [ | now rewrite seq_length ].
cbn - [ fact ] in Hx.
rewrite seq_nth in Hx; [ | easy ].
rewrite Nat.add_0_l in Hx.
subst x.
rewrite rngl_mul_comm; [ | easy ].
symmetry.
rewrite <- rngl_mul_assoc.
rewrite rngl_mul_comm; [ | easy ].
do 3 rewrite <- rngl_mul_assoc.
f_equal.
(* elimination done *)
(* separation factors "∏" and "ε" *)
rewrite rngl_mul_comm; [ | easy ].
rewrite <- rngl_mul_assoc.
f_equal. {
  (* equality of the two "∏" *)
  rewrite rngl_product_shift; [ | flia Hnz ].
  rewrite (rngl_product_shift _ 2); [ | flia Hnz ].
  rewrite Nat.sub_succ.
  apply rngl_product_eq_compat.
  intros i Hi.
  rewrite Nat.add_comm, Nat.add_sub.
  replace (2 + i - 1) with (S i) by flia.
  unfold mat_el.
  unfold vect_nat_el, vect_vect_nat_el.
  cbn - [ subm fact ].
  rewrite (List_map_nth' 0). 2: {
    rewrite seq_length.
    apply Nat.mod_upper_bound, fact_neq_0.
  }
  rewrite (List_map_nth' 0); [ | now rewrite seq_length ].
  rewrite seq_nth; [ | apply Nat.mod_upper_bound, fact_neq_0 ].
  rewrite seq_nth; [ | easy ].
  do 2 rewrite Nat.add_0_l.
  unfold subm.
  cbn - [ fact butn ].
  rewrite (List_map_nth' []). 2: {
    apply is_sm_mat_iff in Hm.
    destruct Hm as (Hr & Hcr & Hc).
    rewrite butn_length, fold_mat_nrows, Hr.
    cbn; flia Hi Hnz.
  }
  rewrite (List_map_nth' 0); [ | rewrite seq_length; flia Hi Hnz ].
  rewrite (List_map_nth' 0); [ | rewrite seq_length; flia Hi Hnz ].
  rewrite seq_nth; [ | flia Hi Hnz ].
  rewrite seq_nth; [ | flia Hi Hnz ].
  rewrite Nat.add_0_l, Nat.add_1_l.
  remember (sym_gr_fun n (mk_canon_sym_gr n) k) as σ eqn:Hσ.
  remember (mk_canon_sym_gr n (k mod n!)) as σ' eqn:Hσ'.
  move σ' before σ.
  rewrite (sym_gr_succ_values Hσ Hσ').
  rewrite if_ltb_lt_dec.
  destruct (lt_dec (σ' i) (k / n!)) as [Hσk| Hσk]. {
    rewrite nth_butn_after; [ | easy ].
    rewrite nth_butn_before; [ | flia ].
    now rewrite Nat.add_1_r.
  } {
    apply Nat.nlt_ge in Hσk.
    rewrite nth_butn_before; [ | easy ].
    rewrite nth_butn_before; [ | easy ].
    now rewrite (Nat.add_1_r i).
  }
  (* end proof equality of the two "∏" *)
}
(* equality of the two "ε" *)
symmetry.
now apply ε_of_sym_gr_permut_succ.
Qed.

(* multilinearity *)

Theorem determinant_multilinear :
  rngl_is_comm = true →
  rngl_has_opp = true →
  rngl_has_inv = true →
  rngl_is_integral = true →
  rngl_has_1_neq_0 = true →
  rngl_has_dec_eq = true →
  rngl_characteristic = 0 →
  ∀ n (M : matrix T) i a b U V,
  is_square_matrix n M = true
  → vect_size U = n
  → vect_size V = n
  → i < n
  → determinant n (mat_repl_vect i M (a × U + b × V)%V) =
       (a * determinant n (mat_repl_vect i M U) +
        b * determinant n (mat_repl_vect i M V))%F.
Proof.
intros Hic Hop Hin Hit H10 Hde Hch * Hsm Hu Hv Hi.
specialize (square_matrix_ncols _ Hsm) as Hcn.
(* using the snd version of determinants: determinant' *)
rewrite det_is_det_by_canon_permut; try easy. 2: {
  apply mat_repl_vect_is_square; [ congruence | cbn | easy ].
  rewrite map2_length.
  do 2 rewrite map_length, fold_vect_size.
  rewrite Hu, Hv.
  apply Nat.min_id.
}
rewrite det_is_det_by_canon_permut; try easy. 2: {
  apply mat_repl_vect_is_square; [ congruence | easy | easy ].
}
rewrite det_is_det_by_canon_permut; try easy. 2: {
  apply mat_repl_vect_is_square; [ congruence | easy | easy ].
}
unfold determinant'.
(* simplification of the lhs *)
remember (a × U + b × V)%V as UV eqn:HUV.
erewrite rngl_summation_eq_compat. 2: {
  intros k Hk.
  assert (Hkn : k < n!). {
    eapply le_lt_trans; [ apply Hk | ].
    apply Nat.sub_lt; [ | flia ].
    apply Nat.neq_0_lt_0, fact_neq_0.
  }
  erewrite rngl_product_eq_compat. 2: {
    intros j Hj.
    rewrite mat_el_repl_vect; cycle 1. {
      now apply (@squ_mat_is_corr n).
    } {
      subst UV; cbn.
      rewrite map2_length.
      rewrite map_length.
      rewrite map_length.
      do 2 rewrite fold_vect_size.
      rewrite Hu, Hv, Nat.min_id.
      flia Hj.
    } {
      apply is_sm_mat_iff in Hsm.
      destruct Hsm as (Hr, _).
      rewrite Hr; flia Hj.
    } {
      cbn.
      rewrite (List_map_nth' 0); [ cbn | now rewrite seq_length ].
      rewrite seq_nth; [ | easy ].
      rewrite (List_map_nth' 0); [ cbn | rewrite seq_length; flia Hj ].
      rewrite seq_nth; [ cbn | flia Hj ].
      rewrite Hcn.
      apply permut_elem_ub; [ easy | flia Hj ].
    } {
      now rewrite Hcn.
    }
    unfold vect_nat_el, vect_vect_nat_el; cbn.
    rewrite (List_map_nth' 0); [ | now rewrite seq_length ].
    cbn - [ nth ].
    rewrite (List_map_nth' 0); [ | rewrite seq_length; flia Hj ].
    rewrite seq_nth; [ cbn | easy ].
    rewrite seq_nth; [ cbn | flia Hj ].
    easy.
  }
  easy.
}
cbn - [ mat_el vect_vect_nat_el ].
(* put a and b inside the sigma in the rhs *)
rewrite rngl_mul_summation_distr_l; [ | now left ].
rewrite rngl_mul_summation_distr_l; [ | now left ].
symmetry.
erewrite rngl_summation_eq_compat. 2: {
  intros k Hk.
  assert (Hkn : k < fact n). {
    specialize (fact_neq_0 n) as Hnz.
    flia Hk Hnz.
  }
  rewrite rngl_mul_assoc.
  rewrite (rngl_mul_comm Hic a).
  erewrite rngl_product_eq_compat. 2: {
    intros j Hj.
    rewrite mat_el_repl_vect; cycle 1. {
      now apply (@squ_mat_is_corr n).
    } {
      rewrite Hu; flia Hj.
    } {
      apply is_sm_mat_iff in Hsm.
      destruct Hsm as (Hr, _).
      rewrite Hr; flia Hj.
    } {
      cbn.
      rewrite (List_map_nth' 0); [ cbn | now rewrite seq_length ].
      rewrite seq_nth; [ | easy ].
      rewrite (List_map_nth' 0); [ cbn | rewrite seq_length; flia Hj ].
      rewrite seq_nth; [ cbn | flia Hj ].
      rewrite Hcn.
      apply permut_elem_ub; [ easy | flia Hj ].
    } {
      now rewrite Hcn.
    }
    unfold vect_nat_el, vect_vect_nat_el; cbn.
    rewrite (List_map_nth' 0); [ | now rewrite seq_length ].
    cbn - [ nth ].
    rewrite (List_map_nth' 0); [ | rewrite seq_length; flia Hj ].
    rewrite seq_nth; [ cbn | easy ].
    rewrite seq_nth; [ cbn | flia Hj ].
    easy.
  }
  easy.
}
rewrite rngl_add_comm.
erewrite rngl_summation_eq_compat. 2: {
  intros k Hk.
  assert (Hkn : k < fact n). {
    specialize (fact_neq_0 n) as Hnz.
    flia Hk Hnz.
  }
  rewrite rngl_mul_assoc.
  rewrite (rngl_mul_comm Hic b).
  erewrite rngl_product_eq_compat. 2: {
    intros j Hj.
    rewrite mat_el_repl_vect; cycle 1. {
      now apply (@squ_mat_is_corr n).
    } {
      rewrite Hv; flia Hj.
    } {
      apply is_sm_mat_iff in Hsm.
      destruct Hsm as (Hr, _).
      rewrite Hr; flia Hj.
    } {
      cbn.
      rewrite (List_map_nth' 0); [ cbn | now rewrite seq_length ].
      rewrite seq_nth; [ | easy ].
      rewrite (List_map_nth' 0); [ cbn | rewrite seq_length; flia Hj ].
      rewrite seq_nth; [ cbn | flia Hj ].
      rewrite Hcn.
      apply permut_elem_ub; [ easy | flia Hj ].
    } {
      now rewrite Hcn.
    }
    unfold vect_nat_el, vect_vect_nat_el; cbn.
    rewrite (List_map_nth' 0); [ | now rewrite seq_length ].
    cbn - [ nth ].
    rewrite (List_map_nth' 0); [ | rewrite seq_length; flia Hj ].
    rewrite seq_nth; [ cbn | easy ].
    rewrite seq_nth; [ cbn | flia Hj ].
    easy.
  }
  easy.
}
rewrite rngl_add_comm.
(* make one summation *)
rewrite <- rngl_summation_add_distr.
apply rngl_summation_eq_compat.
intros k Hk.
do 2 rewrite <- rngl_mul_assoc.
rewrite <- rngl_mul_add_distr_l.
(* elimination of the ε-s *)
f_equal.
(* *)
assert (Hkn : k < fact n). {
  specialize (fact_neq_0 n) as Hnz.
  flia Hk Hnz.
}
specialize (sym_gr_surjective Hkn Hi) as Hp.
destruct Hp as (p & Hp & Hpp).
rewrite (rngl_product_split (p + 1)); [ | flia Hp ].
rewrite rngl_product_split_last; [ | flia ].
erewrite rngl_product_eq_compat. 2: {
  intros j Hj.
  replace (j - 1 - 1) with (j - 2) by flia.
  destruct (Nat.eq_dec (mk_canon_sym_gr n k (j - 2)) i) as [Hpj| Hpj]. {
    exfalso.
    rewrite <- Hpp in Hpj.
    apply mk_canon_sym_gr_inj1 in Hpj; [ | easy | flia Hp Hj | easy ].
    flia Hj Hpj.
  }
  easy.
}
rewrite (rngl_mul_comm Hic (iter_seq _ _ _ _)).
rewrite rngl_add_comm.
rewrite (rngl_product_split (p + 1)); [ | flia Hp ].
rewrite rngl_product_split_last; [ | flia ].
erewrite rngl_product_eq_compat. 2: {
  intros j Hj.
  replace (j - 1 - 1) with (j - 2) by flia.
  destruct (Nat.eq_dec (mk_canon_sym_gr n k (j - 2)) i) as [Hpj| Hpj]. {
    exfalso.
    rewrite <- Hpp in Hpj.
    apply mk_canon_sym_gr_inj1 in Hpj; [ | easy | flia Hp Hj | easy ].
    flia Hj Hpj.
  }
  easy.
}
rewrite (rngl_mul_comm Hic (iter_seq _ _ _ _)).
rewrite rngl_add_comm.
symmetry.
rewrite (rngl_product_split (p + 1)); [ | flia Hp ].
rewrite rngl_product_split_last; [ | flia ].
erewrite rngl_product_eq_compat. 2: {
  intros j Hj.
  replace (j - 1 - 1) with (j - 2) by flia.
  destruct (Nat.eq_dec (mk_canon_sym_gr n k (j - 2)) i) as [Hpj| Hpj]. {
    exfalso.
    rewrite <- Hpp in Hpj.
    apply mk_canon_sym_gr_inj1 in Hpj; [ | easy | flia Hp Hj | easy ].
    flia Hj Hpj.
  }
  easy.
}
rewrite (rngl_mul_comm Hic (iter_seq _ _ _ _)).
rewrite Nat.add_sub.
cbn in Hpp.
rewrite Hpp.
destruct (Nat.eq_dec i i) as [H| H]; [ clear H | easy ].
do 4 rewrite rngl_mul_assoc.
subst UV.
cbn - [ mat_el vect_vect_nat_el ].
rewrite map2_nth with (a := 0%F) (b := 0%F); cycle 1. {
  now rewrite map_length, fold_vect_size, Hu.
} {
  now rewrite map_length, fold_vect_size, Hv.
}
rewrite (List_map_nth' 0%F); [ | now rewrite fold_vect_size, Hu ].
rewrite (List_map_nth' 0%F); [ | now rewrite fold_vect_size, Hv ].
do 2 rewrite fold_vect_el.
(* elimination of the following term (q) *)
remember
  (∏ (i0 = 2, p + 1), mat_el M (i0 - 2) (mk_canon_sym_gr n k (i0 - 2)))
  as q eqn:Hq.
rewrite (rngl_mul_mul_swap Hic _ _ q).
do 3 rewrite (rngl_mul_comm Hic _ q).
do 5 rewrite <- rngl_mul_assoc.
rewrite <- rngl_mul_add_distr_l.
f_equal.
clear q Hq.
erewrite rngl_product_eq_compat. 2: {
  intros j Hj.
  destruct (Nat.eq_dec (mk_canon_sym_gr n k (j - 1)) i) as [Hpj| Hpj]. {
    rewrite <- Hpp in Hpj.
    apply mk_canon_sym_gr_inj1 in Hpj; [ | easy | flia Hp Hj | easy ].
    flia Hj Hpj.
  }
  easy.
}
symmetry.
erewrite rngl_product_eq_compat. 2: {
  intros j Hj.
  destruct (Nat.eq_dec (mk_canon_sym_gr n k (j - 1)) i) as [Hpj| Hpj]. {
    rewrite <- Hpp in Hpj.
    apply mk_canon_sym_gr_inj1 in Hpj; [ | easy | flia Hp Hj | easy ].
    flia Hj Hpj.
  }
  easy.
}
rewrite rngl_add_comm.
erewrite rngl_product_eq_compat. 2: {
  intros j Hj.
  destruct (Nat.eq_dec (mk_canon_sym_gr n k (j - 1)) i) as [Hpj| Hpj]. {
    rewrite <- Hpp in Hpj.
    apply mk_canon_sym_gr_inj1 in Hpj; [ | easy | flia Hp Hj | easy ].
    flia Hj Hpj.
  }
  easy.
}
cbn.
rewrite rngl_add_comm.
do 2 rewrite rngl_mul_assoc.
now rewrite <- rngl_mul_add_distr_r.
Qed.

(* list of terms in determinant' (determinant by sum of products of
   permutations *)

Definition determinant'_list n (M : matrix T) :=
  map (λ k,
    (ε_permut n k *
     ∏ (i = 1, n),
     mat_el M (i - 1)
       (vect_nat_el (vect_vect_nat_el (mk_canon_sym_gr_vect n) k) (i - 1)%nat))%F)
    (seq 0 n!).

Arguments determinant'_list n%nat M%M.

Theorem determinant'_by_list :
  rngl_is_comm = true →
  rngl_has_opp = true →
  rngl_has_inv = true →
  rngl_has_1_neq_0 = true →
  rngl_is_integral = true →
  rngl_has_dec_eq = true →
  rngl_characteristic = 0 →
  ∀ n (M : matrix T),
  determinant' n M = ∑ (k = 0, fact n - 1), nth k (determinant'_list n M) 0.
Proof.
intros Hic Hop Hin H10 Hit Hde Hch *.
unfold determinant', determinant'_list.
apply rngl_summation_eq_compat; intros k Hk.
assert (Hkn : k < fact n). {
  specialize (fact_neq_0 n) as Hn.
  flia Hk Hn.
}
rewrite List_map_nth' with (a := 0); [ | now rewrite seq_length ].
rewrite seq_nth; [ | easy ].
rewrite Nat.add_0_l.
f_equal.
now apply ε_of_permut_ε.
Qed.

Theorem det_is_det_by_any_permut :
  rngl_is_comm = true →
  rngl_has_opp = true →
  rngl_has_inv = true →
  rngl_is_integral = true →
  rngl_has_1_neq_0 = true →
  rngl_has_dec_eq = true →
  rngl_characteristic = 0 →
  ∀ n (M : matrix T) l,
  is_square_matrix n M = true
  → Permutation l (determinant'_list n M)
  → determinant n M = ∑ (k = 0, fact n - 1), nth k l 0.
Proof.
intros Hic Hop Hin Hit H10 Hde Hch * Hsm Hl.
rewrite det_is_det_by_canon_permut; try easy.
rewrite determinant'_by_list; try easy.
apply rngl_summation_permut; [ now symmetry | | ]. {
  unfold determinant'_list.
  now rewrite List_map_seq_length.
} {
  apply Permutation_length in Hl.
  unfold determinant'_list in Hl.
  now rewrite List_map_seq_length in Hl.
}
Qed.

(* yet another definition of determinant *)

Definition determinant'' p q n (M : matrix T) :=
  ∑ (k = 0, fact n - 1),
    ε_permut n k *
    ∏ (i = 1, n),
    mat_el M (i - 1) (vect_nat_el (sym_gr_elem_swap_last p q n k) (i - 1)).

Definition determinant''_list p q n (M : matrix T) :=
  map (λ k,
    (ε_permut n k *
     ∏ (i = 1, n),
     mat_el M (i - 1) (vect_nat_el (sym_gr_elem_swap_last p q n k) (i - 1)))%F)
    (seq 0 (fact n)).

Theorem determinant''_by_list : ∀ n p q (M : matrix T),
  determinant'' p q n M =
    ∑ (k = 0, fact n - 1), nth k (determinant''_list p q n M) 0.
Proof.
intros.
unfold determinant'', determinant''_list.
apply rngl_summation_eq_compat; intros k Hk.
assert (Hkn : k < fact n). {
  specialize (fact_neq_0 n) as Hn.
  flia Hk Hn.
}
rewrite (List_map_nth' 0); [ | now rewrite seq_length ].
rewrite seq_nth; [ | easy ].
now rewrite Nat.add_0_l.
Qed.

Definition list_swap_scal {A} d i1 i2 (l : list A) :=
  map (λ i, nth (transposition i1 i2 i) l d) (seq 0 (length l)).

Definition mat_swap_rows i1 i2 (M : matrix T) :=
  mk_mat (list_swap_scal [] i1 i2 (mat_list_list M)).

Theorem list_swap_scal_0_succ_cons : ∀ A (d : A) j a l,
  list_swap_scal d 0 (S j) (a :: l) =
  nth j l d :: map (λ i, if i =? j then a else nth i l d) (seq 0 (length l)).
Proof.
intros.
cbn - [ nth ].
f_equal.
rewrite <- seq_shift, map_map.
apply map_ext_in.
intros i Hi; apply in_seq in Hi.
unfold transposition.
cbn - [ nth ].
do 2 rewrite if_eqb_eq_dec.
now destruct (Nat.eq_dec i j).
Qed.

Theorem mat_swap_rows_is_square : ∀ n (M : matrix T) p q,
  p < n
  → q < n
  → is_square_matrix n M = true
  → is_square_matrix n (mat_swap_rows p q M) = true.
Proof.
intros * Hp Hq Hsm.
specialize (square_matrix_ncols _ Hsm) as Hcn.
specialize (squ_mat_is_corr M Hsm) as Hco.
apply is_sm_mat_iff in Hsm.
apply is_sm_mat_iff.
destruct Hsm as (Hr & Hcr & Hc).
cbn; unfold list_swap_scal.
rewrite List_map_seq_length.
unfold mat_swap_rows, list_swap_scal; cbn.
split; [ easy | ].
split. {
  destruct (Nat.eq_dec (mat_nrows M) 0) as [Hrz| Hrz]; [ easy | ].
  apply Nat.neq_0_lt_0 in Hrz.
  unfold mat_ncols; cbn.
  rewrite List_hd_nth_0.
  rewrite (List_map_nth' 0); [ | now rewrite seq_length ].
  rewrite seq_nth; [ | easy ].
  rewrite Nat.add_0_l.
  rewrite Hc; [ now intros Hn; subst n | ].
  apply nth_In; rewrite fold_mat_nrows; rewrite Hr.
  unfold transposition.
  do 2 rewrite if_eqb_eq_dec.
  destruct (Nat.eq_dec 0 p); [ easy | ].
  destruct (Nat.eq_dec 0 q); [ easy | ].
  flia Hp.
} {
  intros la Hla.
  apply in_map_iff in Hla.
  rewrite fold_mat_nrows, Hr in Hla.
  destruct Hla as (a & Ha & Hla).
  apply in_seq in Hla; subst la.
  rewrite fold_corr_mat_ncols; [ easy | easy | rewrite Hr ].
  unfold transposition.
  do 2 rewrite if_eqb_eq_dec.
  destruct (Nat.eq_dec a p); [ easy | ].
  destruct (Nat.eq_dec a q); [ easy | ].
  easy.
}
Qed.

Theorem mat_swap_rows_nrows : ∀ (M : matrix T) p q,
  mat_nrows (mat_swap_rows p q M) = mat_nrows M.
Proof.
intros.
unfold mat_swap_rows; cbn.
unfold list_swap_scal.
rewrite map_length.
now rewrite seq_length.
Qed.

Theorem corr_mat_swap_rows_ncols : ∀ (M : matrix T) p q,
  p < mat_nrows M
  → q < mat_nrows M
  → is_correct_matrix M
  → mat_ncols (mat_swap_rows p q M) = mat_ncols M.
Proof.
intros * Hp Hq Hcm.
destruct (Nat.eq_dec (mat_nrows M) 0) as [Hrz| Hrz]. {
  unfold mat_nrows in Hrz.
  apply length_zero_iff_nil in Hrz.
  unfold mat_ncols; cbn.
  now rewrite Hrz.
}
apply Nat.neq_0_lt_0 in Hrz.
unfold mat_swap_rows; cbn.
unfold list_swap_scal.
unfold mat_ncols; cbn.
rewrite List_hd_nth_0.
rewrite (List_map_nth' 0); [ | now rewrite seq_length ].
rewrite seq_nth; [ | easy ].
rewrite Nat.add_0_l.
unfold transposition.
do 2 rewrite if_eqb_eq_dec.
destruct (Nat.eq_dec 0 p) as [Hzp| Hzp]. {
  now rewrite fold_corr_mat_ncols.
}
destruct (Nat.eq_dec 0 q) as [Hzq| Hzq]. {
  now rewrite fold_corr_mat_ncols.
}
now rewrite List_hd_nth_0.
Qed.

Theorem is_permut_mk_canon_transp : ∀ n k p q,
  k < n!
  → p < n
  → q < n
  → is_permut (λ j : nat, mk_canon_sym_gr n k (transposition p q j)) n.
Proof.
intros * Hkn Hpn Hqn.
split. {
  intros j Hj.
  apply permut_elem_ub; [ easy | ].
  now apply transposition_lt.
} {
  intros u v Hu Hv Huv.
  assert (Htu : transposition p q u < n) by now apply transposition_lt.
  assert (Htv : transposition p q v < n) by now apply transposition_lt.
  apply mk_canon_sym_gr_inj1 in Huv; [ | easy | easy | easy ].
  now apply transposition_injective in Huv.
}
Qed.

Theorem determinant_alternating :
  rngl_is_comm = true →
  rngl_has_opp = true →
  rngl_has_inv = true →
  rngl_is_integral = true →
  rngl_has_1_neq_0 = true →
  rngl_has_dec_eq = true →
  rngl_characteristic = 0 →
  ∀ n (M : matrix T) p q,
  p ≠ q
  → p < n
  → q < n
  → is_square_matrix n M = true
  → determinant n (mat_swap_rows p q M) = (- determinant n M)%F.
Proof.
intros Hic Hop Hin Hit H10 Hde Hch * Hpq Hp Hq Hsm.
rewrite det_is_det_by_canon_permut; try easy. 2: {
  now apply mat_swap_rows_is_square.
}
unfold determinant'.
erewrite rngl_summation_eq_compat. 2: {
  intros k Hk.
  rewrite rngl_product_shift; [ | flia Hp ].
  erewrite rngl_product_eq_compat. 2: {
    intros i Hi.
    now rewrite Nat.add_comm, Nat.add_sub.
  }
  easy.
}
cbn - [ mat_swap_rows ].
erewrite rngl_summation_eq_compat. 2: {
  intros k Hk.
  rewrite rngl_product_change_var with
    (g := transposition p q) (h := transposition p q). 2: {
    intros i Hi.
    apply transposition_involutive.
  }
  rewrite Nat.sub_0_r.
  rewrite <- Nat.sub_succ_l; [ | flia Hp ].
  rewrite Nat_sub_succ_1.
  easy.
}
cbn - [ mat_swap_rows ].
erewrite rngl_summation_eq_compat. 2: {
  intros k Hk.
  rewrite rngl_product_list_permut with (l2 := seq 0 n); [ | easy | ]. 2: {
    apply permut_fun_Permutation.
    now apply transposition_is_permut.
  }
  easy.
}
cbn - [ mat_swap_rows ].
erewrite rngl_summation_eq_compat. 2: {
  intros k Hk.
  assert (Hkn : k < fact n). {
    specialize (fact_neq_0 n) as Hn.
    flia Hk Hn.
  }
  erewrite rngl_product_list_eq_compat. 2: {
    intros i Hi.
    replace (mat_el _ _ _) with
      (mat_el M i
         (vect_nat_el (vect_vect_nat_el (mk_canon_sym_gr_vect n) k)
            (transposition p q i))). 2: {
      cbn.
      rewrite (List_map_nth' 0); [ | now rewrite seq_length ].
      rewrite seq_nth; [ cbn | easy ].
      assert (Ht : transposition p q i < length (seq 0 n)). {
        rewrite seq_length.
        unfold transposition.
        do 2 rewrite if_eqb_eq_dec.
        destruct (Nat.eq_dec i p) as [Hip| Hip]; [ now subst p | ].
        destruct (Nat.eq_dec i q) as [Hiq| Hiq]; [ now subst q | ].
        now apply in_seq in Hi.
      }
      rewrite (List_map_nth' 0); [ | easy ].
      unfold list_swap_scal.
      rewrite fold_mat_nrows.
      apply is_sm_mat_iff in Hsm.
      destruct Hsm as (Hr, _).
      rewrite Hr.
      rewrite (List_map_nth' 0); [ | easy ].
      unfold transposition.
      do 2 rewrite if_eqb_eq_dec.
      destruct (Nat.eq_dec i p) as [Hip| Hip]. {
        subst i.
        rewrite seq_nth; [ | easy ].
        rewrite Nat.add_0_l.
        rewrite Nat.eqb_refl.
        rewrite if_eqb_eq_dec.
        apply Nat.neq_sym in Hpq.
        now destruct (Nat.eq_dec q p).
      }
      destruct (Nat.eq_dec i q) as [Hiq| Hiq]. {
        subst i.
        rewrite seq_nth; [ | easy ].
        rewrite Nat.add_0_l.
        now rewrite Nat.eqb_refl.
      }
      apply in_seq in Hi.
      rewrite seq_nth; [ | easy ].
      rewrite Nat.add_0_l.
      do 2 rewrite if_eqb_eq_dec.
      destruct (Nat.eq_dec i p) as [H| H]; [ easy | clear H ].
      now destruct (Nat.eq_dec i q).
    }
    easy.
  }
  rewrite (List_map_nth' 0); [ | now rewrite seq_length ].
  rewrite seq_nth; [ | easy ].
  rewrite Nat.add_0_l.
  easy.
}
set
  (f :=
   λ k, vect_swap_elem (vect_vect_nat_el (mk_canon_sym_gr_vect n) k) p q).
erewrite rngl_summation_eq_compat. 2: {
  intros k Hk.
  assert (Hkn : k < n!). {
    specialize (fact_neq_0 n) as Hn.
    flia Hk Hn.
  }
  erewrite rngl_product_seq_product; [ | flia Hp ].
  rewrite Nat.add_0_l.
  erewrite rngl_product_eq_compat. 2: {
    intros i Hi; cbn.
    rewrite (List_map_nth' 0); [ cbn | now rewrite seq_length ].
    rewrite (List_map_nth' 0). 2: {
      rewrite seq_length.
      apply transposition_lt; [ easy | easy | flia Hi Hp ].
    }
    rewrite seq_nth; [ | easy ].
    rewrite Nat.add_0_l.
    rewrite seq_nth. 2: {
      apply transposition_lt; [ easy | easy | flia Hi Hp ].
    }
    rewrite Nat.add_0_l.
    replace (mk_canon_sym_gr _ _ _) with (vect_nat_el (f k) i). 2: {
      unfold f; cbn.
      rewrite (List_map_nth' 0). 2: {
        rewrite seq_length.
        rewrite (List_map_nth' 0); [ cbn | now rewrite seq_length ].
        rewrite List_map_seq_length; flia Hi Hp.
      }
      rewrite (List_map_nth' 0); cbn; [ | now rewrite seq_length ].
      rewrite List_map_seq_length.
      rewrite (List_map_nth' 0). 2: {
        rewrite seq_length.
        rewrite seq_nth; [ | flia Hi Hp ].
        apply transposition_lt; [ easy | easy | flia Hi Hp ].
      }
      rewrite seq_nth; [ | easy ].
      rewrite seq_nth. 2: {
        rewrite seq_nth; [ | flia Hi Hp ].
        apply transposition_lt; [ easy | easy | flia Hi Hp ].
      }
      rewrite seq_nth; [ easy | flia Hi Hp ].
    }
    easy.
  }
  cbn - [ f ].
  replace ({| vect_list := map (mk_canon_sym_gr n k) (seq 0 n) |}) with
    (mk_vect
       (map (λ i, vect_nat_el (f k) (transposition p q i)) (seq 0 n))). 2: {
    f_equal.
    apply map_ext_in.
    intros i Hi; cbn.
    apply in_seq in Hi.
    rewrite (List_map_nth' 0). 2: {
      rewrite seq_length.
      rewrite (List_map_nth' 0); [ cbn | now rewrite seq_length ].
      rewrite List_map_seq_length.
      now apply transposition_lt.
    }
    rewrite (List_map_nth' 0); [ cbn | now rewrite seq_length ].
    rewrite List_map_seq_length.
    rewrite seq_nth; [ | now apply transposition_lt ].
    rewrite Nat.add_0_l.
    rewrite transposition_involutive.
    rewrite (List_map_nth' 0); [ | now rewrite seq_length ].
    rewrite seq_nth; [ | easy ].
    rewrite seq_nth; [ | easy ].
    easy.
  }
  replace
    (mk_vect (map (λ i, vect_nat_el (f k) (transposition p q i)) (seq 0 n)))
  with (f k ° mk_vect (map (λ i, transposition p q i) (seq 0 n))). 2: {
    unfold "°"; f_equal; cbn.
    now rewrite map_map.
  }
  rewrite signature_comp; try easy. {
    split. {
      cbn; rewrite map_length, seq_length.
      rewrite (List_map_nth' 0); [ | now rewrite seq_length ].
      now cbn; rewrite map_length, seq_length.
    }
    unfold f; cbn.
    split; cbn. {
      intros i Hi.
      rewrite (List_map_nth' 0). 2: {
        rewrite seq_length.
        rewrite (List_map_nth' 0); [ cbn | now rewrite seq_length ].
        now rewrite List_map_seq_length.
      }
      rewrite (List_map_nth' 0); [ cbn | now rewrite seq_length ].
      rewrite List_map_seq_length.
      rewrite seq_nth; [ | easy ].
      rewrite seq_nth; [ cbn | easy ].
      rewrite (List_map_nth' 0). 2: {
        rewrite seq_length.
        now apply transposition_lt.
      }
      apply permut_elem_ub; [ easy | ].
      now rewrite seq_nth; apply transposition_lt.
    }
    intros i j Hi Hj Hij.
    rewrite (List_map_nth' 0) in Hij. 2: {
      rewrite seq_length.
      rewrite (List_map_nth' 0); [ cbn | now rewrite seq_length ].
      now rewrite List_map_seq_length.
    }
    rewrite (List_map_nth' 0) in Hij; [ cbn in Hij | now rewrite seq_length ].
    rewrite List_map_seq_length in Hij.
    rewrite seq_nth in Hij; [ | easy ].
    rewrite seq_nth in Hij; [ | easy ].
    rewrite (List_map_nth' 0) in Hij. 2: {
      rewrite seq_length.
      now apply transposition_lt.
    }
    rewrite (List_map_nth' 0) in Hij; [ | now rewrite seq_length ].
    rewrite (List_map_nth' 0) in Hij. 2: {
      rewrite seq_length.
      rewrite seq_nth; [ | easy ].
      now apply transposition_lt.
    }
    rewrite seq_nth in Hij; [ | now apply transposition_lt ].
    rewrite seq_nth in Hij. 2: {
      rewrite seq_nth; [ | easy ].
      now apply transposition_lt.
    }
    rewrite seq_nth in Hij; [ | easy ].
    cbn in Hij.
    apply mk_canon_sym_gr_inj1 in Hij; [ | easy | | ]; cycle 1. {
      now apply transposition_lt.
    } {
      now apply transposition_lt.
    }
    now apply transposition_injective in Hij.
  }
  split; [ now cbn; rewrite map_length, seq_length | ].
  split. {
    intros i Hi; cbn.
    rewrite (List_map_nth' 0); [ | now rewrite seq_length ].
    rewrite seq_nth; [ | easy ].
    now apply transposition_lt.
  }
  intros i j Hi Hj Hij; cbn in Hij.
  rewrite (List_map_nth' 0) in Hij; [ | now rewrite seq_length ].
  rewrite (List_map_nth' 0) in Hij; [ | now rewrite seq_length ].
  rewrite seq_nth in Hij; [ | easy ].
  rewrite seq_nth in Hij; [ | easy ].
  now apply transposition_injective in Hij.
}
cbn - [ f ].
erewrite rngl_summation_eq_compat. 2: {
  intros k (_, Hk).
  rewrite (rngl_mul_comm Hic (ε n (f k))).
  rewrite <- rngl_mul_assoc.
  now rewrite transposition_signature.
}
cbn - [ f ].
rewrite <- rngl_mul_summation_distr_l; [ | now left ].
rewrite rngl_mul_opp_l; [ | easy ].
f_equal.
rewrite rngl_mul_1_l.
symmetry.
set (g := λ k, rank_of_permut_in_sym_gr_vect n (f k)).
rewrite rngl_summation_change_var with (g0 := g) (h := g). 2: {
  intros k (_, Hk).
  assert (Hkn : k < n!). {
    specialize (fact_neq_0 n) as Hn.
    flia Hk Hn.
  }
  unfold g, f.
  unfold rank_of_permut_in_sym_gr_vect; cbn.
  rewrite (List_map_nth' 0). 2: {
    rewrite seq_length.
    apply rank_of_permut_upper_bound.
    rewrite (List_map_nth' 0); [ | now rewrite seq_length ].
    rewrite seq_nth; [ | easy ].
    rewrite Nat.add_0_l.
    unfold vect_swap_elem; cbn.
    unfold vect_nat_el; cbn.
    rewrite List_map_seq_length.
    eapply is_permut_eq_compat. {
      intros i Hi; symmetry.
      rewrite (List_map_nth' 0); [ | now rewrite seq_length ].
      rewrite seq_nth; [ | easy ].
      rewrite Nat.add_0_l.
      rewrite (List_map_nth' 0). 2: {
        unfold vect_nat_el.
        rewrite seq_length.
        now apply transposition_lt.
      }
      rewrite seq_nth; [ | now apply transposition_lt ].
      now rewrite Nat.add_0_l.
    }
    split. {
      intros i Hi.
      apply permut_elem_ub; [ easy | now apply transposition_lt ].
    } {
      intros i j Hi Hj Hij.
      assert (Hti : transposition p q i < n) by now apply transposition_lt.
      assert (Htj : transposition p q j < n) by now apply transposition_lt.
      apply mk_canon_sym_gr_inj1 in Hij; [ | easy | easy | easy ].
      now apply transposition_injective in Hij.
    }
  }
  rewrite (List_map_nth' 0); [ | now rewrite seq_length ].
  unfold vect_swap_elem; cbn.
  do 2 rewrite List_map_seq_length.
  unfold vect_nat_el; cbn.
  erewrite rank_of_permut_in_sym_gr_eq_compat. 2: {
    intros i Hi.
    rewrite (List_map_nth' 0); [ | now rewrite seq_length ].
    rewrite (List_map_nth' 0). 2: {
      rewrite seq_length.
      rewrite seq_nth; [ | easy ].
      now apply transposition_lt.
    }
    rewrite seq_nth. 2: {
      apply rank_of_permut_upper_bound.
      eapply is_permut_eq_compat. {
        intros j Hj; symmetry.
        rewrite (List_map_nth' 0); [ | now rewrite seq_length ].
        rewrite seq_nth; [ | easy ].
        rewrite (List_map_nth' 0). 2: {
          rewrite seq_length.
          now apply transposition_lt.
        }
        rewrite seq_nth; [ | easy ].
        rewrite seq_nth; [ | now apply transposition_lt ].
        now do 3 rewrite Nat.add_0_l.
      }
      now apply is_permut_mk_canon_transp.
    }
    rewrite Nat.add_0_l.
    erewrite rank_of_permut_in_sym_gr_eq_compat. 2: {
      intros j Hj.
      rewrite (List_map_nth' 0); [ | now rewrite seq_length ].
      rewrite seq_nth; [ | easy ].
      rewrite (List_map_nth' 0). 2: {
        rewrite seq_length.
        now apply transposition_lt.
      }
      rewrite seq_nth; [ | easy ].
      rewrite seq_nth; [ | now apply transposition_lt ].
      now do 3 rewrite Nat.add_0_l.
    }
    rewrite seq_nth. 2: {
      rewrite seq_nth; [ | easy ].
      now apply transposition_lt.
    }
    rewrite seq_nth; [ | easy ].
    now do 2 rewrite Nat.add_0_l.
  }
  erewrite rank_of_permut_in_sym_gr_eq_compat. 2: {
    intros i Hi.
    rewrite permut_in_sym_gr_of_its_rank; [ easy | | ]. 2: {
      now apply transposition_lt.
    }
    now apply is_permut_mk_canon_transp.
  }
  erewrite rank_of_permut_in_sym_gr_eq_compat. 2: {
    intros i Hi.
    now rewrite transposition_involutive.
  }
  now apply rank_of_permut_of_rank.
}
rewrite Nat.sub_0_r.
rewrite <- Nat.sub_succ_l; [ | apply Nat.neq_0_lt_0, fact_neq_0 ].
rewrite Nat_sub_succ_1.
rewrite rngl_summation_list_permut with (l2 := seq 0 n!); [ | easy | ]. 2: {
  apply permut_fun_Permutation.
  unfold g, f.
  eapply is_permut_eq_compat. {
    intros j Hj; symmetry; cbn.
    rewrite (List_map_nth' 0); [ | now rewrite seq_length ].
    rewrite seq_nth; [ cbn | easy ].
    easy.
  }
  split. {
    intros i Hi.
    unfold rank_of_permut_in_sym_gr_vect.
    unfold vect_nat_el; cbn.
    erewrite rank_of_permut_in_sym_gr_eq_compat. 2: {
      intros u Hu.
      rewrite (List_map_nth' 0); [ | now rewrite List_map_seq_length, seq_length ].
      rewrite List_map_seq_length.
      rewrite seq_nth; [ cbn | easy ].
      rewrite (List_map_nth' 0). 2: {
        rewrite seq_length.
        now apply transposition_lt.
      }
      rewrite seq_nth; [ cbn | now apply transposition_lt ].
      easy.
    }
    apply rank_of_permut_upper_bound.
    now apply is_permut_mk_canon_transp.
  } {
    intros i j Hi Hj Hij.
    unfold vect_swap_elem in Hij.
    cbn in Hij.
    unfold rank_of_permut_in_sym_gr_vect in Hij.
    unfold vect_nat_el in Hij.
    cbn in Hij.
    erewrite rank_of_permut_in_sym_gr_eq_compat in Hij. 2: {
      intros u Hu.
      rewrite (List_map_nth' 0); [ | now rewrite List_map_seq_length, seq_length ].
      rewrite List_map_seq_length.
      rewrite seq_nth; [ cbn | easy ].
      rewrite (List_map_nth' 0). 2: {
        rewrite seq_length.
        now apply transposition_lt.
      }
      rewrite seq_nth; [ cbn | now apply transposition_lt ].
      easy.
    }
    symmetry in Hij.
    erewrite rank_of_permut_in_sym_gr_eq_compat in Hij. 2: {
      intros u Hu.
      rewrite (List_map_nth' 0); [ | now rewrite List_map_seq_length, seq_length ].
      rewrite List_map_seq_length.
      rewrite seq_nth; [ cbn | easy ].
      rewrite (List_map_nth' 0). 2: {
        rewrite seq_length.
        now apply transposition_lt.
      }
      rewrite seq_nth; [ cbn | now apply transposition_lt ].
      easy.
    }
    symmetry in Hij.
    specialize (is_permut_mk_canon_transp Hi Hp Hq) as Hf.
    specialize (is_permut_mk_canon_transp Hj Hp Hq) as Hg.
    specialize (rank_of_permut_injective Hf Hg Hij) as H1.
    cbn in H1.
    specialize (H1 p Hp) as Hp1.
    specialize (H1 q Hq) as Hq1.
    rewrite transposition_1 in Hp1.
    rewrite transposition_2 in Hq1.
    apply (mk_canon_sym_gr_inj2 Hi Hj).
    intros k Hk.
    specialize (H1 k Hk).
    destruct (Nat.eq_dec k p) as [Hkp| Hkp]; [ now subst k | ].
    destruct (Nat.eq_dec k q) as [Hkq| Hkq]; [ now subst k | ].
    now rewrite transposition_out in H1.
  }
}
erewrite rngl_summation_list_eq_compat. 2: {
  intros k Hk.
  assert (Hkn : k < n!). {
    apply in_seq in Hk.
    specialize (fact_neq_0 n) as Hn.
    flia Hk Hn.
  }
  unfold g, f.
  unfold mk_canon_sym_gr_vect at 1.
  unfold vect_vect_nat_el at 1.
  cbn - [ vect_vect_nat_el vect_nat_el ].
  assert (Hps :
    is_permut
      (vect_nat_el
         (vect_swap_elem (vect_vect_nat_el (mk_canon_sym_gr_vect n) k) p q))
      n). {
    eapply is_permut_eq_compat. {
      intros i Hi; symmetry.
      unfold vect_nat_el; cbn.
      rewrite (List_map_nth' 0). 2: {
        rewrite seq_length.
        rewrite (List_map_nth' 0); [ cbn | now rewrite seq_length ].
        now rewrite List_map_seq_length.
      }
      rewrite (List_map_nth' 0); [ cbn | now rewrite seq_length ].
      rewrite seq_nth; [ | now rewrite List_map_seq_length ].
      rewrite seq_nth; [ cbn | easy ].
      rewrite (List_map_nth' 0). 2: {
        rewrite seq_length.
        now apply transposition_lt.
      }
      rewrite seq_nth; [ cbn | now apply transposition_lt ].
      easy.
    }
    now apply is_permut_mk_canon_transp.
  }
  assert
  (Hrpq :
     rank_of_permut_in_sym_gr_vect n
       (vect_swap_elem (vect_vect_nat_el (mk_canon_sym_gr_vect n) k) p q) <
     n!). {
    unfold rank_of_permut_in_sym_gr_vect.
    now apply rank_of_permut_upper_bound.
  }
  rewrite (List_map_nth' 0); [ | now rewrite seq_length ].
  rewrite seq_nth; [ | easy ].
  rewrite Nat.add_0_l.
  unfold rank_of_permut_in_sym_gr_vect.
  erewrite map_ext_in. 2: {
    intros i Hi.
    apply in_seq in Hi.
    unfold rank_of_permut_in_sym_gr_vect in Hrpq.
    rewrite permut_in_sym_gr_of_its_rank; [ cbn | easy | easy ].
    rewrite (List_map_nth' 0). 2: {
      rewrite seq_length.
      rewrite (List_map_nth' 0); [ cbn | now rewrite seq_length ].
      now rewrite List_map_seq_length.
    }
    rewrite (List_map_nth' 0); [ cbn | now rewrite seq_length ].
    rewrite List_map_seq_length.
    rewrite seq_nth; [ | easy ].
    rewrite seq_nth; [ | easy ].
    rewrite (List_map_nth' 0). 2: {
      rewrite seq_length.
      now apply transposition_lt.
    }
    rewrite seq_nth; [ cbn | now apply transposition_lt ].
    easy.
  }
  easy.
}
rewrite det_is_det_by_canon_permut; try easy.
unfold determinant'.
rewrite rngl_summation_seq_summation; [ | apply fact_neq_0 ].
rewrite Nat.add_0_l.
apply rngl_summation_eq_compat.
intros k Hk.
assert (Hkn : k < n!). {
  specialize (fact_neq_0 n) as Hn.
  flia Hk Hn.
}
f_equal. {
  cbn.
  rewrite (List_map_nth' 0); [ | now rewrite seq_length ].
  rewrite seq_nth; [ cbn | easy ].
  unfold vect_swap_elem; cbn.
  rewrite List_map_seq_length.
  f_equal; f_equal.
  apply map_ext_in.
  intros i Hi.
  apply in_seq in Hi.
  rewrite (List_map_nth' 0). 2: {
    rewrite seq_length.
    now apply transposition_lt.
  }
  rewrite seq_nth; [ | now apply transposition_lt ].
  rewrite Nat.add_0_l.
  now rewrite transposition_involutive.
}
rewrite rngl_product_shift; [ | flia Hp ].
apply rngl_product_eq_compat.
intros i Hi.
rewrite Nat.add_comm, Nat.add_sub.
unfold vect_swap_elem at 1.
cbn - [ vect_vect_nat_el ].
assert
  (Hrg :
   rank_of_permut_in_sym_gr n
     (vect_nat_el
        (vect_swap_elem {| vect_list := map (mk_canon_sym_gr n k) (seq 0 n) |}
           p q)) < n!). {
  unfold vect_nat_el.
  apply rank_of_permut_upper_bound; cbn.
  rewrite List_map_seq_length.
  eapply is_permut_eq_compat. {
    intros j Hj; symmetry.
    rewrite (List_map_nth' 0); [ | now rewrite seq_length ].
    rewrite seq_nth; [ | easy ].
    rewrite (List_map_nth' 0). 2: {
      rewrite seq_length.
      now apply transposition_lt.
    }
    rewrite seq_nth; [ cbn | now apply transposition_lt ].
    easy.
  }
  now apply is_permut_mk_canon_transp.
}
assert (Hi' : i < n) by flia Hi Hp.
rewrite (List_map_nth' 0). 2: {
  rewrite seq_length; cbn.
  rewrite (List_map_nth' 0). 2: {
    rewrite (List_map_nth' 0); [ | now rewrite seq_length ].
    rewrite seq_length.
    rewrite seq_nth; [ cbn | easy ].
    apply Hrg.
  }
  cbn.
  now rewrite List_map_seq_length.
}
rewrite seq_nth. 2: {
  cbn.
  rewrite (List_map_nth' 0). 2: {
    rewrite seq_length.
    rewrite (List_map_nth' 0); [ | now rewrite seq_length ].
    now rewrite seq_nth.
  }
  cbn.
  now rewrite List_map_seq_length.
}
cbn.
rewrite (List_map_nth' 0); [ cbn | now rewrite seq_length ].
rewrite seq_nth; [ | easy ].
rewrite (List_map_nth' 0); [ cbn | now rewrite seq_length ].
rewrite seq_nth; [ cbn | easy ].
rewrite (List_map_nth' 0); [ cbn | now rewrite seq_length ].
rewrite (List_map_nth' 0). 2: {
  rewrite seq_length.
  now apply transposition_lt.
}
rewrite seq_nth; [ cbn | easy ].
rewrite seq_nth; [ cbn | now apply transposition_lt ].
rewrite permut_in_sym_gr_of_its_rank; cycle 1. {
  unfold vect_nat_el.
  eapply is_permut_eq_compat. {
    intros j Hj; symmetry; cbn.
    rewrite (List_map_nth' 0); [ | now rewrite List_map_seq_length, seq_length ].
    rewrite seq_nth; [ | now rewrite List_map_seq_length ].
    rewrite (List_map_nth' 0). 2: {
      rewrite seq_length.
      now apply transposition_lt.
    }
    rewrite seq_nth; [ cbn | now apply transposition_lt ].
    easy.
  }
  now apply is_permut_mk_canon_transp.
} {
  now apply transposition_lt.
}
cbn.
rewrite List_map_seq_length.
rewrite (List_map_nth' 0). 2: {
  rewrite seq_length.
  now apply transposition_lt.
}
rewrite seq_nth; [ cbn | now apply transposition_lt ].
rewrite transposition_involutive.
rewrite (List_map_nth' 0); [ | now rewrite seq_length ].
now rewrite seq_nth.
Qed.

Theorem determinant_same_rows :
  rngl_is_comm = true →
  rngl_has_opp = true →
  rngl_has_inv = true →
  rngl_is_integral = true →
  rngl_has_1_neq_0 = true →
  rngl_has_dec_eq = true →
  rngl_characteristic = 0 →
  ∀ n (M : matrix T) p q,
  is_square_matrix n M = true
  → p ≠ q
  → p < n
  → q < n
  → (∀ j, mat_el M p j = mat_el M q j)
  → determinant n M = 0%F.
Proof.
intros Hic Hop Hin Hit H10 Hde Hch * Hsm Hpq Hpn Hqn Hjpq.
specialize (square_matrix_ncols M Hsm) as Hc.
assert (HM : determinant n M = (- determinant n M)%F). {
  rewrite <- determinant_alternating with (p := p) (q := q); try easy.
  f_equal.
  apply matrix_eq.
  intros i j.
  unfold nth_nth_error.
  remember (nth_error (mat_list_list M) i) as x eqn:Hx; symmetry in Hx.
  remember (nth_error (mat_list_list (mat_swap_rows p q M)) i)
    as y eqn:Hy; symmetry in Hy.
  destruct x as [la| ]. {
    apply List_nth_error_Some_iff with (d := []) in Hx.
    destruct Hx as (Hla & Hi).
    destruct y as [lb|]. {
      f_equal.
      apply List_nth_error_Some_iff with (d := []) in Hy.
      destruct Hy as (Hlb & Hi').
      remember (nth_error la j) as xx eqn:Hxx; symmetry in Hxx.
      remember (nth_error lb j) as yy eqn:Hyy; symmetry in Hyy.
      destruct xx as [xx| ]. {
        apply List_nth_error_Some_iff with (d := 0%F) in Hxx.
        destruct Hxx as (Hxx & Hj).
        destruct yy as [yy| ]. {
          apply List_nth_error_Some_iff with (d := 0%F) in Hyy.
          destruct Hyy as (Hyy & Hj').
          f_equal; subst xx yy.
          subst la lb.
          unfold mat_swap_rows; cbn.
          unfold list_swap_scal.
          rewrite (List_map_nth' 0); [ | now rewrite seq_length ].
          rewrite seq_nth; [ | easy ].
          rewrite Nat.add_0_l.
          unfold transposition.
          do 2 rewrite if_eqb_eq_dec.
          destruct (Nat.eq_dec i p) as [Hip| Hip]. {
            subst i.
            now rewrite fold_mat_el, Hjpq.
          }
          destruct (Nat.eq_dec i q) as [Hiq| Hiq]. {
            subst i.
            now rewrite fold_mat_el, <- Hjpq.
          }
          easy.
        }
        exfalso.
        apply nth_error_None in Hyy.
        apply Nat.nlt_ge in Hyy; apply Hyy; clear Hyy.
        subst lb.
        rewrite fold_corr_mat_ncols. {
          rewrite corr_mat_swap_rows_ncols; cycle 1. {
            apply is_sm_mat_iff in Hsm.
            now destruct Hsm as (Hr, _); rewrite Hr.
          } {
            apply is_sm_mat_iff in Hsm.
            now destruct Hsm as (Hr, _); rewrite Hr.
          } {
            now apply squ_mat_is_corr in Hsm.
          }
          subst la.
          rewrite fold_corr_mat_ncols in Hj; [ easy | | easy ].
          now apply squ_mat_is_corr in Hsm.
        } {
          apply (@squ_mat_is_corr n).
          now apply mat_swap_rows_is_square.
        }
        now rewrite mat_swap_rows_nrows.
      }
      apply nth_error_None in Hxx.
      destruct yy as [yy| ]; [ exfalso | easy ].
      apply List_nth_error_Some_iff with (d := 0%F) in Hyy.
      destruct Hyy as (Hyy & Hj').
      apply Nat.nlt_ge in Hxx; apply Hxx; clear Hxx.
      subst la lb.
      rewrite fold_corr_mat_ncols in Hj'. {
        rewrite corr_mat_swap_rows_ncols in Hj'; cycle 1. {
          apply is_sm_mat_iff in Hsm.
          now destruct Hsm as (Hr, _); rewrite Hr.
        } {
          apply is_sm_mat_iff in Hsm.
          now destruct Hsm as (Hr, _); rewrite Hr.
        } {
          now apply squ_mat_is_corr in Hsm.
        }
        rewrite fold_corr_mat_ncols; [ easy | | easy ].
        now apply squ_mat_is_corr in Hsm.
      } {
        apply (@squ_mat_is_corr n).
        now apply mat_swap_rows_is_square.
      }
      now rewrite mat_swap_rows_nrows.
    }
    exfalso.
    apply nth_error_None in Hy.
    apply Nat.nlt_ge in Hy; apply Hy; clear Hy.
    rewrite fold_mat_nrows in Hi.
    rewrite fold_mat_nrows.
    now rewrite mat_swap_rows_nrows.
  }
  apply nth_error_None in Hx.
  destruct y as [lb|]; [ exfalso | easy ].
  apply List_nth_error_Some_iff with (d := []) in Hy.
  destruct Hy as (Hlb & Hi').
  apply Nat.nlt_ge in Hx; apply Hx; clear Hx.
  rewrite fold_mat_nrows in Hi'.
  rewrite fold_mat_nrows.
  now rewrite mat_swap_rows_nrows in Hi'.
}
apply rngl_add_move_0_r in HM; [ | easy ].
apply eq_rngl_add_same_0 in HM; try easy; [ now left | ].
apply orb_true_iff.
now left.
Qed.

(* transpositions list of permutation *)

Fixpoint first_non_fixpoint it i σ :=
  match it with
  | 0 => None
  | S it' => if i =? σ i then first_non_fixpoint it' (i + 1) σ else Some i
  end.

Fixpoint tlopf_loop it n (σ : nat → nat) :=
  match it with
  | 0 => []
  | S it' =>
      match first_non_fixpoint n 0 σ with
      | None => []
      | Some i =>
          let σ' := comp (transposition i (σ i)) σ in
          (i, σ i) :: tlopf_loop it' n σ'
      end
  end.

Definition transp_list_of_permut_fun n (σ : nat → nat) := tlopf_loop n n σ.

Definition transp_list_of_permut {n} (σ : vector nat) :=
  transp_list_of_permut_fun n (vect_nat_el σ).

Theorem first_non_fixpoint_Some_iff : ∀ σ it i j,
  first_non_fixpoint it i σ = Some j
  ↔ i ≤ j ∧ j - i < it ∧ (∀ k, i ≤ k < j → σ k = k) ∧ σ j ≠ j.
Proof.
intros.
split. {
  intros Hs.
  revert σ i j Hs.
  induction it; intros; [ easy | cbn in Hs ].
  rewrite if_eqb_eq_dec in Hs.
  destruct (Nat.eq_dec i (σ i)) as [Hii| Hii]. {
    specialize (IHit σ (i + 1) j Hs) as (H1 & H2 & H3 & H4).
    split; [ flia H1 | ].
    split; [ flia H2 | ].
    split; [ | easy ].
    intros k Hk.
    destruct (Nat.eq_dec i k) as [Hik| Hik]; [ now subst k | ].
    apply H3; flia Hk Hik.
  } {
    injection Hs; clear Hs; intros; subst j.
    split; [ flia | ].
    split; [ flia | ].
    split; [ | now apply Nat.neq_sym ].
    intros k Hk; flia Hk.
  }
} {
  intros (Hij & Hji & Hj & Hjj).
  revert i j Hij Hji Hj Hjj.
  induction it; intros; [ easy | cbn ].
  rewrite if_eqb_eq_dec.
  destruct (Nat.eq_dec i (σ i)) as [Hii| Hii]. {
    assert (Heij : i ≠ j) by now intros H; symmetry in Hii; subst i.
    apply IHit; [ flia Hij Hji Heij | flia Hij Hji Heij | | easy ].
    intros k Hk.
    apply Hj.
    flia Hk.
  }
  destruct (Nat.eq_dec i j) as [Heij| Heij]; [ congruence | exfalso ].
  assert (H : i ≤ i < j) by flia Hij Heij.
  specialize (Hj _ H) as H1.
  now symmetry in H1.
}
Qed.

Theorem first_non_fixpoint_None_if : ∀ σ it i,
  first_non_fixpoint it i σ = None
  → ∀ k, i ≤ k < i + it → k = σ k.
Proof.
intros * Hs k Hik.
revert σ i k Hik Hs.
induction it; intros; [ flia Hik | ].
cbn in Hs.
rewrite if_eqb_eq_dec in Hs.
destruct (Nat.eq_dec i (σ i)) as [H1| H1]; [ | easy ].
destruct (Nat.eq_dec i k) as [H2| H2]; [ now subst i | ].
eapply IHit; [ | apply Hs ].
flia Hik H2.
Qed.

Fixpoint nb_good_loop it i σ :=
  match it with
  | 0 => 0
  | S it' => Nat.b2n (σ i =? i) + nb_good_loop it' (i + 1) σ
  end.

Definition nb_good n σ := nb_good_loop n 0 σ.

Theorem nb_good_loop_comp_transp : ∀ n it σ i k,
  is_permut σ n
  → k < i ≤ n
  → σ k < i
  → n = i + it
  → nb_good_loop it i (comp (transposition k (σ k)) σ) =
    nb_good_loop it i σ.
Proof.
intros * Hp Hkin Hski Hnit.
revert i k Hkin Hski Hnit.
induction it; intros; [ easy | cbn ].
replace (i + S it) with (i + 1 + it) in Hnit by flia.
unfold comp at 1, transposition at 1, Nat.b2n.
do 4 rewrite if_eqb_eq_dec.
destruct (Nat.eq_dec (σ i) k) as [Hsik| Hsik]. {
  rewrite Hsik.
  destruct (Nat.eq_dec k i) as [H| H]; [ flia Hkin H | clear H ].
  rewrite Nat.add_0_l.
  destruct (Nat.eq_dec (σ k) i) as [H| H]; [ flia Hski H | clear H ].
  rewrite Nat.add_0_l.
  apply IHit; try easy; [ | flia Hski ].
  split; [ flia Hkin | ].
  flia Hnit.
}
destruct (Nat.eq_dec (σ i) (σ k)) as [Hsisk| Hsisk]. {
  apply Hp in Hsisk; [ flia Hkin Hsisk | | flia Hkin ].
  flia Hnit.
}
f_equal.
apply IHit; [ | flia Hski | easy ].
split; [ flia Hkin | flia Hnit ].
Qed.

Theorem comp_transp_permut_id : ∀ n σ i j k,
  is_permut σ n
  → i < k
  → k < j < n
  → σ k = i
  → comp (transposition i (σ i)) σ j = σ j.
Proof.
intros * Hp Hikn Hkp Hski.
unfold comp, transposition.
do 2 rewrite if_eqb_eq_dec.
destruct (Nat.eq_dec (σ j) i) as [Hsji| Hsji]. {
  exfalso.
  rewrite <- Hski in Hsji.
  apply Hp in Hsji; [ flia Hkp Hsji | easy | flia Hkp ].
}
destruct (Nat.eq_dec (σ j) (σ i)) as [Hspi| Hspi]; [ | easy ].
apply Hp in Hspi; [ | easy | flia Hikn Hkp ].
flia Hikn Hkp Hspi.
Qed.

Theorem nb_good_loop_comp_transp_permit_id : ∀ n it σ i k,
  is_permut σ n
  → i < n
  → k < n
  → n = k + it
  → (∀ j, k ≤ j → comp (transposition i (σ i)) σ j = σ j)
  → nb_good_loop it k (comp (transposition i (σ i)) σ) =
    nb_good_loop it k σ.
Proof.
intros * Hp Hin Hkn Hnit Hj.
revert i k Hin Hkn Hj Hnit.
induction it; intros; [ easy | cbn ].
unfold comp at 1, transposition at 1, Nat.b2n.
do 4 rewrite if_eqb_eq_dec.
destruct (Nat.eq_dec (σ k) i) as [Hski| Hski]. {
  rewrite Hski.
  destruct (Nat.eq_dec i k) as [Hik| Hik]. {
    move Hik at top; subst k.
    rewrite Hski.
    rewrite <- if_eqb_eq_dec, Nat.eqb_refl.
    f_equal.
    clear.
    remember (i + 1) as k eqn:Hk; clear Hk.
    revert i k.
    induction it; intros; [ easy | cbn ].
    unfold comp at 1, transposition at 1, Nat.b2n.
    do 4 rewrite if_eqb_eq_dec.
    destruct (Nat.eq_dec (σ k) i) as [Hki| Hki]. {
      rewrite Hki.
      now rewrite IHit.
    }
    now rewrite IHit.
  }
  destruct (Nat.eq_dec (σ i) k) as [Hsik| Hsik]. {
    exfalso.
    specialize (Hj k (le_refl _)).
    unfold comp, transposition in Hj.
    rewrite Hski, Nat.eqb_refl in Hj.
    apply Hik, Hp; [ easy | easy | congruence ].
  }
  f_equal.
  specialize (Hj k (le_refl _)).
  unfold comp, transposition in Hj.
  rewrite Hski, Nat.eqb_refl in Hj.
  rewrite <- Hj in Hski.
  apply Hp in Hski; [ congruence | easy | easy ].
}
destruct (Nat.eq_dec (σ k) (σ i)) as [Hsksi| Hsksi]. {
  apply Hp in Hsksi; [ | easy | easy ].
  subst k.
  rewrite <- if_eqb_eq_dec, Nat.eqb_refl.
  destruct (Nat.eq_dec (σ i) i) as [H| H]; [ easy | clear H ].
  specialize (Hj i (le_refl _)).
  unfold comp, transposition in Hj.
  rewrite if_eqb_eq_dec in Hj.
  destruct (Nat.eq_dec (σ i) i) as [H| H]; [ easy | clear H ].
  rewrite Nat.eqb_refl in Hj.
  congruence.
}
f_equal.
destruct (Nat.eq_dec (k + 1) n) as [Hk1n| Hk1n]. {
  destruct it; [ easy | ].
  flia Hnit Hk1n.
}
rewrite IHit; [ easy | easy | flia Hkn Hk1n | | flia Hnit ].
intros j Hkj.
apply Hj; flia Hkj.
Qed.

Theorem nb_good_loop_comp_transp2 : ∀ n it σ i,
  is_permut σ n
  → (∀ k, k < i → σ k = k)
  → σ i ≠ i
  → σ (σ i) ≠ i
  → σ (σ i) ≠ σ i
  → n = i + 1 + it
  → nb_good_loop it (i + 1) (comp (transposition i (σ i)) σ) =
    nb_good_loop it (i + 1) σ.
Proof.
intros * Hp Hi Hsii Hssii Hssisi Hnit.
remember (σ i) as j eqn:Hj; symmetry in Hj.
remember (permut_fun_inv σ n i) as k eqn:Hk.
assert (Hkd : σ k = i). {
  subst k.
  apply fun_permut_fun_inv; [ easy | flia Hnit ].
}
assert (Hik : i < k). {
  assert (H1 : i ≤ k). {
    apply Nat.nlt_ge; intros H.
    apply Hi in H.
    rewrite Hkd in H; move H at top; subst k.
    congruence.
  }
  destruct (Nat.eq_dec i k) as [Hik| Hik]; [ | flia Hik H1 ].
  move Hik at top; subst k.
  congruence.
}
assert (Hjk : j ≠ k). {
  now intros H; move H at top; subst k.
}
assert (Hij : i < j). {
  apply Nat.nle_gt; intros H.
  assert (H' : j < i) by flia Hsii H.
  now apply Hi in H'.
}
assert (Hkn : k < n). {
  rewrite Hk.
  apply permut_ub; [ | flia Hnit ].
  now apply permut_fun_inv_is_permut.
}
clear Hk.
clear Hi.
clear Hj.
clear Hsii.
clear Hssii.
remember (i + 1) as p eqn:Hp'.
assert (Hip : i < p) by flia Hp'.
clear Hp'.
revert i j k p Hssisi Hnit Hkd Hik Hjk Hij Hip Hkn.
induction it; intros; [ easy | cbn ].
replace (p + S it) with (p + 1 + it) in Hnit by flia.
unfold comp at 1, transposition at 1, Nat.b2n.
do 4 rewrite if_eqb_eq_dec.
destruct (Nat.eq_dec (σ p) i) as [Hspi| Hspi]. {
  rewrite Hspi.
  rewrite <- Hkd in Hspi.
  apply Hp in Hspi; [ | flia Hnit | easy ].
  move Hspi at top; subst p.
  destruct (Nat.eq_dec j k) as [H| H]; [ easy | clear H ].
  destruct (Nat.eq_dec i k) as [H| H]; [ flia Hip H | clear H ].
  cbn.
  apply IHit with (k := k); try easy; flia Hip.
}
destruct (Nat.eq_dec (σ p) j) as [Hspj| Hspj]. {
  rewrite Hspj.
  destruct (Nat.eq_dec i p) as [H| H]; [ flia Hip H | clear H ].
  destruct (Nat.eq_dec j p) as [Hjp| Hjp]. {
    now move Hjp at top; subst p.
  }
  cbn.
  apply IHit with (k := k); try easy; flia Hip.
}
f_equal.
apply IHit with (k := k); try easy; flia Hip.
Qed.

Theorem nb_good_loop_comp_transp' : ∀ n it σ i d,
  is_permut σ n
  → i < n
  → d ≠ 0
  → (∀ k, k < i → σ k = k)
  → (∀ k, k < d → σ (i + k) ≠ i)
  → σ (σ i) = i
  → n = i + d + it
  → nb_good_loop it (i + d) (comp (transposition i (σ i)) σ) =
     nb_good_loop it (i + d) σ + 1.
Proof.
intros * Hp Hin Hdz Hskk Hsii Hssi Hnit.
revert i d Hin Hdz Hskk Hsii Hssi Hnit.
induction it; intros; cbn. {
  exfalso.
  destruct Hp as (Hp1, Hp2).
  rewrite Nat.add_0_r in Hnit.
  specialize (Hp1 i Hin) as H1.
  clear - d Hin Hnit Hsii Hskk Hssi H1.
  assert (Hisi : i ≤ σ i). {
    apply Nat.nlt_ge; intros H2.
    specialize (Hskk (σ i) H2) as H3.
    flia Hssi H2 H3.
  }
  specialize (Hsii (σ i - i)) as H2.
  assert (H : σ i - i < d). {
    apply Nat.add_lt_mono_r with (p := i).
    rewrite (Nat.add_comm d), <- Hnit.
    now rewrite Nat.sub_add.
  }
  specialize (H2 H); clear H.
  rewrite Nat.add_sub_assoc in H2; [ | easy ].
  now rewrite Nat.add_comm, Nat.add_sub in H2.
}
replace (i + d + S it) with (i + d + 1 + it) in Hnit by flia.
unfold comp at 1, transposition at 1, Nat.b2n.
do 4 rewrite if_eqb_eq_dec.
destruct (Nat.eq_dec (σ (i + d)) i) as [Hsi2i| Hsi2i]. {
  rewrite Hsi2i.
  destruct (Nat.eq_dec (σ i) (i + d)) as [Hsiid| Hsiid]. {
    destruct (Nat.eq_dec i (i + d)) as [H| H]; [ flia Hdz H | clear H ].
    rewrite Nat.add_0_l, Nat.add_comm; f_equal.
    apply nb_good_loop_comp_transp with (n := n); [ easy | | | easy ]. {
      flia Hnit.
    }
    flia Hsiid.
  }
  destruct (Nat.eq_dec i (i + d)) as [H| H]; [ flia Hdz H | clear H ].
  rewrite <- Nat.add_assoc; cbn.
  replace (i + d + 1 + it) with (i + (d + 1) + it) in Hnit by flia.
  rewrite <- Hssi in Hsi2i at 2.
  apply Nat.neq_sym in Hsiid.
  apply Hp in Hsi2i; [ easy | flia Hnit | ].
  now apply Hp.
}
destruct (Nat.eq_dec (σ (i + d)) (σ i)) as [Hsidsi| Hsidsi]. {
  apply Hp in Hsidsi; [ | flia Hnit | easy ].
  flia Hdz Hsidsi.
}
rewrite <- (Nat.add_assoc (if Nat.eq_dec _ _ then _ else _)).
f_equal.
rewrite <- Nat.add_assoc.
replace (i + d + 1 + it) with (i + (d + 1) + it) in Hnit by flia.
apply IHit; try easy; [ flia | ].
intros k Hk.
destruct (Nat.eq_dec k d) as [Hkd| Hkd]; [ now subst k | ].
apply Hsii.
flia Hk Hkd.
Qed.

Theorem nb_good_loop_comp_transp_eq : ∀ it n σ i k,
  is_permut σ n
  → first_non_fixpoint n 0 σ = Some i
  → k ≤ i
  → n = k + it
  → nb_good_loop it k (comp (transposition i (σ i)) σ) =
    nb_good_loop it k σ + 1 + Nat.b2n (σ (σ i) =? i).
Proof.
intros * Hp Hi Hki Hnit.
apply first_non_fixpoint_Some_iff in Hi.
rewrite Nat.sub_0_r in Hi.
destruct Hi as (_ & Hin & Hi & Hsii).
revert i k Hin Hi Hsii Hki Hnit.
induction it; intros; cbn. {
  flia Hin Hki Hnit.
}
replace (k + S it) with (k + 1 + it) in Hnit by flia.
unfold comp at 1, transposition at 1, Nat.b2n.
do 5 rewrite if_eqb_eq_dec.
destruct (Nat.eq_dec (σ k) i) as [Hski| Hski]. {
  destruct (Nat.eq_dec k i) as [Heki| Heki]; [ congruence | ].
  assert (H : 0 ≤ k < i) by flia Hki Heki.
  specialize (Hi _ H); clear H.
  congruence.
}
destruct (Nat.eq_dec (σ k) (σ i)) as [Hsksi| Hsksi]. {
  apply Hp in Hsksi; [ | flia Hnit | easy ].
  move Hsksi at top; subst k.
  rewrite <- if_eqb_eq_dec, Nat.eqb_refl.
  clear Hski Hki.
  destruct (Nat.eq_dec (σ i) i) as [H| H]; [ easy | clear H ].
  rewrite Nat.add_0_l.
  destruct (Nat.eq_dec (σ (σ i)) i) as [Hssii| Hssii]. {
    rewrite Nat.add_comm; f_equal.
    apply nb_good_loop_comp_transp' with (n := n); try easy. {
      intros k Hk.
      apply Hi.
      split; [ flia | easy ].
    }
    intros k Hk.
    destruct k; [ | flia Hk ].
    now rewrite Nat.add_0_r.
  }
  rewrite Nat.add_comm, Nat.add_0_r; f_equal.
  destruct (Nat.eq_dec (σ (σ i)) (σ i)) as [Hssisi| Hssisi]. {
    apply Hp in Hssisi; [ easy | | easy ].
    now apply Hp.
  }
  apply nb_good_loop_comp_transp2 with (n := n); try easy.
  intros k Hk.
  apply Hi; flia Hk.
}
do 2 rewrite <- Nat.add_assoc.
f_equal.
destruct (Nat.eq_dec k i) as [Hk1i| Hk1i]. {
  now move Hk1i at top; subst k.
}
rewrite IHit; try easy; [ | flia Hki Hk1i ].
unfold Nat.b2n.
rewrite if_eqb_eq_dec.
symmetry.
apply Nat.add_assoc.
Qed.

Theorem first_non_fixpoint_enough_iter : ∀ n m σ i j,
  n ≤ m
  → first_non_fixpoint n i σ = Some j
  → first_non_fixpoint m i σ = Some j.
Proof.
intros * Hnm Hij.
revert i j n σ Hnm Hij.
induction m; intros; cbn. {
  now apply Nat.le_0_r in Hnm; subst n.
}
rewrite if_eqb_eq_dec.
destruct (Nat.eq_dec i (σ i)) as [Hii| Hii]. {
  destruct n; [ easy | ].
  cbn in Hij.
  rewrite <- Hii, Nat.eqb_refl in Hij.
  apply Nat.succ_le_mono in Hnm.
  now apply IHm with (n := n).
}
apply first_non_fixpoint_Some_iff in Hij.
destruct Hij as (Hij & Hjin & Hikj & Hjj).
destruct (Nat.eq_dec i j) as [H1| H1]; [ now subst i | ].
exfalso; apply Hii; symmetry.
apply Hikj.
split; [ flia | flia Hij H1 ].
Qed.

(* If we add a row (column) of A multiplied by a scalar k to another
   row (column) of A, then the determinant will not change. *)
(* https://math.vanderbilt.edu/sapirmv/msapir/proofdet1.html *)
(* doing it only when the first row is 0; can be generalized later *)

Definition mat_add_row_mul_scal_row n (M : matrix T) i1 v i2 :=
  mk_mat
    (map
      (λ i,
       map
         (λ j,
          if Nat.eq_dec i i1 then (mat_el M i1 j + v * mat_el M i2 j)%F
          else mat_el M i j)
         (seq 0 n))
     (seq 0 n)).

(* *)

Definition mat_mul_row_by_scal n k (M : matrix T) s :=
  mk_mat
    (map
       (λ i,
        map
          (λ j, if Nat.eq_dec i k then (s * mat_el M i j)%F else mat_el M i j)
          (seq 0 n))
       (seq 0 n)).

Theorem subm_mat_mul_row_by_scal : ∀ (A : matrix T) n i v,
  is_square_matrix n A = true
  → subm (mat_mul_row_by_scal n 0 A v) 0 i = subm A 0 i.
Proof.
intros * Hsm.
unfold subm.
f_equal.
f_equal.
unfold butn.
do 2 rewrite firstn_O.
f_equal.
do 2 rewrite List_skipn_1.
destruct A as (ll).
destruct ll as [| la ll]. {
  cbn.
  apply is_sm_mat_iff in Hsm.
  cbn in Hsm.
  now destruct Hsm as (Hr, _); subst n.
}
apply is_sm_mat_iff in Hsm.
cbn in Hsm.
destruct Hsm as (Hr & Hcr & Hc).
destruct n; [ easy | ].
apply Nat.succ_inj in Hr.
cbn - [ mat_mul_row_by_scal ].
rewrite List_map_nth_seq with (d := []).
rewrite Hr.
cbn - [ seq mat_el ].
rewrite List_map_tl.
remember (tl (seq 0 (S n))) as x eqn:Hx.
cbn in Hx; subst x.
rewrite <- seq_shift.
rewrite map_map.
apply map_ext_in.
intros j Hj.
apply in_seq in Hj.
destruct Hj as (_, Hj).
rewrite List_map_nth_seq with (d := 0%F).
rewrite Hc. 2: {
  right.
  apply nth_In.
  now rewrite Hr.
}
apply map_ext_in.
intros k Hk.
now destruct (Nat.eq_dec (S j) 0).
Qed.

(* If we multiply a row (column) of A by a number, the determinant of
   A will be multiplied by the same number. *)
(* https://math.vanderbilt.edu/sapirmv/msapir/proofdet1.html
   point 1 *)

(* Well, since my definition of the determinant only covers the
   row 0, we can prove that only when i=0; this will able us to
   prove next theorems, swapping rows by going via row 0 *)

Theorem det_mul_row_0_by_scal :
  rngl_has_opp = true ∨ rngl_has_sous = true →
  rngl_is_comm = true →
  ∀ n (A : matrix T) v,
  n ≠ 0
  → is_square_matrix n A = true
  → determinant n (mat_mul_row_by_scal n 0 A v) = (v * determinant n A)%F.
Proof.
intros Hom Hic * Hnz Hsm.
destruct n; [ easy | clear Hnz ].
cbn - [ mat_mul_row_by_scal ].
rewrite rngl_mul_summation_distr_l; [ | easy ].
apply rngl_summation_eq_compat.
intros i (_, Hi).
symmetry.
rewrite (rngl_mul_comm Hic).
symmetry.
do 3 rewrite <- rngl_mul_assoc.
f_equal.
rewrite rngl_mul_assoc, (rngl_mul_mul_swap Hic).
rewrite (rngl_mul_comm Hic _ v).
f_equal. {
  destruct i; [ easy | cbn ].
  rewrite (List_map_nth' 0); [ | now rewrite seq_length ].
  now rewrite seq_nth.
}
f_equal.
now apply subm_mat_mul_row_by_scal.
Qed.

(* If the i-th row (column) in A is a sum of the i-th row (column) of
   a matrix B and the i-th row (column) of a matrix C and all other
   rows in B and C are equal to the corresponding rows in A (that is B
   and C differ from A by one row only), then det(A)=det(B)+det(C). *)
(* https://math.vanderbilt.edu/sapirmv/msapir/proofdet1.html
   point 2 *)

(* Well, since my definition of the discriminant only covers the
   row 0, we can prove that only when i=0; this will able us to
   prove the next theorem, swapping rows by going via row 0 *)

Theorem det_sum_row_row : ∀ n (A B C : matrix T),
  n ≠ 0
  → is_square_matrix n A = true
  → is_square_matrix n B = true
  → is_square_matrix n C = true
  → (∀ j, mat_el A 0 j = (mat_el B 0 j + mat_el C 0 j)%F)
  → (∀ i j, i ≠ 0 → mat_el B i j = mat_el A i j)
  → (∀ i j, i ≠ 0 → mat_el C i j = mat_el A i j)
  → determinant n A = (determinant n B + determinant n C)%F.
Proof.
intros * Hnz Hsma Hsmb Hsmc Hbc Hb Hc.
assert (Hra : mat_nrows A = n) by now apply is_sm_mat_iff in Hsma.
assert (Hrb : mat_nrows B = n) by now apply is_sm_mat_iff in Hsmb.
assert (Hrc : mat_nrows C = n) by now apply is_sm_mat_iff in Hsmc.
specialize (square_matrix_ncols _ Hsma) as Hca.
specialize (square_matrix_ncols _ Hsmb) as Hcb.
destruct n; [ easy | clear Hnz; cbn ].
assert (Hab : ∀ j, subm A 0 j = subm B 0 j). {
  intros.
  destruct A as (lla).
  destruct B as (llb).
  cbn in *.
  unfold subm; f_equal.
  cbn - [ butn ].
  rewrite (List_map_nth_seq lla []).
  rewrite (List_map_nth_seq llb []).
  rewrite Hra, Hrb.
  do 2 rewrite <- map_butn.
  do 2 rewrite map_map.
  apply map_ext_in.
  intros u Hu.
  destruct (Nat.eq_dec u 0) as [Huz| Huz]. {
    subst u; cbn in Hu.
    now apply in_seq in Hu.
  }
  rewrite (List_map_nth_seq (nth u lla []) 0%F).
  rewrite (List_map_nth_seq (nth u llb []) 0%F).
  apply is_sm_mat_iff in Hsma.
  destruct Hsma as (_ & _ & Hca').
  apply in_butn, in_seq in Hu.
  rewrite Hca'. 2: {
    cbn; apply nth_In.
    now rewrite Hra.
  }
  apply is_sm_mat_iff in Hsmb.
  destruct Hsmb as (_ & _ & Hcb').
  rewrite Hcb'. 2: {
    cbn; apply nth_In.
    now rewrite Hrb.
  }
  f_equal.
  apply map_ext_in.
  intros v Hv.
  apply in_seq in Hv.
  now symmetry; apply Hb.
}
assert (Hac : ∀ j, subm A 0 j = subm C 0 j). {
  intros.
  intros.
  destruct A as (lla).
  destruct C as (llc).
  cbn in *.
  unfold subm; f_equal.
  cbn - [ butn ].
  rewrite (List_map_nth_seq lla []).
  rewrite (List_map_nth_seq llc []).
  rewrite Hra, Hrc.
  do 2 rewrite <- map_butn.
  do 2 rewrite map_map.
  apply map_ext_in.
  intros u Hu.
  destruct (Nat.eq_dec u 0) as [Huz| Huz]. {
    subst u; cbn in Hu.
    now apply in_seq in Hu.
  }
  rewrite (List_map_nth_seq (nth u lla []) 0%F).
  rewrite (List_map_nth_seq (nth u llc []) 0%F).
  apply is_sm_mat_iff in Hsma.
  destruct Hsma as (_ & _ & Hca').
  apply in_butn, in_seq in Hu.
  rewrite Hca'. 2: {
    cbn; apply nth_In.
    now rewrite Hra.
  }
  apply is_sm_mat_iff in Hsmc.
  destruct Hsmc as (_ & _ & Hcc').
  rewrite Hcc'. 2: {
    cbn; apply nth_In.
    now rewrite Hrc.
  }
  f_equal.
  apply map_ext_in.
  intros v Hv.
  apply in_seq in Hv.
  now symmetry; apply Hc.
}
erewrite rngl_summation_eq_compat. 2: {
  intros j Hj.
  rewrite Hbc.
  rewrite rngl_mul_add_distr_l.
  rewrite rngl_mul_add_distr_r.
  rewrite Hab at 1.
  rewrite Hac at 1.
  easy.
}
cbn.
now apply rngl_summation_add_distr.
Qed.

(* If two rows (columns) in A are equal then det(A)=0. *)
(* https://math.vanderbilt.edu/sapirmv/msapir/proofdet1.html
   point 3 *)
(* doing it only when the first row is 0; can be generalized later *)

Definition δ_lt i k := Nat.b2n (i <? k).

Theorem subm_subm_swap : ∀ (A : matrix T) i j k l,
  subm (subm A i j) k l =
  subm (subm A (k + δ_lt i k) (l + δ_lt j l)) (i - δ_lt k i) (j - δ_lt l j).
Proof.
intros.
rewrite mat_eq_map_seq; symmetry.
rewrite mat_eq_map_seq; symmetry.
f_equal.
unfold δ_lt.
do 4 rewrite mat_nrows_subm.
unfold Nat.b2n; do 8 rewrite if_ltb_lt_dec.
destruct (lt_dec i (mat_nrows A)) as [Hir| Hir]. 2: {
  apply Nat.nlt_ge in Hir.
  rewrite Nat.sub_0_r.
  destruct (lt_dec i k) as [Hik| Hik]. {
    destruct (lt_dec k i) as [H| H]; [ flia Hik H | clear H ].
    rewrite Nat.sub_0_r.
    destruct (lt_dec k (mat_nrows A)) as [H| H]; [ flia Hir Hik H | clear H ].
    rewrite Nat.sub_0_r.
    destruct (lt_dec (k + 1) (mat_nrows A)) as [H| H]; [ flia Hir Hik H | ].
    clear H; rewrite Nat.sub_0_r.
    destruct (lt_dec i (mat_nrows A)) as [H| H]; [ flia Hir H | clear H ].
    rewrite Nat.sub_0_r.
    apply map_ext_in.
    intros u Hu; apply in_seq in Hu.
    destruct (lt_dec j l) as [Hjl| Hjl]. {
      destruct (lt_dec l j) as [H| H]; [ flia Hjl H | clear H ].
      rewrite Nat.sub_0_r.
      unfold subm; cbn.
      do 6 rewrite map_butn.
      rewrite nth_butn_after; [ | flia Hik Hir Hu ].
      rewrite nth_butn_after; [ | flia Hir Hu ].
      rewrite nth_butn_after; [ | flia Hir Hu ].
      rewrite nth_butn_after; [ | flia Hik Hir Hu ].
      do 2 rewrite map_map.
      f_equal.
      apply map_ext_in.
      intros la Hla.
      apply butn_butn; flia Hjl.
    } {
      apply Nat.nlt_ge in Hjl.
      rewrite Nat.add_0_r.
      destruct (lt_dec l j) as [Hlj| Hlj]. 2: {
        apply Nat.nlt_ge in Hlj.
        replace l with j by flia Hjl Hlj.
        clear l Hjl Hlj.
        rewrite Nat.sub_0_r.
        rewrite subm_subm_r_r; [ easy | flia Hik ].
      }
      rewrite (@subm_out_l _ (k + 1) i A); [ | flia Hir Hik | easy ].
      rewrite (@subm_out_l _ k i); cycle 1. {
        rewrite mat_nrows_subm; flia Hir Hik.
      } {
        rewrite mat_nrows_subm; flia Hir.
      }
      symmetry.
      destruct (lt_dec l (j - 1)) as [Hlj1| Hlj1]. 2: {
        apply Nat.nlt_ge in Hlj1.
        replace j with (l + 1) by flia Hlj Hlj1.
        rewrite Nat.add_sub.
        f_equal; f_equal.
        now apply subm_subm_l_l.
      }
      f_equal; f_equal.
      rewrite subm_subm_l_l; [ | flia Hlj1 ].
      rewrite Nat.sub_add; [ easy | flia Hlj ].
    }
  } {
    apply Nat.nlt_ge in Hik.
    rewrite Nat.add_0_r.
    destruct (lt_dec k i) as [Hki| Hki]. 2: {
      replace k with i by flia Hik Hki.
      clear k Hik Hki.
      destruct (lt_dec i (mat_nrows A)) as [H| H]; [ flia Hir H | clear H ].
      do 2 rewrite Nat.sub_0_r.
      destruct (lt_dec i (mat_nrows A)) as [H| H]; [ flia Hir H | clear H ].
      rewrite Nat.sub_0_r.
      destruct (lt_dec j l) as [Hjl| Hjl]. {
        rewrite subm_subm_l_l; [ | flia Hjl ].
        destruct (lt_dec l j) as [H| H]; [ flia Hjl H | clear H ].
        now rewrite Nat.sub_0_r.
      } {
        destruct (lt_dec l j) as [Hlj| Hlj]. 2: {
          replace l with j by flia Hjl Hlj.
          now rewrite Nat.add_0_r, Nat.sub_0_r.
        }
        rewrite Nat.add_0_r.
        symmetry.
        destruct (lt_dec l (j - 1)) as [Hlj1| Hlj1]. 2: {
          replace j with (l + 1) by flia Hlj Hlj1.
          rewrite Nat.add_sub.
          clear j Hjl Hlj Hlj1.
          rename l into j.
          now rewrite subm_subm_l_l.
        }
        clear Hjl Hlj.
        rewrite subm_subm_l_l; [ | flia Hlj1 ].
        rewrite Nat.sub_add; [ easy | flia Hlj1 ].
      }
    } {
      destruct (lt_dec k (mat_nrows A)) as [Hkr| Hkr]. {
        destruct (lt_dec (i - 1) (mat_nrows A - 1)) as [H| H];
          [ flia Hir H | clear H ].
        rewrite Nat.sub_0_r.
        destruct (lt_dec j l) as [Hjl| Hjl]. {
          destruct (lt_dec l j) as [H| H]; [ flia Hjl H | clear H ].
          rewrite Nat.sub_0_r.
          apply map_ext_in.
          intros m Hm.
          f_equal; f_equal; clear m Hm.
          rewrite subm_subm_exch; [ easy | easy | flia Hjl ].
        }
        destruct (lt_dec l j) as [Hlj| Hlj]. {
          rewrite Nat.add_0_r.
          apply map_ext_in.
          intros m Hm.
          f_equal; f_equal; clear m Hm.
          now apply subm_subm_exch'.
        }
        rewrite Nat.add_0_r, Nat.sub_0_r.
        replace l with j by flia Hjl Hlj.
        clear l Hjl Hlj.
        apply map_ext_in.
        intros l Hl.
        apply in_seq in Hl.
        destruct (lt_dec k (i - 1)) as [Hki1| Hki1]. {
          symmetry.
          rewrite subm_subm_r_r; [ | flia Hki1 ].
          rewrite Nat.sub_add; [ easy | flia Hki ].
        }
        assert (Hk : k = mat_nrows A - 1) by flia Hir Hki Hkr Hki1.
        assert (Hi : i = mat_nrows A) by flia Hir Hki Hkr Hki1.
        assert (Hr : mat_nrows A ≠ 0) by flia Hkr.
        clear Hir Hik Hki Hkr Hki1.
        rewrite <- Hi in Hl, Hk, Hr.
        replace i with (k + 1) by flia Hk Hi Hr.
        rewrite Nat.add_sub.
        rewrite subm_subm_l_l; [ | easy ].
        unfold subm; cbn.
        rewrite (List_map_nth' []). 2: {
          rewrite butn_length, map_length.
          rewrite butn_length, fold_mat_nrows.
          unfold Nat.b2n.
          do 2 rewrite if_ltb_lt_dec.
          rewrite <- Hi.
          destruct (lt_dec (k + 1) i) as [H| H]; [ flia Hk H | clear H ].
          rewrite Nat.sub_0_r.
          destruct (lt_dec k i) as [H| H]; [ flia Hl H | clear H ].
          rewrite Nat.sub_0_r; flia Hl Hi.
        }
        rewrite nth_butn_after; [ | flia Hl Hk ].
        rewrite (List_map_nth' []). 2: {
          rewrite butn_length, fold_mat_nrows, <- Hi.
          unfold Nat.b2n; rewrite if_ltb_lt_dec.
          destruct (lt_dec (k + 1) i); flia Hl Hi.
        }
        rewrite nth_butn_after; [ | flia Hl Hk ].
        do 3 rewrite map_butn.
        rewrite nth_butn_after; [ | flia Hl Hk ].
        rewrite nth_butn_after; [ | flia Hl Hk ].
        rewrite (List_map_nth' []). 2: {
          rewrite map_length, fold_mat_nrows, <- Hi; flia Hl.
        }
        rewrite (List_map_nth' []). 2: {
          rewrite fold_mat_nrows, <- Hi; flia Hl.
        }
        now rewrite butn_butn.
      }
      apply Nat.nlt_ge in Hkr.
      rewrite Nat.sub_0_r.
      destruct (lt_dec (i - 1) (mat_nrows A)) as [Hi1r| Hi1r]. 2: {
        apply Nat.nlt_ge in Hi1r.
        rewrite Nat.sub_0_r.
        apply map_ext_in.
        intros m Hm; apply in_seq in Hm.
        destruct (lt_dec j l) as [Hjl| Hjl]. {
          destruct (lt_dec l j) as [H| H]; [ flia Hjl H | clear H ].
          rewrite Nat.sub_0_r.
          rewrite subm_subm_exch; [ easy | easy | flia Hjl ].
        } {
          apply Nat.nlt_ge in Hjl.
          rewrite Nat.add_0_r.
          f_equal; f_equal.
          destruct (lt_dec l j) as [Hlj| Hlj]. 2: {
            replace l with j by flia Hjl Hlj.
            rewrite Nat.sub_0_r.
            destruct (lt_dec k (i - 1)) as [Hki1| Hki1]. {
              symmetry; rewrite subm_subm_r_r; [ | flia Hki1 ].
              rewrite Nat.sub_add; [ easy | flia Hki1 ].
            } {
              replace i with (k + 1) by flia Hki Hki1.
              rewrite Nat.add_sub.
              rewrite subm_subm_l_l; [ | easy ].
              rewrite (@subm_out_l _ (k + 1) k); [ | flia Hkr | easy ].
              now apply subm_subm_l_l.
            }
          } {
            now rewrite subm_subm_exch'.
          }
        }
      }
      flia Hki Hkr Hi1r.
    }
  }
}
destruct (lt_dec k (mat_nrows A - 1)) as [Hkr1| Hkr1]. 2: {
  apply Nat.nlt_ge in Hkr1.
  rewrite Nat.sub_0_r.
  destruct (lt_dec i k) as [Hik| Hik]. {
    destruct (lt_dec k i) as [H| H]; [ flia Hik H | clear H ].
    rewrite Nat.sub_0_r.
    destruct (lt_dec (k + 1) (mat_nrows A)) as [H| H]; [ flia Hkr1 H | ].
    clear H; rewrite Nat.sub_0_r.
    destruct (lt_dec i (mat_nrows A)) as [H| H]; [ clear H | flia Hir H ].
    apply map_ext_in.
    intros m Hm; apply in_seq in Hm.
    f_equal; f_equal.
    destruct (lt_dec j l) as [Hjl| Hjl]. {
      destruct (lt_dec l j) as [H| H]; [ flia Hjl H | clear H ].
      rewrite Nat.sub_0_r.
      symmetry.
      rewrite subm_subm_exch'; [ | flia Hik | flia Hjl ].
      now do 2 rewrite Nat.add_sub.
    } {
      apply Nat.nlt_ge in Hjl.
      rewrite Nat.add_0_r.
      destruct (lt_dec l j) as [Hlj| Hlj]. 2: {
        replace l with j by flia Hjl Hlj.
        rewrite Nat.sub_0_r.
        apply subm_subm_r_r; flia Hik.
      } {
        symmetry.
        destruct (lt_dec l (j - 1)) as [Hlj1| Hlj1]. {
          rewrite subm_subm_exch; [ | flia Hik | flia Hlj1 ].
          rewrite Nat.add_sub.
          rewrite Nat.sub_add; [ easy | flia Hlj ].
        }
        replace l with (j - 1) by flia Hlj Hlj1.
        rewrite <- subm_subm_exch''; [ | flia Hik ].
        rewrite Nat.sub_add; [ easy | flia Hlj ].
      }
    }
  } {
    apply Nat.nlt_ge in Hik.
    replace k with i by flia Hir Hkr1 Hik.
    assert (Hir1 : i = mat_nrows A - 1) by flia Hir Hkr1 Hik.
    assert (Hrz : mat_nrows A ≠ 0) by flia Hir.
    clear k Hir Hkr1 Hik.
    rewrite Nat.add_0_r.
    destruct (lt_dec i i) as [H| H]; [ flia H | clear H ].
    destruct (lt_dec i (mat_nrows A)) as [H| H]; [ | flia Hrz Hir1 H ].
    clear H; rewrite Nat.sub_0_r.
    destruct (lt_dec i (mat_nrows A - 1)) as [H| H]; [ flia Hir1 H | ].
    clear H; rewrite Nat.sub_0_r.
    apply map_ext_in.
    intros k Hk; apply in_seq in Hk.
    destruct (lt_dec j l) as [Hjl| Hjl]. {
      destruct (lt_dec l j) as [H| H]; [ flia Hjl H | clear H ].
      rewrite Nat.sub_0_r.
      rewrite subm_subm_l_l; [ easy | flia Hjl ].
    } {
      destruct (lt_dec l j) as [Hlj| Hlj]. 2: {
        replace l with j by flia Hjl Hlj.
        now rewrite Nat.add_0_r, Nat.sub_0_r.
      }
      clear Hjl; rewrite Nat.add_0_r.
      destruct (lt_dec l (j - 1)) as [Hlj1| Hlj1]. {
        symmetry.
        rewrite subm_subm_l_l; [ | flia Hlj ].
        rewrite Nat.sub_add; [ easy | flia Hlj ].
      }
      replace l with (j - 1) by flia Hlj Hlj1.
      symmetry.
      rewrite subm_subm_l_l; [ | easy ].
      rewrite Nat.sub_add; [ easy | flia Hlj ].
    }
  }
}
destruct (lt_dec i k) as [Hik| Hik]. {
  destruct (lt_dec (k + 1) (mat_nrows A)) as [H| H]; [ | flia Hkr1 H ].
  clear H.
  destruct (lt_dec k i) as [H| H]; [ flia Hik H | clear H ].
  rewrite Nat.sub_0_r.
  destruct (lt_dec i (mat_nrows A - 1)) as [Hir1| Hir1]. 2: {
    flia Hir Hir1 Hkr1 Hik.
  }
  apply map_ext_in.
  intros m Hm; apply in_seq in Hm.
  destruct (lt_dec j l) as [Hjl| Hjl]. {
    destruct (lt_dec l j) as [H| H]; [ flia Hjl H | clear H ].
    rewrite Nat.sub_0_r.
    symmetry.
    rewrite subm_subm_exch'; [ | flia Hik | flia Hjl ].
    now do 2 rewrite Nat.add_sub.
  } {
    destruct (lt_dec l j) as [Hlj| Hlj]. {
      rewrite Nat.add_0_r.
      f_equal; f_equal.
      destruct (lt_dec l (j - 1)) as [Hlj1| Hlj1]. {
        symmetry.
        rewrite subm_subm_exch; [ | flia Hik | flia Hlj1 ].
        rewrite Nat.sub_add; [ | flia Hlj ].
        now rewrite Nat.add_sub.
      }
      replace j with (l + 1) by flia Hlj Hlj1.
      rewrite Nat.add_sub.
      symmetry.
      rewrite subm_subm_exch''; [ easy | flia Hik ].
    }
    rewrite Nat.add_0_r, Nat.sub_0_r.
    f_equal; f_equal.
    replace j with l by flia Hjl Hlj.
    apply subm_subm_r_r; flia Hik.
  }
} {
  apply Nat.nlt_ge in Hik.
  rewrite Nat.add_0_r.
  destruct (lt_dec k i) as [Hki| Hki]. {
    destruct (lt_dec k (mat_nrows A)) as [H| H]; [ clear H | flia Hkr1 H ].
    destruct (lt_dec (i - 1) (mat_nrows A - 1)) as [H| H];
      [ clear H | flia Hir Hki H ].
    apply map_ext_in.
    intros m Hm; apply in_seq in Hm.
    destruct (lt_dec j l) as [Hjl| Hjl]. {
      destruct (lt_dec l j) as [H| H]; [ flia Hjl H | clear H ].
      rewrite Nat.sub_0_r.
      f_equal; f_equal.
      rewrite subm_subm_exch; [ easy | easy | flia Hjl ].
    }
    apply Nat.nlt_ge in Hjl.
    rewrite Nat.add_0_r.
    destruct (lt_dec l j) as [Hlj| Hlj]. 2: {
      rewrite Nat.sub_0_r.
      replace l with j by flia Hjl Hlj.
      f_equal; f_equal.
      destruct (lt_dec k (i - 1)) as [Hki1| Hki1]. {
        symmetry.
        rewrite subm_subm_r_r; [ | flia Hki1 ].
        rewrite Nat.sub_add; [ easy | flia Hki ].
      }
      replace i with (k + 1) by flia Hki Hki1.
      rewrite Nat.add_sub.
      rewrite subm_subm_l_l; [ | easy ].
      rewrite subm_subm_exch; [ | flia | easy ].
      now rewrite Nat.add_sub.
    }
    f_equal; f_equal.
    now apply subm_subm_exch'.
  }
  replace i with k by flia Hik Hki.
  clear i Hir Hik Hki.
  rename k into i.
  rewrite Nat.sub_0_r.
  destruct (lt_dec i (mat_nrows A)) as [H| H]; [ clear H | flia Hkr1 H ].
  destruct (lt_dec i (mat_nrows A - 1)) as [H| H]; [ | flia Hkr1 H ].
  clear H.
  apply map_ext_in.
  intros k Hk; apply in_seq in Hk.
  f_equal; f_equal.
  destruct (lt_dec j l) as [Hjl| Hjl]. {
    destruct (lt_dec l j) as [H| H]; [ flia Hjl H | clear H ].
    rewrite Nat.sub_0_r.
    rewrite subm_subm_l_l; [ easy | flia Hjl ].
  }
  rewrite Nat.add_0_r.
  destruct (lt_dec l j) as [Hlj| Hlj]. {
    symmetry.
    rewrite subm_subm_l_l; [ | flia Hlj ].
    rewrite Nat.sub_add; [ easy | flia Hlj ].
  }
  rewrite Nat.sub_0_r.
  now replace l with j by flia Hjl Hlj.
}
Qed.

Definition swap_in_permut n i j k :=
  vect_swap_elem (vect_vect_nat_el (mk_canon_sym_gr_vect n) k) i j.

(* comatrix *)

Definition comatrix n (M : matrix T) : matrix T :=
  mk_mat
    (map
      (λ i,
       map
         (λ j, (minus_one_pow (i + j) * determinant (n - 1) (subm M i j))%F)
         (seq 0 (mat_ncols M)))
      (seq 0 (mat_nrows M))).

Theorem mat_swap_same_rows : ∀ (M : matrix T) i,
  mat_swap_rows i i M = M.
Proof.
intros.
destruct M as (ll); cbn.
unfold mat_swap_rows; f_equal.
cbn - [ list_swap_scal ].
rewrite (List_map_nth_seq ll (nth i ll [])) at 2.
unfold list_swap_scal.
apply map_ext_in.
intros j Hj; apply in_seq in Hj.
unfold transposition.
do 2 rewrite if_eqb_eq_dec.
destruct (Nat.eq_dec j i) as [Hji| Hji]. {
  subst j.
  now apply nth_indep.
}
now apply nth_indep.
Qed.

Theorem mat_swap_rows_comm : ∀ (M : matrix T) p q,
  mat_swap_rows p q M = mat_swap_rows q p M.
Proof.
intros.
unfold mat_swap_rows; f_equal; cbn.
unfold list_swap_scal.
apply map_ext_in.
intros i Hi; apply in_seq in Hi.
now rewrite transposition_comm.
Qed.

Theorem subm_mat_swap_rows_lt_lt : ∀ (M : matrix T) p q r j,
  p < q
  → q < r
  → subm (mat_swap_rows p q M) r j = mat_swap_rows p q (subm M r j).
Proof.
intros * Hpq Hq.
destruct M as (ll); cbn.
unfold subm, mat_swap_rows; cbn; f_equal.
rewrite map_length.
rewrite butn_length.
rewrite <- map_butn, map_map.
rewrite map_butn_seq.
rewrite Nat.add_0_l.
apply map_ext_in.
intros i Hi; apply in_seq in Hi.
unfold Nat.b2n.
rewrite if_leb_le_dec.
destruct Hi as (_, Hi).
destruct (le_dec r i) as [Hir| Hir]. 2: {
  apply Nat.nle_gt in Hir.
  rewrite Nat.add_0_r.
  destruct (Nat.eq_dec i p) as [Hip| Hip]. {
    subst i; clear Hir.
    rewrite transposition_1.
    destruct (lt_dec q (length (butn r ll))) as [Hqrl| Hqrl]. {
      rewrite (List_map_nth' []); [ | easy ].
      now rewrite nth_butn_after.
    }
    apply Nat.nlt_ge in Hqrl.
    symmetry.
    rewrite nth_overflow; [ | now rewrite map_length ].
    rewrite butn_length in Hqrl.
    destruct (le_dec (length ll) q) as [Hlq| Hlq]. {
      rewrite nth_overflow with (n := q); [ | easy ].
      now rewrite butn_nil.
    }
    apply Nat.nle_gt in Hlq.
    unfold Nat.b2n in Hi, Hqrl.
    rewrite if_ltb_lt_dec in Hi, Hqrl.
    destruct (lt_dec r (length ll)) as [Hrl| Hrl]; [ | flia Hqrl Hlq ].
    flia Hq Hrl Hqrl Hlq.
  }
  destruct (Nat.eq_dec i q) as [Hiq| Hiq]. {
    subst i; clear Hir.
    rewrite transposition_2.
    destruct (lt_dec p (length (butn r ll))) as [Hprl| Hprl]. {
      rewrite (List_map_nth' []); [ | easy ].
      rewrite nth_butn_after; [ easy | flia Hpq Hq ].
    }
    apply Nat.nlt_ge in Hprl.
    rewrite butn_length in Hprl.
    flia Hpq Hi Hprl.
  }
  unfold transposition.
  do 2 rewrite if_eqb_eq_dec.
  destruct (Nat.eq_dec i p) as [H| H]; [ easy | clear H ].
  destruct (Nat.eq_dec i q) as [H| H]; [ easy | clear H ].
  rewrite map_butn.
  rewrite nth_butn_after; [ | easy ].
  rewrite (List_map_nth' []); [ easy | flia Hi ].
}
unfold transposition.
do 4 rewrite if_eqb_eq_dec.
destruct (Nat.eq_dec i p) as [H| H]; [ flia Hpq Hq Hir H | clear H ].
destruct (Nat.eq_dec i q) as [H| H]; [ flia Hq Hir H | clear H ].
destruct (Nat.eq_dec (i + 1) p) as [H| H]; [ flia Hpq Hq Hir H | clear H ].
destruct (Nat.eq_dec (i + 1) q) as [H| H]; [ flia Hq Hir H | clear H ].
rewrite map_butn.
rewrite nth_butn_before; [ | easy ].
rewrite (List_map_nth' []); [ easy | ].
unfold Nat.b2n in Hi.
rewrite if_ltb_lt_dec in Hi.
destruct (lt_dec r (length ll)) as [Hrl| Hrl]; [ flia Hi Hir | ].
flia Hrl Hi Hir.
Qed.

Theorem subm_mat_swap_rows_lt : ∀ (M : matrix T) p q r j,
  p < r
  → q < r
  → subm (mat_swap_rows p q M) r j = mat_swap_rows p q (subm M r j).
Proof.
intros * Hp Hq.
destruct (lt_dec p q) as [Hpq| Hpq]; [ now apply subm_mat_swap_rows_lt_lt | ].
do 2 rewrite mat_swap_rows_comm with (p := p).
destruct (lt_dec q p) as [Hqp| Hqp]; [ now apply subm_mat_swap_rows_lt_lt | ].
replace q with p by flia Hpq Hqp.
now do 2 rewrite mat_swap_same_rows.
Qed.

Theorem mat_el_mat_swap_rows : ∀ (M : matrix T) p q j,
  q < mat_nrows M
  → mat_el (mat_swap_rows p q M) q j = mat_el M p j.
Proof.
intros * Hql; cbn.
destruct M as (ll); cbn in Hql |-*.
f_equal; clear j.
rewrite (List_map_nth' 0); [ | now rewrite seq_length ].
rewrite seq_nth; [ | easy ].
rewrite Nat.add_0_l.
now rewrite transposition_2.
Qed.

Theorem length_fold_left_map_transp : ∀ A (ll : list A) sta len f g d,
  length
    (fold_left
       (λ ll' k,
        map (λ i, nth (transposition (f k) (g k) i) ll' d)
          (seq 0 (length ll')))
       (seq sta len) ll) = length ll.
Proof.
intros.
induction len; [ easy | ].
rewrite seq_S.
rewrite fold_left_app; cbn.
rewrite List_map_seq_length.
apply IHlen.
Qed.

Theorem mat_nrows_fold_left_swap : ∀ (M : matrix T) p q f g,
  mat_nrows (fold_left (λ M' k, mat_swap_rows (f k) (g k) M') (seq p q) M) =
  mat_nrows M.
Proof.
intros.
unfold mat_nrows.
rewrite fold_left_mat_fold_left_list_list.
apply length_fold_left_map_transp.
Qed.

Theorem nth_fold_left_map_transp_1 : ∀ A (la : list A) i sta len d,
  i < length la
  → i < sta ∨ sta + len < i
  → nth i
      (fold_left
         (λ la' k,
            map (λ j, nth (transposition k (k + 1) j) la' d)
              (seq 0 (length la')))
         (seq sta len) la) d =
    nth i la d.
Proof.
intros * Hi Hip.
induction len; [ easy | ].
rewrite seq_S; cbn.
rewrite fold_left_app; cbn.
rewrite (List_map_nth' 0). 2: {
  rewrite seq_length.
  now rewrite length_fold_left_map_transp.
}
rewrite seq_nth. 2: {
  now rewrite length_fold_left_map_transp.
}
rewrite Nat.add_0_l.
unfold transposition.
do 2 rewrite if_eqb_eq_dec.
destruct (Nat.eq_dec i (sta + len)) as [His| His]; [ flia His Hip | ].
destruct (Nat.eq_dec i (sta + len + 1)) as [Hip1| Hip1]; [ flia Hip Hip1 | ].
apply IHlen.
flia Hip His.
Qed.

Theorem nth_0_fold_left_cons_cons : ∀ A B (b : A) (la : list B) lb lc d f,
  nth 0 (fold_left (λ v i, nth 0 v d :: f v i) la (b :: lb)) lc = b.
Proof.
intros.
revert lb.
induction la as [| a]; intros; [ easy | cbn ].
now rewrite IHla.
Qed.

Theorem nth_0_fold_left_nth_transp: ∀ A (b : A) lb d f n,
  nth 0
    (fold_left
       (λ v i, nth (transposition i (i + 1) 0) v d :: f v i) (seq 0 (S n))
       (b :: lb))
    d = nth 0 lb d.
Proof.
intros; cbn.
rewrite <- seq_shift.
rewrite List_fold_left_map; cbn.
now rewrite nth_0_fold_left_cons_cons.
Qed.

Theorem nth_succ_fold_left_app_cons : ∀ A B n (b : A) (la : list B) lb d f g,
  length lb = S n
  → (∀ v i, length (g v i) = n)
  → nth (S n)
       (fold_left (λ v i, f v i :: g v i ++ [nth (S n) v d]) la (b :: lb)) d =
    nth n lb d.
Proof.
intros * Hlb Hf.
revert b lb Hlb Hf.
induction la as [| a]; intros; [ easy | cbn ].
rewrite IHla; [ | | apply Hf ]. 2: {
  rewrite app_length; cbn.
  rewrite Nat.add_1_r; f_equal.
  apply Hf.
}
rewrite app_nth2; [ | now unfold "≥"; rewrite Hf ].
now rewrite Hf, Nat.sub_diag.
Qed.

Theorem nth_fold_left_seq_gen : ∀ A (u : list A) i d n sta,
  sta + n ≤ length u
  → sta ≤ i < sta + n - 1
  → nth i
      (fold_left
         (λ la' k,
            map (λ j, nth (transposition k (k + 1) j) la' d)
              (seq 0 (length la')))
         (seq sta n) u) d =
     nth (i + 1) u d.
Proof.
intros * Hn Hi.
revert i Hi.
induction n; intros; [ flia Hi  | ].
assert (H : sta + n ≤ length u) by flia Hn.
specialize (IHn H); clear H.
rewrite <- Nat.add_sub_assoc in Hi; [ | flia ].
rewrite Nat_sub_succ_1 in Hi.
rewrite seq_S.
rewrite fold_left_app.
destruct (Nat.eq_dec i (sta + n - 1)) as [Hin| Hin]. {
  subst i.
  rewrite Nat.sub_add; [ | flia Hi ].
  cbn.
  rewrite length_fold_left_map_transp.
  rewrite (List_map_nth' 0); [ | rewrite seq_length; flia Hn ].
  rewrite seq_nth; [ | flia Hn ].
  rewrite transposition_out; [ cbn | flia Hi | flia ].
  destruct n; [ flia Hi | ].
  rewrite <- Nat.add_sub_assoc; [ | flia ].
  rewrite Nat_sub_succ_1.
  rewrite seq_S; cbn.
  rewrite fold_left_app; cbn.
  rewrite length_fold_left_map_transp.
  rewrite (List_map_nth' 0); [ | rewrite seq_length; flia Hn ].
  rewrite seq_nth; [ | flia Hn ].
  rewrite transposition_1.
  rewrite Nat.add_1_r.
  rewrite nth_fold_left_map_transp_1; [ | flia Hn | right; flia ].
  now rewrite <- Nat.add_succ_comm.
}
cbn.
rewrite length_fold_left_map_transp.
rewrite (List_map_nth' 0); [ | rewrite seq_length; flia Hn Hi ].
rewrite seq_nth; [ | flia Hn Hi ].
rewrite transposition_out; [ cbn | flia Hi | flia Hi Hin ].
apply IHn.
flia Hi Hin.
Qed.

Theorem nth_fold_left_map_transp : ∀ A (la : list A) i sta len d,
  nth i
    (fold_left
       (λ la' k,
          map (λ j, nth (transposition k (k + 1) j) la' d)
            (seq 0 (length la')))
       (seq sta len) la) d =
  if le_dec (length la) i then d
  else if Nat.eq_dec i (sta + len) then nth sta la d
  else if le_dec (length la) sta then nth i la d
  else if le_dec (length la) (sta + len) then
    nth i
      (fold_left
         (λ la' k,
          map (λ j, nth (transposition k (k + 1) j) la' d)
            (seq 0 (length la)))
         (seq sta (length la - sta)) la) d
  else
    nth (i + Nat.b2n ((sta <=? i) && (i <=? sta + len))) la d.
Proof.
intros.
destruct (le_dec (length la) i) as [Hi| Hi]. {
  rewrite nth_overflow; [ easy | ].
  now rewrite length_fold_left_map_transp.
}
apply Nat.nle_gt in Hi.
destruct (Nat.eq_dec i (sta + len)) as [Hisl| Hisl]. {
  subst i.
  revert la sta d Hi.
  induction len; intros. {
    rewrite Nat.add_0_r in Hi |-*.
    now destruct la.
  }
  cbn.
  rewrite <- Nat.add_succ_comm in Hi.
  rewrite <- Nat.add_succ_comm.
  rewrite IHlen; [ | now rewrite map_length, seq_length ].
  rewrite (List_map_nth' 0); [ | rewrite seq_length; flia Hi ].
  rewrite seq_nth; [ | flia Hi ].
  rewrite Nat.add_0_l, Nat.add_1_r.
  now rewrite transposition_2.
}
unfold Nat.b2n, "&&", negb.
destruct (le_dec (length la) sta) as [Hsla| Hsla]. {
  rewrite List_fold_left_map_nth_len.
  erewrite List_fold_left_ext_in. 2: {
    intros j v Hj; apply in_seq in Hj.
    erewrite map_ext_in. 2: {
      intros k Hk; apply in_seq in Hk.
      rewrite transposition_out; [ | flia Hsla Hj Hk | flia Hsla Hj Hk ].
      easy.
    }
    easy.
  }
  rewrite <- (List_seq_shift' len).
  rewrite List_fold_left_map.
  rewrite <- List_fold_left_map_nth_len.
  rewrite List_fold_left_nop_r.
  rewrite seq_length.
  rewrite repeat_apply_id. 2: {
    intros u.
    symmetry; apply List_map_nth_seq.
  }
  easy.
}
apply Nat.nle_gt in Hsla.
destruct (le_dec (length la) (sta + len)) as [Hsl| Hsl]. {
  replace len with (length la - sta + (sta + len - length la)) at 1
    by flia Hsla Hsl.
  rewrite seq_app.
  rewrite fold_left_app.
  rewrite Nat.add_comm, Nat.sub_add; [ | flia Hsla ].
  rewrite List_fold_left_map_nth_len.
  erewrite List_fold_left_ext_in. 2: {
    intros j v Hj; apply in_seq in Hj.
    erewrite map_ext_in. 2: {
      intros k Hk; apply in_seq in Hk.
      rewrite length_fold_left_map_transp in Hk.
      rewrite transposition_out; [ | flia Hsla Hj Hk | flia Hsla Hj Hk ].
      easy.
    }
    easy.
  }
  rewrite <- List_fold_left_map_nth_len.
  rewrite List_fold_left_nop_r.
  rewrite seq_length.
  rewrite repeat_apply_id. 2: {
    intros u.
    symmetry; apply List_map_nth_seq.
  }
  now rewrite <- List_fold_left_map_nth_len.
}
apply Nat.nle_gt in Hsl.
rewrite if_leb_le_dec.
destruct (le_dec sta i) as [Hip| Hip]. 2: {
  apply Nat.nle_gt in Hip.
  rewrite Nat.add_0_r.
  apply nth_fold_left_map_transp_1; [ easy | now left ].
}
rewrite if_leb_le_dec.
destruct (le_dec i (sta + len)) as [Hip'| Hip']. 2: {
  apply Nat.nle_gt in Hip'.
  rewrite Nat.add_0_r.
  apply nth_fold_left_map_transp_1; [ easy | now right ].
}
assert (H : i < sta + len) by flia Hisl Hip'.
clear Hisl Hip'; rename H into Hisl.
destruct (Nat.eq_dec i (length la - 1)) as [Hila| Hila]. {
  flia Hsl Hisl Hila.
}
destruct (Nat.eq_dec i (sta + len - 1)) as [Hisl1| Hisl1]. 2: {
  rewrite nth_fold_left_seq_gen; [ easy | flia Hsl | flia Hip Hisl Hisl1 ].
}
rewrite Hisl1.
rewrite Nat.sub_add; [ | flia Hisl ].
destruct len; [ flia Hip Hisl | ].
rewrite seq_S.
rewrite fold_left_app; cbn.
rewrite <- Nat.add_sub_assoc; [ | flia ].
rewrite Nat_sub_succ_1.
rewrite length_fold_left_map_transp.
rewrite (List_map_nth' 0); [ | rewrite seq_length; flia Hsl ].
rewrite seq_nth; [ | flia Hsl ].
rewrite transposition_1.
rewrite <- Nat.add_assoc, Nat.add_1_r.
apply nth_fold_left_map_transp_1; [ easy | right; flia ].
Qed.

Theorem mat_el_circ_rot_rows_succ_1 : ∀ (M : matrix T) i j p q,
  i < mat_nrows M
  → i < p ∨ p + q < i
  → mat_el M i j =
    mat_el (fold_left (λ M' k, mat_swap_rows k (k + 1) M') (seq p q) M)
      i j.
Proof.
intros * Hi Hpi.
destruct M as (ll); cbn in Hi; cbn.
unfold mat_el.
rewrite fold_left_mat_fold_left_list_list; cbn.
f_equal; clear j; symmetry.
rewrite nth_fold_left_map_transp.
destruct (le_dec (length ll) i) as [H| H]; [ flia Hi H | clear H ].
destruct (Nat.eq_dec i (p + q)) as [H| H]; [ | clear H ]. {
  destruct Hpi as [Hpi| Hpi]; flia H Hpi.
}
destruct (le_dec (length ll) p) as [Hlp| Hlp]; [ easy | ].
apply Nat.nle_gt in Hlp.
destruct (le_dec (length ll) (p + q)) as [Hpql| Hpql]. 2: {
  apply Nat.nle_gt in Hpql.
  unfold Nat.b2n.
  rewrite andb_if.
  do 2 rewrite if_leb_le_dec.
  destruct (le_dec p i) as [Hpi'| Hpi']; [ | now rewrite Nat.add_0_r ].
  destruct (le_dec i (p + q)) as [H| H]; [ | clear H ]. {
    destruct Hpi as [Hpi| Hpi]; flia H Hpi Hpi'.
  }
  now rewrite Nat.add_0_r.
}
destruct Hpi as [Hpi| Hpi]; [ | flia Hi Hpi Hpql ].
rewrite <- List_fold_left_map_nth_len.
rewrite nth_fold_left_map_transp_1; [ easy | easy | now left ].
Qed.

Theorem mat_el_circ_rot_rows : ∀ (M : matrix T) i j,
  i < mat_nrows M
  → mat_el M 0 j =
      mat_el (fold_left (λ M' k, mat_swap_rows k (k + 1) M') (seq 0 i) M) i j.
Proof.
intros * Hi.
revert M Hi.
induction i; intros; [ easy | ].
rewrite seq_S.
rewrite fold_left_app.
cbn - [ mat_swap_rows ].
rewrite Nat.add_1_r.
rewrite mat_el_mat_swap_rows. 2: {
  now rewrite mat_nrows_fold_left_swap.
}
apply IHi.
flia Hi.
Qed.

Theorem nth_fold_left_map_transp' : ∀ A (la : list A) i len d,
  i + 1 < length la
  → i < len
  → nth i
      (fold_left
         (λ la' k,
            map (λ j, nth (transposition k (k + 1) j) la' d)
              (seq 0 (length la'))) 
         (seq 0 len) la) d =
    nth (i + 1) la d.
Proof.
intros * Hi Hpi.
rewrite nth_fold_left_map_transp; cbn.
rewrite Nat.sub_0_r.
destruct (le_dec (length la) i) as [H| H]; [ flia Hi H | clear H ].
destruct (Nat.eq_dec i len) as [H| H]; [ flia Hpi H | clear H ].
destruct (le_dec (length la) 0) as [H| H]; [ flia Hi H | clear H ].
destruct (le_dec (length la) len) as [Hll| Hll]. 2: {
  apply Nat.nle_gt in Hll.
  unfold Nat.b2n.
  rewrite if_leb_le_dec.
  destruct (le_dec i len) as [H| H]; [ easy | flia Hpi H ].
}
clear len Hpi Hll.
rewrite <- List_fold_left_map_nth_len.
rewrite nth_fold_left_seq_gen; [ easy | easy | flia Hi ].
Qed.

Theorem mat_el_circ_rot_rows_succ : ∀ (M : matrix T) i j p,
  i + 1 < mat_nrows M
  → i + 1 ≠ p
  → mat_el M (i + 1) j =
    mat_el
      (fold_left (λ (M' : matrix T) (k : nat), mat_swap_rows k (k + 1) M')
         (seq 0 (p - 1)) M) (i + Nat.b2n (p <=? i)) j.
Proof.
intros * Hi Hi1p.
destruct M as (ll); cbn in Hi |-*.
unfold mat_el; f_equal; clear j.
rewrite fold_left_mat_fold_left_list_list; cbn.
unfold Nat.b2n.
rewrite if_leb_le_dec.
destruct (le_dec p i) as [Hpi| Hpi]. {
  destruct (le_dec p i) as [H| H]; [ clear H | flia Hpi H ].
  rewrite nth_fold_left_map_transp; cbn.
  destruct (le_dec (length ll) (i + 1)) as [H| H]; [ flia Hi H | clear H ].
  destruct (Nat.eq_dec (i + 1) (p - 1)) as [H| H]; [ flia Hpi H | clear H ].
  destruct (le_dec (length ll) 0) as [H| H]; [ flia Hi H | clear H ].
  destruct (le_dec (length ll) (p - 1)) as [H| H]; [ flia Hi Hpi H | clear H ].
  unfold Nat.b2n.
  rewrite if_leb_le_dec.
  destruct (le_dec (i + 1) (p - 1)) as [H| H]; [ flia Hpi H | clear H ].
  now rewrite Nat.add_0_r.
}
apply Nat.nle_gt in Hpi.
rewrite Nat.add_0_r.
symmetry.
apply nth_fold_left_map_transp'; [ easy | flia Hi1p Hpi ].
Qed.

Theorem subm_mat_swap_rows_succ_succ : ∀ (M : matrix T) i j,
  i + 2 < mat_nrows M
  → subm (mat_swap_rows (i + 1) (i + 2) (mat_swap_rows i (i + 1) M)) (S i) j =
    subm (mat_swap_rows i (i + 1) M) (S (S i)) j.
Proof.
intros * Hi2.
destruct M as (ll); cbn in Hi2 |-*.
unfold subm; f_equal; cbn - [ list_swap_scal butn ].
unfold list_swap_scal.
rewrite List_map_seq_length.
do 2 rewrite <- map_butn.
do 2 rewrite map_map.
do 2 rewrite map_butn_seq.
unfold Nat.b2n.
do 2 rewrite if_ltb_lt_dec.
destruct (lt_dec (S i) (length ll)) as [H| H]; [ clear H | flia Hi2 H ].
destruct (lt_dec (S (S i)) (length ll)) as [H| H]; [ clear H | flia Hi2 H ].
do 2 rewrite Nat.add_0_l.
apply map_ext_in.
intros k Hk; apply in_seq in Hk.
unfold Nat.b2n.
do 2 rewrite if_leb_le_dec.
destruct (le_dec (S i) k) as [Hksi| Hksi]. 2: {
  apply Nat.nle_gt in Hksi.
  rewrite (@transposition_out (i + 1)); [ | flia Hksi | flia Hksi ].
  destruct (le_dec (S (S i)) k) as [Hkssi| Hkssi]. 2: {
    apply Nat.nle_gt in Hkssi.
    rewrite (List_map_nth' 0); [ | rewrite seq_length; flia Hk ].
    rewrite seq_nth; [ easy | flia Hk ].
  }
  flia Hi2 Hk Hksi Hkssi.
} {
  destruct (le_dec (S (S i)) k) as [Hkssi| Hkssi]. 2: {
    apply Nat.nle_gt in Hkssi.
    replace k with (i + 1) by flia Hksi Hkssi.
    rewrite Nat.add_0_r.
    rewrite <- Nat.add_assoc.
    do 2 rewrite transposition_2.
    rewrite List_nth_map_seq; [ | flia Hk Hksi ].
    now rewrite transposition_2.
  }
  rewrite (@transposition_out i (i + 1) (k + 1)); [ | flia Hksi | flia Hksi ].
  rewrite List_nth_map_seq. 2: {
    apply transposition_lt; [ flia Hi2 | easy | flia Hk ].
  }
  rewrite Nat.add_0_l.
  rewrite (@transposition_out (i + 1)); [ | flia Hkssi | flia Hkssi ].
  rewrite transposition_out; [ easy | flia Hkssi | flia Hkssi ].
}
Qed.

(*
Theorem butn_list_swap_scal_0_l : ∀ d (l : list T) p,
  p < length l
  → butn 0 (list_swap_scal d 0 p l) =
    butn p
      (fold_left (λ l' k, list_swap_scal d k (k + 1) l') (seq 0 (p - 1)) l).
Proof.
intros * Hp.
revert l Hp.
induction p; intros. {
  unfold list_swap_scal.
  cbn - [ nth ].
  erewrite map_ext_in. 2: {
    intros i Hi; apply in_seq in Hi.
    now rewrite transposition_id.
  }
  now rewrite <- (List_map_nth_seq l d).
}
...
intros * Hp.
destruct l as [| a]; intros; [ easy | cbn in Hp ].
destruct p. {
  unfold list_swap_scal.
  cbn - [ nth ].
  rewrite <- seq_shift, map_map.
  erewrite map_ext_in. 2: {
    intros i Hi; apply in_seq in Hi.
    now cbn.
  }
  symmetry.
  apply List_map_nth_seq.
}
apply Nat.succ_lt_mono in Hp.
rewrite list_swap_scal_0_succ_cons.
rewrite butn_0.
rewrite Nat_sub_succ_1.
cbn - [ butn ].
revert p Hp.
induction l as [| b]; intros; [ easy | ].
destruct p. {
  cbn - [ nth ]; f_equal.
  rewrite <- seq_shift, map_map; cbn.
  symmetry.
  apply List_map_nth_seq.
}
cbn in Hp.
apply Nat.succ_lt_mono in Hp.
cbn - [ map nth butn fold_left ].
rewrite map_cons.
cbn - [ map nth butn fold_left ].
remember (nth 0 _ _) as x; cbn in Heqx; subst x.
rewrite <- seq_shift, map_map.
erewrite map_ext_in; [ | now intros i Hi; cbn ].
rewrite IHl; [ clear IHl | easy ].
replace (0 :: seq 1 p) with (seq 0 (S p)) by easy.
rewrite seq_S, Nat.add_0_l.
rewrite fold_left_app.
remember (S p) as sp.
cbn - [ butn list_swap_scal ].
unfold list_swap_scal at 2.
unfold list_swap_scal.
rewrite length_fold_left_map_transp.
rewrite <- map_butn.
rewrite map_butn_seq.
rewrite Nat.add_0_l.
cbn - [ "<=?" "-" ].
unfold Nat.b2n at 2.
rewrite if_ltb_lt_dec.
destruct (lt_dec (S sp) (S (S (length l)))) as [H| H]; [ | flia Hp Heqsp H ].
clear H.
rewrite Nat_sub_succ_1.
cbn; f_equal. {
  unfold transposition at 1.
  do 2 rewrite if_eqb_eq_dec.
  destruct (Nat.eq_dec 0 (p + 1)) as [H| H]; [ flia H | clear H ].
  destruct (Nat.eq_dec 0 p) as [Hpz| Hpz]; [ now subst p | ].
  destruct p; [ easy | ].
...
Theorem mat_list_list_fold_left : ∀ A (M : matrix T) f g (l : list A),
  mat_list_list (fold_left f l M) = g M.
Proof.
intros.
destruct l as [| a]; intros; cbn.
(*
  mat_list_list M = g M
*)
admit.
...
intros.
revert M.
induction l as [| a]; intros; [ admit | cbn ].
cbn.
rewrite IHl.
...
g M = mat_list_list M
g (f M a) = g M
Search (mat_list_list (fold_left _ _ _)).
...
Search (nth 0).
Search (nth _ (fold_left _ _ _)).

Search (nth (transposition _ _ _)).
...
Search (length (fold_left _ _ _)).
Search mat_swap_rows.
About mat_el_circ_rot_rows.
...
unfold list_swap_scal at 2.
Search (length (fold_left _ _ _)).
...
unfold butn at 2.
Search (firstn (S _)).
...
Search (butn (S _)).
rewrite butn_cons.
cbn - [ butn list_swap_scal ].
cbn - [ fold_left].
...
rewrite map_cons.
cbn - [ nth ].
...
*)

Theorem subm_mat_swap_rows_circ : ∀ (M : matrix T) p q,
  p < mat_nrows M
  → subm (mat_swap_rows 0 p M) 0 q =
    subm (fold_left (λ M' k, mat_swap_rows k (k + 1) M') (seq 0 (p - 1)) M)
      p q.
Proof.
intros * Hp.
destruct M as (ll); cbn in Hp |-*.
unfold subm; f_equal.
cbn - [ butn ].
f_equal; clear q.
rewrite fold_left_mat_fold_left_list_list.
cbn - [ butn ].
rewrite List_map_nth_seq with (d := []); symmetry.
rewrite List_map_nth_seq with (d := []); symmetry.
rewrite butn_length, map_length, seq_length.
rewrite butn_length.
rewrite length_fold_left_map_transp.
unfold Nat.b2n.
do 2 rewrite if_ltb_lt_dec.
destruct (lt_dec 0 (length ll)) as [H| H]; [ clear H | flia H Hp ].
destruct (lt_dec p (length ll)) as [H| H]; [ clear H | flia H Hp ].
apply map_ext_in.
intros i Hi; apply in_seq in Hi.
cbn in Hi.
rewrite <- map_butn.
rewrite (List_map_nth' 0). 2: {
  rewrite butn_length, seq_length.
  unfold Nat.b2n.
  rewrite if_ltb_lt_dec.
  destruct (lt_dec 0 (length ll)) as [H| H]; [ easy | flia Hp H ].
}
rewrite nth_butn_before; [ | flia ].
rewrite seq_nth; [ cbn | flia Hi ].
destruct (le_dec p i) as [Hpi| Hpi]. 2: {
  apply Nat.nle_gt in Hpi.
  rewrite nth_butn_after; [ | easy ].
  rewrite nth_fold_left_map_transp; cbn.
  rewrite Nat.sub_0_r.
  destruct (le_dec (length ll) i) as [H| H]; [ flia Hi H | clear H ].
  destruct (Nat.eq_dec i (p - 1)) as [Hip1| Hip1]. {
    rewrite Hip1, Nat.sub_add; [ | flia Hpi ].
    now rewrite transposition_2.
  }
  destruct (le_dec (length ll) 0) as [H| H]; [ flia Hp H | clear H ].
  destruct (le_dec (length ll) (p - 1)) as [H| H]; [ flia Hp H | clear H ].
  unfold transposition.
  unfold Nat.b2n.
  do 2 rewrite if_eqb_eq_dec.
  rewrite if_leb_le_dec.
  rewrite Nat.add_1_r.
  destruct (Nat.eq_dec (S i) 0) as [H| H]; [ easy | clear H ].
  destruct (Nat.eq_dec (S i) p) as [H| H]; [ flia Hip1 H | clear H ].
  destruct (le_dec i (p - 1)) as [H| H]; [ | flia Hpi H ].
  now rewrite Nat.add_1_r.
}
rewrite transposition_out; [ | flia | flia Hpi ].
rewrite nth_butn_before; [ | easy ].
symmetry.
rewrite nth_fold_left_map_transp; cbn; rewrite Nat.sub_0_r.
destruct (le_dec (length ll) (i + 1)) as [H| H]; [ flia Hi H | clear H ].
destruct (Nat.eq_dec (i + 1) (p - 1)) as [H| H]; [ flia Hpi H | clear H ].
destruct (le_dec (length ll) 0) as [H| H]; [ flia Hp H | clear H ].
destruct (le_dec (length ll) (p - 1)) as [H| H]; [ flia Hp H | clear H ].
unfold Nat.b2n.
rewrite if_leb_le_dec.
destruct (le_dec (i + 1) (p - 1)) as [H| H]; [ flia Hpi H | clear H ].
now rewrite Nat.add_0_r.
Qed.

Theorem mat_swap_rows_fold_left : ∀ (M : matrix T) i,
  mat_swap_rows i (S i)
    (fold_left (λ M' k, mat_swap_rows k (k + 1) M') (seq 0 i) M) =
   fold_left (λ M' k, mat_swap_rows k (k + 1) M') (seq 0 (S i)) M.
Proof.
intros.
rewrite seq_S; cbn.
rewrite fold_left_app; cbn.
now rewrite Nat.add_1_r.
Qed.

Theorem subm_fold_left_lt : ∀ (M : matrix T) i j m,
  m < i
  → subm
      (fold_left (λ M' k, mat_swap_rows k (k + 1) M')
         (seq 0 m) M) i j =
    fold_left
      (λ M' k, mat_swap_rows k (k + 1) M')
      (seq 0 m) (subm M i j).
Proof.
intros * Hmi.
revert i Hmi.
induction m; intros; [ easy | ].
rewrite seq_S; cbn.
do 2 rewrite fold_left_app; cbn.
rewrite <- IHm; [ | flia Hmi ].
apply subm_mat_swap_rows_lt; flia Hmi.
Qed.

Theorem determinant_circular_shift_rows :
  rngl_is_comm = true →
  rngl_has_opp = true →
  rngl_has_inv = true →
  rngl_is_integral = true →
  rngl_has_1_neq_0 = true →
  rngl_has_dec_eq = true →
  rngl_characteristic = 0 →
  ∀ n (M : matrix T) i,
  i < n
  → is_square_matrix n M = true
  → determinant n (fold_left (λ M' k, mat_swap_rows k (k + 1) M') (seq 0 i) M) =
    (minus_one_pow i * determinant n M)%F.
Proof.
intros Hic Hop Hiv Hit H10 Hde Hch * Hin Hsm.
revert M Hsm.
induction i; intros; [ now cbn; rewrite rngl_mul_1_l | ].
assert (H : i < n) by flia Hin.
specialize (IHi H); clear H.
rewrite seq_S; cbn.
rewrite fold_left_app; cbn.
rewrite determinant_alternating; try easy; [ | flia | flia Hin | flia Hin | ].
2: {
  specialize (square_matrix_ncols _ Hsm) as Hc1.
  apply is_sm_mat_iff.
  apply is_sm_mat_iff in Hsm.
  destruct Hsm as (Hr & Hcr & Hc).
  rewrite mat_nrows_fold_left_swap.
  split; [ easy | ].
  split. {
    intros Hc'.
    unfold mat_ncols in Hc'.
    rewrite fold_left_mat_fold_left_list_list in Hc'.
    cbn in Hc'.
    apply length_zero_iff_nil in Hc'.
    rewrite List_hd_nth_0 in Hc'.
    rewrite nth_fold_left_map_transp in Hc'.
    rewrite fold_mat_nrows in Hc'.
    do 2 rewrite Nat.add_0_l in Hc'.
    destruct (le_dec (mat_nrows M) 0) as [Hlz| Hlz]. {
      now apply Nat.le_0_r in Hlz.
    }
    apply Nat.nle_gt in Hlz.
    destruct (Nat.eq_dec 0 i) as [Hiz| Hiz]. {
      subst i.
      apply Hcr.
      unfold mat_ncols.
      rewrite List_hd_nth_0.
      now rewrite Hc'.
    }
    rewrite Nat.sub_0_r in Hc'.
    destruct (le_dec (mat_nrows M) i) as [Hri| Hri]. {
      unfold mat_nrows in Hc'.
      rewrite <- List_fold_left_map_nth_len in Hc'.
      rewrite nth_fold_left_map_transp' in Hc'; cycle 1. {
        rewrite fold_mat_nrows.
        flia Hin Hr.
      } {
        now rewrite fold_mat_nrows.
      }
      cbn in Hc'.
      apply (f_equal length) in Hc'.
      rewrite Hc in Hc'. 2: {
        apply nth_In.
        rewrite fold_mat_nrows.
        flia Hr Hin.
      }
      now rewrite Hr, Hc'.
    }
    apply Nat.nle_gt in Hri.
    cbn in Hc'.
    apply (f_equal length) in Hc'.
    rewrite Hc in Hc'. 2: {
      apply nth_In.
      rewrite fold_mat_nrows.
      flia Hr Hin.
    }
    now rewrite Hr, Hc'.
  }
  intros la Hla.
  rewrite fold_left_mat_fold_left_list_list in Hla.
  cbn in Hla.
  apply In_nth with (d := []) in Hla.
  rewrite length_fold_left_map_transp, fold_mat_nrows in Hla.
  destruct Hla as (j & Hj & Hla).
  rewrite nth_fold_left_map_transp in Hla.
  rewrite fold_mat_nrows in Hla.
  rewrite Nat.add_0_l in Hla.
  destruct (le_dec (mat_nrows M) j) as [H| H]; [ flia Hj H | clear H ].
  destruct (Nat.eq_dec j i) as [Hji| Hji]. {
    subst la.
    apply Hc, nth_In.
    rewrite fold_mat_nrows; flia Hj.
  }
  destruct (le_dec (mat_nrows M) 0) as [H| H]; [ flia Hj H | clear H ].
  destruct (le_dec (mat_nrows M) i) as [H| H]; [ flia Hin Hr H | clear H ].
  subst la.
  unfold Nat.b2n.
  rewrite andb_if.
  do 2 rewrite if_leb_le_dec.
  destruct (le_dec 0 j) as [Hjz| Hjz]. {
    destruct (le_dec j i) as [Hji'| Hji']. {
      apply Hc, nth_In.
      rewrite fold_mat_nrows.
      rewrite Hr in Hj |-*.
      flia Hji' Hin.
    }
    apply Nat.nle_gt in Hji'.
    rewrite Nat.add_0_r.
    apply Hc, nth_In.
    now rewrite fold_mat_nrows.
  }
  now apply Nat.nle_gt in Hjz.
}
rewrite IHi; [ | easy ].
rewrite minus_one_pow_succ; [ | easy ].
now symmetry; apply rngl_mul_opp_l.
Qed.

Theorem determinant_subm_mat_swap_rows_0_i :
  rngl_is_comm = true →
  rngl_has_opp = true →
  rngl_has_inv = true →
  rngl_is_integral = true →
  rngl_has_1_neq_0 = true →
  rngl_has_dec_eq = true →
  rngl_characteristic = 0 →
  ∀ n (M : matrix T) i j,
  is_square_matrix (S n) M = true
  → 0 < i ≤ n
  → j ≤ n
  → determinant n (subm (mat_swap_rows 0 i M) 0 j) =
    (- minus_one_pow i * determinant n (subm M i j))%F.
Proof.
intros Hic Hop Hiv Hit H10 Hde Hch * Hsm (Hiz, Hin) Hjn.
rewrite subm_mat_swap_rows_circ. 2: {
  apply is_sm_mat_iff in Hsm.
  destruct Hsm as (Hr, _).
  rewrite Hr; flia Hin.
}
destruct i; [ flia Hiz | ].
rewrite minus_one_pow_succ; [ | easy ].
rewrite rngl_opp_involutive; [ | easy ].
rewrite Nat_sub_succ_1.
rewrite subm_fold_left_lt; [ | flia ].
apply determinant_circular_shift_rows; try easy.
apply is_squ_mat_subm; [ flia Hin | flia Hin | flia Hjn | easy ].
Qed.

(* Laplace formulas *)

Theorem laplace_formula_on_rows :
  rngl_is_comm = true →
  rngl_has_opp = true →
  rngl_has_inv = true →
  rngl_is_integral = true →
  rngl_has_1_neq_0 = true →
  rngl_has_dec_eq = true →
  rngl_characteristic = 0 →
  ∀ n (M : matrix T) i,
  is_square_matrix n M = true
  → i < n
  → determinant n M =
    ∑ (j = 0, n - 1), mat_el M i j * mat_el (comatrix n M) i j.
Proof.
intros Hic Hop Hin Hit H10 Hde Hch * Hsm Hlin.
specialize (square_matrix_ncols M Hsm) as Hc.
specialize (proj1 (is_sm_mat_iff n M) Hsm) as H1.
destruct H1 as (Hr & Hcr & Hc').
destruct (Nat.eq_dec i 0) as [Hiz| Hiz]. {
  subst i.
  destruct n; [ easy | cbn ].
  rewrite Nat.sub_0_r at 1.
  symmetry.
  apply rngl_summation_eq_compat.
  intros j Hj.
  rewrite rngl_mul_comm; [ | easy ].
  rewrite rngl_mul_mul_swap; [ | easy ].
  rewrite (List_map_nth' 0); [ | rewrite seq_length; flia Hr ].
  rewrite (List_map_nth' 0); [ | rewrite seq_length; flia Hj Hc ].
  rewrite seq_nth; [ | flia Hr ].
  rewrite seq_nth; [ | flia Hj Hc ].
  rewrite Nat.sub_0_r.
  do 3 rewrite Nat.add_0_l.
  easy.
}
move i before n.
move Hiz after Hlin.
destruct n; [ easy | cbn ].
rewrite Nat.sub_0_r.
symmetry.
erewrite rngl_summation_eq_compat. 2: {
  intros j Hj.
  rewrite (List_map_nth' 0); [ | rewrite seq_length; flia Hlin Hr ].
  rewrite (List_map_nth' 0); [ | rewrite seq_length; flia Hj Hc ].
  rewrite seq_nth; [ | flia Hlin Hr ].
  rewrite seq_nth; [ | flia Hj Hc ].
  do 2 rewrite Nat.add_0_l.
  rewrite rngl_mul_comm; [ | easy ].
  rewrite rngl_mul_mul_swap; [ | easy ].
  easy.
}
cbn.
rename i into p.
remember (mat_swap_rows 0 p M) as M'.
erewrite rngl_summation_eq_compat. 2: {
  intros j Hj.
  rewrite rngl_mul_mul_swap; [ | easy ].
  rewrite Nat.add_comm.
  rewrite minus_one_pow_add_r; [ | easy ].
  do 2 rewrite <- rngl_mul_assoc.
  rewrite rngl_mul_comm; [ | easy ].
  rewrite rngl_mul_assoc.
  remember (minus_one_pow p * _)%F as x eqn:Hx.
  rewrite <- rngl_opp_involutive in Hx; [ | easy ].
  rewrite <- rngl_mul_opp_l in Hx; [ | easy ].
  specialize determinant_subm_mat_swap_rows_0_i as H1.
  specialize (H1 Hic Hop Hin Hit H10 Hde Hch).
  specialize (H1 n M p j Hsm).
  cbn in H1.
  rewrite <- H1 in Hx; [ | flia Hiz Hlin | easy ].
  subst x; clear H1.
  rewrite rngl_mul_comm; [ | easy ].
  rewrite rngl_mul_assoc, rngl_mul_mul_swap; [ | easy ].
  replace (mat_el M p j) with (mat_el (mat_swap_rows 0 p M) 0 j). 2: {
    unfold mat_swap_rows.
    cbn; unfold list_swap_scal.
    rewrite fold_mat_nrows.
    rewrite (List_map_nth' 0); [ | rewrite seq_length; flia Hr ].
    rewrite seq_nth; [ | flia Hr ].
    rewrite Nat.add_0_r, transposition_1.
    easy.
  }
  rewrite <- HeqM'.
  rewrite rngl_mul_opp_r; [ | easy ].
  easy.
}
cbn.
rewrite <- rngl_opp_summation; [ | easy ].
do 2 rewrite <- determinant_succ.
subst M'.
rewrite <- rngl_opp_involutive; [ | easy ].
f_equal.
apply determinant_alternating; try easy; [ flia Hiz | flia ].
Qed.

Theorem rngl_product_fun_permut :
  rngl_is_comm = true →
  ∀ n (σ : vector nat) (f : nat → T),
  n ≠ 0
  → is_permut_vect n σ
  → ∏ (i = 0, n - 1), f (vect_nat_el σ i) = ∏ (i = 0, n - 1), f i.
Proof.
intros Hic * Hnz Hσ.
destruct n; [ easy | clear Hnz ].
rewrite Nat_sub_succ_1.
destruct Hσ as (Hs & H1 & H2).
revert σ Hs H1 H2.
induction n; intros. cbn. {
  rewrite rngl_product_only_one.
  rewrite rngl_product_only_one.
  specialize (H1 0 Nat.lt_0_1) as H3.
  apply Nat.lt_1_r in H3.
  now rewrite H3.
}
set
  (g := λ i,
   if lt_dec i (vect_nat_el (permut_inv (S (S n)) σ) (S n)) then i else i + 1).
set (σ' := mk_vect (map (λ i, vect_nat_el σ (g i)) (seq 0 (S n)))).
specialize (IHn σ').
assert (H : vect_size σ' = S n). {
  unfold σ'; cbn.
  now rewrite map_length, seq_length.
}
specialize (IHn H); clear H.
assert (H : ∀ i : nat, i < S n → vect_nat_el σ' i < S n). {
  intros i Hi.
  unfold σ'; cbn - [ seq ].
  rewrite (List_map_nth' 0); [ | now rewrite seq_length ].
  rewrite seq_nth; [ | easy ].
  rewrite Nat.add_0_l.
  unfold g; cbn - [ seq ].
  rewrite (List_map_nth' 0); [ | rewrite seq_length; flia ].
  rewrite seq_nth; [ | flia ].
  rewrite Nat.add_0_l.
  destruct (Nat.eq_dec (vect_nat_el σ (S n)) (S n)) as [Hσn| Hσn]. {
    destruct (lt_dec i (S n)) as [H| H]; [ clear H | flia Hi H ].
    specialize (H1 i).
    assert (H : i < S (S n)) by flia Hi.
    specialize (H1 H); clear H.
    destruct (Nat.eq_dec (vect_nat_el σ i) (S n)) as [Hσ| Hσ]; [ | flia H1 Hσ ].
    rewrite <- Hσn in Hσ.
    apply H2 in Hσ; [ flia Hi Hσ | flia Hi | flia ].
  }
  destruct (Nat.eq_dec (vect_nat_el σ n) (S n)) as [Hσs| Hσs]. {
    destruct (lt_dec i n) as [Hin| Hin]. {
      specialize (H1 i).
      assert (H : i < S (S n)) by flia Hi.
      specialize (H1 H); clear H.
      destruct (Nat.eq_dec (vect_nat_el σ i) (S n)) as [Hσ| Hσ]. 2: {
        flia H1 Hσ.
      }
      rewrite <- Hσs in Hσ.
      apply H2 in Hσ; [ flia Hin Hσ | flia Hi | flia ].
    }
    replace i with n by flia Hi Hin.
    rewrite Nat.add_1_r.
    specialize (H1 (S n) (Nat.lt_succ_diag_r (S n))).
    flia H1 Hσn.
  }
  destruct (lt_dec i (permut_fun_inv (vect_nat_el σ) n (S n))) as [H3| H3]. {
    destruct (Nat.eq_dec (vect_nat_el σ i) (S n)) as [H4| H4]. {
      exfalso.
      rewrite <- H4 in H3. (* at 2 *)
      rewrite permut_fun_inv_fun' in H3; [ flia H3 | | ]. 2: {
        destruct (Nat.eq_dec i n) as [H5| H5]; [ now subst i | ].
        flia Hi H5.
      }
      intros j k Hj Hk Hjk.
      apply H2; [ flia Hj | flia Hk | easy ].
    }
    specialize (H1 i).
    assert (H : i < S (S n)) by flia Hi.
    specialize (H1 H); clear H.
    flia H1 H4.
  }
  rewrite Nat.add_1_r.
  specialize (H1 (S i)).
  assert (H : S i < S (S n)) by flia Hi.
  specialize (H1 H); clear H.
  destruct (Nat.eq_dec (vect_nat_el σ (S i)) (S n)) as [H4| H4]. {
    exfalso.
    rewrite <- H4 in H3. (* at 2 *)
    rewrite permut_fun_inv_fun' in H3; [ flia H3 | | ]. 2: {
      destruct (Nat.eq_dec i n) as [H5| H5]; [ now subst i | ].
      destruct (Nat.eq_dec (S i) n) as [H6| H6]. {
        now rewrite H6 in H4.
      }
      flia Hi H5 H6.
    }
    intros j k Hj Hk Hjk.
    apply H2; [ flia Hj | flia Hk | easy ].
  }
  flia H1 H4.
}
specialize (IHn H); clear H.
assert
  (H : ∀ i j, i < S n → j < S n →
   vect_nat_el σ' i = vect_nat_el σ' j → i = j). {
  intros i j Hi Hj Hij; cbn - [ seq ] in Hij.
  rewrite (List_map_nth' 0) in Hij; [ | now rewrite seq_length ].
  rewrite (List_map_nth' 0) in Hij; [ | now rewrite seq_length ].
  rewrite seq_nth in Hij; [ | easy ].
  rewrite seq_nth in Hij; [ | easy ].
  do 2 rewrite Nat.add_0_l in Hij.
  unfold g in Hij; cbn - [ seq ] in Hij.
  rewrite (List_map_nth' 0) in Hij; [ | rewrite seq_length; flia ].
  rewrite seq_nth in Hij; [ | flia ].
  rewrite Nat.add_0_l in Hij.
  destruct (Nat.eq_dec (vect_nat_el σ (S n)) (S n)) as [H3| H3]. {
    destruct (lt_dec i (S n)) as [H| H]; [ clear H | flia Hi H ].
    destruct (lt_dec j (S n)) as [H| H]; [ clear H | flia Hj H ].
    apply H2; [ flia Hi | flia Hj | easy ].
  }
  destruct (Nat.eq_dec (vect_nat_el σ n) (S n)) as [H4| H4]. {
    destruct (lt_dec i n) as [Hin| Hin]. {
      destruct (lt_dec j n) as [Hjn| Hjn]. {
        apply H2; [ flia Hi | flia Hj | easy ].
      }
      replace j with n in Hij by flia Hj Hjn.
      rewrite Nat.add_1_r in Hij.
      rewrite <- Hij in H3.
      apply H2 in Hij; [ flia Hin Hij | flia Hi | flia ].
    }
    replace i with n in Hij |-* by flia Hi Hin.
    rewrite Nat.add_1_r in Hij.
    destruct (lt_dec j n) as [Hjn| Hjn]. {
      apply H2 in Hij; [ flia Hjn Hij | flia | flia Hjn ].
    }
    now replace j with n by flia Hj Hjn.
  }
  remember (permut_fun_inv (vect_nat_el σ) n (S n)) as k eqn:Hk.
  destruct (lt_dec i k) as [H5| H5]. {
    destruct (lt_dec j k) as [H6| H6]. {
      apply H2; [ flia Hi | flia Hj | easy ].
    }
    apply H2 in Hij; [ | flia Hi | flia Hj ].
    flia H5 H6 Hij.
  }
  destruct (lt_dec j k) as [H6| H6]. {
    apply H2 in Hij; [ | flia Hi | flia Hj ].
    flia H5 H6 Hij.
  }
  apply H2 in Hij; [ | flia Hi | flia Hj ].
  flia Hij.
}
specialize (IHn H); clear H.
remember (vect_nat_el (permut_inv (S (S n)) σ) (S n)) as k eqn:Hk.
destruct (Nat.eq_dec k (S n)) as [Hksn| Hksn]. {
  erewrite rngl_product_eq_compat in IHn. 2: {
    intros i Hi.
    unfold σ', g; cbn - [ seq ].
    rewrite (List_map_nth' 0); [ | rewrite seq_length; flia Hi ].
    rewrite seq_nth; [ | flia Hi ].
    rewrite Nat.add_0_l.
    destruct (lt_dec i k) as [H| H]; [ easy | flia Hksn Hi H ].
  }
  cbn in IHn.
  rewrite rngl_product_split_last; [ | flia ].
  rewrite rngl_product_succ_succ' with (g0 := λ i, f (vect_nat_el σ i)).
  symmetry.
  rewrite rngl_product_split_last; [ | flia ].
  rewrite rngl_product_succ_succ'.
  symmetry.
  rewrite IHn; f_equal; f_equal.
  rewrite Hk in Hksn.
  rewrite <- Hksn at 1.
  unfold permut_inv.
  cbn - [ permut_fun_inv seq ].
  rewrite (List_map_nth' 0); [ | rewrite seq_length; flia ].
  rewrite seq_nth; [ | flia ].
  rewrite Nat.add_0_l.
  rewrite fun_permut_fun_inv; [ easy | easy | flia ].
}
(* voir permut_fun_inv_fun et fun_find_prop : ils font pas double
   emploi, ceux-là ? *)
(* et permut_fun_inv_fun' aussi !!! *)
specialize permut_inv_is_permut as H3.
specialize (H3 (S (S n)) σ).
assert (H : is_permut_vect (S (S n)) σ) by easy.
specialize (H3 H); clear H.
rewrite rngl_product_split with (j := k) in IHn. 2: {
  split; [ flia | ].
  destruct H3 as (Hsi & H3 & H4).
  apply -> Nat.succ_le_mono.
  specialize (H3 (S n)) as H5.
  assert (H : S n < S (S n)) by flia.
  specialize (H5 H); clear H.
  rewrite <- Hk in H5.
  flia Hksn H5.
}
rewrite rngl_product_split_last in IHn; [ | flia ].
destruct (Nat.eq_dec k 0) as [Hkz| Hkz]. {
  move Hkz at top; subst k.
  rewrite rngl_product_empty in IHn; [ | flia ].
  rewrite rngl_mul_1_l, Nat.add_0_l in IHn.
  unfold σ' in IHn at 1.
  cbn - [ seq ] in IHn.
  rewrite (List_map_nth' 0) in IHn; [ | rewrite seq_length; flia ].
  rewrite seq_nth in IHn; [ | flia ].
  rewrite Nat.add_0_l in IHn.
  erewrite rngl_product_eq_compat in IHn. 2: {
    intros i Hi.
    rewrite (List_map_nth' 0); [ | rewrite seq_length; flia Hi ].
    rewrite seq_nth; [ | flia Hi ].
    rewrite Nat.add_0_l.
    easy.
  }
  symmetry.
  rewrite rngl_product_split_last; [ | flia ].
  rewrite rngl_product_succ_succ'.
  rewrite <- IHn.
  symmetry.
  rewrite rngl_product_split_first; [ | flia ].
  rewrite Hk at 1.
  unfold permut_inv.
  cbn - [ permut_fun_inv seq ].
  rewrite (List_map_nth' 0); [ | rewrite seq_length; flia ].
  rewrite seq_nth; [ | flia ].
  rewrite Nat.add_0_l.
  rewrite fun_permut_fun_inv; [ | easy | flia ].
  rewrite rngl_mul_comm; [ | easy ].
  f_equal.
  rewrite rngl_product_succ_succ.
  rewrite rngl_product_split_first; [ | flia ].
  f_equal.
  apply rngl_product_eq_compat.
  now intros; rewrite Nat.add_1_r.
}
erewrite rngl_product_eq_compat in IHn. 2: {
  intros i Hi.
  unfold σ'; cbn - [ seq ].
  assert (H : i - 1 < S n). {
    rewrite Hk in Hi.
    unfold is_permut_vect in H3.
    destruct H3 as (Hsi, (H3, H4)).
    specialize (H3 (S n)).
    assert (H : S n < S (S n)) by flia.
    specialize (H3 H); clear H.
    flia H3 Hi.
  }
  rewrite (List_map_nth' 0); [ | now rewrite seq_length ].
  rewrite seq_nth; [ | easy ].
  clear H.
  rewrite Nat.add_0_l.
  unfold g.
  destruct (lt_dec (i - 1) k) as [H| H]; [ | flia Hi H ].
  easy.
}
cbn - [ seq ] in IHn.
destruct k; [ easy | clear Hkz ].
rewrite rngl_product_succ_succ' with (g0 := λ i, f (vect_nat_el σ i)) in IHn.
erewrite rngl_product_eq_compat with (b := S k + 1) in IHn. 2: {
  intros i Hi.
  rewrite (List_map_nth' 0); [ | rewrite seq_length; flia Hi ].
  rewrite seq_nth; [ | flia Hi ].
  rewrite Nat.add_0_l.
  unfold g.
  destruct (lt_dec i (S k)) as [H| H]; [ flia Hi H | easy ].
}
cbn in IHn.
rewrite rngl_mul_mul_swap in IHn; [ | easy ].
symmetry.
rewrite rngl_product_split_last; [ | flia ].
rewrite rngl_product_succ_succ'.
rewrite <- IHn.
symmetry.
rewrite rngl_product_split with (j := k). 2: {
  split; [ flia | ].
  destruct H3 as (Hsi, (H3, H4)).
  rewrite Hk.
  apply Nat.lt_le_incl.
  apply H3; flia.
}
do 2 rewrite <- rngl_mul_assoc.
f_equal.
rewrite rngl_product_split_last. 2: {
  rewrite Nat.add_1_r.
  rewrite Hk.
  destruct H3 as (Hsi, (H3, H4)).
  apply Nat.lt_succ_r.
  apply H3; flia.
}
rewrite rngl_product_succ_succ' with (g0 := λ i, f (vect_nat_el σ i)).
rewrite rngl_product_split_first. 2: {
  rewrite Nat.add_1_r.
  rewrite Hk.
  destruct H3 as (Hsi, (H3, H4)).
  specialize (H3 (S n) (Nat.lt_succ_diag_r _)).
  rewrite <- Hk in H3.
  rewrite (List_map_nth' 0) in IHn; [ | rewrite seq_length; flia Hksn H3 ].
  rewrite seq_nth in IHn; [ | flia Hksn H3 ].
  destruct
    (Nat.eq_dec (vect_nat_el (permut_inv (S (S n)) σ) (S n)) (S n))
    as [H5| H5]. {
    flia Hk Hksn H5.
  }
  rewrite <- Hk in H5 |-*.
  flia H3 H5.
}
replace (vect_nat_el σ (k + 1)) with (S n). 2: {
  rewrite Nat.add_1_r.
  rewrite Hk.
  unfold permut_inv.
  cbn - [ permut_fun_inv seq ].
  rewrite (List_map_nth' 0); [ | rewrite seq_length; flia ].
  rewrite seq_nth; [ | flia ].
  rewrite fun_permut_fun_inv; [ easy | easy | flia ].
}
rewrite <- rngl_mul_assoc.
rewrite rngl_mul_comm; [ | easy ].
rewrite rngl_mul_assoc.
f_equal.
destruct
  (Nat.eq_dec (vect_nat_el (permut_inv (S (S n)) σ) (S n)) n) as [H7| H7]. {
  rewrite H7 in Hk.
  rewrite Nat.add_1_r.
  rewrite Hk.
  rewrite rngl_product_empty; [ | flia ].
  rewrite rngl_product_empty; [ | flia ].
  rewrite (List_map_nth' 0); [ | rewrite seq_length; flia Hk ].
  rewrite seq_nth; [ | flia Hk ].
  unfold g; cbn.
  destruct (lt_dec (S k) (S k)) as [H| H]; [ flia H | clear H ].
  now rewrite Nat.add_1_r, Hk.
}
assert (Hkn : S (k + 1) ≤ n). {
  rewrite Nat.add_1_r.
  rewrite Hk.
  destruct H3 as (Hsi, (H3, H4)).
  apply Nat.le_succ_l.
  specialize (H3 (S n) (Nat.lt_succ_diag_r _)) as H5.
  destruct
    (Nat.eq_dec (vect_nat_el (permut_inv (S (S n)) σ) (S n)) (S n))
    as [H6| H6]. {
    flia Hk Hksn H6.
  }
  flia H5 H6 H7.
}
rewrite rngl_product_split_first; [ | easy ].
rewrite <- rngl_mul_assoc.
rewrite rngl_mul_comm; [ | easy ].
unfold g.
rewrite (List_map_nth' 0); [ | rewrite seq_length; flia Hkn ].
rewrite seq_nth; [ | flia Hkn ].
rewrite Nat.add_1_r.
cbn.
destruct (lt_dec (S k) (S k)) as [H| H]; [ flia H | clear H ].
rewrite Nat.add_1_r.
f_equal.
symmetry.
rewrite rngl_product_split_last; [ | flia Hkn ].
rewrite Nat.add_1_r.
f_equal.
apply rngl_product_eq_compat.
intros i Hi.
rewrite Nat.sub_add; [ easy | flia Hi ].
Qed.

Theorem permut_comp_assoc : ∀ n (f g h : vector nat),
  vect_size g = n
  → is_permut_vect n h
  → (f ° (g ° h) = (f ° g) ° h)%F.
Proof.
intros n (f) (g) (h) Hsg Hh.
cbn in Hsg, Hh.
unfold "°", comp_list; cbn.
rewrite map_map.
f_equal.
apply map_ext_in.
intros i Hi.
rewrite (List_map_nth' 0); [ easy | ].
destruct Hh as (Hsh, (Hh1, Hh2)).
cbn in Hsh, Hh1, Hh2.
apply (In_nth h i 0) in Hi.
destruct Hi as (j & Hjh & Hj).
subst i.
rewrite Hsh in Hjh.
rewrite Hsg.
now apply Hh1.
Qed.

Theorem comp_permut_inv_r : ∀ n f,
  is_permut_vect n f
  → (f ° permut_inv n f = mk_vect (seq 0 n)).
Proof.
intros n (f) Hf.
unfold "°"; cbn.
f_equal.
rewrite map_map.
rewrite (List_map_nth_seq (seq 0 n)) with (d := 0) at 2.
rewrite seq_length.
apply map_ext_in.
intros i Hi; apply in_seq in Hi.
rewrite seq_nth; [ | easy ].
destruct Hf as (Hs, Hf).
now apply (@fun_permut_fun_inv (λ i, nth i f 0)).
Qed.

Theorem comp_id_l : ∀ A B (f : A → B), comp id f = f.
Proof. easy. Qed.

Fixpoint vect_eqb_loop A n (eqb : A → A → bool) d (u v : vector A) i :=
  match i with
  | 0 => true
  | S i' =>
      if eqb (vect_el u i' d) (vect_el v i' d) then vect_eqb_loop eqb n d u v i'
      else false
  end.

...

Definition vect_eqb A n (eqb : A → A → bool) (u v : vector n A) : bool :=
  vect_eqb_loop eqb u v n.

Fixpoint vect_find_loop A n (f : A → bool) (u : vector n A) i :=
  match i with
  | 0 => 0
  | S i' => if f (vect_el u i') then i else vect_find_loop f u i'
  end.

(* 0 => not found ; S n => found at position n *)
Definition vect_find A n (f : A → bool) (u : vector n A) : nat :=
  vect_find_loop f u n.

Theorem sym_gr_surj : ∀ n (σ : vector n! _) p,
  n ≠ 0
  → is_sym_gr_vect σ
  → is_permut_vect p
  → { i | i < n! ∧ vect_el σ i = p }.
Proof.
intros * Hnz Hσ Hp.
destruct Hσ as (H1, H2).
destruct Hp as (H3, H4).
exists (vect_find (vect_eqb Nat.eqb p) σ - 1).
split. {
  unfold vect_find.
...
Print is_sym_gr.
Print Module Pigeonhole.
Check find.
Print vector_eq.
Search (vector _ _ → vector _ _ → bool).
Search (vector _ _ → vector _ _ → _).
...
Check (permut_fun_inv (λ k, vect_el (vect_el σ k) n)).
Print permut_fun_inv.
Check (λ k, vect_el (vect_el σ k)).
Print permut_fun_inv.
Print permut_fun_inv'.
Print is_permut_fun.
Search permut_fun_inv.
...
unfold is_permut in H2.
Print permut_fun_inv'.
permut_fun = vect_el σ
exists (permut_fun_inv n
...

Theorem glop : ∀ n (σ σ' : vector n! _),
  n ≠ 0
  → is_sym_gr σ
  → is_sym_gr σ'
  → { σ'' : vector n! _ |
      is_sym_gr σ'' ∧ ∀ i, vect_el σ i ° vect_el σ'' i = vect_el σ' i }.
Proof.
intros * Hnz Hσ Hσ'.
destruct Hσ as (H1, H2).
destruct Hσ' as (H3, H4).
...

Theorem fun_betw_sym_gr : ∀ n (σ σ' : vector n! _),
  n ≠ 0
  → is_sym_gr σ
  → is_sym_gr σ'
  → { f | ∀ i, i < n! → vect_el σ (f i) = vect_el σ' i }.
Proof.
intros * Hnz Hσ Hσ'.
destruct n; [ easy | clear Hnz ].
destruct Hσ as (H1, H2).
destruct Hσ' as (H3, H4).
assert (Hσp : ∀ p, is_permut p → { i | vect_el σ i = p }). {
  intros p Hp.
...
intros * Hnz Hσ Hσ'.
destruct n; [ easy | clear Hnz ].
induction n. {
  cbn.
  exists (λ i, i).
  intros i Hi.
  apply vector_eq.
  intros j Hj.
  apply Nat.lt_1_r in Hi.
  apply Nat.lt_1_r in Hj.
  subst i j.
  destruct Hσ as (H1, H2).
  destruct Hσ' as (H3, H4).
  specialize (H2 0 Nat.lt_0_1).
  destruct H2 as (H2, H2').
  specialize (H2 0 Nat.lt_0_1).
  apply Nat.lt_1_r in H2.
  specialize (H4 0 Nat.lt_0_1).
  destruct H4 as (H4, H4').
  specialize (H4 0 Nat.lt_0_1).
  apply Nat.lt_1_r in H4.
  cbn in H2, H4.
  congruence.
}
Check (mk_vect (S n)! (λ i, vect_el σ (i / (S n)!))).
assert (∀ i, i < S (S n)! → IHn (
...
specialize (IHn (mk_vect (S n)! (λ i, let j := i / (S n)! in
...
intros * Hσ Hσ'.
destruct Hσ as (H1, H2).
destruct Hσ' as (H3, H4).
...
*)

Theorem det_by_any_sym_gr :
  rngl_is_comm = true →
  rngl_has_opp = true →
  rngl_has_inv = true →
  rngl_is_integral = true →
  rngl_has_1_neq_0 = true →
  rngl_has_dec_eq = true →
  rngl_characteristic = 0 →
  ∀ n (M : matrix n n T) (σ : vector n! (vector n nat)),
  n ≠ 0
  → is_sym_gr σ
  → determinant M =
    ∑ (k = 0, n! - 1),
    ε (vect_el σ k) *
    ∏ (i = 1, n), mat_el M (i - 1) (vect_el (vect_el σ k) (i - 1)).
Proof.
intros Hic Hop Hiv Hit H10 Hed Hch * Hnz Hσ.
rewrite det_is_det_by_canon_permut; try easy.
unfold determinant'.
remember (mk_canon_sym_gr n) as σ' eqn:Hσ'.
specialize rngl_summation_change_var as H1.
specialize (H1 nat 0 (n! - 1)).
set
  (f := λ k,
   (ε (vect_el σ' k) *
    ∏ (i = 1, n), mat_el M (i - 1) (vect_el (vect_el σ' k) (i - 1)))%F).
specialize (H1 f).
unfold f in H1.
...
specialize fun_betw_sym_gr as H2.
specialize (H2 n (mk_canon_sym_gr n) σ).
specialize (H2 Hnz (canon_sym_gr_prop n) Hσ).
rewrite <- Hσ' in H2.
destruct H2 as (g, Hg).
...
assert (Hh : ∃ h, ∀ i, i < n! → g (h i) = i).
admit.
destruct Hh as (h, Hh).
rewrite H1 with (g := g) (h := h).
...
assert (H : ∀ i, i < n! → h (g i) = i). {
  intros i Hi.
  destruct Hσ as (H2, H3).
...
assert (H : ∀ i, i < n! → h i < n!). {
  intros i Hi.
...
rngl_summation_list_permut:
  ∀ (T : Type) (ro : ring_like_op T),
    ring_like_prop T
    → ∀ (A : Type) (l1 l2 : list A) (f : A → T), Permutation l1 l2 → ∑ (i ∈ l1), f i = ∑ (i ∈ l2), f i
...
rngl_summation_list_change_var:
  ∀ (T : Type) (ro : ring_like_op T) (A B : Type) (f : A → B) (g : B → T) (l : list A),
    ∑ (i ∈ l), g (f i) = ∑ (j ∈ map f l), g j
Search (∑ (_ ∈ _), _ = ∑ (_ ∈ _), _).
...
rngl_summation_list_permut:
  ∀ (T : Type) (ro : ring_like_op T),
    ring_like_prop T
    → ∀ (A : Type) (l1 l2 : list A) (f : A → T), Permutation l1 l2 → ∑ (i ∈ l1), f i = ∑ (i ∈ l2), f i
rngl_summation_permut:
  ∀ (T : Type) (ro : ring_like_op T),
    ring_like_prop T
    → ∀ (n : nat) (l1 l2 : list T),
        Permutation l1 l2
        → length l1 = n → length l2 = n → ∑ (i = 0, n - 1), nth i l1 0 = ∑ (i = 0, n - 1), nth i l2 0
...
specialize (glop (canon_sym_gr_prop n) Hσ) as H1.
destruct H1 as (f, Hf).
erewrite rngl_summation_eq_compat. 2: {
  intros k Hk.
  specialize (Hf k).
  assert (H : k < n!). {
    specialize (fact_neq_0 n) as H.
    flia Hk H.
  }
  specialize (Hf H); clear H.
  rewrite Hf.
  easy.
}
cbn.
induction n; [ easy | ].
destruct n. {
  cbn.
  do 2 rewrite rngl_summation_only_one.
  do 2 rewrite rngl_product_only_one.
  cbn.
  specialize (Hf 0 Nat.lt_0_1).
  cbn in Hf.
  rewrite <- Hf; cbn.
  destruct Hσ as (H1, H2).
  specialize (H2 0 Nat.lt_0_1).
  unfold is_permut in H2.
  destruct H2 as (H2, H3).
  specialize (H2 0 Nat.lt_0_1).
  apply Nat.lt_1_r in H2.
  cbn in H2; cbn.
  now rewrite H2.
}
destruct n. {
  cbn.
  unfold iter_seq, iter_list.
  cbn.
  do 2 rewrite rngl_add_0_l.
  do 4 rewrite rngl_mul_1_l.
  specialize (Hf 0 Nat.lt_0_2) as H1.
  specialize (Hf 1 Nat.lt_1_2) as H2.
  cbn in H1, H2; cbn.
  rewrite <- H1, <- H2; cbn.
  rewrite ε_ws_ε; try easy.
  rewrite ε_ws_ε; try easy.
  rewrite ε_ws_ε; try easy.
  rewrite ε_ws_ε; try easy.
  unfold ε_ws; cbn.
  unfold ε_fun_ws; cbn.
  unfold iter_seq, iter_list; cbn.
  repeat rewrite rngl_mul_1_l.
  repeat rewrite rngl_mul_1_r.
  unfold sign_diff.
....
rngl_summation_permut:
  ∀ (T : Type) (ro : ring_like_op T),
    ring_like_prop T
    → ∀ (n : nat) (l1 l2 : list T),
        Permutation l1 l2
        → length l1 = n → length l2 = n → ∑ (i = 0, n - 1), nth i l1 0 = ∑ (i = 0, n - 1), nth i l2 0
...
*)

Theorem det_any_permut :
  rngl_has_opp = true →
  rngl_has_inv = true →
  rngl_is_comm = true →
  rngl_has_dec_eq = true →
  rngl_has_1_neq_0 = true →
  rngl_is_integral = true →
  rngl_characteristic = 0 →
  ∀ n (M : matrix n n T) (σ : vector n nat),
  n ≠ 0
  → is_permut σ
  → determinant M =
    (∑ (μ ∈ list_of_vect (mk_canon_sym_gr n)), ε μ * ε σ *
     ∏ (k = 0, n - 1), mat_el M (vect_el σ k) (vect_el μ k))%F.
Proof.
intros Hop Hiv Hic Hde H10 Hit Hch * Hnz Hσ.
unfold is_permut in Hσ.
destruct Hσ as (Hσ_lt, Hσ_inj).
erewrite rngl_summation_list_eq_compat. 2: {
  intros μ Hμ.
  remember (μ ° permut_inv σ) as ν eqn:Hν.
  assert (Hσν : ν ° σ = μ). {
    rewrite Hν.
    rewrite <- permut_comp_assoc.
    apply vector_eq.
    intros i Hi; cbn.
    unfold comp.
    now rewrite permut_fun_inv_fun.
  }
  subst ν.
  rewrite <- Hσν at 1.
  assert (Hpμ : is_permut μ). {
    unfold mk_canon_sym_gr in Hμ.
    apply in_map_iff in Hμ.
    destruct Hμ as (i & Hi & His).
    rewrite <- Hi.
    apply in_seq in His.
    now apply sym_gr_elem_is_permut.
  }
  rewrite signature_comp;
    [ | easy | easy | easy | easy | easy | easy | easy | | easy ]. 2: {
    apply is_permut_comp; [ easy | now apply permut_inv_is_permut ].
  }
  rewrite rngl_mul_comm; [ | easy ].
  rewrite <- rngl_mul_assoc.
  rewrite ε_square;
    [ | easy | easy | easy | easy | easy | easy | easy | easy ].
  rewrite rngl_mul_1_r.
  erewrite rngl_product_eq_compat. 2: {
    intros i Hi.
    rewrite <- Hσν at 1.
    easy.
  }
  easy.
}
cbn - [ "°" ].
unfold list_of_vect.
rewrite <- rngl_summation_list_change_var.
rewrite rngl_summation_seq_summation; [ | apply fact_neq_0 ].
rewrite Nat.add_0_l.
(*1*)
set (ν := λ i, vect_el (mk_canon_sym_gr n) i ° permut_inv σ).
erewrite rngl_summation_eq_compat. 2: {
  intros i Hi.
  rewrite rngl_mul_comm; [ | easy ].
  replace (vect_el (mk_canon_sym_gr n) i ° permut_inv σ) with (ν i) by easy.
  unfold "°".
  unfold comp.
  easy.
}
cbn - [ ν ].
erewrite rngl_summation_eq_compat. 2: {
  intros i Hi.
  now rewrite rngl_product_fun_permut with
    (f := λ j, mat_el M j (vect_el (ν i) j)).
}
cbn - [ ν ].
assert (Hν : is_sym_gr (mk_vect n! ν)). {
...
}
apply (det_by_any_sym_gr M Hν).
...1
remember
  (map
     (λ i, ε (canon_permut n i ° permut_inv σ) *
      ∏ (i0 = 0, n - 1),
      mat_el M (vect_el σ i0)
       (vect_el ((canon_permut n i ° permut_inv σ) ° σ) i0))%F
  (seq 0 n!)) as d eqn:Hd.
enough (H : determinant M = ∑ (i = 0, n! - 1), nth i d 0). {
  rewrite Hd in H.
  erewrite rngl_summation_eq_compat in H. 2: {
    intros i Hi.
    rewrite List_map_nth_in with (a := 0).
    easy.
    rewrite seq_length.
    specialize (fact_neq_0 n) as H1.
    flia Hi H1.
  }
  cbn in H.
  rewrite H.
  apply rngl_summation_eq_compat.
  intros i Hi.
  rewrite rngl_mul_comm; [ | easy ].
  f_equal. 2: {
    f_equal; f_equal.
    rewrite seq_nth; [ easy | ].
    specialize (fact_neq_0 n) as H1.
    flia Hi H1.
  }
  apply rngl_product_eq_compat.
  intros j Hj.
  f_equal.
  cbn.
  rewrite seq_nth; [ easy | ].
  specialize (fact_neq_0 n) as H1.
  flia Hi H1.
}
apply det_is_det_by_any_permut; try easy.
unfold determinant'_list.
set (f := λ i, canon_permut n i ° permut_inv σ).
erewrite map_ext_in in Hd. 2: {
  intros i Hi.
  replace (canon_permut n i ° permut_inv σ) with (f i) by easy.
  easy.
}
erewrite map_ext_in. 2: {
  intros i Hi.
  replace n with (S (n - 1)) at 2 by flia Hnz.
  rewrite rngl_product_succ_succ.
  erewrite rngl_product_eq_compat. 2: {
    intros j Hj.
    now rewrite Nat_sub_succ_1.
  }
  rewrite <- ε_of_canon_permut_ε; try easy.
  apply in_seq in Hi; flia Hi.
}
remember (canon_permut n) as g eqn:Hg.
subst d.
erewrite map_ext_in. 2: {
  intros i Hi.
  unfold "°".
  cbn - [ f ].
  unfold comp.
  easy.
}
erewrite map_ext_in. 2: {
  intros i Hi.
  now rewrite rngl_product_fun_permut with
    (f := λ j, mat_el M j (vect_el (f i) j)).
}
...
Search (Permutation (map _ _)).
Print determinant'.
Search determinant.
...
(*
intros * Hnz Hσ Hg.
unfold iter_seq.
Theorem glop : ∀ d len f g,
  ∏ (i = 0, len - 1), nth i (list_of_fun len f) d =
  ∏ (i = 0, len - 1), nth i (list_of_fun len g) d
  → ∏ (i = 0, len - 1), f i = ∏ (i = 0, len - 1), g i.
...
apply (glop 0%F).
apply rngl_product_permut.
...
*)
intros * Hnz Hσ Hg.
destruct n; [ easy | clear Hnz ].
rewrite Nat_sub_succ_1.
unfold is_permut in Hσ.
remember (vect_el σ) as u eqn:Hu; clear σ Hu.
destruct Hσ as (H1, H2).
...
induction n; cbn. {
  rewrite rngl_product_only_one; [ | easy ].
  rewrite rngl_product_only_one; [ | easy ].
  specialize (H1 0 Nat.lt_0_1) as H3.
  specialize (Hg 0 Nat.lt_0_1) as H4.
  apply Nat.lt_1_r in H3.
  apply Nat.lt_1_r in H4.
  now rewrite H3, H4, H3.
}
destruct (Nat.eq_dec (s (S n)) (S n)) as [Hsn| Hsn]. {
  assert (H : ∀ i : nat, i < S n → s i < S n). {
    intros i Hi.
    specialize (H1 i) as H3.
    assert (H : i < S (S n)) by flia Hi.
    specialize (H3 H).
    specialize (H2 _ (S n) H) as H4; clear H.
    destruct (Nat.eq_dec (s i) (s (S n))) as [Hisn| Hsin]. {
      assert (H' : S n < S (S n)) by flia.
      specialize (H4 H' Hisn).
      subst i; flia Hi.
    }
    flia Hsn H3 Hsin.
  }
  specialize (IHn H); clear H.
  assert (H : ∀ i j : nat, i < S n → j < S n → s i = s j → i = j). {
    intros i j Hi Hj Hij.
    apply H2; [ flia Hi | flia Hj | easy ].
  }
  specialize (IHn H); clear H.
  assert (H : ∀ i : nat, i < S n → g i < S n). {
    intros i Hi.
...
(*
...
rewrite rngl_product_split_last; [ | flia ].
rewrite rngl_product_succ_succ.
symmetry.
rewrite rngl_product_split_last; [ | flia ].
rewrite rngl_product_succ_succ.
symmetry.
...
Search (∏ (_ = _, _), _ = ∏ (_ = _, _), _).
...
*)
erewrite map_ext_in. 2: {
  intros i Hi.
  rewrite glop.
  easy.
}
...
etransitivity. {
...
  apply Permutation_map with (l' := map f (seq 0 n!)).
Search (Permutation (map _ _)).
Print canon_permut_inv.
Search canon_permut_inv.
Check (map (canon_permut_inv n) (seq 0 n!)).
Check ε.
  apply Permutation_map with (l' := map (canon_permut_inv n ° permut_inv σ ° canon_permut n) (seq 0 n!)).
  apply Permutation_map with (l' := map (λ i, vect_el (permut_inv σ) i) (seq 0 n!)).
f = canon_permut_inv n ° permut_inv σ ° canon_permut n
...
}
rewrite map_map.
...
Search (map _ _ = map _ _).
...
map_map: ∀ (A B C : Type) (f : A → B) (g : B → C) (l : list A), map g (map f l) = map (λ x : A, g (f x)) l
...
permut_inv σ ° canon_permut n i = canon_permut n (f i)
...
f = canon_permut_inv n ° permut_inv σ ° canon_permut n

...
  ============================
  Permutation
    (map
       (λ i : nat,
          (ε (permut_inv σ ° canon_permut n i) *
           ∏ (i0 = 0, n - 1), mat_el M (vect_el σ i0) (vect_el (σ ° (permut_inv σ ° canon_permut n i)) i0))%F)
       (seq 0 n!))
    (map (λ k : nat, (ε_canon_permut n k * ∏ (i = 1, n), mat_el M (i - 1) (vect_el (canon_permut n k) (i - 1)))%F)
       (seq 0 n!))
...
apply det_is_det_by_any_permut.
...3
rewrite det_is_det_by_canon_permut; try easy.
unfold determinant'.
Search determinant'.

...2
rewrite rngl_summation_list_change_var with
  (f := λ i, permut_inv σ ° i)
  (g :=
     λ k,
     (ε k * ∏ (i = 0, n - 1), mat_el M (vect_el σ i) (vect_el (σ ° k) i))%F).
unfold mk_canon_sym_gr.
rewrite map_map.
rewrite det_is_det_by_canon_permut; try easy.
unfold determinant'.
(*1*)
Search (∑ (_ ∈ map _ _), _).
...1
rewrite rngl_summation_map_seq.
rewrite rngl_summation_seq_summation; [ | apply fact_neq_0 ].
rewrite Nat.add_0_l.
...
cbn.
rewrite det_is_det_by_canon_permut; try easy.
unfold determinant'.
unfold mk_canon_sym_gr.
rewrite rngl_summation_map_seq.
rewrite rngl_summation_seq_summation; [ | apply fact_neq_0 ].
rewrite Nat.add_0_l.
remember (canon_permut n) as μ eqn:Hμ.
symmetry.
erewrite rngl_summation_eq_compat. 2: {
  intros i Hi.
  rewrite <- rngl_product_succ_succ'.
  replace (S (n - 1)) with n by flia Hnz.
  easy.
}
symmetry.
...
  Hμ : μ = canon_permut n
  ============================
  ∑ (k = 0, n! - 1), ε (μ k) * ∏ (i = 1, n), mat_el M (i - 1) (vect_el (μ k) (i - 1)) =
  ∑ (i = 0, n! - 1),
  ε (permut_inv σ ° μ i) *
  ∏ (i0 = 1, n),
  mat_el M (vect_el σ (i0 - 1))
    (comp (vect_el σ) (comp (permut_fun_inv (vect_el σ) n) (vect_el (μ i))) (i0 - 1)%nat)
...
apply rngl_summation_eq_compat.
intros i Hi.
symmetry.
rewrite rngl_mul_comm; [ | easy ].
rewrite <- rngl_mul_assoc.
f_equal.
rewrite <- rngl_product_succ_succ'.
replace (S (n - 1)) with n by flia Hnz.
rewrite rngl_product_shift; [ | now apply Nat.neq_0_lt_0 ].
symmetry.
rewrite rngl_product_shift; [ | now apply Nat.neq_0_lt_0 ].
erewrite rngl_product_eq_compat. 2: {
  intros j Hj.
  now rewrite Nat.add_comm, Nat.add_sub.
}
symmetry.
erewrite rngl_product_eq_compat. 2: {
  intros j Hj.
  now rewrite Nat.add_comm, Nat.add_sub.
}
symmetry.
...
Search (_ * _ = 1)%F.
rngl_mul_move_1_r:
  ∀ (T : Type) (ro : ring_like_op T),
    ring_like_prop T → rngl_has_inv = true → ∀ a b : T, b ≠ 0%F → (a * b)%F = 1%F ↔ a = b⁻¹%F
...

rewrite ε_ws_ε.
unfold ε_ws.
unfold ε_fun_ws.
unfold sign_diff.

...
unfold ε, ε_fun.
unfold δ.
Search ε.
Print ε_ws.
Print ε_fun_ws.
...
  rewrite <- signature_comp;
    [ | easy | easy | easy | easy | easy | easy | easy | easy | easy ].
  unfold ε at 2.
  unfold ε_fun.
  cbn.
...
rewrite <- signature_comp_fun.
Search (ε _ * ε _)%F.
...
   apply is_permut_permut_inv.
...
  rewrite <- rngl_product_succ_succ'.
  replace (S (n - 1)) with n by flia Hnz.
  erewrite rngl_product_eq_compat. 2: {
    intros i Hi.
    rewrite <- Hσν at 1.
    rewrite permut_comp_assoc.
    rewrite comp_permut_inv_r; [ cbn | easy ].
    unfold id.
    easy.
  }
  cbn.
  rewrite permut_comp_assoc.
  rewrite comp_permut_inv_r; [ | easy ].
  unfold ε at 1; cbn.
  rewrite comp_id_l.
  replace (ε_fun (vect_el μ) n) with (ε μ) by easy.
  rewrite rngl_mul_mul_swap, rngl_mul_comm; [ | easy | easy ].
  easy.
}
cbn.
rewrite <- rngl_mul_summation_list_distr_l; [ | easy ].
unfold mk_canon_sym_gr.
rewrite rngl_summation_map_seq.
rewrite rngl_summation_seq_summation; [ | apply fact_neq_0 ].
cbn.
Print determinant'.
...
erewrite rngl_summation_eq_compat. 2: {
  intros k Hk.
Print determinant'.
...
  erewrite rngl_product_eq_compat. 2: {
    intros i Hi.
...

replace (n!) with (S (n! - 1) - 0).
remember (λ v : nat, canon_permut n v) as h eqn:Hh.
remember 0 as b eqn:Hb.
rewrite Hb at 2.
remember (n! - 1) as e eqn:He.
Check rngl_summation_change_var.
...
Search (∑ (_ ∈ map _ _), _)%F.
rewrite <- rngl_summation_change_var.
Print determinant'.
...

Theorem determinant_transp :
  rngl_is_comm = true →
  rngl_has_opp = true →
  rngl_has_inv = true →
  rngl_is_integral = true →
  rngl_has_1_neq_0 = true →
  rngl_has_dec_eq = true →
  rngl_characteristic = 0 →
  ∀ n (M : matrix n n T), determinant M⁺ = determinant M.
Proof.
intros Hic Hop Hiv Hit H10 Hde Hch *.
rewrite det_is_det_by_canon_permut; try easy.
rewrite determinant'_by_list; try easy.
symmetry.
rewrite det_is_det_by_canon_permut; try easy.
rewrite determinant'_by_list; try easy.
apply rngl_summation_permut; cycle 1. {
  unfold determinant'_list.
  now rewrite List_map_seq_length.
} {
  unfold determinant'_list.
  now rewrite List_map_seq_length.
}
unfold determinant'_list.
cbn.
erewrite map_ext_in. 2: {
  intros m Hm.
  apply in_seq in Hm.
  now rewrite <- ε_of_canon_permut_ε.
}
symmetry.
erewrite map_ext_in. 2: {
  intros m Hm.
  apply in_seq in Hm.
  now rewrite <- ε_of_canon_permut_ε.
}
symmetry.
remember (canon_permut n) as f eqn:Hf.
...
look at
https://proofwiki.org/wiki/Permutation_of_Determinant_Indices
...
Search canon_permut.
Print FinFun.Injective.
Print FinFun.Surjective.
Print Module FinFun.
Print FinFun.Finite.
Print FinFun.Full.
Definition is_symmetric_group n (f : nat → vector n nat) :=
  FinFun.Injective nat {
...
Definition is_symmetric_group n (f : nat → vector n nat) :=
  (∀ i j, i < n! → j < n! → f i = f j → i = j) ∧
  (∀ v, ∃ i, i < n! ∧ f i = v).
...
Theorem glop : ∀ n (M : matrix n n T) (f g : nat → vector n nat),
  is_symmetric_group f
  → is_symmetric_group f
  → determinant M =
      (∑ (i = 1, n!), ε (f i) * ε (g i) *
       ∏ (j = 1, n), mat_el M (vect_el (f i) j) (vect_el (g i) j))%F.
...
Check determinant_multilinear.
About nat_bijection_Permutation.
Search (Permutation (map _ _)).
Search determinant'_list.
Search canon_permut.
...
Print FinFun.Injective.
Print FinFun.Surjective.
Search FinFun.Surjective.
Theorem glop : ∀ A B (f g : A → B) l,
  FinFun.Injective f
  → FinFun.Injective g
  → FinFun.Surjective f
  → FinFun.Surjective g
  → Permutation (map f l) (map g l).
Proof.
intros * Hif Hig Hsf Hsg.
unfold FinFun.Injective in Hif, Hig.
unfold FinFun.Surjective in Hsf, Hsg.
induction l as [| x]; [ easy | ].
cbn.
Search Permutation (_ :: _).
...
destruct n; [ easy | ].
destruct n. {
  now subst f; unfold iter_seq, iter_list; cbn.
}
destruct n. {
  subst f; unfold iter_seq, iter_list; cbn.
  repeat rewrite rngl_mul_1_l.
  rewrite rngl_mul_1_r.
  rewrite (rngl_mul_comm Hic (mat_el M 0 1)).
  easy.
}
...
cbn in Hf.
subst f.
remember (S n) as sn; cbn; subst sn.
Print canon_permut_fun.
...
apply det_is_det_by_any_permut; try easy.
unfold determinant'_list.
Search determinant'_list.
Search (Permutation (map _ _)).
About nat_bijection_Permutation.
etransitivity. {
About permut_fun_Permutation.
...
Search Permutation.
apply nat_bijection_Permutation.
Check Permutation_map.
Check Permutation_trans.
...
permut_fun_Permutation: ∀ (f : nat → nat) (n : nat), is_permut_fun f n → Permutation (map f (seq 0 n)) (seq 0 n)

cbn.
transitivity (seq 0 n!).
Check Permutation_trans.

Search (Permutation (map _ _)).
apply Permutation_trans with (l' := seq 0 n!).
eapply Permutation_trans. {
apply permut_fun_Permutation.
...
intros Hic Hop Hiv Hit H10 Hde Hch *.
rewrite det_is_det_by_canon_permut; try easy.
unfold determinant'.
symmetry.
rewrite det_is_det_by_canon_permut; try easy.
unfold determinant'.
cbn.
Search determinant'.
...
intros Hic Hop Hin Hit H10 Hde Hch * Hlin.
intros.
...

Theorem laplace_formula_on_cols :
  rngl_is_comm = true →
  rngl_has_opp = true →
  rngl_has_inv = true →
  rngl_is_integral = true →
  rngl_has_1_neq_0 = true →
  rngl_has_dec_eq = true →
  rngl_characteristic = 0 →
  ∀ n (M : matrix n n T) j,
  j < n
  → determinant M = ∑ (i = 0, n - 1), mat_el M i j * mat_el (comatrix M) i j.
Proof.
intros Hic Hop Hin Hit H10 Hde Hch * Hlin.
...
Check determinant_transp.
...

Theorem mat_swap_rows_involutive : ∀ n (M : matrix n n T) i j,
  mat_swap_rows i j (mat_swap_rows i j M) = M.
Proof.
intros.
apply matrix_eq.
intros p q Hp Hq; cbn.
destruct (Nat.eq_dec p i) as [Hpi| Hpi]. {
  subst p.
  destruct (Nat.eq_dec j i) as [Hji| Hji]; [ now subst j | ].
  now rewrite <- (if_eqb_eq_dec j), Nat.eqb_refl.
}
destruct (Nat.eq_dec p j) as [Hpj| Hpj]; [ | easy ].
subst p.
now rewrite <- (if_eqb_eq_dec i), Nat.eqb_refl.
Qed.

(*
The following two theorems, "determinant_with_row" and determinant_with_bad_row
have some similitudes.
  The theorem "determinant_with_row" says that we can compute the determinant
by going through any row (not necessarily the 0th one). Here, row "i".
  The theorem "determinant_with_bad_row" says that if we go through another
row "k" different from "i", the same formula (where "M i j" is replaced
with "M k j") returns 0. It is what I call a "bad determinant formula".

determinant_with_row
  ∀ (i n : nat) (M : matrix (S n) (S n) T),
  i ≤ n
  → ∑ (j = 0, n), minus_one_pow (i + j) * M i j * det (subm M i j) = det M

determinant_with_bad_row
  ∀ (i k n : nat) (M : matrix (S n) (S n) T),
  i ≤ n → k ≤ n → i ≠ k
  → ∑ (j = 0, n), minus_one_pow (i + j) * M k j * det (subm M i j) = 0%F

Isn't it strange? (or beautiful?)
*)

Theorem determinant_with_row :
  rngl_is_comm = true →
  rngl_has_opp = true →
  rngl_has_inv = true →
  rngl_is_integral = true →
  rngl_has_1_neq_0 = true →
  rngl_has_dec_eq = true →
  rngl_characteristic = 0 →
  ∀ i n (M : matrix (S n) (S n) T),
  i ≤ n
  → ∑ (j = 0, n),
    minus_one_pow (i + j) * mat_el M i j * determinant (subm M i j) =
    determinant M.
Proof.
intros Hic Hop Hiv Hit H10 Hde Hch * Hin.
symmetry.
destruct (Nat.eq_dec i 0) as [Hiz| Hiz]; [ now subst i | ].
apply rngl_opp_inj; [ easy | ].
rewrite <- determinant_alternating with (p := 0) (q := i); try easy;
  [ | flia Hiz | flia | flia Hin ].
rewrite determinant_succ at 1.
erewrite rngl_summation_eq_compat. 2: {
  intros j Hj.
  rewrite mat_swap_rows_comm.
  rewrite mat_el_mat_swap_rows.
  easy.
}
rewrite rngl_opp_summation; [ | easy | easy ].
apply rngl_summation_eq_compat.
intros j Hj.
rewrite <- rngl_mul_assoc; symmetry.
rewrite <- rngl_mul_opp_r; [ | easy ].
rewrite (Nat.add_comm i j).
rewrite minus_one_pow_add_r; [ | easy | easy ].
do 2 rewrite <- rngl_mul_assoc.
f_equal.
rewrite rngl_mul_comm; [ | easy ].
rewrite <- rngl_mul_assoc.
f_equal.
rewrite rngl_mul_opp_l, <- rngl_mul_opp_r; [ | easy | easy ].
rewrite rngl_mul_comm; [ | easy ].
symmetry.
rewrite mat_swap_rows_comm.
apply determinant_subm_mat_swap_rows_0_i; try easy.
flia Hiz Hin.
Qed.

Theorem determinant_with_bad_row :
  rngl_is_comm = true →
  rngl_has_opp = true →
  rngl_has_inv = true →
  rngl_is_integral = true →
  rngl_has_1_neq_0 = true →
  rngl_has_dec_eq = true →
  rngl_characteristic = 0 →
  ∀ i k n (M : matrix (S n) (S n) T),
  i ≤ n
  → k ≤ n
  → i ≠ k
  → ∑ (j = 0, n),
    minus_one_pow (i + j) * mat_el M k j * determinant (subm M i j) = 0%F.
Proof.
intros Hic Hop Hiv Hit H10 Hde Hch.
intros * Hi Hk Hik.
remember
  (mk_mat (S n) (S n) (λ p q, mat_el M (if Nat.eq_dec p i then k else p) q))
  as A eqn:HA.
assert (H1 : determinant A = 0%F). {
  subst A.
  apply Nat.lt_succ_r in Hi.
  apply Nat.lt_succ_r in Hk.
  apply determinant_same_rows with (p := i) (q := k); try easy.
  intros j.
  cbn.
  rewrite <- (if_eqb_eq_dec i), Nat.eqb_refl.
  now destruct (Nat.eq_dec k i).
}
rewrite <- determinant_with_row with (i := i) in H1; try easy.
rewrite <- H1 at 2.
apply rngl_summation_eq_compat.
intros j Hj.
do 2 rewrite <- rngl_mul_assoc.
f_equal; f_equal. {
  rewrite HA; cbn.
  now rewrite <- if_eqb_eq_dec, Nat.eqb_refl.
}
f_equal.
rewrite HA.
apply matrix_eq.
intros p q Hp Hq; cbn.
destruct (Nat.eq_dec (p + Nat.b2n (i <=? p)) i) as [Hpi| Hpi]; [ | easy ].
destruct (le_dec i p) as [Hip| Hip]. {
  apply Nat.leb_le in Hip.
  rewrite Hip in Hpi.
  cbn in Hpi.
  apply Nat.leb_le in Hip.
  flia Hpi Hip.
} {
  apply Nat.leb_nle in Hip.
  rewrite Hip in Hpi.
  cbn in Hpi.
  apply Nat.leb_nle in Hip.
  flia Hpi Hip.
}
Qed.

Theorem matrix_comatrix_mul :
  rngl_is_comm = true →
  rngl_has_opp = true →
  rngl_has_inv = true →
  rngl_is_integral = true →
  rngl_has_1_neq_0 = true →
  rngl_has_dec_eq = true →
  rngl_characteristic = 0 →
  ∀ n (M : matrix n n T),
  (M * (comatrix M)⁺ = determinant M × mI n)%M.
Proof.
intros Hic Hop Hiv Hit H10 Hde Hch *.
apply matrix_eq.
intros i j Hi Hj.
rewrite laplace_formula_on_rows with (i := i); try easy; cbn.
destruct (Nat.eq_dec i j) as [Hij| Hij]. {
  subst j.
  now rewrite rngl_mul_1_r.
}
rewrite rngl_mul_0_r; [ | now left ].
destruct n; [ easy | ].
rewrite Nat.sub_succ at 1.
rewrite Nat.sub_0_r.
erewrite rngl_summation_eq_compat. 2: {
  intros k Hk.
  rewrite rngl_mul_comm; [ | easy ].
  rewrite rngl_mul_mul_swap; [ | easy ].
  easy.
}
cbn.
apply -> Nat.lt_succ_r in Hi.
apply -> Nat.lt_succ_r in Hj.
apply Nat.neq_sym in Hij.
now apply determinant_with_bad_row.
Qed.

Theorem comatrix_matrix_mul :
  rngl_is_comm = true →
  rngl_has_opp = true →
  rngl_has_inv = true →
  rngl_is_integral = true →
  rngl_has_1_neq_0 = true →
  rngl_has_dec_eq = true →
  rngl_characteristic = 0 →
  ∀ n (M : matrix n n T),
  ((comatrix M)⁺ * M = determinant M × mI n)%M.
Proof.
intros Hic Hop Hiv Hit H10 Hde Hch *.
apply matrix_eq.
intros i j Hi Hj.
rewrite laplace_formula_on_cols with (j := j); try easy; cbn.
destruct (Nat.eq_dec i j) as [Hij| Hij]. {
  subst i.
  rewrite rngl_mul_1_r.
  apply rngl_summation_eq_compat.
  intros k Hk.
  rewrite rngl_mul_mul_swap; [ | easy ].
  rewrite rngl_mul_assoc.
  f_equal.
  now apply rngl_mul_comm.
}
rewrite rngl_mul_0_r; [ | now left ].
...
destruct n; [ easy | ].
rewrite Nat.sub_succ at 1.
rewrite Nat.sub_0_r.
erewrite rngl_summation_eq_compat. 2: {
  intros k Hk.
  rewrite rngl_mul_comm; [ | easy ].
  rewrite rngl_mul_mul_swap; [ | easy ].
  easy.
}
cbn.
apply -> Nat.lt_succ_r in Hi.
apply -> Nat.lt_succ_r in Hj.
apply Nat.neq_sym in Hij.
now apply determinant_with_bad_row.
Qed.

Definition mat_inv n (M : matrix n n T) :=
  ((determinant M)⁻¹ × (comatrix M)⁺)%M.

Theorem matrix_right_inv :
  rngl_is_comm = true →
  rngl_has_opp = true →
  rngl_has_inv = true →
  rngl_is_integral = true →
  rngl_has_1_neq_0 = true →
  rngl_has_dec_eq = true →
  rngl_characteristic = 0 →
  ∀ n (M : matrix n n T),
  determinant M ≠ 0%F → (M * mat_inv M = mI n)%M.
Proof.
intros Hic Hop Hiv Hit H10 Hde Hch *.
intros Hdz.
unfold mat_inv.
rewrite mat_mul_mul_scal_l; [ | easy | easy ].
rewrite matrix_comatrix_mul; try easy.
rewrite mat_mul_scal_l_mul_assoc; [ | easy ].
rewrite rngl_mul_inv_l; [ | easy | easy ].
now apply mat_mul_scal_1_l.
Qed.

Theorem matrix_left_inv :
  rngl_is_comm = true →
  rngl_has_opp = true →
  rngl_has_inv = true →
  rngl_is_integral = true →
  rngl_has_1_neq_0 = true →
  rngl_has_dec_eq = true →
  rngl_characteristic = 0 →
  ∀ n (M : matrix n n T),
  determinant M ≠ 0%F → (mat_inv M * M = mI n)%M.
Proof.
intros Hic Hop Hiv Hit H10 Hde Hch *.
intros Hdz.
unfold mat_inv.
rewrite mat_mul_scal_l_mul; [ | easy ].
...
rewrite matrix_comatrix_mul; try easy.
rewrite mat_mul_scal_l_mul_assoc; [ | easy ].
rewrite rngl_mul_inv_l; [ | easy | easy ].
now apply mat_mul_scal_1_l.
...

End a.

Arguments determinant {T ro} {n%nat} M%M.
Arguments det_from_row {T}%type {ro} {n}%nat M%M i%nat.
Arguments det_from_col {T}%type {ro} {n}%nat M%M j%nat.
Arguments comatrix {T}%type {ro} {n}%nat M%M.
Arguments subm {T m n} M%M i%nat j%nat.
