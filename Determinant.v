Set Nested Proofs Allowed.
Set Implicit Arguments.

Require Import Utf8 Arith Bool.
Require Import Permutation.
Import List List.ListNotations.

Require Import Misc RingLike MyVector Matrix PermutSeq.
Require Import RLsummation RLproduct.
Import matrix_Notations.

Definition list_of_fun {A} n (f : _ → A) := map f (seq 0 n).
Definition fun_of_list {A} (d : A) l i := nth i l d.

Section a.

Context {T : Type}.
Context (ro : ring_like_op T).
Context (rp : ring_like_prop T).

(* determinant *)

Fixpoint det_loop {n} (M : matrix n n T) i :=
  match i with
  | 0 => 1%F
  | S i' =>
      Σ (j = 0, i'),
      minus_one_pow j * mat_el M 0 j * det_loop (subm M 0 j) i'
  end.

Definition mat_permut_rows_fun n (σ : nat → nat) (M : matrix n n T) :=
  mk_mat n n (λ i j, mat_el M (σ i) j).

Definition mat_permut_rows n (σ : vector n nat) (M : matrix n n T) :=
  mat_permut_rows_fun (vect_el σ) M.

Definition determinant {n} (M : matrix n n T) := det_loop M n.

(* the following versions of computing the determinant should
   (to be proven) be equivalent; perhaps could help for proving
   Cramer's rule of resolving equations *)

Definition det_from_row {n} (M : matrix n n T) i :=
  (minus_one_pow i *
   Σ (j = 0, n - 1),
     minus_one_pow j * mat_el M i j * determinant (subm M i j))%F.

Definition det_from_col {n} (M : matrix n n T) j :=
  (minus_one_pow j *
   Σ (i = 0, n - 1),
     minus_one_pow i * mat_el M i j * determinant (subm M i j))%F.

(* Alternative version of the determinant: sum of product of the
   factors a_{i,σ(i)} where σ goes through all permutations of
   the naturals of the interval [0, n-1].
   The permutations generated are in the same order as the
   terms generated by the determinant defined by induction on
   the size of the matrix.
     The order happens to be the canonical (alphabetical) order.
   Example for n=3
     = [[0; 1; 2]; [0; 2; 1]; [1; 0; 2]; [1; 2; 0]; [2; 0; 1]; [2; 1; 0]]
   Having the same terms order, the proof of equality of both definitions
   of both determinants is easy.
   See PermutSeq.v *)

Theorem rngl_summation_change_var : ∀ A b e f g (h : _ → A),
  (∀ i, b ≤ i ≤ e → g (h i) = i)
  → Σ (i = b, e), f i = Σ (i ∈ map h (seq b (S e - b))), f (g i).
Proof.
intros * Hgh.
unfold iter_seq, iter_list.
rewrite List_fold_left_map.
apply List_fold_left_ext_in.
intros i c Hi.
f_equal; f_equal; symmetry.
apply Hgh.
apply in_seq in Hi.
flia Hi.
Qed.

(* definition of determinant by sum of products involving all
   permutations *)

Definition determinant' n (M : matrix n n T) :=
  Σ (k = 0, fact n - 1),
    ε (canon_permut n k) *
    Π (i = 1, n), mat_el M (i - 1) (vect_el (canon_permut n k) (i - 1)).

(* Proof that both definitions of determinants are equal *)

Theorem det_is_det_by_canon_permut :
  rngl_is_comm = true →
  rngl_has_opp = true →
  rngl_has_inv = true →
  rngl_is_integral = true →
  rngl_has_1_neq_0 = true →
  rngl_has_dec_eq = true →
  rngl_characteristic = 0 →
  ∀ n (M : matrix n n T), determinant M = determinant' M.
Proof.
intros Hic Hop Hin Hit H10 Hde Hch *.
unfold determinant, determinant'.
destruct n; intros. {
  unfold iter_seq, iter_list.
  cbn; rewrite rngl_add_0_l.
  unfold ε, ε_fun, iter_seq, iter_list; cbn.
  rewrite rngl_div_1_r; [ | now left | easy ].
  symmetry; apply rngl_mul_1_l.
}
erewrite rngl_summation_eq_compat. 2: {
  intros i Hi.
  rewrite rngl_product_succ_succ.
  erewrite rngl_product_eq_compat. 2: {
    intros j Hj.
    now rewrite Nat.sub_succ, Nat.sub_0_r.
  }
  easy.
}
cbn - [ fact det_loop canon_permut ε ].
revert M.
induction n; intros. {
  cbn.
  unfold ε, ε_fun, iter_seq, iter_list; cbn.
  do 2 rewrite rngl_add_0_l.
  do 3 rewrite rngl_mul_1_l.
  rewrite rngl_div_1_r; [ | now left | easy ].
  rewrite rngl_mul_1_l.
  now rewrite rngl_mul_1_r.
}
remember (S n) as sn.
cbn - [ fact "mod" "/" canon_permut ]; subst sn.
erewrite rngl_summation_eq_compat. 2: {
  intros i Hi.
  now rewrite IHn.
}
cbn - [ fact "mod" "/" canon_permut ].
erewrite rngl_summation_eq_compat. 2: {
  intros i Hi.
  now rewrite rngl_mul_summation_distr_l.
}
cbn - [ fact "mod" "/" canon_permut ].
rewrite rngl_summation_summation_distr; [ | easy ].
rewrite <- Nat.sub_succ_l; [ | apply lt_O_fact ].
rewrite Nat.sub_succ, Nat.sub_0_r.
rewrite <- Nat_fact_succ.
symmetry.
erewrite rngl_summation_eq_compat. 2: {
  intros i Hi.
  rewrite rngl_product_split_first; [ | flia ].
  rewrite rngl_product_succ_succ.
  easy.
}
cbn - [ fact "mod" "/" canon_permut ].
symmetry.
apply rngl_summation_eq_compat.
intros k Hk.
do 2 rewrite rngl_mul_assoc.
f_equal. 2: {
  apply rngl_product_eq_compat.
  intros i Hi.
  now rewrite Nat.add_1_r.
}
rewrite rngl_mul_mul_swap; [ | easy ].
symmetry.
f_equal.
apply ε_of_canon_permut_succ; try easy.
specialize (fact_neq_0 (S (S n))) as Hnz.
flia Hk Hnz.
Qed.

(* multilinearity *)

Theorem determinant_multilinear :
  rngl_is_comm = true →
  rngl_has_opp = true →
  rngl_has_inv = true →
  rngl_is_integral = true →
  rngl_has_1_neq_0 = true →
  rngl_has_dec_eq = true →
  rngl_characteristic = 0 →
  ∀ n (M : matrix n n T) i a b U V,
    i < n
    → determinant (mat_repl_vect i M (a × U + b × V)%V) =
         (a * determinant (mat_repl_vect i M U) +
          b * determinant (mat_repl_vect i M V))%F.
Proof.
intros Hic Hop Hin Hit H10 Hde Hch * Hi.
rewrite det_is_det_by_canon_permut; try easy.
rewrite det_is_det_by_canon_permut; try easy.
rewrite det_is_det_by_canon_permut; try easy.
unfold determinant'.
erewrite rngl_summation_eq_compat. 2: {
  intros k Hk.
  erewrite rngl_product_eq_compat. 2: {
    intros j Hj.
    now cbn.
  }
  easy.
}
cbn.
rewrite rngl_mul_summation_distr_l.
rewrite rngl_mul_summation_distr_l.
symmetry.
erewrite rngl_summation_eq_compat. 2: {
  intros k Hk.
  rewrite rngl_mul_assoc.
  now rewrite (rngl_mul_comm Hic a).
}
rewrite rngl_add_comm.
erewrite rngl_summation_eq_compat. 2: {
  intros k Hk.
  rewrite rngl_mul_assoc.
  now rewrite (rngl_mul_comm Hic b).
}
rewrite rngl_add_comm.
rewrite <- rngl_summation_add_distr; [ | easy ].
apply rngl_summation_eq_compat.
intros k Hk.
do 2 rewrite <- rngl_mul_assoc.
rewrite <- rngl_mul_add_distr_l.
f_equal.
assert (Hkn : k < fact n). {
  specialize (fact_neq_0 n) as Hnz.
  flia Hk Hnz.
}
specialize (canon_permut_vect_surjective Hkn Hi) as Hp.
destruct Hp as (p & Hp & Hpp).
rewrite (rngl_product_split (p + 1)); [ | flia Hp ].
rewrite rngl_product_split_last; [ | flia ].
erewrite rngl_product_eq_compat. 2: {
  intros j Hj.
  replace (j - 1 - 1) with (j - 2) by flia.
  destruct (Nat.eq_dec (vect_el (canon_permut n k) (j - 2)) i) as [Hpj| Hpj]. {
    exfalso.
    rewrite <- Hpp in Hpj.
    apply canon_permut_vect_injective in Hpj; [ | easy | flia Hp Hj | easy ].
    flia Hj Hpj.
  }
  easy.
}
rewrite (rngl_mul_comm Hic (iter_seq _ _ _ _)).
rewrite rngl_add_comm.
rewrite (rngl_product_split (p + 1)); [ | flia Hp ].
rewrite rngl_product_split_last; [ | flia ].
erewrite rngl_product_eq_compat. 2: {
  intros j Hj.
  replace (j - 1 - 1) with (j - 2) by flia.
  destruct (Nat.eq_dec (vect_el (canon_permut n k) (j - 2)) i) as [Hpj| Hpj]. {
    exfalso.
    rewrite <- Hpp in Hpj.
    apply canon_permut_vect_injective in Hpj; [ | easy | flia Hp Hj | easy ].
    flia Hj Hpj.
  }
  easy.
}
rewrite (rngl_mul_comm Hic (iter_seq _ _ _ _)).
rewrite rngl_add_comm.
symmetry.
rewrite (rngl_product_split (p + 1)); [ | flia Hp ].
rewrite rngl_product_split_last; [ | flia ].
erewrite rngl_product_eq_compat. 2: {
  intros j Hj.
  replace (j - 1 - 1) with (j - 2) by flia.
  destruct (Nat.eq_dec (vect_el (canon_permut n k) (j - 2)) i) as [Hpj| Hpj]. {
    exfalso.
    rewrite <- Hpp in Hpj.
    apply canon_permut_vect_injective in Hpj; [ | easy | flia Hp Hj | easy ].
    flia Hj Hpj.
  }
  easy.
}
rewrite (rngl_mul_comm Hic (iter_seq _ _ _ _)).
rewrite Nat.add_sub.
rewrite Hpp.
destruct (Nat.eq_dec i i) as [H| H]; [ clear H | easy ].
do 4 rewrite rngl_mul_assoc.
remember
  (Π (i0 = 2, p + 1),
   mat_el M (i0 - 2) (vect_el (canon_permut n k) (i0 - 2)%nat))%F
  as q eqn:Hq.
rewrite (rngl_mul_mul_swap Hic _ _ q).
do 3 rewrite (rngl_mul_comm Hic _ q).
do 5 rewrite <- rngl_mul_assoc.
rewrite <- rngl_mul_add_distr_l.
f_equal.
clear q Hq.
erewrite rngl_product_eq_compat. 2: {
  intros j Hj.
  destruct (Nat.eq_dec (vect_el (canon_permut n k) (j - 1)) i) as [Hpj| Hpj]. {
    rewrite <- Hpp in Hpj.
    apply canon_permut_vect_injective in Hpj; [ | easy | flia Hp Hj | easy ].
    flia Hj Hpj.
  }
  easy.
}
symmetry.
erewrite rngl_product_eq_compat. 2: {
  intros j Hj.
  destruct (Nat.eq_dec (vect_el (canon_permut n k) (j - 1)) i) as [Hpj| Hpj]. {
    rewrite <- Hpp in Hpj.
    apply canon_permut_vect_injective in Hpj; [ | easy | flia Hp Hj | easy ].
    flia Hj Hpj.
  }
  easy.
}
rewrite rngl_add_comm.
erewrite rngl_product_eq_compat. 2: {
  intros j Hj.
  destruct (Nat.eq_dec (vect_el (canon_permut n k) (j - 1)) i) as [Hpj| Hpj]. {
    rewrite <- Hpp in Hpj.
    apply canon_permut_vect_injective in Hpj; [ | easy | flia Hp Hj | easy ].
    flia Hj Hpj.
  }
  easy.
}
cbn.
rewrite rngl_add_comm.
do 2 rewrite rngl_mul_assoc.
now rewrite <- rngl_mul_add_distr_r.
Qed.

(* list of terms in determinant' (determinant by sum of products of
   permutations *)

Definition determinant'_list {n} (M : matrix n n T) :=
  map (λ k,
    (ε_canon_permut n k *
     Π (i = 1, n), mat_el M (i - 1) (vect_el (canon_permut n k) (i - 1)%nat))%F)
    (seq 0 (fact n)).

Theorem determinant'_by_list :
  rngl_is_comm = true →
  rngl_has_opp = true →
  rngl_has_inv = true →
  rngl_has_1_neq_0 = true →
  rngl_is_integral = true →
  rngl_has_dec_eq = true →
  rngl_characteristic = 0 →
  ∀ n (M : matrix n n T),
  determinant' M = Σ (k = 0, fact n - 1), nth k (determinant'_list M) 0.
Proof.
intros Hic Hop Hin H10 Hit Hde Hch *.
unfold determinant', determinant'_list.
apply rngl_summation_eq_compat; intros k Hk.
assert (Hkn : k < fact n). {
  specialize (fact_neq_0 n) as Hn.
  flia Hk Hn.
}
rewrite List_map_nth_in with (a := 0); [ | now rewrite seq_length ].
rewrite seq_nth; [ | easy ].
rewrite Nat.add_0_l.
f_equal.
now apply ε_of_canon_permut_ε.
Qed.

Theorem rngl_summation_permut : ∀ n l1 l2,
  Permutation l1 l2
  → length l1 = n
  → length l2 = n
  → Σ (i = 0, n - 1), nth i l1 0 = Σ (i = 0, n - 1), nth i l2 0.
Proof.
intros * Hl H1 H2.
destruct n. {
  apply length_zero_iff_nil in H1.
  apply length_zero_iff_nil in H2.
  now subst l1 l2.
}
rewrite Nat.sub_succ, Nat.sub_0_r.
revert n H1 H2.
induction Hl; intros; [ easy | | | ]. {
  cbn in H1, H2.
  apply Nat.succ_inj in H1.
  apply Nat.succ_inj in H2.
  rewrite rngl_summation_split_first; [ symmetry | easy | flia ].
  rewrite rngl_summation_split_first; [ symmetry | easy | flia ].
  destruct n; [ easy | ].
  do 2 rewrite rngl_summation_succ_succ.
  now rewrite IHHl.
} {
  destruct n; [ easy | ].
  cbn in H1, H2.
  do 2 apply Nat.succ_inj in H1.
  do 2 apply Nat.succ_inj in H2.
  rewrite rngl_summation_split_first; [ symmetry | easy | flia ].
  rewrite rngl_summation_split_first; [ symmetry | easy | flia ].
  rewrite rngl_summation_split_first; [ symmetry | easy | flia ].
  rewrite rngl_summation_split_first; [ symmetry | easy | flia ].
  do 2 rewrite rngl_add_assoc.
  do 2 rewrite rngl_summation_succ_succ.
  f_equal; [ apply rngl_add_comm | ].
  apply rngl_summation_eq_compat.
  intros i Hi; cbn.
  destruct i; [ flia Hi | easy ].
} {
  specialize (Permutation_length Hl2) as H3.
  rewrite H2 in H3.
  rewrite IHHl1; [ | easy | easy ].
  now rewrite IHHl2.
}
Qed.

Theorem det_is_det_by_any_permut :
  rngl_is_comm = true →
  rngl_has_opp = true →
  rngl_has_inv = true →
  rngl_is_integral = true →
  rngl_has_1_neq_0 = true →
  rngl_has_dec_eq = true →
  rngl_characteristic = 0 →
  ∀ n (M : matrix n n T) l,
  Permutation l (determinant'_list M)
  → determinant M = Σ (k = 0, fact n - 1), nth k l 0.
Proof.
intros Hic Hop Hin Hit H10 Hde Hch * Hl.
rewrite det_is_det_by_canon_permut; try easy.
rewrite determinant'_by_list; try easy.
apply rngl_summation_permut; [ now symmetry | | ]. {
  unfold determinant'_list.
  now rewrite map_length, seq_length.
} {
  apply Permutation_length in Hl.
  unfold determinant'_list in Hl.
  now rewrite map_length, seq_length in Hl.
}
Qed.

(* yet another definition of determinant *)

Definition determinant'' p q n (M : matrix n n T) :=
  Σ (k = 0, fact n - 1),
    ε_canon_permut n k *
    Π (i = 1, n),
    mat_el M (i - 1) (vect_el (canon_permut_swap_last p q n k) (i - 1)).

Definition determinant''_list p q {n} (M : matrix n n T) :=
  map (λ k,
    (ε_canon_permut n k *
     Π (i = 1, n),
     mat_el M (i - 1) (vect_el (canon_permut_swap_last p q n k) (i - 1)))%F)
    (seq 0 (fact n)).

Theorem determinant''_by_list : ∀ n p q (M : matrix n n T),
  determinant'' p q M =
    Σ (k = 0, fact n - 1), nth k (determinant''_list p q M) 0.
Proof.
intros.
unfold determinant'', determinant''_list.
apply rngl_summation_eq_compat; intros k Hk.
assert (Hkn : k < fact n). {
  specialize (fact_neq_0 n) as Hn.
  flia Hk Hn.
}
rewrite List_map_nth_in with (a := 0); [ | now rewrite seq_length ].
rewrite seq_nth; [ | easy ].
now rewrite Nat.add_0_l.
Qed.

Definition mat_swap_rows n i1 i2 (M : matrix n n T) :=
  mk_mat n n
    (λ i j,
     if Nat.eq_dec i i1 then mat_el M i2 j
     else if Nat.eq_dec i i2 then mat_el M i1 j
     else mat_el M i j).

Theorem determinant_alternating :
  rngl_is_comm = true →
  rngl_has_opp = true →
  rngl_has_inv = true →
  rngl_is_integral = true →
  rngl_has_1_neq_0 = true →
  rngl_has_dec_eq = true →
  rngl_characteristic = 0 →
  ∀ n (M : matrix n n T) p q,
  p ≠ q
  → p < n
  → q < n
  → determinant (mat_swap_rows p q M) = (- determinant M)%F.
Proof.
intros Hic Hop Hin Hit H10 Hde Hch * Hpq Hp Hq.
rewrite det_is_det_by_canon_permut; try easy.
unfold determinant'.
erewrite rngl_summation_eq_compat. 2: {
  intros k Hk.
  rewrite rngl_product_shift; [ | flia Hp ].
  erewrite rngl_product_eq_compat. 2: {
    intros i Hi.
    now rewrite Nat.add_comm, Nat.add_sub.
  }
  easy.
}
cbn - [ mat_swap_rows ].
erewrite rngl_summation_eq_compat. 2: {
  intros k Hk.
  rewrite rngl_product_change_var with
    (g := transposition p q) (h := transposition p q). 2: {
    intros i Hi.
    apply transposition_involutive.
  }
  rewrite Nat.sub_0_r.
  rewrite <- Nat.sub_succ_l; [ | flia Hp ].
  rewrite Nat.sub_succ, Nat.sub_0_r.
  easy.
}
cbn - [ mat_swap_rows ].
erewrite rngl_summation_eq_compat. 2: {
  intros k Hk.
  rewrite rngl_product_list_permut with (l2 := seq 0 n); [ | easy | ]. 2: {
    apply permut_fun_Permutation.
    now apply transposition_is_permut_fun.
  }
  easy.
}
cbn - [ mat_swap_rows ].
erewrite rngl_summation_eq_compat. 2: {
  intros k Hk.
  erewrite rngl_product_list_eq_compat. 2: {
    intros i Hi.
    replace (mat_el _ _ _) with
      (mat_el M i (vect_el (canon_permut n k) (transposition p q i))). 2: {
      cbn.
      unfold transposition.
      do 2 rewrite if_eqb_eq_dec.
      destruct (Nat.eq_dec i p) as [Hip| Hip]. {
        subst i.
        apply Nat.neq_sym in Hpq.
        destruct (Nat.eq_dec q p) as [Hqp| Hqp]; [ easy | ].
        now destruct (Nat.eq_dec q q).
      }
      destruct (Nat.eq_dec i q) as [Hiq| Hiq]. {
        subst i.
        apply Nat.neq_sym in Hpq.
        now destruct (Nat.eq_dec p p).
      }
      destruct (Nat.eq_dec i p) as [H| H]; [ easy | clear H ].
      destruct (Nat.eq_dec i q) as [H| H]; [ easy | clear H ].
      easy.
    }
    easy.
  }
  easy.
}
cbn - [ mat_swap_rows ].
set (f := λ k, vect_swap_elem (canon_permut n k) p q).
erewrite rngl_summation_eq_compat. 2: {
  intros k Hk.
  assert (Hkn : k < n!). {
    specialize (fact_neq_0 n) as Hn.
    flia Hk Hn.
  }
  erewrite rngl_product_seq_product; [ | flia Hp ].
  rewrite Nat.add_0_l.
  erewrite rngl_product_eq_compat. 2: {
    intros i Hi.
    now replace (vect_el _ _) with (vect_el (f k) i).
  }
  cbn - [ f ].
  replace (canon_permut n k) with
    (mk_vect n (λ i, vect_el (f k) (transposition p q i))). 2: {
    apply vector_eq.
    intros i Hi; cbn.
    now rewrite transposition_involutive.
  }
  replace (mk_vect n (λ i, vect_el (f k) (transposition p q i))) with
    (f k ° mk_vect n (transposition p q)) by easy.
  rewrite signature_comp; try easy. {
    subst f; cbn.
    split; cbn. {
      intros i Hi.
      apply vect_el_permut_ub; [ now apply canon_permut_is_permut | ].
      now apply transposition_lt.
    } {
      intros * Hi Hj Hij.
      apply canon_permut_vect_injective in Hij; [ | easy | | ]; cycle 1. {
        now apply transposition_lt.
      } {
        now apply transposition_lt.
      }
      now apply transposition_injective in Hij.
    }
  } {
    split; cbn. {
      intros i Hi.
      now apply transposition_lt.
    } {
      intros * Hi Hj Hij.
      now apply transposition_injective in Hij.
    }
  }
}
cbn - [ f ].
erewrite rngl_summation_eq_compat. 2: {
  intros k (_, Hk).
  rewrite (rngl_mul_comm Hic (ε (f k))).
  rewrite <- rngl_mul_assoc.
  now rewrite transposition_signature.
}
cbn - [ f ].
rewrite <- rngl_mul_summation_distr_l.
rewrite rngl_mul_opp_l; [ | easy ].
f_equal.
rewrite rngl_mul_1_l.
symmetry.
set (g := λ k, nat_of_canon_permut (f k)).
rewrite rngl_summation_change_var with (g := g) (h := g). 2: {
  intros k (_, Hk).
  assert (Hkn : k < n!). {
    specialize (fact_neq_0 n) as Hn.
    flia Hk Hn.
  }
  unfold g, f.
  rewrite permut_nat_of_canon_permut. 2: {
    apply vect_swap_elem_is_permut; [ easy | easy | ].
    now apply canon_permut_is_permut.
  }
  rewrite vect_swap_elem_involutive.
  now apply nat_of_canon_permut_permut.
}
rewrite Nat.sub_0_r.
rewrite <- Nat.sub_succ_l; [ | apply Nat.neq_0_lt_0, fact_neq_0 ].
rewrite Nat.sub_succ, Nat.sub_0_r.
rewrite rngl_summation_list_permut with (l2 := seq 0 n!); [ | easy | ]. 2: {
  apply permut_fun_Permutation.
  unfold g, f.
  split. {
    intros i Hi.
    apply nat_of_canon_permut_upper_bound.
    apply vect_swap_elem_is_permut; [ easy | easy | ].
    now apply canon_permut_is_permut.
  } {
    intros * Hi Hj Hij.
    apply nat_of_canon_permut_injective in Hij; cycle 1. {
      apply vect_swap_elem_is_permut; [ easy | easy | ].
      now apply canon_permut_is_permut.
    } {
      apply vect_swap_elem_is_permut; [ easy | easy | ].
      now apply canon_permut_is_permut.
    }
    apply vect_swap_elem_injective in Hij.
    now apply canon_permut_injective in Hij.
  }
}
erewrite rngl_summation_list_eq_compat. 2: {
  intros k Hk.
  assert (Hkn : k < n!). {
    apply in_seq in Hk.
    specialize (fact_neq_0 n) as Hn.
    flia Hk Hn.
  }
  unfold g, f.
  rewrite permut_nat_of_canon_permut. 2: {
    apply vect_swap_elem_is_permut; [ easy | easy | ].
    now apply canon_permut_is_permut.
  }
  rewrite vect_swap_elem_involutive.
  easy.
}
rewrite det_is_det_by_canon_permut; try easy.
unfold determinant'.
rewrite rngl_summation_seq_summation; [ | apply fact_neq_0 ].
rewrite Nat.add_0_l.
apply rngl_summation_eq_compat.
intros k Hk; f_equal.
rewrite rngl_product_shift; [ | flia Hp ].
apply rngl_product_eq_compat.
intros i Hi.
now rewrite Nat.add_comm, Nat.add_sub.
Qed.

(* transpositions list of permutation *)

Fixpoint first_non_fixpoint it i σ :=
  match it with
  | 0 => None
  | S it' => if i =? σ i then first_non_fixpoint it' (i + 1) σ else Some i
  end.

Fixpoint tlopf_loop it n (σ : nat → nat) :=
  match it with
  | 0 => []
  | S it' =>
      match first_non_fixpoint n 0 σ with
      | None => []
      | Some i =>
          let σ' := comp (transposition i (σ i)) σ in
          (i, σ i) :: tlopf_loop it' n σ'
      end
  end.

Definition transp_list_of_permut_fun n (σ : nat → nat) := tlopf_loop n n σ.

Definition transp_list_of_permut {n} (σ : vector n nat) :=
  transp_list_of_permut_fun n (vect_el σ).

Theorem first_non_fixpoint_Some_iff : ∀ σ it i j,
  first_non_fixpoint it i σ = Some j
  ↔ i ≤ j ∧ j - i < it ∧ (∀ k, i ≤ k < j → σ k = k) ∧ σ j ≠ j.
Proof.
intros.
split. {
  intros Hs.
  revert σ i j Hs.
  induction it; intros; [ easy | cbn in Hs ].
  rewrite if_eqb_eq_dec in Hs.
  destruct (Nat.eq_dec i (σ i)) as [Hii| Hii]. {
    specialize (IHit σ (i + 1) j Hs) as (H1 & H2 & H3 & H4).
    split; [ flia H1 | ].
    split; [ flia H2 | ].
    split; [ | easy ].
    intros k Hk.
    destruct (Nat.eq_dec i k) as [Hik| Hik]; [ now subst k | ].
    apply H3; flia Hk Hik.
  } {
    injection Hs; clear Hs; intros; subst j.
    split; [ flia | ].
    split; [ flia | ].
    split; [ | now apply Nat.neq_sym ].
    intros k Hk; flia Hk.
  }
} {
  intros (Hij & Hji & Hj & Hjj).
  revert i j Hij Hji Hj Hjj.
  induction it; intros; [ easy | cbn ].
  rewrite if_eqb_eq_dec.
  destruct (Nat.eq_dec i (σ i)) as [Hii| Hii]. {
    assert (Heij : i ≠ j) by now intros H; symmetry in Hii; subst i.
    apply IHit; [ flia Hij Hji Heij | flia Hij Hji Heij | | easy ].
    intros k Hk.
    apply Hj.
    flia Hk.
  }
  destruct (Nat.eq_dec i j) as [Heij| Heij]; [ congruence | exfalso ].
  assert (H : i ≤ i < j) by flia Hij Heij.
  specialize (Hj _ H) as H1.
  now symmetry in H1.
}
Qed.

Theorem first_non_fixpoint_None_if : ∀ σ it i,
  first_non_fixpoint it i σ = None
  → ∀ k, i ≤ k < i + it → k = σ k.
Proof.
intros * Hs k Hik.
revert σ i k Hik Hs.
induction it; intros; [ flia Hik | ].
cbn in Hs.
rewrite if_eqb_eq_dec in Hs.
destruct (Nat.eq_dec i (σ i)) as [H1| H1]; [ | easy ].
destruct (Nat.eq_dec i k) as [H2| H2]; [ now subst i | ].
eapply IHit; [ | apply Hs ].
flia Hik H2.
Qed.

Fixpoint nb_good_loop it i σ :=
  match it with
  | 0 => 0
  | S it' => Nat.b2n (σ i =? i) + nb_good_loop it' (i + 1) σ
  end.

Definition nb_good n σ := nb_good_loop n 0 σ.

(*
Theorem nb_good_loop_comp_transp : ∀ n it σ i j k,
  is_permut_fun σ n
  → n = i + it
  → nb_good_loop it i (comp (transposition j k) σ) =
    nb_good_loop it i σ.
Proof.
intros * Hp Hnit.
revert i j k Hnit.
induction it; intros; [ easy | cbn ].
unfold comp at 1, transposition at 1, Nat.b2n.
do 4 rewrite if_eqb_eq_dec.
destruct (Nat.eq_dec (σ i) j) as [Hsij| Hsij]. {
destruct (Nat.eq_dec k i) as [Hki| Hki]. {
  move Hki at top; subst k.
  destruct (Nat.eq_dec (σ i) i) as [Hsii| Hsii]. {
    f_equal.
    apply IHit; flia Hnit.
  }
...
*)

Theorem nb_good_loop_comp_transp : ∀ n it σ i k,
  is_permut_fun σ n
  → k < i ≤ n
  → σ k < i
  → n = i + it
  → nb_good_loop it i (comp (transposition k (σ k)) σ) =
    nb_good_loop it i σ.
Proof.
intros * Hp Hkin Hski Hnit.
revert i k Hkin Hski Hnit.
induction it; intros; [ easy | cbn ].
replace (i + S it) with (i + 1 + it) in Hnit by flia.
unfold comp at 1, transposition at 1, Nat.b2n.
do 4 rewrite if_eqb_eq_dec.
destruct (Nat.eq_dec (σ i) k) as [Hsik| Hsik]. {
  rewrite Hsik.
  destruct (Nat.eq_dec k i) as [H| H]; [ flia Hkin H | clear H ].
  rewrite Nat.add_0_l.
  destruct (Nat.eq_dec (σ k) i) as [H| H]; [ flia Hski H | clear H ].
  rewrite Nat.add_0_l.
  apply IHit; try easy; [ | flia Hski ].
  split; [ flia Hkin | ].
  flia Hnit.
}
destruct (Nat.eq_dec (σ i) (σ k)) as [Hsisk| Hsisk]. {
  apply Hp in Hsisk; [ flia Hkin Hsisk | | flia Hkin ].
  flia Hnit.
}
f_equal.
apply IHit; [ | flia Hski | easy ].
split; [ flia Hkin | flia Hnit ].
Qed.

(*
Theorem glop : ∀ n σ i k,
  is_permut_fun σ n
  → i < n
  → (∀ k, k < i → σ k = k)
  → σ i ≠ i
  → σ (σ i) ≠ i
  → i + 1 ≤ k < n
  → ∀ p, k ≤ p → comp (transposition i (σ i)) σ p = σ p.
Proof.
intros * Hp Hin Hsi Hsii Hssii Hsik p Hkp.
unfold comp, transposition; cbn.
rewrite if_eqb_eq_dec.
destruct (Nat.eq_dec (σ p) i) as [Hspi| Hspi]. {
  destruct (Nat.eq_dec (σ i) p) as [Hpsi| Hpsi]. {
    now rewrite <- Hpsi in Hspi.
  }
...
intros * Hp Hin Hsi Hsii Hssii Hsik p Hkp.
revert i k Hin Hsi Hsii Hssii Hsik Hkp.
induction p; intros; [ flia Hsik Hkp | cbn ].
unfold comp, transposition; cbn.
rewrite if_eqb_eq_dec.
destruct (Nat.eq_dec (σ (S p)
...
*)

Theorem comp_transp_permut_id : ∀ n σ i j k,
  is_permut_fun σ n
  → i < k
  → k < j < n
  → σ k = i
  → comp (transposition i (σ i)) σ j = σ j.
Proof.
intros * Hp Hikn Hkp Hski.
unfold comp, transposition.
do 2 rewrite if_eqb_eq_dec.
destruct (Nat.eq_dec (σ j) i) as [Hsji| Hsji]. {
  exfalso.
  rewrite <- Hski in Hsji.
  apply Hp in Hsji; [ flia Hkp Hsji | easy | flia Hkp ].
}
destruct (Nat.eq_dec (σ j) (σ i)) as [Hspi| Hspi]; [ | easy ].
apply Hp in Hspi; [ | easy | flia Hikn Hkp ].
flia Hikn Hkp Hspi.
Qed.

Theorem nb_good_loop_comp_transp_permit_id : ∀ n it σ i k,
  is_permut_fun σ n
  → i < n
  → k < n
  → n = k + it
  → (∀ j, k ≤ j → comp (transposition i (σ i)) σ j = σ j)
  → nb_good_loop it k (comp (transposition i (σ i)) σ) =
    nb_good_loop it k σ.
Proof.
intros * Hp Hin Hkn Hnit Hj.
revert i k Hin Hkn Hj Hnit.
induction it; intros; [ easy | cbn ].
unfold comp at 1, transposition at 1, Nat.b2n.
do 4 rewrite if_eqb_eq_dec.
destruct (Nat.eq_dec (σ k) i) as [Hski| Hski]. {
  rewrite Hski.
  destruct (Nat.eq_dec i k) as [Hik| Hik]. {
    move Hik at top; subst k.
    rewrite Hski.
    rewrite <- if_eqb_eq_dec, Nat.eqb_refl.
    f_equal.
    clear.
    remember (i + 1) as k eqn:Hk; clear Hk.
    revert i k.
    induction it; intros; [ easy | cbn ].
    unfold comp at 1, transposition at 1, Nat.b2n.
    do 4 rewrite if_eqb_eq_dec.
    destruct (Nat.eq_dec (σ k) i) as [Hki| Hki]. {
      rewrite Hki.
      now rewrite IHit.
    }
    now rewrite IHit.
  }
  destruct (Nat.eq_dec (σ i) k) as [Hsik| Hsik]. {
    exfalso.
    specialize (Hj k (le_refl _)).
    unfold comp, transposition in Hj.
    rewrite Hski, Nat.eqb_refl in Hj.
    apply Hik, Hp; [ easy | easy | congruence ].
  }
  f_equal.
  specialize (Hj k (le_refl _)).
  unfold comp, transposition in Hj.
  rewrite Hski, Nat.eqb_refl in Hj.
  rewrite <- Hj in Hski.
  apply Hp in Hski; [ congruence | easy | easy ].
}
destruct (Nat.eq_dec (σ k) (σ i)) as [Hsksi| Hsksi]. {
  apply Hp in Hsksi; [ | easy | easy ].
  subst k.
  rewrite <- if_eqb_eq_dec, Nat.eqb_refl.
  destruct (Nat.eq_dec (σ i) i) as [H| H]; [ easy | clear H ].
  specialize (Hj i (le_refl _)).
  unfold comp, transposition in Hj.
  rewrite if_eqb_eq_dec in Hj.
  destruct (Nat.eq_dec (σ i) i) as [H| H]; [ easy | clear H ].
  rewrite Nat.eqb_refl in Hj.
  congruence.
}
f_equal.
destruct (Nat.eq_dec (k + 1) n) as [Hk1n| Hk1n]. {
  destruct it; [ easy | ].
  flia Hnit Hk1n.
}
rewrite IHit; [ easy | easy | flia Hkn Hk1n | | flia Hnit ].
intros j Hkj.
apply Hj; flia Hkj.
Qed.

(*
Theorem nb_good_loop_comp_transp3 : ∀ n it σ i k,
  is_permut_fun σ n
  → i < k < n
  → σ k = i
  → n = k + 1 + it
  → nb_good_loop it (k + 1) (comp (transposition i (σ i)) σ) =
    nb_good_loop it (k + 1) σ.
Proof.
intros * Hp Hikn Hski Hnit.
revert i k Hikn Hski Hnit.
induction it; intros; [ easy | cbn ].
unfold comp at 1, transposition at 1, Nat.b2n.
do 4 rewrite if_eqb_eq_dec.
destruct (Nat.eq_dec (σ (k + 1)) i) as [Hsk1i| Hsk1i]. {
  rewrite <- Hski in Hsk1i.
  apply Hp in Hsk1i; [ flia Hsk1i | flia Hnit | easy ].
}
destruct (Nat.eq_dec (σ (k + 1)) (σ i)) as [Hsk1si| Hsk1si]. {
  apply Hp in Hsk1si; [ | flia Hnit | flia Hikn ].
  flia Hikn Hsk1si.
}
f_equal.
replace (k + 1 + S it) with (k + 1 + 1 + it) in Hnit by flia.
apply IHit; try easy. {
  split; [ flia Hikn | ].
  flia Hnit.
}
...
apply nb_good_loop_comp_transp_permit_id with (n := n); try easy.
...
*)

(*
Theorem nb_good_loop_comp_transp2 : ∀ n it σ i k,
  is_permut_fun σ n
  → i < n
  → (∀ k, k < i → σ k = k)
  → σ i ≠ i
  → σ (σ i) ≠ i
  → n = i + 1 + it
  → i + 1 ≤ k < n
  → nb_good_loop it k (comp (transposition i (σ i)) σ) =
    nb_good_loop it k σ.
Proof.
intros * Hp Hin Hsi Hsii Hssii Hnit Hik.
(*
assert (Hssisi : σ (σ i) ≠ σ i). {
  intros H.
  apply Hp in H; [ easy | | easy ].
  now apply Hp.
}
*)
revert i k Hin Hsi Hsii Hssii Hnit Hik.
induction it; intros; [ easy | cbn ].
replace (i + 1 + S it) with (i + 1 + 1 + it) in Hnit by flia.
unfold comp at 1, transposition at 1, Nat.b2n.
do 4 rewrite if_eqb_eq_dec.
destruct (Nat.eq_dec (σ k) i) as [Hsi1i| Hsi1i]. {
  destruct (Nat.eq_dec (σ i) k) as [Hsii1| Hsii1]. {
    now rewrite Hsii1 in Hssii.
  }
  destruct (Nat.eq_dec (σ k) k) as [Hsi1i1| Hsi1i1]. {
    flia Hik Hsi1i Hsi1i1.
  }
  cbn.
...
  apply nb_good_loop_comp_transp3 with (n := n); try easy.
  flia Hik.
...
  apply IHit; try easy.
...
  apply nb_good_loop_comp_transp with (n := n); try easy. {
    split; [ | flia Hik ].
    flia Hik.
  } {
...
  rewrite Hsik.
  destruct (Nat.eq_dec k i) as [H| H]; [ flia Hkin H | clear H ].
  rewrite Nat.add_0_l.
  destruct (Nat.eq_dec (σ k) i) as [H| H]; [ flia Hski H | clear H ].
  rewrite Nat.add_0_l.
  apply IHit; try easy; [ | flia Hski ].
  split; [ flia Hkin | ].
  flia Hnit.
}
destruct (Nat.eq_dec (σ i) (σ k)) as [Hsisk| Hsisk]. {
  apply Hp in Hsisk; [ flia Hkin Hsisk | | flia Hkin ].
  flia Hnit.
}
f_equal.
apply IHit; [ | flia Hski | easy ].
split; [ flia Hkin | flia Hnit ].
Qed.
...
*)

Theorem nb_good_loop_comp_transp2 : ∀ n it σ i,
  is_permut_fun σ n
  → (∀ k, k < i → σ k = k)
  → σ i ≠ i
  → σ (σ i) ≠ i
  → σ (σ i) ≠ σ i
  → n = i + 1 + it
  → nb_good_loop it (i + 1) (comp (transposition i (σ i)) σ) =
    nb_good_loop it (i + 1) σ.
Proof.
intros * Hp Hi Hsii Hssii Hssisi Hnit.
remember (σ i) as j eqn:Hj; symmetry in Hj.
remember (permut_fun_inv σ n i) as k eqn:Hk.
assert (Hkd : σ k = i). {
  subst k.
  apply fun_permut_fun_inv; [ easy | flia Hnit ].
}
assert (Hik : i < k). {
  assert (H1 : i ≤ k). {
    apply Nat.nlt_ge; intros H.
    apply Hi in H.
    rewrite Hkd in H; move H at top; subst k.
    congruence.
  }
  destruct (Nat.eq_dec i k) as [Hik| Hik]; [ | flia Hik H1 ].
  move Hik at top; subst k.
  congruence.
}
assert (Hjk : j ≠ k). {
  now intros H; move H at top; subst k.
}
assert (Hij : i < j). {
  apply Nat.nle_gt; intros H.
  assert (H' : j < i) by flia Hsii H.
  now apply Hi in H'.
}
assert (Hkn : k < n). {
  rewrite Hk.
  apply permut_fun_ub; [ | flia Hnit ].
  now apply permut_fun_inv_is_permut.
}
clear Hk.
clear Hi.
clear Hj.
clear Hsii.
clear Hssii.
remember (i + 1) as p eqn:Hp'.
assert (Hip : i < p) by flia Hp'.
clear Hp'.
revert i j k p Hssisi Hnit Hkd Hik Hjk Hij Hip Hkn.
induction it; intros; [ easy | cbn ].
replace (p + S it) with (p + 1 + it) in Hnit by flia.
unfold comp at 1, transposition at 1, Nat.b2n.
do 4 rewrite if_eqb_eq_dec.
destruct (Nat.eq_dec (σ p) i) as [Hspi| Hspi]. {
  rewrite Hspi.
  rewrite <- Hkd in Hspi.
  apply Hp in Hspi; [ | flia Hnit | easy ].
  move Hspi at top; subst p.
  destruct (Nat.eq_dec j k) as [H| H]; [ easy | clear H ].
  destruct (Nat.eq_dec i k) as [H| H]; [ flia Hip H | clear H ].
  cbn.
  apply IHit with (k := k); try easy; flia Hip.
}
destruct (Nat.eq_dec (σ p) j) as [Hspj| Hspj]. {
  rewrite Hspj.
  destruct (Nat.eq_dec i p) as [H| H]; [ flia Hip H | clear H ].
  destruct (Nat.eq_dec j p) as [Hjp| Hjp]. {
    now move Hjp at top; subst p.
  }
  cbn.
  apply IHit with (k := k); try easy; flia Hip.
}
f_equal.
apply IHit with (k := k); try easy; flia Hip.
Qed.

Theorem nb_good_loop_comp_transp' : ∀ n it σ i d,
  is_permut_fun σ n
  → i < n
  → d ≠ 0
  → (∀ k, k < i → σ k = k)
  → (∀ k, k < d → σ (i + k) ≠ i)
  → σ (σ i) = i
  → n = i + d + it
  → nb_good_loop it (i + d) (comp (transposition i (σ i)) σ) =
     nb_good_loop it (i + d) σ + 1.
Proof.
intros * Hp Hin Hdz Hskk Hsii Hssi Hnit.
revert i d Hin Hdz Hskk Hsii Hssi Hnit.
induction it; intros; cbn. {
  exfalso.
  destruct Hp as (Hp1, Hp2).
  rewrite Nat.add_0_r in Hnit.
  specialize (Hp1 i Hin) as H1.
  clear - d Hin Hnit Hsii Hskk Hssi H1.
  assert (Hisi : i ≤ σ i). {
    apply Nat.nlt_ge; intros H2.
    specialize (Hskk (σ i) H2) as H3.
    flia Hssi H2 H3.
  }
  specialize (Hsii (σ i - i)) as H2.
  assert (H : σ i - i < d). {
    apply Nat.add_lt_mono_r with (p := i).
    rewrite (Nat.add_comm d), <- Hnit.
    now rewrite Nat.sub_add.
  }
  specialize (H2 H); clear H.
  rewrite Nat.add_sub_assoc in H2; [ | easy ].
  now rewrite Nat.add_comm, Nat.add_sub in H2.
}
replace (i + d + S it) with (i + d + 1 + it) in Hnit by flia.
unfold comp at 1, transposition at 1, Nat.b2n.
do 4 rewrite if_eqb_eq_dec.
destruct (Nat.eq_dec (σ (i + d)) i) as [Hsi2i| Hsi2i]. {
  rewrite Hsi2i.
  destruct (Nat.eq_dec (σ i) (i + d)) as [Hsiid| Hsiid]. {
    destruct (Nat.eq_dec i (i + d)) as [H| H]; [ flia Hdz H | clear H ].
    rewrite Nat.add_0_l, Nat.add_comm; f_equal.
    apply nb_good_loop_comp_transp with (n := n); [ easy | | | easy ]. {
      flia Hnit.
    }
    flia Hsiid.
  }
  destruct (Nat.eq_dec i (i + d)) as [H| H]; [ flia Hdz H | clear H ].
  rewrite <- Nat.add_assoc; cbn.
  replace (i + d + 1 + it) with (i + (d + 1) + it) in Hnit by flia.
  rewrite <- Hssi in Hsi2i at 2.
  apply Nat.neq_sym in Hsiid.
  apply Hp in Hsi2i; [ easy | flia Hnit | ].
  now apply Hp.
}
destruct (Nat.eq_dec (σ (i + d)) (σ i)) as [Hsidsi| Hsidsi]. {
  apply Hp in Hsidsi; [ | flia Hnit | easy ].
  flia Hdz Hsidsi.
}
rewrite <- (Nat.add_assoc (if Nat.eq_dec _ _ then _ else _)).
f_equal.
rewrite <- Nat.add_assoc.
replace (i + d + 1 + it) with (i + (d + 1) + it) in Hnit by flia.
apply IHit; try easy; [ flia | ].
intros k Hk.
destruct (Nat.eq_dec k d) as [Hkd| Hkd]; [ now subst k | ].
apply Hsii.
flia Hk Hkd.
Qed.

Theorem nb_good_loop_comp_transp_eq : ∀ it n σ i k,
  is_permut_fun σ n
  → first_non_fixpoint n 0 σ = Some i
  → k ≤ i
  → n = k + it
  → nb_good_loop it k (comp (transposition i (σ i)) σ) =
    nb_good_loop it k σ + 1 + Nat.b2n (σ (σ i) =? i).
Proof.
intros * Hp Hi Hki Hnit.
apply first_non_fixpoint_Some_iff in Hi.
rewrite Nat.sub_0_r in Hi.
destruct Hi as (_ & Hin & Hi & Hsii).
revert i k Hin Hi Hsii Hki Hnit.
induction it; intros; cbn. {
  flia Hin Hki Hnit.
}
replace (k + S it) with (k + 1 + it) in Hnit by flia.
unfold comp at 1, transposition at 1, Nat.b2n.
do 5 rewrite if_eqb_eq_dec.
destruct (Nat.eq_dec (σ k) i) as [Hski| Hski]. {
  destruct (Nat.eq_dec k i) as [Heki| Heki]; [ congruence | ].
  assert (H : 0 ≤ k < i) by flia Hki Heki.
  specialize (Hi _ H); clear H.
  congruence.
}
destruct (Nat.eq_dec (σ k) (σ i)) as [Hsksi| Hsksi]. {
  destruct (Nat.eq_dec i k) as [Hik| Hik]. {
    move Hik at top; subst k.
    clear Hsksi Hski Hki.
    destruct (Nat.eq_dec (σ i) i) as [H| H]; [ easy | clear H ].
    rewrite Nat.add_0_l.
    destruct (Nat.eq_dec (σ (σ i)) i) as [Hssii| Hssii]. {
      rewrite Nat.add_comm; f_equal.
      apply nb_good_loop_comp_transp' with (n := n); try easy. {
        intros k Hk.
        apply Hi.
        split; [ flia | easy ].
      }
      intros k Hk.
      destruct k; [ | flia Hk ].
      now rewrite Nat.add_0_r.
    }
    rewrite Nat.add_comm, Nat.add_0_r; f_equal.
    destruct (Nat.eq_dec (σ (σ i)) (σ i)) as [Hssisi| Hssisi]. {
      apply Hp in Hssisi; [ easy | | easy ].
      now apply Hp.
    }
    apply nb_good_loop_comp_transp2 with (n := n); try easy.
    intros k Hk.
    apply Hi; flia Hk.
  }
...

Fixpoint where_is it (σ : nat → nat) i j :=
  match it with
  | 0 => None
  | S it' => if σ j =? i then Some j else where_is it' σ i (j + 1)
  end.

Definition first_transp n (σ : nat → nat) :=
  match first_non_fixpoint n 0 σ with
  | None => None
  | Some i =>
      match where_is n σ i 0 with
      | None => None
      | Some j => Some (i, j)
      end
  end.

Fixpoint tlopf_loop' it n (σ : nat → nat) :=
  match it with
  | 0 => []
  | S it' =>
      match first_transp n σ with
      | None => []
      | Some (i, j) =>
          let σ' := comp (transposition i j) σ in
          (i, j) :: tlopf_loop' it' n σ'
      end
  end.

Definition transp_list_of_permut_fun' n (σ : nat → nat) := tlopf_loop' n n σ.

Definition transp_list_of_permut' {n} (σ : vector n nat) :=
  transp_list_of_permut_fun' n (vect_el σ).

Definition transp_fun_of_nat_pair '(i, j) := transposition i j.

Definition transp_of_nat_pair n '(i, j) :=
  mk_vect n (transp_fun_of_nat_pair (i, j)).

(*
Compute transp_list_of_permut (vect_of_list 0 [0;5;1;2;4;3]).
Compute transp_list_of_permut' (vect_of_list 0 [0;5;1;2;4;3]).
Compute transp_list_of_permut (vect_of_list 0 [0;4;1;2;5;3]).
(*     = [(1, 4); (2, 4); (3, 4); (4, 5)] *)
Compute transp_list_of_permut' (vect_of_list 0 [0;4;1;2;5;3]).
(*     = [(1, 2); (1, 3); (1, 5); (1, 4)] *)
Compute (transp_list_of_permut (vect_of_list 0 [1;0;2;3;4;5])).
Compute (transp_list_of_permut (vect_of_list 0 [1;2;0;3;4;5])).
Compute (transp_list_of_permut (vect_of_list 0 [5;4;3;2;1;0])).
Compute (transp_list_of_permut (vect_of_list 0 [4;0;1;2;3;5])).
Compute (transp_list_of_permut (vect_of_list 0 [3;4;0;1;2;5])).

Compute let n := 4 in map (λ k, list_of_vect (canon_permut n k)) (seq 0 n!).
Compute let n := 4 in map (λ k, (list_of_vect (canon_permut n k), transp_list_of_permut (canon_permut n k))) (seq 0 n!).
Compute let n := 4 in map (λ k, (list_of_vect (canon_permut n k), transp_list_of_permut' (canon_permut n k))) (seq 0 n!).
Compute let n := 2 in length (filter (λ ij, snd ij =? 1) (map (λ k, (list_of_vect (canon_permut n k), length (transp_list_of_permut (canon_permut n k)))) (seq 0 n!))).
(*
1;15;85;225;274;120
1;10;35;50;24
1;6;11;6
1;3;2
1;1
(Stirling numbers)
*)
Compute let σ := vect_of_list 0 [1;2;0] in let n := vect_size σ in list_of_vect (iter_list (map (transp_of_nat_pair n) (transp_list_of_permut σ)) (λ σ τ, τ ° σ) σ).
Compute let σ := vect_of_list 0 [1;2;0] in let n := vect_size σ in list_of_vect (iter_list (map (transp_of_nat_pair n) (transp_list_of_permut σ)) (λ σ τ, σ ° τ) (mk_vect n (λ i, i))).

Compute let σ := vect_of_list 0 [0;5;1;2;4;3] in let n := vect_size σ in list_of_vect (iter_list (map (transp_of_nat_pair n) (transp_list_of_permut σ)) (λ σ τ, τ ° σ) σ).
Compute let σ := vect_of_list 0 [0;5;1;2;4;3] in let n := vect_size σ in list_of_vect (iter_list (map (transp_of_nat_pair n) (transp_list_of_permut σ)) (λ σ τ, σ ° τ) (mk_vect n (λ i, i))).
*)

(*
Compute let σ := vect_of_list 0 [0;5;1;2;4;3] in let n := vect_size σ in list_of_fun n (Comp (τ ∈ transp_list_of_permut_fun n (vect_el σ)), transp_fun_of_nat_pair τ).
*)

Theorem where_is_Some_iff : ∀ n σ i j k,
  where_is n σ i j = Some k
  ↔ σ k = i ∧ j ≤ k < j + n ∧ (∀ p, j ≤ p < k → σ p ≠ i).
Proof.
intros.
split. {
  intros Hw.
  revert i j k Hw.
  induction n; intros; [ easy | ].
  cbn in Hw.
  rewrite if_eqb_eq_dec in Hw.
  destruct (Nat.eq_dec (σ j) i) as [H1| H1]. {
    injection Hw; intros; subst j.
    split; [ easy | ].
    split; flia.
  }
  specialize (IHn i _ k Hw) as H2.
  split; [ easy | ].
  split; [ flia H2 | ].
  destruct H2 as (Hki & Hkjn & Hp).
  intros p Hjp.
  destruct (Nat.eq_dec p j) as [Hpj| Hpj]; [ congruence | ].
  apply Hp.
  split; [ | easy ].
  flia Hjp Hpj.
} {
  intros (Hski & Hkjn & Hjk).
  revert i j k Hski Hkjn Hjk.
  induction n; intros; [ flia Hkjn | cbn ].
  rewrite if_eqb_eq_dec.
  destruct (Nat.eq_dec (σ j) i) as [Hsji| Hsji]. {
    f_equal.
    destruct (Nat.eq_dec j k) as [H| Hnjk]; [ easy | exfalso ].
    specialize (Hjk j).
    assert (H : j ≤ j < k) by flia Hkjn Hnjk.
    now specialize (Hjk H); clear H.
  }
  apply IHn; [ easy | | ]. {
    split; [ | flia Hkjn ].
    destruct (Nat.eq_dec j k) as [Hejk| Hnjk]; [ | flia Hkjn Hnjk ].
    now subst k.
  }
  intros p Hp.
  apply Hjk.
  split; [ | flia Hp ].
  destruct (Nat.eq_dec j k) as [Hejk| Hnjk]; [ flia Hp Hkjn | ].
  flia Hp Hnjk.
}
Qed.

Theorem where_is_None_iff : ∀ n σ i j,
  where_is n σ i j = None
  ↔ ∀ k, j ≤ k < j + n → σ k ≠ i.
Proof.
intros.
split. {
  intros Hw k Hk.
  revert i j k Hw Hk.
  induction n; intros; [ flia Hk | ].
  cbn in Hw.
  rewrite if_eqb_eq_dec in Hw.
  destruct (Nat.eq_dec (σ j) i) as [H1| H1]; [ easy | ].
  destruct (Nat.eq_dec k j) as [Hkj| Hkj]; [ now subst k | ].
  apply IHn with (i := i) (j := j + 1); [ easy | ].
  flia Hk Hkj.
} {
  intros Hn.
  revert i j Hn.
  induction n; intros; [ easy | cbn ].
  rewrite if_eqb_eq_dec.
  destruct (Nat.eq_dec (σ j) i) as [Hi| Hi]. {
    exfalso.
    specialize (Hn j) as H1.
    assert (H : j ≤ j < j + S n) by flia.
    now specialize (H1 H); clear H.
  }
  apply IHn.
  intros k Hk.
  apply Hn; flia Hk.
}
Qed.

Theorem first_transp_Some_iff : ∀ n σ j k,
  first_transp n σ = Some (j, k)
  ↔ j < k < n ∧
    (∀ i, i < j → σ i = i) ∧
    σ j ≠ j ∧
    (∀ i, j < i < k → σ i ≠ j) ∧
    σ k = j.
Proof.
intros.
split. {
  intros Hfnt.
  unfold first_transp in Hfnt.
  remember (first_non_fixpoint n 0 σ) as x eqn:Hx; symmetry in Hx.
  destruct x as [i| ]; [ | easy ].
  apply first_non_fixpoint_Some_iff in Hx.
  rewrite Nat.sub_0_r in Hx.
  destruct Hx as (_ & Hj & Hk & Hsj).
  remember (where_is n σ i 0) as y eqn:Hy; symmetry in Hy.
  destruct y as [m| ]; [ | easy ].
  injection Hfnt; clear Hfnt; intros; subst m j.
  apply where_is_Some_iff in Hy.
  cbn in Hy.
  split. {
    split; [ | easy ].
    apply Nat.nle_gt; intros Hik.
    destruct (Nat.eq_dec k i) as [Hki| Hki]; [ now subst k | ].
    assert (H : 0 ≤ k < i) by flia Hik Hki.
    specialize (Hk _ H); clear H.
    destruct Hy as (Hski, Hkn).
    congruence.
  }
  split. {
    intros j Hm.
    apply Hk; flia Hm.
  }
  split; [ easy | ].
  split; [ | easy ].
  intros j Hjk.
  apply Hy.
  split; [ flia | easy ].
} {
  intros ((Hjkn & Hkn) & Hj & Hjj & Hjk & Hkj).
  unfold first_transp.
  remember (first_non_fixpoint n 0 σ) as x eqn:Hx; symmetry in Hx.
  destruct x as [i| ]. 2: {
    specialize first_non_fixpoint_None_if as H1.
    specialize (H1 σ n 0 Hx).
    cbn in H1.
    assert (H : 0 ≤ j < n) by flia Hjkn Hkn.
    specialize (H1 j H); clear H.
    now symmetry in H1.
  }
  apply first_non_fixpoint_Some_iff in Hx.
  rewrite Nat.sub_0_r in Hx.
  destruct Hx as (_ & Hin & Hi & Hii).
  remember (where_is n σ i 0) as y eqn:Hy; symmetry in Hy.
  destruct y as [m| ]. 2: {
    specialize (proj1 (where_is_None_iff _ _ _ _) Hy) as H1.
    cbn in H1.
    destruct (Nat.eq_dec i j) as [Heij| Heij]. {
      subst i; clear Hii Hi.
      assert (H : 0 ≤ k < n). {
        split; [ flia | easy ].
      }
      now specialize (H1 _ H); clear H.
    }
    assert (Hji : j < i). {
      apply Nat.nle_gt.
      intros Hij.
      assert (H : i < j) by flia Heij Hij.
      now specialize (Hj _ H); clear H.
    }
    exfalso; apply Hjj.
    apply Hi; flia Hji.
  }
  apply where_is_Some_iff in Hy.
  cbn in Hy.
  destruct Hy as (Hmi & (_ & Hmn) & Hsi).
  assert (Hij : i = j). {
    destruct (lt_dec i j) as [Hij| Hij]. {
      now specialize (Hj _ Hij).
    }
    destruct (lt_dec j i) as [Hji| Hji]. {
      assert (H : 0 ≤ j < i) by flia Hji.
      now specialize (Hi _ H); clear H.
    }
    flia Hij Hji.
  }
  f_equal; f_equal; [ easy | ].
  move Hij at top; subst i.
  clear Hii.
  destruct (lt_dec m j) as [Hmj| Hmj]. {
    assert (H : 0 ≤ m < j) by flia Hmj.
    specialize (Hi _ H).
    congruence.
  }
  destruct (lt_dec k m) as [Hkm| Hkm]. {
    assert (H : 0 ≤ k < m) by flia Hkm.
    now specialize (Hsi _ H).
  }
  destruct (lt_dec m k) as [Hmk| Hmk]. {
    assert (H : j < m < k). {
      split; [ | easy ].
      destruct (Nat.eq_dec j m) as [Hjm| Hjm]; [ congruence | ].
      flia Hmj Hjm.
    }
    now specialize (Hjk _ H); clear H.
  }
  flia Hkm Hmk.
}
Qed.

Theorem first_transp_None_iff : ∀ n σ,
  first_transp n σ = None
  ↔ match first_non_fixpoint n 0 σ with
     | Some i => (∀ j, j < i → j = σ j) ∧ where_is n σ i 0 = None
     | None => ∀ k, k < n → k = σ k
    end.
Proof.
intros.
split. {
  intros Hfnt.
  unfold first_transp in Hfnt.
  remember (first_non_fixpoint n 0 σ) as x eqn:Hx; symmetry in Hx.
  destruct x as [i| ]. 2: {
    intros k Hk.
    specialize first_non_fixpoint_None_if as H1.
    apply (H1 σ n 0 Hx).
    split; [ flia | easy ].
  }
  destruct (where_is n σ i 0); [ easy | ].
  split; [ | easy ].
  apply first_non_fixpoint_Some_iff in Hx.
  destruct Hx as (Hi & Hin & Hkk & Hii).
  rewrite Nat.sub_0_r in Hin.
  intros j Hj.
  symmetry.
  apply Hkk; flia Hj.
} {
  intros Hn.
  unfold first_transp.
  remember (first_non_fixpoint n 0 σ) as x eqn:Hx; symmetry in Hx.
  destruct x as [i| ]; [ | easy ].
  destruct Hn as (Hj, Hni).
  now rewrite Hni.
}
Qed.

Theorem Comp_tfonp_tlopf : ∀ σ it n i,
  σ i = i
  → (Comp (j ∈ map transp_fun_of_nat_pair (tlopf_loop' it n σ)), j) i = i.
Proof.
intros * Hii.
revert σ Hii.
induction it; intros; [ easy | cbn ].
remember (first_transp n σ) as x eqn:Hx; symmetry in Hx.
destruct x as [(i', j')| ]; [ | easy ].
apply first_transp_Some_iff in Hx.
destruct Hx as (Hjn & Hkn & Hi & Hj & Hkj).
cbn.
rewrite iter_list_cons; [ | easy | easy | easy ].
unfold comp at 1.
rewrite IHit. 2: {
  unfold comp, transposition.
  do 2 rewrite if_eqb_eq_dec.
  destruct (Nat.eq_dec (σ i) i') as [H1| H1]. {
    rewrite Hii in H1.
    now move H1 at top; subst i'.
  }
  destruct (Nat.eq_dec (σ i) j') as [H2| H2]; [ | easy ].
  congruence.
}
unfold transposition.
do 2 rewrite if_eqb_eq_dec.
destruct (Nat.eq_dec i i') as [Hii'| Hii']; [ congruence | ].
destruct (Nat.eq_dec i j') as [Hij| Hij]; [ | easy ].
congruence.
Qed.

Theorem where_is_enough_iter : ∀ n m σ i j k,
  n ≤ m
  → where_is n σ i j = Some k
  → where_is m σ i j = Some k.
Proof.
intros * Hnm Hij.
revert i j k n σ Hnm Hij.
induction m; intros; cbn. {
  now apply Nat.le_0_r in Hnm; subst n.
}
rewrite if_eqb_eq_dec.
destruct (Nat.eq_dec (σ j) i) as [Hsmi| Hsmi]. {
  destruct n; [ easy | ].
  cbn in Hij.
  rewrite if_eqb_eq_dec in Hij.
  now destruct (Nat.eq_dec (σ j) i).
}
destruct n; [ easy | ].
apply Nat.succ_le_mono in Hnm.
cbn in Hij.
rewrite if_eqb_eq_dec in Hij.
destruct (Nat.eq_dec (σ j) i) as [Hji| Hji]; [ easy | ].
now apply IHm with (n := n).
Qed.

Theorem first_non_fixpoint_enough_iter : ∀ n m σ i j,
  n ≤ m
  → first_non_fixpoint n i σ = Some j
  → first_non_fixpoint m i σ = Some j.
Proof.
intros * Hnm Hij.
revert i j n σ Hnm Hij.
induction m; intros; cbn. {
  now apply Nat.le_0_r in Hnm; subst n.
}
rewrite if_eqb_eq_dec.
destruct (Nat.eq_dec i (σ i)) as [Hii| Hii]. {
  destruct n; [ easy | ].
  cbn in Hij.
  rewrite <- Hii, Nat.eqb_refl in Hij.
  apply Nat.succ_le_mono in Hnm.
  now apply IHm with (n := n).
}
apply first_non_fixpoint_Some_iff in Hij.
destruct Hij as (Hij & Hjin & Hikj & Hjj).
destruct (Nat.eq_dec i j) as [H1| H1]; [ now subst i | ].
exfalso; apply Hii; symmetry.
apply Hikj.
split; [ flia | flia Hij H1 ].
Qed.

Theorem first_transp_enough_iter : ∀ n m σ i j,
  n ≤ m
  → first_transp n σ = Some (i, j)
  → first_transp m σ = Some (i, j).
Proof.
intros * Hnm Hij.
unfold first_transp in Hij |-*.
remember (first_non_fixpoint n 0 σ) as x eqn:Hx.
remember (first_non_fixpoint m 0 σ) as y eqn:Hy.
symmetry in Hx, Hy.
destruct x as [i'| ]; [ | easy ].
apply first_non_fixpoint_enough_iter with (m := m) in Hx; [ | easy ].
rewrite Hx in Hy; subst y.
remember (where_is n σ i' 0) as y eqn:Hy; symmetry in Hy.
destruct y as [j'| ]; [ | easy ].
injection Hij; clear Hij; intros; subst i' j'.
now rewrite where_is_enough_iter with (n := n) (k := j).
Qed.

Theorem old_nb_good_loop_comp_transp_2 : ∀ n it σ i j k,
  is_permut_fun σ n
  → k < i < n
  → j ≤ i
  → n = i + 1 + it
  → nb_good_loop it (i + 1) (comp σ (transposition k j)) =
    nb_good_loop it (i + 1) σ.
Proof.
intros * Hp Hkin Hji Hnit.
revert k i j Hkin Hji Hnit.
induction it; intros; [ easy | cbn ].
unfold comp at 1, transposition at 1, Nat.b2n.
do 4 rewrite if_eqb_eq_dec.
replace (i + 1 + S it) with (i + 1 + 1 + it) in Hnit by flia.
destruct (Nat.eq_dec (i + 1) k) as [H| H]; [ flia Hkin H | clear H ].
destruct (Nat.eq_dec (i + 1) j) as [H| H]; [ flia Hji H | clear H ].
f_equal.
apply IHit; [ | flia Hji | easy ].
split; [ flia Hkin | ].
flia Hnit.
Qed.

Theorem old_nb_good_loop_comp_transp' : ∀ n it σ i j k,
  is_permut_fun σ n
  → i ≤ j < n
  → k < i
  → σ k = j
  → σ j = k
  → n = i + it
  → nb_good_loop it i (comp σ (transposition k j)) = nb_good_loop it i σ + 1.
Proof.
intros * Hp Hijn Hki Hkj Hjk Hnit.
revert i j Hijn Hki Hnit Hkj Hjk.
induction it; intros; [ flia Hijn Hnit | cbn ].
unfold comp at 1, transposition at 1, Nat.b2n.
do 4 rewrite if_eqb_eq_dec.
replace (i + S it) with (i + 1 + it) in Hnit by flia.
destruct (Nat.eq_dec i k) as [Hik| Hik]; [ flia Hki Hik | ].
destruct (Nat.eq_dec i j) as [Hij| Hij]. {
  rewrite Hkj, <- Hij, <- if_eqb_eq_dec, Nat.eqb_refl.
  move Hij at top; subst j.
  destruct (Nat.eq_dec (σ i) i) as [Hsii| Hsii]. {
    rewrite <- Hsii in Hkj.
    apply Hp in Hkj; [ | flia Hijn Hki| easy ].
    now symmetry in Hkj.
  }
  rewrite Nat.add_0_l, Nat.add_comm; f_equal.
Abort. (*
  now apply nb_good_loop_comp_transp with (n := n).
}
rewrite <- Nat.add_assoc.
f_equal.
apply IHit; [ | flia Hki | easy | easy | easy ].
flia Hijn Hij.
Qed.
*)

Theorem nb_good_loop_comp_transp2 : ∀ n it σ i j k,
  is_permut_fun σ n
  → k ≤ j < n
  → i < k
  → σ j = i
  → σ i ≠ j
  → n = k + it
  → nb_good_loop it k (comp σ (transposition i j)) =
    nb_good_loop it k σ.
Proof.
intros * Hp Hkjn Hik Hsji Hsij Hnit.
revert i j k Hkjn Hik Hsji Hsij Hnit.
induction it; intros; [ easy | cbn ].
unfold comp at 1, transposition at 1, Nat.b2n.
do 4 rewrite if_eqb_eq_dec.
replace (k + S it) with (k + 1 + it) in Hnit by flia.
destruct (Nat.eq_dec k i) as [H| H]; [ flia Hik H | clear H ].
destruct (Nat.eq_dec k j) as [Hkj| Hkj]. {
  destruct (Nat.eq_dec (σ i) k) as [Hsik| Hsik]; [ congruence | ].
  destruct (Nat.eq_dec (σ k) k) as [H| H]; [ congruence | ].
  move Hkj at top; subst k.
  clear H; cbn.
Abort. (*
  now apply nb_good_loop_comp_transp with (n := n).
}
destruct (Nat.eq_dec (σ k) k) as [Hskk| Hskk]. {
  f_equal.
  apply IHit; try easy; [ | flia Hik ].
  split; [ | easy ].
  flia Hkjn Hkj.
}
apply IHit; try easy; [ | flia Hik ].
flia Hkjn Hkj.
Qed.
*)

Theorem nb_good_loop_comp_transp'2 : ∀ n it σ i j,
  is_permut_fun σ n
  → i < j < n
  → σ j = i
  → σ i ≠ j
  → n = i + it
  → nb_good_loop it i (comp σ (transposition i j)) =
    nb_good_loop it i σ + 1.
Proof.
intros * Hp Hijn Hsji Hsij Hnit.
revert i j Hijn Hsji Hsij Hnit.
destruct it; intros; [ flia Hijn Hnit | cbn ].
unfold comp at 1, transposition at 1, Nat.b2n.
rewrite Nat.eqb_refl.
rewrite Hsji.
rewrite Nat.eqb_refl.
rewrite if_eqb_eq_dec.
destruct (Nat.eq_dec (σ i) i) as [Hsii| Hsii]. {
  rewrite <- Hsii in Hsji.
  apply Hp in Hsji; [ | easy | flia Hijn ].
  flia Hijn Hsji.
}
rewrite Nat.add_0_l.
rewrite Nat.add_comm.
f_equal.
replace (i + S it) with (i + 1 + it) in Hnit by flia.
clear Hsii.
Abort. (*
apply nb_good_loop_comp_transp2 with (n := n); try easy; [ | flia ].
flia Hijn.
Qed.
*)

Theorem nb_good_loop_comp_transp'' : ∀ n it σ i j,
  is_permut_fun σ n
  → i < j < n
  → σ i = j
  → σ j = i
  → n = i + it
  → nb_good_loop it i (comp σ (transposition i j)) = nb_good_loop it i σ + 2.
Proof.
intros * Hp Hn Hsij Hsji Hnit.
revert i j Hn Hsij Hsji Hnit.
induction it; intros; [ flia Hn Hnit | cbn ].
unfold comp at 1, transposition at 1, Nat.b2n.
rewrite Nat.eqb_refl.
rewrite Hsij, Hsji.
rewrite Nat.eqb_refl.
rewrite if_eqb_eq_dec.
destruct (Nat.eq_dec j i) as [H| H]; [ flia Hn H | clear H ].
rewrite Nat.add_0_l.
rewrite (Nat.add_comm _ 2); cbn.
f_equal.
rewrite <- (Nat.add_1_r (nb_good_loop _ _ _)).
replace (i + S it) with (i + 1 + it) in Hnit by flia.
Abort. (*
apply nb_good_loop_comp_transp' with (n := n); try easy; [ | flia ].
flia Hn.
Qed.
*)

Theorem nb_good_loop_comp_transp_eq : ∀ it n σ i j k,
  is_permut_fun σ n
  → first_transp n σ = Some (i, j)
  → k < i
  → n = k + it
  → nb_good_loop it k (comp σ (transposition i j)) =
    nb_good_loop it k σ + 1 + Nat.b2n (σ i =? j).
Proof.
intros * Hp Hn Hki Hknit.
apply first_transp_Some_iff in Hn.
destruct Hn as (Hijn & Hi & Hii & Hij & Hji).
revert k Hknit Hki.
induction it; intros. 2: {
  cbn.
  replace (k + S it) with (k + 1 + it) in Hknit by flia.
  unfold Nat.b2n.
  unfold comp at 1, transposition at 1.
  do 4 rewrite if_eqb_eq_dec.
  destruct (Nat.eq_dec k i) as [H| H]; [ flia Hki H | clear H ].
  destruct (Nat.eq_dec k j) as [H| H]; [ flia Hijn Hki H | clear H ].
  do 2 rewrite <- Nat.add_assoc.
  f_equal.
  rewrite Nat.add_assoc.
  destruct (lt_dec (k + 1) i) as [Hk1i| Hk1i]; [ now rewrite IHit | ].
  replace i with (k + 1) in * by flia Hki Hk1i.
  clear Hki Hk1i.
  clear i; rename k into i.
  rewrite if_eqb_eq_dec.
  destruct (Nat.eq_dec (σ (i + 1)) j) as [Hsij| Hsij]. {
    rewrite <- Nat.add_assoc; cbn.
Abort. (*
    now apply nb_good_loop_comp_transp'' with (n := n).
  }
  rewrite Nat.add_0_r.
  now apply nb_good_loop_comp_transp'2 with (n := n).
}
flia Hijn Hknit Hki.
Qed.
*)

Theorem tlopf_loop'_enough_iter : ∀ n σ it1 it2,
  n ≤ it1
  → n ≤ it2
  → tlopf_loop' it1 n σ = tlopf_loop' it2 n σ.
Proof.
intros * Hit1 Hit2.
revert n σ it2 Hit1 Hit2.
induction it1; intros. {
  apply Nat.le_0_r in Hit1; subst n; cbn.
  now destruct it2.
}
cbn.
destruct it2; [ now rewrite Nat.le_0_r in Hit2; subst n | cbn ].
remember (first_transp n σ) as x eqn:Hx; symmetry in Hx.
destruct x as [(i, j)| ]; [ | easy ].
f_equal.
(*
apply first_transp_Some_if in Hx.
destruct Hx as (Hin & Hjn & Hi & Hsi & Hsj).
*)
destruct n; [ easy | ].
apply Nat.succ_le_mono in Hit1.
apply Nat.succ_le_mono in Hit2.
set (σ' := comp (transposition i j) σ).
specialize (IHit1 n σ' it2 Hit1 Hit2) as H1.
Print tlopf_loop'.
Abort. (*
...
Restart.
intros * Hit1 Hit2.
revert it1 it2 σ Hit1 Hit2.
induction n; intros; [ now destruct it1, it2 | ].
destruct it1; [ easy | ].
destruct it2; [ easy | ].
cbn.
remember (first_transp (S n) σ) as x eqn:Hx.
symmetry in Hx.
destruct x as [(i, j)| ]; [ | easy ].
f_equal.
apply Nat.succ_le_mono in Hit1.
apply Nat.succ_le_mono in Hit2.
set (σ' := comp (transposition i j) σ).
specialize (IHn it1 it2 σ Hit1 Hit2) as H1.
...
  IHn : ∀ (it1 it2 : nat) (σ : nat → nat), n ≤ it1 → n ≤ it2 → tlopf_loop' it1 n σ = tlopf_loop' it2 n σ
  Hit1 : n ≤ it1
  Hit2 : n ≤ it2
  Hx : first_transp (S n) σ = Some (i, j)
  σ' := comp (transposition i j) σ : nat → nat
  H1 : tlopf_loop' it1 n σ = tlopf_loop' it2 n σ
  ============================
  tlopf_loop' it1 (S n) σ' = tlopf_loop' it2 (S n) σ'

Print first_transp.
Print first_non_fixpoint.
Print where_is.
...
intros * Hit1 Hit2.
revert n σ it2 Hit1 Hit2.
induction it1; intros. {
  apply Nat.le_0_r in Hit1.
  subst n; cbn.
  now destruct it2.
}
cbn.
remember (first_transp n σ) as x eqn:Hx.
symmetry in Hx.
destruct x as [(i, j)| ]. {
  apply first_transp_Some_if in Hx.
  destruct Hx as (Hin & Hjn & Hi & Hii & Hji).
  destruct n; [ easy | ].
Print tlopf_loop'.
Print first_transp.
Print where_is.
...
*)

(*
Definition transp_list_of_permut_fun' n (σ : nat → nat) := tlopf_loop' n n σ.
...
*)

Theorem glop : ∀ it n (σ : nat → nat),
  n ≠ 0
  → n ≤ it
  → is_permut_fun σ n
  → ∀ i, i < n
  → (Comp (τ ∈ map transp_fun_of_nat_pair (tlopf_loop' it n σ)), τ) i = σ i.
Proof.
intros * Hnz Hit Hp * Hin.
revert σ n i Hnz Hit Hp Hin.
induction it; intros; [ flia Hnz Hit | ].
destruct (Nat.eq_dec n (S it)) as [Hnsit| Hnsit]. 2: {
  cbn.
  remember (first_transp n σ) as x eqn:Hx; symmetry in Hx.
  destruct x as [(j, k)| ]. {
Abort. (*
    apply first_transp_Some_if in Hx.
    destruct Hx as (Hjn & Hkn & Hii & Hj & Hkj).
    cbn.
    rewrite iter_list_cons; [ | easy | easy | easy ].
    unfold comp.
    rewrite IHit; [ | easy | flia Hit Hnsit | | easy ]. {
      apply transposition_involutive.
    }
    specialize comp_is_permut_fun as H1.
    apply (H1 _ (transposition j k) σ); [ | easy ].
    now apply transposition_is_permut_fun.
  }
  cbn.
  unfold iter_list; cbn.
  apply first_transp_None_iff in Hx.
  remember (first_non_fixpoint n 0 σ) as y eqn:Hy; symmetry in Hy.
  destruct y as [j| ]; [ | now apply Hx ].
  apply first_non_fixpoint_Some_iff in Hy.
  destruct Hx as (Hx & Hnj).
  specialize where_is_None_iff as H1.
  specialize (proj1 (H1 _ _ _) Hnj) as H2.
  specialize (fun_permut_fun_inv) as H3.
  specialize (H3 σ n Hp j).
  destruct Hy as (Hjz & Hj & Hkj & Hjj).
  rewrite Nat.sub_0_r in Hj.
  specialize (H3 Hj).
  exfalso; apply (H2 (permut_fun_inv σ n j)); [ | easy ].
  apply permut_fun_ub; [ | easy ].
  now apply permut_fun_inv_is_permut.
}
cbn.
remember (first_transp n σ) as x eqn:Hx; symmetry in Hx.
destruct x as [(j, k)| ]. 2: {
  unfold iter_list; cbn.
  apply first_transp_None_iff in Hx.
  remember (first_non_fixpoint n 0 σ) as y eqn:Hy.
  symmetry in Hy.
  destruct y as [j| ]; [ | now apply Hx ].
  destruct Hx as (Hj & Hwj).
  apply first_non_fixpoint_Some_iff in Hy.
  rewrite Nat.sub_0_r in Hy.
  destruct Hy as (Hjz & Hjn & Hkj & Hjj).
  specialize (proj1 (where_is_None_iff _ _ _) Hwj) as H1.
  specialize (H1 (permut_fun_inv σ n j)) as H2.
  assert (H : permut_fun_inv σ n j < n). {
    apply permut_fun_ub; [ | easy ].
    now apply permut_fun_inv_is_permut.
  }
  specialize (H2 H); clear H.
  now rewrite fun_permut_fun_inv in H2.
} {
  apply first_transp_Some_if in Hx.
  destruct Hx as (Hjn & Hkn & Hii & Hj & Hkj).
  cbn.
  rewrite iter_list_cons; [ | easy | easy | easy ].
  unfold comp at 1.
  destruct (lt_dec i j) as [Hij| Hij]. {
    specialize (Hii _ Hij) as H1.
    rewrite Comp_tfonp_tlopf. 2: {
      unfold comp, transposition.
      do 2 rewrite if_eqb_eq_dec.
      destruct (Nat.eq_dec (σ i) j) as [Hsij| Hsij]; [ congruence | ].
      destruct (Nat.eq_dec (σ i) k) as [Hsik| Hsik]; [ congruence | easy ].
    }
    unfold transposition.
    do 2 rewrite if_eqb_eq_dec.
    destruct (Nat.eq_dec i j) as [Hsij| Hsij]; [ congruence | ].
    destruct (Nat.eq_dec i k) as [Hsik| Hsik]; [ congruence | easy ].
  }
  apply Nat.nlt_ge in Hij.
...
  destruct (Nat.eq_dec i j) as [Heij| Heij]. {
    move Heij at top; subst i.
    clear Hij Hin.
    clear IHit.
    clear Hit.
    clear Hnz.
    revert σ j k n Hp Hnsit Hjn Hkn Hii Hj Hkj.
    induction it; intros. {
      unfold iter_list; cbn.
      unfold transposition.
      rewrite Nat.eqb_refl.
      subst n.
      apply Nat.lt_1_r in Hjn.
      apply Nat.lt_1_r in Hkn.
      now subst j k.
    }
    cbn.
    remember (first_transp n (comp (transposition j k) σ)) as x eqn:Hx.
    symmetry in Hx.
    destruct x as [(i', j')| ]. {
      cbn.
      rewrite iter_list_cons; [ | easy | easy | easy ].
      apply first_transp_Some_if in Hx.
      destruct Hx as (Hjn' & Hkn' & Hi' & Hii' & Hkj').
      unfold comp at 1.
      rewrite IHit.
...
rewrite Comp_tfonp_tlopf_2.
...
    rewrite <- Hkj.
Check Comp_tfonp_tlopf.
...
cbn.
subst n.
clear Hit Hnz Hin.
remember (first_transp (S it) σ) as x eqn:Hx; symmetry in Hx.
destruct x as [(j, k)| ]. {
  apply first_transp_Some_if in Hx.
  destruct Hx as (Hjn & Hkn & Hj & Hjj & Hkj).
  cbn.
  rewrite iter_list_cons; [ | easy | easy | easy ].
(**)
  assert
    (H :
  comp (transposition j k)
    (Comp (i0 ∈ map transp_fun_of_nat_pair (tlopf_loop' (S it) (S it) (comp (transposition j k) σ))), i0) i =
  σ i). {
    cbn.
    remember (first_transp (S it) (comp (transposition j k) σ)) as x eqn:Hx.
    symmetry in Hx.
    destruct x as [(i', j')| ]. {
      cbn.
      rewrite iter_list_cons; [ | easy | easy | easy ].
      unfold comp at 1 2.
      rewrite IHit.
...
  destruct (lt_dec i j) as [Hij| Hij]. {
    specialize (Hj _ Hij) as H1.
    rewrite H1.
    remember (Comp (m ∈ _), _) as σ' eqn:Hσ'.
    enough (H : σ' i = i). {
      unfold comp; rewrite H.
      unfold transposition.
      do 2 rewrite if_eqb_eq_dec.
      destruct (Nat.eq_dec i j) as [H2| H2]; [ flia H2 Hij | clear H2 ].
      destruct (Nat.eq_dec i k) as [H2| H2]; [ | easy ].
      congruence.
    }
    subst σ'.
    enough
      (H :
       (Comp
          (m ∈ map transp_fun_of_nat_pair (tlopf_loop' it n σ)), m) i = i). {
      apply Comp_tfonp_tlopf.
      unfold comp, transposition.
      do 2 rewrite if_eqb_eq_dec.
      destruct (Nat.eq_dec (σ i) j) as [H2| H2]; [ congruence | ].
      destruct (Nat.eq_dec (σ i) k) as [H3| H3]; [ | easy ].
      congruence.
    }
    clear IHit.
    clear Hnsit.
    clear j Hjn Hj Hjj Hkj Hij.
    revert n σ i Hp Hin Hkn H1.
    induction it; intros; [ easy | ].
    cbn.
    remember (first_transp n σ) as x eqn:Hx.
    symmetry in Hx.
    destruct x as [(i', j')| ]; [ | easy ].
    apply first_transp_Some_if in Hx.
    destruct Hx as (Hin' & Hjn' & Hj & Hjj & Hkj).
    cbn.
    rewrite iter_list_cons; [ | easy | easy | easy ].
    unfold comp at 1.
    rewrite IHit; [ | | easy | easy | ]; cycle 1. {
      apply comp_is_permut_fun; [ | easy ].
      now apply transposition_is_permut_fun.
    } {
      unfold comp, transposition.
      do 2 rewrite if_eqb_eq_dec.
      destruct (Nat.eq_dec (σ i) i') as [Hii| Hii]. {
        apply Hp; [ easy | easy | ].
        congruence.
      }
      destruct (Nat.eq_dec (σ i) j') as [Hij'| Hij']; [ | easy ].
      congruence.
    }
    unfold transposition.
    do 2 rewrite if_eqb_eq_dec.
    destruct (Nat.eq_dec i i') as [H| Hii]; [ congruence | ].
    destruct (Nat.eq_dec i j') as [H| H]; [ | easy ].
    congruence.
  }
  apply Nat.nlt_ge in Hij.
  destruct (Nat.eq_dec i j) as [Heij| Heij]. {
    move Heij at top; subst i.
    clear Hij Hin.
    destruct (Nat.eq_dec (σ j) k) as [Hsjk| Hsjk]. {
      rewrite Hsjk.
      unfold comp at 1.
      remember (Comp (i ∈ _), _) as σ' eqn:Hσ'.
      unfold transposition.
      do 2 rewrite if_eqb_eq_dec.
      destruct (Nat.eq_dec (σ' j) j) as [Hsjj| Hsjj]; [ easy | ].
      destruct (Nat.eq_dec (σ' j) k) as [Hjk| Hjk]. {
        destruct (Nat.eq_dec j k) as [Hejk| Hejk]; [ easy | exfalso ].
        apply Hsjj; clear Hsjj.
        subst σ'.
        enough (H : (Comp (i ∈ map transp_fun_of_nat_pair (tlopf_loop' it n (transposition j k))), i) (σ j) = j). {
          apply Comp_tfonp_tlopf.
          unfold comp, transposition.
          do 2 rewrite if_eqb_eq_dec.
          destruct (Nat.eq_dec (σ j) j) as [H1| H1]; [ easy | clear H1 ].
          now destruct (Nat.eq_dec (σ j) k).
        }
        rewrite Hsjk.
(* désespérant tellement c'est compliqué *)
...
        enough (H : (Comp (i ∈ map transp_fun_of_nat_pair (tlopf_loop' it n (λ i, i))), i) j = j). {
...
      clear.
      revert j k.
      induction it; intros; [ easy | ].
      cbn.
      remember (first_transp n (comp (transposition j k) σ)) as x eqn:Hx.
      symmetry in Hx.
      destruct x as [(i', j')| ]. {
        cbn.
        rewrite iter_list_cons; [ | easy | easy | easy ].
        unfold comp at 1.
        rewrite IHit.
...
    enough (Hk : j < k).
    unfold comp at 1.
    clear IHit Hnsit.
    clear Hj Hjj Hkj H1.
    revert σ Hp.
    revert j k Hjn Hkn Hij Hk.
    induction it; intros. {
      cbn.
      unfold iter_list; cbn.
      unfold transposition.
      do 2 rewrite if_eqb_eq_dec.
      destruct (Nat.eq_dec i j) as [H| H]; [ flia Hij H | clear H ].
      destruct (Nat.eq_dec i k) as [H| H]; [ | easy ].
      flia Hij Hk H.
    }
    cbn.
    remember (first_transp n (comp (transposition j k) σ)) as x eqn:Hx.
    symmetry in Hx.
    destruct x as [(i', j')| ]. {
      cbn.
      rewrite iter_list_cons; [ | easy | easy | easy ].
      unfold comp at 1; cbn.
      apply first_transp_Some_if in Hx.
      rewrite IHit; try easy.
...
remember (first_non_fixpoint (S it) 0 σ) as x eqn:Hx; symmetry in Hx.
destruct x as [j| ]. {
  apply first_non_fixpoint_Some_if in Hx.
  destruct Hx as (Hj1 & Hj2 & Hj3).
  cbn - [ where_is ].
  rewrite iter_list_cons; [ | easy | easy | easy ].
  remember (where_is (S it) σ j) as k eqn:Hk.
  destruct (lt_dec i j) as [Hij| Hij]. {
    specialize (Hj2 i) as H1.
    assert (H : 0 ≤ i < j) by flia Hij.
    specialize (H1 H); clear H.
    rewrite H1.
...
  remember (transposition j (σ j)) as τ eqn:Hτ.
  remember (Comp (f ∈ _), _) as σ' eqn:Hσ'.
  unfold comp.
  unfold transposition.
  do 2 rewrite if_eqb_eq_dec.
  destruct (Nat.eq_dec (σ' i) j) as [Hij| Hij]. {
...
    rewrite Hij.
    rewrite Hτ.
    unfold transposition.
    rewrite Nat.eqb_refl.
    destruct (Nat.eq_dec i j) as [Heij| Heij]; [ now subst i | ].
    exfalso.
    destruct (Nat.eq_dec (σ i) j) as [Hisj| Hisj]. {
...
*)

Theorem glop : ∀ it n (σ : nat → nat),
  n ≠ 0
  → n ≤ it
  → is_permut_fun σ n
  → ∀ i, i < n
  → (Comp (τ ∈ map transp_fun_of_nat_pair (tlopf_loop it n σ)), τ) i = σ i.
Proof.
intros * Hnz Hit Hp * Hin.
revert σ n i Hnz Hit Hp Hin.
induction it; intros; [ flia Hnz Hit | ].
destruct (Nat.eq_dec n (S it)) as [Hnsit| Hnsit]. 2: {
  cbn.
  remember (first_non_fixpoint n 0 σ) as x eqn:Hx; symmetry in Hx.
  destruct x as [j| ]. {
Abort. (*
    apply first_non_fixpoint_Some_if in Hx.
    destruct Hx as (Hj1 & Hj2 & Hj3).
    cbn.
    rewrite iter_list_cons; [ | easy | easy | easy ].
    unfold comp.
    rewrite IHit; [ | easy | flia Hit Hnsit | | easy ]. {
      apply transposition_involutive.
    }
    specialize comp_is_permut_fun as H1.
    specialize (H1 n (transposition j (σ j))).
    apply H1; [ | easy ].
    apply transposition_is_permut_fun; [ easy | now apply Hp ].
  } {
    unfold iter_list; cbn.
    apply first_non_fixpoint_None_if with (k := i) in Hx; [ easy | ].
    split; [ flia | easy ].
  }
}
cbn.
subst n.
clear Hit Hnz.
remember (first_non_fixpoint (S it) 0 σ) as x eqn:Hx; symmetry in Hx.
destruct x as [j| ]. {
  apply first_non_fixpoint_Some_if in Hx.
  destruct Hx as (Hj1 & Hj2 & Hj3).
  cbn.
  rewrite iter_list_cons; [ | easy | easy | easy ].
  remember (transposition j (σ j)) as τ eqn:Hτ.
  remember (Comp (f ∈ _), _) as σ' eqn:Hσ'.
  unfold comp.
  destruct (Nat.eq_dec (σ' i) j) as [Hij| Hij]. {
    rewrite Hij.
    rewrite Hτ.
    unfold transposition.
    rewrite Nat.eqb_refl.
    destruct (Nat.eq_dec i j) as [Heij| Heij]; [ now subst i | ].
    exfalso.
    destruct (Nat.eq_dec (σ i) j) as [Hisj| Hisj]. {
...
    unfold comp.
    remember (iter_list _ _ _) as σ' eqn:Hσ'.
    unfold transposition.
    do 2 rewrite if_eqb_eq_dec.
    destruct (Nat.eq_dec (σ' i) j) as [Hσij| Hσij]. {
...
      rewrite <- Hσij.
      subst σ'.
      unfold iter_list.
      destruct it; [ easy | ].
      cbn.
      unfold transposition.
      rewrite Hσ₀.
      repeat rewrite if_eqb_eq_dec.
      destruct (Nat.eq_dec 0 j) as [H| H]; [ now subst j | clear H ].
      destruct (Nat.eq_dec 0 (σ j)) as [H| H]. {
        exfalso; apply Hj3.
        apply Hp; try easy.
        rewrite <- H; flia.
        now rewrite <- H.
      }
      destruct (Nat.eq_dec (σ 1) j) as [H1| H1].
...
*)

Theorem iter_compose_transp_fun : ∀ n (σ : nat → nat),
  n ≠ 0
  → is_permut_fun σ n
  → ∀ i, i < n
  → (Comp (τ ∈ transp_list_of_permut_fun n σ), transp_fun_of_nat_pair τ) i = σ i.
Proof.
intros * Hnz Hp * Hin.
Abort. (*
...
apply glop.
...
unfold transp_list_of_permut_fun.
...
revert i σ Hin Hp.
induction n; intros; [ easy | clear Hnz ].
Print transp_list_of_permut_fun.
...
intros * Hnz Hp * Hin.
destruct n; [ easy | clear Hnz ].
unfold iter_list.
revert i σ Hp Hin.
induction n; intros. {
  apply Nat.lt_1_r in Hin; subst i; cbn.
  remember (σ 0) as σ₀ eqn:Hσ₀; symmetry in Hσ₀.
  now destruct σ₀.
}
remember (S n) as sn; cbn; subst sn.
remember (σ 0) as σ₀ eqn:Hσ₀; symmetry in Hσ₀.
destruct σ₀. {
...
*)

Theorem iter_compose_transp : ∀ n (σ : vector n nat),
  is_permut σ
  → Comp (τ ∈ transp_list_of_permut σ), transp_fun_of_nat_pair τ = vect_el σ.
Proof.
intros * Hp.
Abort. (*
...
apply iter_compose_transp_fun.
easy.
...
*)

Theorem iter_transp_list_of_permut : ∀ n (σ : vector n nat),
  is_permut σ
  → iter_list (transp_list_of_permut σ)
       (λ σ τ, σ ° transp_of_nat_pair n τ) (mk_vect n (λ i, i)) = σ.
Abort.

Theorem iter_transp_list_of_permut : ∀ n (σ : vector n nat),
  is_permut σ
  → iter_list (map (transp_of_nat_pair n) (transp_list_of_permut σ))
       (λ σ τ, σ ° τ) (mk_vect n (λ i, i)) = σ.
Proof.
intros * Hp.
unfold iter_list.
rewrite List_fold_left_map.
Abort. (*
...
*)

(*
Theorem glop : ∀ n (σ : vector n nat) it,
  is_permut σ
  → n ≤ it
  → ∀ i, i < n →
  vect_el
    (iter_list (map (transp_of_nat_pair n) (tlopf_loop it n (vect_el σ)))
       (λ σ τ, τ ° σ) σ) i = i.
Proof.
intros * Hp Hit * Hin.
unfold iter_list.
revert i n σ Hit Hin Hp.
induction it; intros; [ flia Hit Hin | cbn ].
remember (first_non_fixpoint n 0 (vect_el σ)) as x eqn:Hx; symmetry in Hx.
destruct x as [j| ]. {
  cbn.
...
intros * Hp Hit * Hin.
destruct it; [ flia Hit Hin | ].
cbn.
destruct it. {
  cbn.
  destruct n; [ easy | ].
  apply Nat.succ_le_mono in Hit.
  apply Nat.le_0_r in Hit; subst n.
  apply Nat.lt_1_r in Hin; subst i.
  cbn.
  remember (vect_el σ 0) as σ₀ eqn:Hσ₀; symmetry in Hσ₀.
  destruct σ₀; [ easy | cbn ].
  rewrite Hσ₀; cbn.
  unfold iter_list; cbn.
  rewrite Hσ₀; cbn.
  now rewrite Nat.eqb_refl.
}
destruct it. {
  cbn.
  destruct n; [ easy | ].
  apply Nat.succ_le_mono in Hit.
  destruct n. {
    apply Nat.lt_1_r in Hin; subst i.
    cbn.
    remember (vect_el σ 0) as σ₀ eqn:Hσ₀; symmetry in Hσ₀.
    destruct σ₀; [ easy | cbn ].
    rewrite Hσ₀; cbn.
    unfold iter_list; cbn.
    unfold comp.
    rewrite Hσ₀; cbn.
    rewrite Nat.eqb_refl; cbn.
    rewrite Hσ₀; cbn.
    now rewrite Nat.eqb_refl.
  }
  apply Nat.succ_le_mono in Hit.
  apply Nat.le_0_r in Hit; subst n.
  cbn.
  unfold transposition; cbn.
  unfold comp; cbn.
  remember (vect_el σ 0) as σ₀ eqn:Hσ₀; symmetry in Hσ₀.
  destruct σ₀. {
    cbn.
    remember (vect_el σ 1) as σ₁ eqn:Hσ₁; symmetry in Hσ₁.
    destruct σ₁. {
      rewrite Hσ₁; cbn.
      unfold transposition, comp; cbn.
      unfold iter_list; cbn.
      destruct i; [ now rewrite Hσ₀ | ].
      destruct i; [ | flia Hin ].
      rewrite Hσ₀, Hσ₁; cbn.
      apply Hp; [ flia | flia | congruence ].
    }
    destruct σ₁. {
      cbn.
      unfold iter_list; cbn.
      destruct i; [ easy | ].
      destruct i; [ easy | ].
      flia Hin.
    }
    rewrite Hσ₁.
    cbn.
    unfold transposition, comp; cbn.
    rewrite Nat.eqb_refl; cbn.
    unfold iter_list; cbn.
    destruct i; [ now rewrite Hσ₀ | ].
    destruct i; [ rewrite Hσ₁ | flia Hin ].
    cbn.
    now rewrite Nat.eqb_refl.
  }
  rewrite Hσ₀; cbn.
  rewrite Nat.eqb_refl.
  remember (vect_el σ 1) as σ₁ eqn:Hσ₁; symmetry in Hσ₁.
  destruct σ₁. {
    cbn.
    unfold transposition, comp; cbn.
    destruct σ₀. {
      cbn.
      unfold iter_list; cbn.
      destruct i; [ now rewrite Hσ₀ | ].
      destruct i; [ now rewrite Hσ₁ | flia Hin ].
    }
    cbn.
    unfold transposition, comp; cbn.
    unfold iter_list; cbn.
    destruct i. {
      rewrite Hσ₀, Hσ₁; cbn.
      now rewrite Nat.eqb_refl.
    }
    destruct i; [ | flia Hin ].
    rewrite Hσ₁; cbn.
    now rewrite Nat.eqb_refl.
  }
  unfold transposition, comp; cbn.
(* etc. *)
...
*)

Theorem iter_transp_list_of_permut : ∀ n (σ : vector n nat),
  is_permut σ
  → iter_list (map (transp_of_nat_pair n) (transp_list_of_permut σ))
       (λ σ τ, τ ° σ) σ = mk_vect n (λ i, i).
Proof.
intros * Hp.
unfold iter_list.
rewrite List_fold_left_map.
unfold transp_list_of_permut.
destruct σ as (σ).
cbn.
unfold is_permut in Hp; cbn in Hp.
apply vector_eq.
intros i Hi; cbn.
cbn.
unfold transp_list_of_permut_fun.
Abort. (*
...
intros * Hp.
apply vector_eq.
intros i Hi; cbn.
unfold transp_list_of_permut.
destruct σ as (σ).
unfold is_permut in Hp.
cbn in Hp.
cbn.
unfold "°".
cbn.
unfold transp_of_nat_pair.
cbn.
...
*)

Theorem glop : ∀ n σ,
  n ≠ 0
  → is_permut_fun σ n
  → ∀ k it,
    n ≤ it
    → iter_list (map transp_fun_of_nat_pair (tlopf_loop n it σ)) comp σ k = k.
Proof.
intros * Hnz Hp * Hit.
destruct it; [ flia Hnz Hit | ].
cbn.
remember (first_non_fixpoint n 0 σ) as x eqn:Hx; symmetry in Hx.
Abort. (*
destruct x as [(i, j)| ]. {
  cbn.
  unfold iter_list; cbn.
...
*)

Theorem apply_transp_list_of_permut_is_id : ∀ n (σ : nat → nat),
  is_permut_fun σ n
  → ∀ i,
    iter_list
      (map transp_fun_of_nat_pair (transp_list_of_permut_fun n σ))
      comp σ i = i.
Proof.
intros * Hp k.
unfold transp_list_of_permut_fun.
Abort. (*
...
*)

Theorem determinant_alternating_permut_fun :
  rngl_is_comm = true →
  rngl_has_opp = true →
  rngl_has_inv = true →
  rngl_is_integral = true →
  rngl_has_1_neq_0 = true →
  rngl_has_dec_eq = true →
  rngl_characteristic = 0 →
  ∀ n (M : matrix n n T) σ,
  n ≠ 0
  → is_permut_fun σ n
  → determinant (mat_permut_rows_fun σ M) = (ε_fun σ n * determinant M)%F.
Proof.
intros Hic Hop Hin Hit H10 Hde Hch * Hnz Hp.
(* prove that any permutation is a sequence of transpositions
   then apply determinant alternating in sequence *)
Check determinant_alternating.
Abort. (*
...
Check det_is_det_by_any_permut.
Print determinant'_list.
...
intros Hic Hop Hin Hit H10 Hde Hch * Hnz Hp.
destruct n; [ easy | clear Hnz; cbn ].
revert σ M Hp.
induction n; intros. {
  cbn.
  unfold iter_seq, iter_list; cbn.
  do 2 rewrite rngl_add_0_l.
  do 2 rewrite rngl_mul_1_l, rngl_mul_1_r.
  destruct Hp as (Hp1, Hp2).
  specialize (Hp1 0 Nat.lt_0_1).
  apply Nat.lt_1_r in Hp1; rewrite Hp1.
  symmetry; rewrite <- rngl_mul_1_l; f_equal.
  unfold ε, ε_fun; cbn.
  unfold iter_seq, iter_list; cbn.
  apply rngl_mul_inv_r; [ now left | ].
  do 2 rewrite rngl_mul_1_l.
  now apply rngl_1_neq_0.
}
cbn.
...
*)

Theorem determinant_alternating_permut :
  rngl_is_comm = true →
  rngl_has_opp = true →
  rngl_has_inv = true →
  rngl_is_integral = true →
  rngl_has_1_neq_0 = true →
  rngl_has_dec_eq = true →
  rngl_characteristic = 0 →
  ∀ n (M : matrix n n T) σ,
  n ≠ 0
  → is_permut σ
  → determinant (mat_permut_rows σ M) = (ε σ * determinant M)%F.
Proof.
intros Hic Hop Hin Hit H10 Hde Hch * Hnz Hp.
Abort. (*
...
now apply determinant_alternating_permut_fun.
...
*)

(* If we add a row (column) of A multiplied by a scalar k to another
   row (column) of A, then the determinant will not change. *)
(* https://math.vanderbilt.edu/sapirmv/msapir/proofdet1.html *)
(* doing it only when the first row is 0; can be generalized later *)

Definition mat_add_row_mul_scal_row n (M : matrix n n T) i1 v i2 :=
  mk_mat n n
    (λ i j,
     if Nat.eq_dec i i1 then (mat_el M i1 j + v * mat_el M i2 j)%F
     else mat_el M i j).

(* *)

Definition mat_mul_row_by_scal n k (M : matrix n n T) s :=
  mk_mat n n
    (λ i j,
     if Nat.eq_dec i k then (s * mat_el M i j)%F else mat_el M i j).

(* If we multiply a row (column) of A by a number, the determinant of
   A will be multiplied by the same number. *)
(* https://math.vanderbilt.edu/sapirmv/msapir/proofdet1.html
   point 1 *)

(* Well, since my definition of the discriminant only covers the
   row 0, we can prove that only when i=0; this will able us to
   prove next theorems, swapping rows by going via row 0 *)

Theorem det_mul_row_0_by_scal :
  rngl_is_comm = true →
  ∀ n (A : matrix n n T) v,
  n ≠ 0
  → determinant (mat_mul_row_by_scal 0 A v) = (v * determinant A)%F.
Proof.
intros Hic * Hnz.
unfold determinant; cbn.
destruct n; [ easy | clear Hnz ].
cbn.
rewrite rngl_mul_summation_distr_l.
apply rngl_summation_eq_compat.
intros j Hj.
rewrite (rngl_mul_comm Hic (minus_one_pow j)).
do 2 rewrite <- rngl_mul_assoc.
f_equal.
rewrite (rngl_mul_comm Hic (mat_el A 0 j)).
do 2 rewrite <- rngl_mul_assoc.
f_equal.
rewrite rngl_mul_comm; [ f_equal | easy ].
f_equal.
apply matrix_eq; cbn.
rename j into k; rename Hj into Hk.
intros i j Hi Hj.
destruct (Nat.eq_dec (i + 1) 0) as [H| H]; [ flia H | easy ].
Qed.

(* If the i-th row (column) in A is a sum of the i-th row (column) of
   a matrix B and the i-th row (column) of a matrix C and all other
   rows in B and C are equal to the corresponding rows in A (that is B
   and C differ from A by one row only), then det(A)=det(B)+det(C). *)
(* https://math.vanderbilt.edu/sapirmv/msapir/proofdet1.html
   point 2 *)

(* Well, since my definition of the discriminant only covers the
   row 0, we can prove that only when i=0; this will able us to
   prove the next theorem, swapping rows by going via row 0 *)

Theorem det_sum_row_row : ∀ n (A B C : matrix n n T),
  n ≠ 0
  → (∀ j, mat_el A 0 j = (mat_el B 0 j + mat_el C 0 j)%F)
  → (∀ i j, i ≠ 0 → mat_el B i j = mat_el A i j)
  → (∀ i j, i ≠ 0 → mat_el C i j = mat_el A i j)
  → determinant A = (determinant B + determinant C)%F.
Proof.
intros * Hnz Hbc Hb Hc.
unfold determinant.
destruct n; [ easy | clear Hnz ].
cbn.
assert (Hab : ∀ j, subm A 0 j = subm B 0 j). {
  intros.
  apply matrix_eq; cbn.
  intros i j' Hi Hj'.
  destruct (lt_dec j' j); symmetry; apply Hb; flia.
}
assert (Hac : ∀ j, subm A 0 j = subm C 0 j). {
  intros.
  apply matrix_eq; cbn.
  intros i j' Hi Hj'.
  destruct (lt_dec j' j); symmetry; apply Hc; flia.
}
erewrite rngl_summation_eq_compat. 2: {
  intros j Hj.
  rewrite Hbc.
  rewrite rngl_mul_add_distr_l.
  rewrite rngl_mul_add_distr_r.
  rewrite Hab at 1.
  rewrite Hac at 1.
  easy.
}
cbn.
now apply rngl_summation_add_distr.
Qed.

(* If two rows (columns) in A are equal then det(A)=0. *)
(* https://math.vanderbilt.edu/sapirmv/msapir/proofdet1.html
   point 3 *)
(* doing it only when the first row is 0; can be generalized later *)

Definition δ_lt i k := Nat.b2n (i <? k).

Theorem subm_subm_swap : ∀ n (A : matrix n n T) i j k l,
  subm (subm A i j) k l =
  subm (subm A (k + δ_lt i k) (l + δ_lt j l)) (i - δ_lt k i) (j - δ_lt l j).
Proof.
intros.
apply matrix_eq; cbn.
intros i' j' Hi' Hj'.
f_equal. {
  do 2 rewrite <- Nat.add_assoc; f_equal.
  rewrite Nat.add_comm.
  unfold δ_lt.
  remember (k <=? i') as a eqn:Ha.
  remember (i <=? i' + Nat.b2n a) as b eqn:Hb.
  remember (i <? k) as c eqn:Hc.
  remember (k <? i) as d eqn:Hd.
  remember (i - Nat.b2n d <=? i') as e eqn:He.
  remember (k + Nat.b2n c <=? i' + Nat.b2n e) as f eqn:Hf.
  move b before a; move c before b; move d before c; move e before d.
  move f before e.
  symmetry in Ha, Hb, Hc, Hd, He, Hf.
  destruct a, b, d, e, f; cbn; try easy; exfalso. {
    apply Nat.leb_le in Ha; apply Nat.leb_le in Hb; apply Nat.leb_le in Hd.
    apply Nat.leb_le in He; apply Nat.leb_nle in Hf.
    destruct c; [ apply Nat.ltb_lt in Hc; flia Ha Hb Hc Hd He Hf | ].
    cbn in Hf.
    apply Nat.ltb_nlt in Hc; flia Ha Hb Hc Hd He Hf.
  } {
    apply Nat.leb_le in Ha; apply Nat.leb_le in Hb; apply Nat.leb_le in Hd.
    apply Nat.leb_nle in He; apply Nat.leb_le in Hf.
    destruct c; [ apply Nat.ltb_lt in Hc; flia Ha Hb Hc Hd He Hf | ].
    apply Nat.ltb_nlt in Hc; flia Ha Hb Hc Hd He Hf.
  } {
    apply Nat.leb_le in Ha; apply Nat.leb_le in Hb; apply Nat.leb_le in Hd.
    apply Nat.leb_nle in He; apply Nat.leb_nle in Hf.
    destruct c; [ apply Nat.ltb_lt in Hc; flia Ha Hb Hc Hd He Hf | ].
    apply Nat.ltb_nlt in Hc; flia Ha Hb Hc Hd He Hf.
  } {
    apply Nat.leb_le in Ha; apply Nat.leb_le in Hb; apply Nat.leb_nle in Hd.
    apply Nat.leb_le in He; apply Nat.leb_nle in Hf.
    destruct c; [ apply Nat.ltb_lt in Hc; flia Ha Hb Hc Hd He Hf | ].
    cbn in Hf.
    apply Nat.ltb_nlt in Hc; flia Ha Hb Hc Hd He Hf.
  } {
    apply Nat.leb_le in Ha; apply Nat.leb_le in Hb; apply Nat.leb_nle in Hd.
    apply Nat.leb_nle in He; apply Nat.leb_le in Hf.
    destruct c; [ apply Nat.ltb_lt in Hc; flia Ha Hb Hc Hd He Hf | ].
    apply Nat.ltb_nlt in Hc; flia Ha Hb Hc Hd He Hf.
  } {
    apply Nat.leb_le in Ha; apply Nat.leb_le in Hb; apply Nat.leb_nle in Hd.
    apply Nat.leb_nle in He; apply Nat.leb_nle in Hf.
    destruct c; [ apply Nat.ltb_lt in Hc; flia Ha Hb Hc Hd He Hf | ].
    apply Nat.ltb_nlt in Hc; flia Ha Hb Hc Hd He Hf.
  } {
    apply Nat.leb_le in Ha; apply Nat.leb_nle in Hb; apply Nat.leb_le in Hd.
    apply Nat.leb_le in He; apply Nat.leb_le in Hf.
    destruct c; [ apply Nat.ltb_lt in Hc; flia Ha Hb Hc Hd He Hf | ].
    apply Nat.ltb_nlt in Hc; flia Ha Hb Hc Hd He Hf.
  } {
    apply Nat.leb_le in Ha; apply Nat.leb_nle in Hb; apply Nat.leb_le in Hd.
    apply Nat.leb_nle in He; apply Nat.leb_nle in Hf.
    destruct c; [ apply Nat.ltb_lt in Hc; flia Ha Hb Hc Hd He Hf | ].
    apply Nat.ltb_nlt in Hc; flia Ha Hb Hc Hd He Hf.
  } {
    apply Nat.leb_le in Ha; apply Nat.leb_nle in Hb; apply Nat.leb_nle in Hd.
    apply Nat.leb_le in He; apply Nat.leb_le in Hf.
    destruct c; [ apply Nat.ltb_lt in Hc; flia Ha Hb Hc Hd He Hf | ].
    apply Nat.ltb_nlt in Hc; flia Ha Hb Hc Hd He Hf.
  } {
    apply Nat.leb_le in Ha; apply Nat.leb_nle in Hb; apply Nat.leb_nle in Hd.
    apply Nat.leb_nle in He; apply Nat.leb_nle in Hf.
    destruct c; [ apply Nat.ltb_lt in Hc; flia Ha Hb Hc Hd He Hf | ].
    apply Nat.ltb_nlt in Hc; flia Ha Hb Hc Hd He Hf.
  } {
    apply Nat.leb_nle in Ha; apply Nat.leb_le in Hb; apply Nat.leb_le in Hd.
    apply Nat.leb_le in He; apply Nat.leb_le in Hf.
    destruct c; [ apply Nat.ltb_lt in Hc; flia Ha Hb Hc Hd He Hf | ].
    cbn in He.
    apply Nat.ltb_nlt in Hc; flia Ha Hb Hc Hd He Hf.
  } {
    apply Nat.leb_nle in Ha; apply Nat.leb_le in Hb; apply Nat.leb_le in Hd.
    apply Nat.leb_nle in He; apply Nat.leb_nle in Hf.
    destruct c; [ apply Nat.ltb_lt in Hc; flia Ha Hb Hc Hd He Hf | ].
    cbn in Hb.
    apply Nat.ltb_nlt in Hc; flia Ha Hb Hc Hd He Hf.
  } {
    apply Nat.leb_nle in Ha; apply Nat.leb_le in Hb; apply Nat.leb_nle in Hd.
    apply Nat.leb_le in He; apply Nat.leb_le in Hf.
    destruct c; [ apply Nat.ltb_lt in Hc; flia Ha Hb Hc Hd He Hf | ].
    cbn in Hb.
    apply Nat.ltb_nlt in Hc; flia Ha Hb Hc Hd He Hf.
  } {
    apply Nat.leb_nle in Ha; apply Nat.leb_le in Hb; apply Nat.leb_nle in Hd.
    apply Nat.leb_nle in He; apply Nat.leb_nle in Hf.
    destruct c; [ apply Nat.ltb_lt in Hc; flia Ha Hb Hc Hd He Hf | ].
    apply Nat.ltb_nlt in Hc; flia Ha Hb Hc Hd He Hf.
  } {
    apply Nat.leb_nle in Ha; apply Nat.leb_nle in Hb; apply Nat.leb_le in Hd.
    apply Nat.leb_le in He; apply Nat.leb_le in Hf.
    destruct c; [ apply Nat.ltb_lt in Hc; flia Ha Hb Hc Hd He Hf | ].
    cbn in He.
    apply Nat.ltb_nlt in Hc; flia Ha Hb Hc Hd He Hf.
  } {
    apply Nat.leb_nle in Ha; apply Nat.leb_nle in Hb; apply Nat.leb_le in Hd.
    apply Nat.leb_le in He; apply Nat.leb_nle in Hf.
    destruct c; [ apply Nat.ltb_lt in Hc; flia Ha Hb Hc Hd He Hf | ].
    cbn in He.
    apply Nat.ltb_nlt in Hc; flia Ha Hb Hc Hd He Hf.
  } {
    apply Nat.leb_nle in Ha; apply Nat.leb_nle in Hb; apply Nat.leb_le in Hd.
    apply Nat.leb_nle in He; apply Nat.leb_le in Hf.
    destruct c; [ apply Nat.ltb_lt in Hc; flia Ha Hb Hc Hd He Hf | ].
    apply Nat.ltb_nlt in Hc; flia Ha Hb Hc Hd He Hf.
  } {
    apply Nat.leb_nle in Ha; apply Nat.leb_nle in Hb; apply Nat.leb_nle in Hd.
    apply Nat.leb_le in He; apply Nat.leb_le in Hf.
    destruct c; [ apply Nat.ltb_lt in Hc; flia Ha Hb Hc Hd He Hf | ].
    apply Nat.ltb_nlt in Hc; flia Ha Hb Hc Hd He Hf.
  } {
    apply Nat.leb_nle in Ha; apply Nat.leb_nle in Hb; apply Nat.leb_nle in Hd.
    apply Nat.leb_le in He; apply Nat.leb_nle in Hf.
    destruct c; [ apply Nat.ltb_lt in Hc; flia Ha Hb Hc Hd He Hf | ].
    apply Nat.ltb_nlt in Hc; flia Ha Hb Hc Hd He Hf.
  } {
    apply Nat.leb_nle in Ha; apply Nat.leb_nle in Hb; apply Nat.leb_nle in Hd.
    apply Nat.leb_nle in He; apply Nat.leb_le in Hf.
    destruct c; [ apply Nat.ltb_lt in Hc; flia Ha Hb Hc Hd He Hf | ].
    apply Nat.ltb_nlt in Hc; flia Ha Hb Hc Hd He Hf.
  }
} {
  do 2 rewrite <- Nat.add_assoc; f_equal.
  rewrite Nat.add_comm.
  unfold δ_lt.
  remember (l <=? j') as a eqn:Ha.
  remember (j <=? j' + Nat.b2n a) as b eqn:Hb.
  remember (j <? l) as c eqn:Hc.
  remember (l <? j) as d eqn:Hd.
  remember (j - Nat.b2n d <=? j') as e eqn:He.
  remember (l + Nat.b2n c <=? j' + Nat.b2n e) as f eqn:Hf.
  move b before a; move c before b; move d before c; move e before d.
  move f before e.
  symmetry in Ha, Hb, Hc, Hd, He, Hf.
  destruct a, b, d, e, f; cbn; try easy; exfalso. {
    apply Nat.leb_le in Ha; apply Nat.leb_le in Hb; apply Nat.leb_le in Hd.
    apply Nat.leb_le in He; apply Nat.leb_nle in Hf.
    destruct c; [ apply Nat.ltb_lt in Hc; flia Ha Hb Hc Hd He Hf | ].
    cbn in He, Hf.
    apply Nat.ltb_nlt in Hc; flia Ha Hb Hc Hd He Hf.
  } {
    apply Nat.leb_le in Ha; apply Nat.leb_le in Hb; apply Nat.leb_le in Hd.
    apply Nat.leb_nle in He; apply Nat.leb_le in Hf.
    destruct c; [ apply Nat.ltb_lt in Hc; flia Ha Hb Hc Hd He Hf | ].
    apply Nat.ltb_nlt in Hc; flia Ha Hb Hc Hd He Hf.
  } {
    apply Nat.leb_le in Ha; apply Nat.leb_le in Hb; apply Nat.leb_le in Hd.
    apply Nat.leb_nle in He; apply Nat.leb_nle in Hf.
    destruct c; [ apply Nat.ltb_lt in Hc; flia Ha Hb Hc Hd He Hf | ].
    apply Nat.ltb_nlt in Hc; flia Ha Hb Hc Hd He Hf.
  } {
    apply Nat.leb_le in Ha; apply Nat.leb_le in Hb; apply Nat.leb_nle in Hd.
    apply Nat.leb_le in He; apply Nat.leb_nle in Hf.
    destruct c; [ apply Nat.ltb_lt in Hc; flia Ha Hb Hc Hd He Hf | ].
    cbn in Hf.
    apply Nat.ltb_nlt in Hc; flia Ha Hb Hc Hd He Hf.
  } {
    apply Nat.leb_le in Ha; apply Nat.leb_le in Hb; apply Nat.leb_nle in Hd.
    apply Nat.leb_nle in He; apply Nat.leb_le in Hf.
    destruct c; [ apply Nat.ltb_lt in Hc; flia Ha Hb Hc Hd He Hf | ].
    apply Nat.ltb_nlt in Hc; flia Ha Hb Hc Hd He Hf.
  } {
    apply Nat.leb_le in Ha; apply Nat.leb_le in Hb; apply Nat.leb_nle in Hd.
    apply Nat.leb_nle in He; apply Nat.leb_nle in Hf.
    destruct c; [ apply Nat.ltb_lt in Hc; flia Ha Hb Hc Hd He Hf | ].
    apply Nat.ltb_nlt in Hc; flia Ha Hb Hc Hd He Hf.
  } {
    apply Nat.leb_le in Ha; apply Nat.leb_nle in Hb; apply Nat.leb_le in Hd.
    apply Nat.leb_le in He; apply Nat.leb_le in Hf.
    destruct c; [ apply Nat.ltb_lt in Hc; flia Ha Hb Hc Hd He Hf | ].
    apply Nat.ltb_nlt in Hc; flia Ha Hb Hc Hd He Hf.
  } {
    apply Nat.leb_le in Ha; apply Nat.leb_nle in Hb; apply Nat.leb_le in Hd.
    apply Nat.leb_nle in He; apply Nat.leb_nle in Hf.
    destruct c; [ apply Nat.ltb_lt in Hc; flia Ha Hb Hc Hd He Hf | ].
    apply Nat.ltb_nlt in Hc; cbn in Hc; flia Ha Hb Hc Hd He Hf.
  } {
    apply Nat.leb_le in Ha; apply Nat.leb_nle in Hb; apply Nat.leb_nle in Hd.
    apply Nat.leb_le in He; apply Nat.leb_le in Hf.
    destruct c; [ apply Nat.ltb_lt in Hc; flia Ha Hb Hc Hd He Hf | ].
    apply Nat.ltb_nlt in Hc; flia Ha Hb Hc Hd He Hf.
  } {
    apply Nat.leb_le in Ha; apply Nat.leb_nle in Hb; apply Nat.leb_nle in Hd.
    apply Nat.leb_nle in He; apply Nat.leb_nle in Hf.
    destruct c; [ apply Nat.ltb_lt in Hc; flia Ha Hb Hc Hd He Hf | ].
    apply Nat.ltb_nlt in Hc; flia Ha Hb Hc Hd He Hf.
  } {
    apply Nat.leb_nle in Ha; apply Nat.leb_le in Hb; apply Nat.leb_le in Hd.
    apply Nat.leb_le in He; apply Nat.leb_le in Hf.
    destruct c; [ apply Nat.ltb_lt in Hc; flia Ha Hb Hc Hd He Hf | ].
    cbn in He.
    apply Nat.ltb_nlt in Hc; flia Ha Hb Hc Hd He Hf.
  } {
    apply Nat.leb_nle in Ha; apply Nat.leb_le in Hb; apply Nat.leb_le in Hd.
    apply Nat.leb_nle in He; apply Nat.leb_nle in Hf.
    destruct c; [ apply Nat.ltb_lt in Hc; flia Ha Hb Hc Hd He Hf | ].
    cbn in Hb.
    apply Nat.ltb_nlt in Hc; flia Ha Hb Hc Hd He Hf.
  } {
    apply Nat.leb_nle in Ha; apply Nat.leb_le in Hb; apply Nat.leb_nle in Hd.
    apply Nat.leb_le in He; apply Nat.leb_le in Hf.
    destruct c; [ apply Nat.ltb_lt in Hc; flia Ha Hb Hc Hd He Hf | ].
    cbn in Hb.
    apply Nat.ltb_nlt in Hc; flia Ha Hb Hc Hd He Hf.
  } {
    apply Nat.leb_nle in Ha; apply Nat.leb_le in Hb; apply Nat.leb_nle in Hd.
    apply Nat.leb_nle in He; apply Nat.leb_nle in Hf.
    destruct c; [ apply Nat.ltb_lt in Hc; flia Ha Hb Hc Hd He Hf | ].
    apply Nat.ltb_nlt in Hc; flia Ha Hb Hc Hd He Hf.
  } {
    apply Nat.leb_nle in Ha; apply Nat.leb_nle in Hb; apply Nat.leb_le in Hd.
    apply Nat.leb_le in He; apply Nat.leb_le in Hf.
    destruct c; [ apply Nat.ltb_lt in Hc; flia Ha Hb Hc Hd He Hf | ].
    cbn in He.
    apply Nat.ltb_nlt in Hc; flia Ha Hb Hc Hd He Hf.
  } {
    apply Nat.leb_nle in Ha; apply Nat.leb_nle in Hb; apply Nat.leb_le in Hd.
    apply Nat.leb_le in He; apply Nat.leb_nle in Hf.
    destruct c; [ apply Nat.ltb_lt in Hc; flia Ha Hb Hc Hd He Hf | ].
    cbn in He.
    apply Nat.ltb_nlt in Hc; flia Ha Hb Hc Hd He Hf.
  } {
    apply Nat.leb_nle in Ha; apply Nat.leb_nle in Hb; apply Nat.leb_le in Hd.
    apply Nat.leb_nle in He; apply Nat.leb_le in Hf.
    destruct c; [ apply Nat.ltb_lt in Hc; flia Ha Hb Hc Hd He Hf | ].
    apply Nat.ltb_nlt in Hc; flia Ha Hb Hc Hd He Hf.
  } {
    apply Nat.leb_nle in Ha; apply Nat.leb_nle in Hb; apply Nat.leb_nle in Hd.
    apply Nat.leb_le in He; apply Nat.leb_le in Hf.
    destruct c; [ apply Nat.ltb_lt in Hc; flia Ha Hb Hc Hd He Hf | ].
    apply Nat.ltb_nlt in Hc; flia Ha Hb Hc Hd He Hf.
  } {
    apply Nat.leb_nle in Ha; apply Nat.leb_nle in Hb; apply Nat.leb_nle in Hd.
    apply Nat.leb_le in He; apply Nat.leb_nle in Hf.
    destruct c; [ apply Nat.ltb_lt in Hc; flia Ha Hb Hc Hd He Hf | ].
    apply Nat.ltb_nlt in Hc; flia Ha Hb Hc Hd He Hf.
  } {
    apply Nat.leb_nle in Ha; apply Nat.leb_nle in Hb; apply Nat.leb_nle in Hd.
    apply Nat.leb_nle in He; apply Nat.leb_le in Hf.
    destruct c; [ apply Nat.ltb_lt in Hc; flia Ha Hb Hc Hd He Hf | ].
    apply Nat.ltb_nlt in Hc; flia Ha Hb Hc Hd He Hf.
  }
}
Qed.

Theorem glop1 : ∀ n (A : matrix n n T) i j,
  subm (subm A i j) 0 0 = subm (subm A 0 0) (i - 1) (j - 1).
Proof.
intros.
rewrite subm_subm_swap.
unfold δ_lt.
now destruct i, j.
Qed.

Definition swap_in_permut n i j k := vect_swap_elem (canon_permut n k) i j.

(* comatrix *)

Definition comatrix {n} (M : matrix n n T) : matrix n n T :=
  {| mat_el i j := (minus_one_pow (i + j) * determinant (subm M i j))%F |}.

Theorem subm_mat_swap_rows_0_1 : ∀ n (M : matrix n n T) r,
  subm (mat_swap_rows 0 1 M) 0 r = subm M 1 r.
Proof.
intros.
apply matrix_eq.
intros i j Hi Hj; cbn.
destruct (Nat.eq_dec (i + 1) 0) as [H| H]; [ flia H | clear H ].
destruct (Nat.eq_dec (i + 1) 1) as [H| H]. {
  now replace i with 0 by flia H.
}
now destruct i.
Qed.

(* Laplace formulas *)

Theorem laplace_formula_on_rows :
  rngl_is_comm = true →
  rngl_has_opp = true →
  rngl_has_inv = true →
  rngl_is_integral = true →
  rngl_has_1_neq_0 = true →
  rngl_has_dec_eq = true →
  rngl_characteristic = 0 →
  ∀ n (M : matrix n n T) i,
  n ≠ 0
  → i < n
  → determinant M = Σ (j = 0, n - 1), mat_el M i j * mat_el (comatrix M) i j.
Proof.
(*
intros Hic Hop Hin Hit H10 Hde Hch * Hnz Hlin.
destruct (Nat.eq_dec i 0) as [Hiz| Hiz]. {
  subst i.
  unfold determinant.
  destruct n; [ easy | cbn ].
  symmetry.
  rewrite Nat.sub_0_r at 1.
  apply rngl_summation_eq_compat.
  intros j Hj.
  rewrite rngl_mul_comm; [ | easy ].
  rewrite rngl_mul_mul_swap; [ | easy ].
  f_equal; f_equal.
  apply Nat.sub_0_r.
}
destruct (le_dec n 1) as [Hn1| Hn1]. {
  destruct n; [ easy | ].
  destruct n; [ flia Hlin Hiz | flia Hn1 ].
}
apply Nat.nle_gt in Hn1.
unfold comatrix; symmetry; cbn.
destruct (Nat.eq_dec i (n - 1)) as [Hin1| Hin1]. {
  unfold comatrix; symmetry; cbn.
  destruct n; [ easy | clear Hnz; cbn ].
  rewrite Nat.sub_succ, Nat.sub_0_r in Hin1; subst i.
...
erewrite rngl_summation_eq_compat. 2: {
  intros j (_, Hj).
  specialize (determinant_alternating Hic Hop Hin Hit H10 Hde Hch) as H1.
  apply Nat.neq_0_lt_0 in Hnz.
  specialize (H1 _ (subm M i j) i 0 Hiz).
...
  assert (0 < n - 1) by flia Hn1.
...
  specialize (H1 _ M i 0 Hiz Hlin Hnz).
  apply (f_equal rngl_opp) in H1.
  rewrite rngl_opp_involutive in H1; [ | easy ].
  rewrite <- H1.
unfold determinant.
destruct n; [ easy | clear Hnz Hiz ].
cbn - [ mat_swap_rows ].
rewrite Nat.sub_0_r at 1.
...
*)
intros Hic Hop Hin Hit H10 Hde Hch * Hnz Hlin.
destruct (Nat.eq_dec i 0) as [Hiz| Hiz]. {
  subst i.
  unfold determinant.
  destruct n; [ easy | cbn ].
  symmetry.
  rewrite Nat.sub_0_r at 1.
  apply rngl_summation_eq_compat.
  intros j Hj.
  rewrite rngl_mul_comm; [ | easy ].
  rewrite rngl_mul_mul_swap; [ | easy ].
  f_equal; f_equal.
  apply Nat.sub_0_r.
}
destruct n; [ easy | clear Hnz ].
replace (S n - 1) with n by flia.
specialize (determinant_alternating Hic Hop Hin Hit H10 Hde Hch) as H1.
specialize (H1 (S n) M 0 i).
assert (H : 0 ≠ i) by flia Hiz.
specialize (H1 H); clear H.
specialize (H1 (Nat.lt_0_succ _) Hlin).
apply (f_equal rngl_opp) in H1.
rewrite rngl_opp_involutive in H1; [ | easy ].
symmetry in H1.
unfold comatrix.
cbn - [ determinant ].
erewrite rngl_summation_eq_compat. 2: {
  intros j Hj.
  rewrite rngl_mul_comm; [ | easy ].
  rewrite rngl_mul_mul_swap; [ | easy ].
  easy.
}
cbn - [ determinant ].
(**)
rewrite H1; cbn.
rewrite rngl_opp_summation; [ | easy | easy ].
unfold determinant.
Abort. (*
...
destruct (Nat.eq_dec i n) as [Hein| Hein]. {
  subst i; clear Hlin.
...
erewrite rngl_summation_eq_compat. 2: {
  intros j (_, Hj).
  specialize (determinant_alternating Hic Hop Hin Hit H10 Hde Hch) as H1.
  specialize (H1 _ (subm M 0 j) 0 i).
  assert (H : 0 ≠ i) by flia Hiz.
  specialize (H1 H); clear H.
  rewrite Nat.sub_succ, Nat.sub_0_r in H1 at 1 2.
...
  assert (H : 0 < S n - 1) by flia Hlin.
  apply Nat.neq_0_lt_0 in Hnz.
specialize (H1 _ M i 0 Hiz Hlin Hnz).
apply (f_equal rngl_opp) in H1.
rewrite rngl_opp_involutive in H1; [ | easy ].
rewrite <- H1; cbn.
unfold determinant.
destruct n; [ easy | clear Hnz Hiz ].
cbn - [ mat_swap_rows ].
rewrite Nat.sub_0_r at 1.
...
intros Hic Hop Hin Hit H10 Hde Hch * Hnz Hlin.
unfold comatrix; cbn.
erewrite rngl_summation_eq_compat. 2: {
  intros j Hj.
  rewrite rngl_mul_comm; [ | easy ].
  rewrite rngl_mul_mul_swap; [ | easy ].
  easy.
}
destruct n; [ easy | clear Hnz ].
...
cbn.
cbn - [ determinant ].
unfold determinant at 1.
cbn - [ determinant ].
...
intros Hic Hop Hin Hit H10 Hde Hch * Hnz Hlin.
unfold determinant.
destruct n; [ easy | clear Hnz ].
rewrite Nat.sub_succ, Nat.sub_0_r.
symmetry.
erewrite rngl_summation_eq_compat. 2: {
  intros j Hj.
  rewrite rngl_mul_comm; [ | easy ].
  rewrite rngl_mul_mul_swap; [ | easy ].
  easy.
}
cbn.
destruct i. {
  apply rngl_summation_eq_compat.
  intros i (_, Hi).
  rewrite Nat.add_0_l.
  f_equal; f_equal.
  apply Nat.sub_0_r.
}
destruct i. {
  destruct (Nat.eq_dec n 0) as [Hnz| Hnz]; [ flia Hlin Hnz | ].
  specialize (determinant_alternating Hic Hop Hin Hit H10 Hde Hch) as H1.
  specialize (H1 _ M 0 1 (Nat.neq_0_succ _) (Nat.lt_0_succ _) Hlin).
  cbn in H1.
  apply (f_equal rngl_opp) in H1.
  rewrite rngl_opp_involutive in H1; [ | easy ].
  rewrite <- H1.
  rewrite rngl_opp_summation; [ | easy | easy ].
  apply rngl_summation_eq_compat.
  intros i (_, Hi).
  rewrite <- rngl_mul_opp_l; [ | easy ].
  rewrite <- rngl_mul_opp_l; [ | easy ].
  f_equal. {
    f_equal; cbn.
    now apply minus_one_pow_succ.
  }
  f_equal; [ | apply Nat.sub_0_r ].
  symmetry; apply subm_mat_swap_rows_0_1.
}
destruct i. {
  destruct (Nat.eq_dec n 0) as [Hnz| Hnz]; [ flia Hlin Hnz | ].
  specialize (determinant_alternating Hic Hop Hin Hit H10 Hde Hch) as H1.
  specialize (H1 _ M 0 2 (Nat.neq_0_succ _) (Nat.lt_0_succ _) Hlin).
  cbn in H1.
  apply (f_equal rngl_opp) in H1.
  rewrite rngl_opp_involutive in H1; [ | easy ].
  rewrite <- H1; clear H1.
  rewrite rngl_opp_summation; [ | easy | easy ].
  erewrite rngl_summation_eq_compat. 2: {
    intros i (_, Hi); cbn.
    rewrite minus_one_pow_succ; [ | easy | easy ].
    rewrite minus_one_pow_succ; [ | easy | easy ].
    rewrite rngl_opp_involutive; [ | easy ].
    easy.
  }
  cbn; symmetry.
  erewrite rngl_summation_eq_compat. 2: {
    intros i (_, Hi); cbn.
    rewrite <- rngl_mul_opp_l; [ | easy ].
    rewrite <- rngl_mul_opp_l; [ | easy ].
    easy.
  }
  cbn; symmetry.
  rewrite (rngl_summation_split _ 2); [ symmetry | flia Hlin ].
  rewrite (rngl_summation_split _ 2); [ symmetry | flia Hlin ].
  rewrite rngl_summation_split_last; [ symmetry | flia ].
  rewrite rngl_summation_split_last; [ symmetry | flia ].
  cbn.
  rewrite rngl_mul_1_l.
  destruct n; [ easy | ].
  destruct n; [ flia Hlin | clear Hnz Hlin ].
  destruct n. {
    f_equal; f_equal. 2: {
      rewrite rngl_mul_opp_l; [ | easy ].
      rewrite rngl_mul_1_l.
      rewrite rngl_mul_opp_l; [ | easy ].
      rewrite <- rngl_mul_opp_r; [ | easy ].
      f_equal; cbn.
      unfold iter_seq, iter_list; cbn.
      do 6 rewrite rngl_add_0_l.
      do 4 rewrite rngl_mul_1_l.
      do 4 rewrite rngl_mul_1_r.
      rewrite rngl_opp_add_distr; [ | easy ].
      rewrite <- rngl_mul_opp_l; [ | easy ].
      rewrite <- rngl_mul_opp_l; [ | easy ].
      rewrite rngl_opp_involutive; [ | easy ].
      rewrite rngl_mul_1_l.
      rewrite rngl_mul_comm; [ | easy ].
      rewrite rngl_mul_opp_l; [ | easy ].
      rewrite rngl_mul_1_l.
      rewrite rngl_mul_opp_l; [ | easy ].
      rewrite fold_rngl_sub; [ | easy ].
      f_equal.
      now apply rngl_mul_comm.
    }
    cbn.
    unfold iter_seq, iter_list; cbn.
    do 12 rewrite rngl_add_0_l.
    do 7 rewrite rngl_mul_1_l.
    do 6 rewrite rngl_mul_1_r.
    do 14 (rewrite rngl_mul_opp_l; [ | easy ]).
    do 4 rewrite rngl_mul_1_l.
    do 4 rewrite rngl_mul_add_distr_l.
    do 4 (rewrite rngl_mul_opp_r; [ | easy ]).
    do 2 (rewrite rngl_opp_add_distr; [ | easy ]).
    do 8 rewrite rngl_mul_assoc.
    do 3 (rewrite rngl_opp_involutive; [ | easy ]).
    unfold rngl_sub; rewrite Hop.
    do 2 rewrite rngl_add_assoc.
    rewrite rngl_mul_mul_swap; [ | easy ].
    do 4 rewrite <- rngl_add_assoc.
    f_equal; rewrite rngl_mul_mul_swap; [ | easy ].
    f_equal; rewrite rngl_mul_mul_swap; [ | easy ].
    f_equal; rewrite rngl_mul_mul_swap; [ | easy ].
    easy.
  }
...
Check determinant_alternating.
...
*)

Theorem mat_comat_mul :
  rngl_is_comm = true →
  rngl_has_opp = true →
  rngl_has_inv = true →
  rngl_is_integral = true →
  rngl_has_1_neq_0 = true →
  rngl_has_dec_eq = true →
  rngl_characteristic = 0 →
  ∀ n (M : matrix n n T),
  (M * (comatrix M)⁺ = determinant M × mI n)%M.
Proof.
intros Hic Hop Hin Hit H10 Hde Hch *.
Abort. (*
...
*)

End a.

Arguments det_loop {T ro} {n}%nat M%M i%nat.
Arguments determinant {T ro n} M%M.
Arguments subm {T m n} M%M i%nat j%nat.

Arguments determinant {T ro} {n%nat} M%M.
Arguments det_loop {T ro} {n%nat} M%M i%nat.
Arguments det_from_row {T}%type {ro} {n}%nat M%M i%nat.
Arguments det_from_col {T}%type {ro} {n}%nat M%M j%nat.
Arguments comatrix {T}%type {ro} {n}%nat M%M.
