Set Nested Proofs Allowed.
Set Implicit Arguments.

Require Import Utf8 Arith Bool.
Require Import Permutation.
Import List List.ListNotations.

Require Import Misc RingLike MyVector Matrix PermutSeq.
Require Import RLsummation RLproduct.
Import matrix_Notations.

Definition list_of_fun {A} n (f : _ → A) := map f (seq 0 n).
Definition fun_of_list {A} (d : A) l i := nth i l d.

Section a.

Context {T : Type}.
Context (ro : ring_like_op T).
Context (rp : ring_like_prop T).

(* determinant *)

(*
   determinant n M recursively computes determinant

      0     n-1
      |     |
      v     v
     ---------    ---------   ---------   ---------
0    |x      |    | x     |   |  x    |   |   x   |
     | ......| -  |. .....| + |.. ....| - |... ...| + etc.
     | ......|    |. .....|   |.. ....|   |... ...|
n-1  | ......|    |. .....|   |.. ....|   |... ...|
     ---------    ---------   ---------   ---------

   each term is the term "x" multiplied by det (n-1) of
   the sub-matrix represented by the dots. The "x" goes through
   the first row.
*)

Fixpoint determinant n (M : matrix n n T) :=
  (match n with
   | 0 => λ _, 1%F
   | S n' =>
       λ M' : matrix (S n') (S n') T,
       Σ (j = 0, n'),
       minus_one_pow j * mat_el M' 0 j * determinant (subm M' 0 j)
   end) M.

Arguments determinant [n]%nat M%M.

Theorem determinant_zero : ∀ (M : matrix 0 0 T),
  determinant M = 1%F.
Proof. easy. Qed.

Theorem determinant_succ : ∀ n (M : matrix (S n) (S n) T),
  determinant M =
     Σ (j = 0, n), minus_one_pow j * mat_el M 0 j * determinant (subm M 0 j).
Proof. easy. Qed.

Definition mat_permut_rows_fun n (σ : nat → nat) (M : matrix n n T) :=
  mk_mat n n (λ i j, mat_el M (σ i) j).

Definition mat_permut_rows n (σ : vector n nat) (M : matrix n n T) :=
  mat_permut_rows_fun (vect_el σ) M.

(* the following versions of computing the determinant should
   (to be proven) be equivalent; perhaps could help for proving
   Cramer's rule of resolving equations *)

Definition det_from_row {n} (M : matrix (S n) (S n) T) i :=
  (minus_one_pow i *
   Σ (j = 0, n),
     minus_one_pow j * mat_el M i j * determinant (subm M i j))%F.

Definition det_from_col {n} (M : matrix (S n) (S n) T) j :=
  (minus_one_pow j *
   Σ (i = 0, n - 1),
     minus_one_pow i * mat_el M i j * determinant (subm M i j))%F.

(* Alternative version of the determinant: sum of product of the
   factors a_{i,σ(i)} where σ goes through all permutations of
   the naturals of the interval [0, n-1].
   The permutations generated are in the same order as the
   terms generated by the determinant defined by induction on
   the size of the matrix.
     The order happens to be the canonical (alphabetical) order.
   Example for n=3
     = [[0; 1; 2]; [0; 2; 1]; [1; 0; 2]; [1; 2; 0]; [2; 0; 1]; [2; 1; 0]]
   Having the same terms order, the proof of equality of both definitions
   of both determinants is easy.
   See PermutSeq.v *)

(* definition of determinant by sum of products involving all
   permutations *)

Definition determinant' n (M : matrix n n T) :=
  Σ (k = 0, fact n - 1),
    ε (canon_permut n k) *
    Π (i = 1, n), mat_el M (i - 1) (vect_el (canon_permut n k) (i - 1)).

Arguments determinant' [n]%nat M%M.

(* Proof that both definitions of determinants are equal *)

Theorem det_is_det_by_canon_permut :
  rngl_is_comm = true →
  rngl_has_opp = true →
  rngl_has_inv = true →
  rngl_is_integral = true →
  rngl_has_1_neq_0 = true →
  rngl_has_dec_eq = true →
  rngl_characteristic = 0 →
  ∀ n (M : matrix n n T), determinant M = determinant' M.
Proof.
intros Hic Hop Hin Hit H10 Hde Hch *.
unfold determinant'.
destruct n; intros. {
  unfold iter_seq, iter_list.
  cbn; rewrite rngl_add_0_l.
  unfold ε, ε_fun, iter_seq, iter_list; cbn.
  rewrite rngl_div_1_r; [ | now left | easy ].
  symmetry; apply rngl_mul_1_l.
}
erewrite rngl_summation_eq_compat. 2: {
  intros i Hi.
  rewrite rngl_product_succ_succ.
  erewrite rngl_product_eq_compat. 2: {
    intros j Hj.
    now rewrite Nat.sub_succ, Nat.sub_0_r.
  }
  easy.
}
cbn - [ fact determinant canon_permut ε ].
revert M.
induction n; intros. {
  cbn.
  unfold ε, ε_fun, iter_seq, iter_list; cbn.
  do 2 rewrite rngl_add_0_l.
  do 3 rewrite rngl_mul_1_l.
  rewrite rngl_div_1_r; [ | now left | easy ].
  rewrite rngl_mul_1_l.
  now rewrite rngl_mul_1_r.
}
remember (S n) as sn.
cbn - [ fact "mod" "/" canon_permut ]; subst sn.
erewrite rngl_summation_eq_compat. 2: {
  intros i Hi.
  now rewrite IHn.
}
cbn - [ fact "mod" "/" canon_permut ].
erewrite rngl_summation_eq_compat. 2: {
  intros i Hi.
  rewrite rngl_mul_summation_distr_l; [ easy | now left ].
}
cbn - [ fact "mod" "/" canon_permut ].
rewrite rngl_summation_summation_distr; [ | easy ].
rewrite <- Nat.sub_succ_l; [ | apply lt_O_fact ].
rewrite Nat.sub_succ, Nat.sub_0_r.
rewrite <- Nat_fact_succ.
symmetry.
erewrite rngl_summation_eq_compat. 2: {
  intros i Hi.
  rewrite rngl_product_split_first; [ | flia ].
  rewrite rngl_product_succ_succ.
  easy.
}
cbn - [ fact "mod" "/" canon_permut ].
symmetry.
apply rngl_summation_eq_compat.
intros k Hk.
do 2 rewrite rngl_mul_assoc.
f_equal. 2: {
  apply rngl_product_eq_compat.
  intros i Hi.
  now rewrite Nat.add_1_r.
}
rewrite rngl_mul_mul_swap; [ | easy ].
symmetry.
f_equal.
apply ε_of_canon_permut_succ; try easy.
specialize (fact_neq_0 (S (S n))) as Hnz.
flia Hk Hnz.
Qed.

(* multilinearity *)

Theorem determinant_multilinear :
  rngl_is_comm = true →
  rngl_has_opp = true →
  rngl_has_inv = true →
  rngl_is_integral = true →
  rngl_has_1_neq_0 = true →
  rngl_has_dec_eq = true →
  rngl_characteristic = 0 →
  ∀ n (M : matrix n n T) i a b U V,
    i < n
    → determinant (mat_repl_vect i M (a × U + b × V)%V) =
         (a * determinant (mat_repl_vect i M U) +
          b * determinant (mat_repl_vect i M V))%F.
Proof.
intros Hic Hop Hin Hit H10 Hde Hch * Hi.
rewrite det_is_det_by_canon_permut; try easy.
rewrite det_is_det_by_canon_permut; try easy.
rewrite det_is_det_by_canon_permut; try easy.
unfold determinant'.
erewrite rngl_summation_eq_compat. 2: {
  intros k Hk.
  erewrite rngl_product_eq_compat. 2: {
    intros j Hj.
    now cbn.
  }
  easy.
}
cbn.
rewrite rngl_mul_summation_distr_l; [ | now left ].
rewrite rngl_mul_summation_distr_l; [ | now left ].
symmetry.
erewrite rngl_summation_eq_compat. 2: {
  intros k Hk.
  rewrite rngl_mul_assoc.
  now rewrite (rngl_mul_comm Hic a).
}
rewrite rngl_add_comm.
erewrite rngl_summation_eq_compat. 2: {
  intros k Hk.
  rewrite rngl_mul_assoc.
  now rewrite (rngl_mul_comm Hic b).
}
rewrite rngl_add_comm.
rewrite <- rngl_summation_add_distr; [ | easy ].
apply rngl_summation_eq_compat.
intros k Hk.
do 2 rewrite <- rngl_mul_assoc.
rewrite <- rngl_mul_add_distr_l.
f_equal.
assert (Hkn : k < fact n). {
  specialize (fact_neq_0 n) as Hnz.
  flia Hk Hnz.
}
specialize (canon_permut_vect_surjective Hkn Hi) as Hp.
destruct Hp as (p & Hp & Hpp).
rewrite (rngl_product_split (p + 1)); [ | flia Hp ].
rewrite rngl_product_split_last; [ | flia ].
erewrite rngl_product_eq_compat. 2: {
  intros j Hj.
  replace (j - 1 - 1) with (j - 2) by flia.
  destruct (Nat.eq_dec (vect_el (canon_permut n k) (j - 2)) i) as [Hpj| Hpj]. {
    exfalso.
    rewrite <- Hpp in Hpj.
    apply canon_permut_vect_injective in Hpj; [ | easy | flia Hp Hj | easy ].
    flia Hj Hpj.
  }
  easy.
}
rewrite (rngl_mul_comm Hic (iter_seq _ _ _ _)).
rewrite rngl_add_comm.
rewrite (rngl_product_split (p + 1)); [ | flia Hp ].
rewrite rngl_product_split_last; [ | flia ].
erewrite rngl_product_eq_compat. 2: {
  intros j Hj.
  replace (j - 1 - 1) with (j - 2) by flia.
  destruct (Nat.eq_dec (vect_el (canon_permut n k) (j - 2)) i) as [Hpj| Hpj]. {
    exfalso.
    rewrite <- Hpp in Hpj.
    apply canon_permut_vect_injective in Hpj; [ | easy | flia Hp Hj | easy ].
    flia Hj Hpj.
  }
  easy.
}
rewrite (rngl_mul_comm Hic (iter_seq _ _ _ _)).
rewrite rngl_add_comm.
symmetry.
rewrite (rngl_product_split (p + 1)); [ | flia Hp ].
rewrite rngl_product_split_last; [ | flia ].
erewrite rngl_product_eq_compat. 2: {
  intros j Hj.
  replace (j - 1 - 1) with (j - 2) by flia.
  destruct (Nat.eq_dec (vect_el (canon_permut n k) (j - 2)) i) as [Hpj| Hpj]. {
    exfalso.
    rewrite <- Hpp in Hpj.
    apply canon_permut_vect_injective in Hpj; [ | easy | flia Hp Hj | easy ].
    flia Hj Hpj.
  }
  easy.
}
rewrite (rngl_mul_comm Hic (iter_seq _ _ _ _)).
rewrite Nat.add_sub.
rewrite Hpp.
destruct (Nat.eq_dec i i) as [H| H]; [ clear H | easy ].
do 4 rewrite rngl_mul_assoc.
remember
  (Π (i0 = 2, p + 1),
   mat_el M (i0 - 2) (vect_el (canon_permut n k) (i0 - 2)%nat))%F
  as q eqn:Hq.
rewrite (rngl_mul_mul_swap Hic _ _ q).
do 3 rewrite (rngl_mul_comm Hic _ q).
do 5 rewrite <- rngl_mul_assoc.
rewrite <- rngl_mul_add_distr_l.
f_equal.
clear q Hq.
erewrite rngl_product_eq_compat. 2: {
  intros j Hj.
  destruct (Nat.eq_dec (vect_el (canon_permut n k) (j - 1)) i) as [Hpj| Hpj]. {
    rewrite <- Hpp in Hpj.
    apply canon_permut_vect_injective in Hpj; [ | easy | flia Hp Hj | easy ].
    flia Hj Hpj.
  }
  easy.
}
symmetry.
erewrite rngl_product_eq_compat. 2: {
  intros j Hj.
  destruct (Nat.eq_dec (vect_el (canon_permut n k) (j - 1)) i) as [Hpj| Hpj]. {
    rewrite <- Hpp in Hpj.
    apply canon_permut_vect_injective in Hpj; [ | easy | flia Hp Hj | easy ].
    flia Hj Hpj.
  }
  easy.
}
rewrite rngl_add_comm.
erewrite rngl_product_eq_compat. 2: {
  intros j Hj.
  destruct (Nat.eq_dec (vect_el (canon_permut n k) (j - 1)) i) as [Hpj| Hpj]. {
    rewrite <- Hpp in Hpj.
    apply canon_permut_vect_injective in Hpj; [ | easy | flia Hp Hj | easy ].
    flia Hj Hpj.
  }
  easy.
}
cbn.
rewrite rngl_add_comm.
do 2 rewrite rngl_mul_assoc.
now rewrite <- rngl_mul_add_distr_r.
Qed.

(* list of terms in determinant' (determinant by sum of products of
   permutations *)

Definition determinant'_list {n} (M : matrix n n T) :=
  map (λ k,
    (ε_canon_permut n k *
     Π (i = 1, n), mat_el M (i - 1) (vect_el (canon_permut n k) (i - 1)%nat))%F)
    (seq 0 (fact n)).

Arguments determinant'_list {n}%nat M%M.

Theorem determinant'_by_list :
  rngl_is_comm = true →
  rngl_has_opp = true →
  rngl_has_inv = true →
  rngl_has_1_neq_0 = true →
  rngl_is_integral = true →
  rngl_has_dec_eq = true →
  rngl_characteristic = 0 →
  ∀ n (M : matrix n n T),
  determinant' M = Σ (k = 0, fact n - 1), nth k (determinant'_list M) 0.
Proof.
intros Hic Hop Hin H10 Hit Hde Hch *.
unfold determinant', determinant'_list.
apply rngl_summation_eq_compat; intros k Hk.
assert (Hkn : k < fact n). {
  specialize (fact_neq_0 n) as Hn.
  flia Hk Hn.
}
rewrite List_map_nth_in with (a := 0); [ | now rewrite seq_length ].
rewrite seq_nth; [ | easy ].
rewrite Nat.add_0_l.
f_equal.
now apply ε_of_canon_permut_ε.
Qed.

Theorem rngl_summation_permut : ∀ n l1 l2,
  Permutation l1 l2
  → length l1 = n
  → length l2 = n
  → Σ (i = 0, n - 1), nth i l1 0 = Σ (i = 0, n - 1), nth i l2 0.
Proof.
intros * Hl H1 H2.
destruct n. {
  apply length_zero_iff_nil in H1.
  apply length_zero_iff_nil in H2.
  now subst l1 l2.
}
rewrite Nat.sub_succ, Nat.sub_0_r.
revert n H1 H2.
induction Hl; intros; [ easy | | | ]. {
  cbn in H1, H2.
  apply Nat.succ_inj in H1.
  apply Nat.succ_inj in H2.
  rewrite rngl_summation_split_first; [ symmetry | easy | flia ].
  rewrite rngl_summation_split_first; [ symmetry | easy | flia ].
  destruct n; [ easy | ].
  do 2 rewrite rngl_summation_succ_succ.
  now rewrite IHHl.
} {
  destruct n; [ easy | ].
  cbn in H1, H2.
  do 2 apply Nat.succ_inj in H1.
  do 2 apply Nat.succ_inj in H2.
  rewrite rngl_summation_split_first; [ symmetry | easy | flia ].
  rewrite rngl_summation_split_first; [ symmetry | easy | flia ].
  rewrite rngl_summation_split_first; [ symmetry | easy | flia ].
  rewrite rngl_summation_split_first; [ symmetry | easy | flia ].
  do 2 rewrite rngl_add_assoc.
  do 2 rewrite rngl_summation_succ_succ.
  f_equal; [ apply rngl_add_comm | ].
  apply rngl_summation_eq_compat.
  intros i Hi; cbn.
  destruct i; [ flia Hi | easy ].
} {
  specialize (Permutation_length Hl2) as H3.
  rewrite H2 in H3.
  rewrite IHHl1; [ | easy | easy ].
  now rewrite IHHl2.
}
Qed.

Theorem det_is_det_by_any_permut :
  rngl_is_comm = true →
  rngl_has_opp = true →
  rngl_has_inv = true →
  rngl_is_integral = true →
  rngl_has_1_neq_0 = true →
  rngl_has_dec_eq = true →
  rngl_characteristic = 0 →
  ∀ n (M : matrix n n T) l,
  Permutation l (determinant'_list M)
  → determinant M = Σ (k = 0, fact n - 1), nth k l 0.
Proof.
intros Hic Hop Hin Hit H10 Hde Hch * Hl.
rewrite det_is_det_by_canon_permut; try easy.
rewrite determinant'_by_list; try easy.
apply rngl_summation_permut; [ now symmetry | | ]. {
  unfold determinant'_list.
  now rewrite map_length, seq_length.
} {
  apply Permutation_length in Hl.
  unfold determinant'_list in Hl.
  now rewrite map_length, seq_length in Hl.
}
Qed.

(* yet another definition of determinant *)

Definition determinant'' p q n (M : matrix n n T) :=
  Σ (k = 0, fact n - 1),
    ε_canon_permut n k *
    Π (i = 1, n),
    mat_el M (i - 1) (vect_el (canon_permut_swap_last p q n k) (i - 1)).

Definition determinant''_list p q {n} (M : matrix n n T) :=
  map (λ k,
    (ε_canon_permut n k *
     Π (i = 1, n),
     mat_el M (i - 1) (vect_el (canon_permut_swap_last p q n k) (i - 1)))%F)
    (seq 0 (fact n)).

Theorem determinant''_by_list : ∀ n p q (M : matrix n n T),
  determinant'' p q M =
    Σ (k = 0, fact n - 1), nth k (determinant''_list p q M) 0.
Proof.
intros.
unfold determinant'', determinant''_list.
apply rngl_summation_eq_compat; intros k Hk.
assert (Hkn : k < fact n). {
  specialize (fact_neq_0 n) as Hn.
  flia Hk Hn.
}
rewrite List_map_nth_in with (a := 0); [ | now rewrite seq_length ].
rewrite seq_nth; [ | easy ].
now rewrite Nat.add_0_l.
Qed.

Definition mat_swap_rows n i1 i2 (M : matrix n n T) :=
  mk_mat n n
    (λ i j,
     if Nat.eq_dec i i1 then mat_el M i2 j
     else if Nat.eq_dec i i2 then mat_el M i1 j
     else mat_el M i j).

Theorem determinant_alternating :
  rngl_is_comm = true →
  rngl_has_opp = true →
  rngl_has_inv = true →
  rngl_is_integral = true →
  rngl_has_1_neq_0 = true →
  rngl_has_dec_eq = true →
  rngl_characteristic = 0 →
  ∀ n (M : matrix n n T) p q,
  p ≠ q
  → p < n
  → q < n
  → determinant (mat_swap_rows p q M) = (- determinant M)%F.
Proof.
intros Hic Hop Hin Hit H10 Hde Hch * Hpq Hp Hq.
rewrite det_is_det_by_canon_permut; try easy.
unfold determinant'.
erewrite rngl_summation_eq_compat. 2: {
  intros k Hk.
  rewrite rngl_product_shift; [ | flia Hp ].
  erewrite rngl_product_eq_compat. 2: {
    intros i Hi.
    now rewrite Nat.add_comm, Nat.add_sub.
  }
  easy.
}
cbn - [ mat_swap_rows ].
erewrite rngl_summation_eq_compat. 2: {
  intros k Hk.
  rewrite rngl_product_change_var with
    (g := transposition p q) (h := transposition p q). 2: {
    intros i Hi.
    apply transposition_involutive.
  }
  rewrite Nat.sub_0_r.
  rewrite <- Nat.sub_succ_l; [ | flia Hp ].
  rewrite Nat.sub_succ, Nat.sub_0_r.
  easy.
}
cbn - [ mat_swap_rows ].
erewrite rngl_summation_eq_compat. 2: {
  intros k Hk.
  rewrite rngl_product_list_permut with (l2 := seq 0 n); [ | easy | ]. 2: {
    apply permut_fun_Permutation.
    now apply transposition_is_permut_fun.
  }
  easy.
}
cbn - [ mat_swap_rows ].
erewrite rngl_summation_eq_compat. 2: {
  intros k Hk.
  erewrite rngl_product_list_eq_compat. 2: {
    intros i Hi.
    replace (mat_el _ _ _) with
      (mat_el M i (vect_el (canon_permut n k) (transposition p q i))). 2: {
      cbn.
      unfold transposition.
      do 2 rewrite if_eqb_eq_dec.
      destruct (Nat.eq_dec i p) as [Hip| Hip]. {
        subst i.
        apply Nat.neq_sym in Hpq.
        destruct (Nat.eq_dec q p) as [Hqp| Hqp]; [ easy | ].
        now destruct (Nat.eq_dec q q).
      }
      destruct (Nat.eq_dec i q) as [Hiq| Hiq]. {
        subst i.
        apply Nat.neq_sym in Hpq.
        now destruct (Nat.eq_dec p p).
      }
      destruct (Nat.eq_dec i p) as [H| H]; [ easy | clear H ].
      destruct (Nat.eq_dec i q) as [H| H]; [ easy | clear H ].
      easy.
    }
    easy.
  }
  easy.
}
cbn - [ mat_swap_rows ].
set (f := λ k, vect_swap_elem (canon_permut n k) p q).
erewrite rngl_summation_eq_compat. 2: {
  intros k Hk.
  assert (Hkn : k < n!). {
    specialize (fact_neq_0 n) as Hn.
    flia Hk Hn.
  }
  erewrite rngl_product_seq_product; [ | flia Hp ].
  rewrite Nat.add_0_l.
  erewrite rngl_product_eq_compat. 2: {
    intros i Hi.
    now replace (vect_el _ _) with (vect_el (f k) i).
  }
  cbn - [ f ].
  replace (canon_permut n k) with
    (mk_vect n (λ i, vect_el (f k) (transposition p q i))). 2: {
    apply vector_eq.
    intros i Hi; cbn.
    now rewrite transposition_involutive.
  }
  replace (mk_vect n (λ i, vect_el (f k) (transposition p q i))) with
    (f k ° mk_vect n (transposition p q)) by easy.
  rewrite signature_comp; try easy. {
    subst f; cbn.
    split; cbn. {
      intros i Hi.
      apply vect_el_permut_ub; [ now apply canon_permut_is_permut | ].
      now apply transposition_lt.
    } {
      intros * Hi Hj Hij.
      apply canon_permut_vect_injective in Hij; [ | easy | | ]; cycle 1. {
        now apply transposition_lt.
      } {
        now apply transposition_lt.
      }
      now apply transposition_injective in Hij.
    }
  } {
    split; cbn. {
      intros i Hi.
      now apply transposition_lt.
    } {
      intros * Hi Hj Hij.
      now apply transposition_injective in Hij.
    }
  }
}
cbn - [ f ].
erewrite rngl_summation_eq_compat. 2: {
  intros k (_, Hk).
  rewrite (rngl_mul_comm Hic (ε (f k))).
  rewrite <- rngl_mul_assoc.
  now rewrite transposition_signature.
}
cbn - [ f ].
rewrite <- rngl_mul_summation_distr_l; [ | now left ].
rewrite rngl_mul_opp_l; [ | easy ].
f_equal.
rewrite rngl_mul_1_l.
symmetry.
set (g := λ k, nat_of_canon_permut (f k)).
rewrite rngl_summation_change_var with (g0 := g) (h := g). 2: {
  intros k (_, Hk).
  assert (Hkn : k < n!). {
    specialize (fact_neq_0 n) as Hn.
    flia Hk Hn.
  }
  unfold g, f.
  rewrite permut_nat_of_canon_permut. 2: {
    apply vect_swap_elem_is_permut; [ easy | easy | ].
    now apply canon_permut_is_permut.
  }
  rewrite vect_swap_elem_involutive.
  now apply nat_of_canon_permut_permut.
}
rewrite Nat.sub_0_r.
rewrite <- Nat.sub_succ_l; [ | apply Nat.neq_0_lt_0, fact_neq_0 ].
rewrite Nat.sub_succ, Nat.sub_0_r.
rewrite rngl_summation_list_permut with (l2 := seq 0 n!); [ | easy | ]. 2: {
  apply permut_fun_Permutation.
  unfold g, f.
  split. {
    intros i Hi.
    apply nat_of_canon_permut_upper_bound.
    apply vect_swap_elem_is_permut; [ easy | easy | ].
    now apply canon_permut_is_permut.
  } {
    intros * Hi Hj Hij.
    apply nat_of_canon_permut_injective in Hij; cycle 1. {
      apply vect_swap_elem_is_permut; [ easy | easy | ].
      now apply canon_permut_is_permut.
    } {
      apply vect_swap_elem_is_permut; [ easy | easy | ].
      now apply canon_permut_is_permut.
    }
    apply vect_swap_elem_injective in Hij.
    now apply canon_permut_injective in Hij.
  }
}
erewrite rngl_summation_list_eq_compat. 2: {
  intros k Hk.
  assert (Hkn : k < n!). {
    apply in_seq in Hk.
    specialize (fact_neq_0 n) as Hn.
    flia Hk Hn.
  }
  unfold g, f.
  rewrite permut_nat_of_canon_permut. 2: {
    apply vect_swap_elem_is_permut; [ easy | easy | ].
    now apply canon_permut_is_permut.
  }
  rewrite vect_swap_elem_involutive.
  easy.
}
rewrite det_is_det_by_canon_permut; try easy.
unfold determinant'.
rewrite rngl_summation_seq_summation; [ | apply fact_neq_0 ].
rewrite Nat.add_0_l.
apply rngl_summation_eq_compat.
intros k Hk; f_equal.
rewrite rngl_product_shift; [ | flia Hp ].
apply rngl_product_eq_compat.
intros i Hi.
now rewrite Nat.add_comm, Nat.add_sub.
Qed.

Theorem determinant_same_rows :
  rngl_is_comm = true →
  rngl_has_opp = true →
  rngl_has_inv = true →
  rngl_is_integral = true →
  rngl_has_1_neq_0 = true →
  rngl_has_dec_eq = true →
  rngl_characteristic = 0 →
  ∀ n (M : matrix n n T) p q,
  p ≠ q
  → p < n
  → q < n
  → (∀ j, mat_el M p j = mat_el M q j)
  → determinant M = 0%F.
Proof.
intros Hic Hop Hin Hit H10 Hde Hch * Hpq Hpn Hqn Hjpq.
assert (HM : determinant M = (- determinant M)%F). {
  rewrite <- determinant_alternating with (p := p) (q := q); try easy.
  f_equal.
  apply matrix_eq.
  intros i j Hi Hj.
  cbn.
  destruct (Nat.eq_dec i p) as [Hip| Hip]; [ subst i; apply Hjpq | ].
  destruct (Nat.eq_dec i q) as [Hiq| Hiq]; [ symmetry; subst i; apply Hjpq | ].
  easy.
}
apply rngl_add_move_0_r in HM; [ | easy ].
apply eq_rngl_add_same_0 in HM; try easy; [ now left | ].
apply orb_true_iff.
now left.
Qed.

(* transpositions list of permutation *)

Fixpoint first_non_fixpoint it i σ :=
  match it with
  | 0 => None
  | S it' => if i =? σ i then first_non_fixpoint it' (i + 1) σ else Some i
  end.

Fixpoint tlopf_loop it n (σ : nat → nat) :=
  match it with
  | 0 => []
  | S it' =>
      match first_non_fixpoint n 0 σ with
      | None => []
      | Some i =>
          let σ' := comp (transposition i (σ i)) σ in
          (i, σ i) :: tlopf_loop it' n σ'
      end
  end.

Definition transp_list_of_permut_fun n (σ : nat → nat) := tlopf_loop n n σ.

Definition transp_list_of_permut {n} (σ : vector n nat) :=
  transp_list_of_permut_fun n (vect_el σ).

Theorem first_non_fixpoint_Some_iff : ∀ σ it i j,
  first_non_fixpoint it i σ = Some j
  ↔ i ≤ j ∧ j - i < it ∧ (∀ k, i ≤ k < j → σ k = k) ∧ σ j ≠ j.
Proof.
intros.
split. {
  intros Hs.
  revert σ i j Hs.
  induction it; intros; [ easy | cbn in Hs ].
  rewrite if_eqb_eq_dec in Hs.
  destruct (Nat.eq_dec i (σ i)) as [Hii| Hii]. {
    specialize (IHit σ (i + 1) j Hs) as (H1 & H2 & H3 & H4).
    split; [ flia H1 | ].
    split; [ flia H2 | ].
    split; [ | easy ].
    intros k Hk.
    destruct (Nat.eq_dec i k) as [Hik| Hik]; [ now subst k | ].
    apply H3; flia Hk Hik.
  } {
    injection Hs; clear Hs; intros; subst j.
    split; [ flia | ].
    split; [ flia | ].
    split; [ | now apply Nat.neq_sym ].
    intros k Hk; flia Hk.
  }
} {
  intros (Hij & Hji & Hj & Hjj).
  revert i j Hij Hji Hj Hjj.
  induction it; intros; [ easy | cbn ].
  rewrite if_eqb_eq_dec.
  destruct (Nat.eq_dec i (σ i)) as [Hii| Hii]. {
    assert (Heij : i ≠ j) by now intros H; symmetry in Hii; subst i.
    apply IHit; [ flia Hij Hji Heij | flia Hij Hji Heij | | easy ].
    intros k Hk.
    apply Hj.
    flia Hk.
  }
  destruct (Nat.eq_dec i j) as [Heij| Heij]; [ congruence | exfalso ].
  assert (H : i ≤ i < j) by flia Hij Heij.
  specialize (Hj _ H) as H1.
  now symmetry in H1.
}
Qed.

Theorem first_non_fixpoint_None_if : ∀ σ it i,
  first_non_fixpoint it i σ = None
  → ∀ k, i ≤ k < i + it → k = σ k.
Proof.
intros * Hs k Hik.
revert σ i k Hik Hs.
induction it; intros; [ flia Hik | ].
cbn in Hs.
rewrite if_eqb_eq_dec in Hs.
destruct (Nat.eq_dec i (σ i)) as [H1| H1]; [ | easy ].
destruct (Nat.eq_dec i k) as [H2| H2]; [ now subst i | ].
eapply IHit; [ | apply Hs ].
flia Hik H2.
Qed.

Fixpoint nb_good_loop it i σ :=
  match it with
  | 0 => 0
  | S it' => Nat.b2n (σ i =? i) + nb_good_loop it' (i + 1) σ
  end.

Definition nb_good n σ := nb_good_loop n 0 σ.

Theorem nb_good_loop_comp_transp : ∀ n it σ i k,
  is_permut_fun σ n
  → k < i ≤ n
  → σ k < i
  → n = i + it
  → nb_good_loop it i (comp (transposition k (σ k)) σ) =
    nb_good_loop it i σ.
Proof.
intros * Hp Hkin Hski Hnit.
revert i k Hkin Hski Hnit.
induction it; intros; [ easy | cbn ].
replace (i + S it) with (i + 1 + it) in Hnit by flia.
unfold comp at 1, transposition at 1, Nat.b2n.
do 4 rewrite if_eqb_eq_dec.
destruct (Nat.eq_dec (σ i) k) as [Hsik| Hsik]. {
  rewrite Hsik.
  destruct (Nat.eq_dec k i) as [H| H]; [ flia Hkin H | clear H ].
  rewrite Nat.add_0_l.
  destruct (Nat.eq_dec (σ k) i) as [H| H]; [ flia Hski H | clear H ].
  rewrite Nat.add_0_l.
  apply IHit; try easy; [ | flia Hski ].
  split; [ flia Hkin | ].
  flia Hnit.
}
destruct (Nat.eq_dec (σ i) (σ k)) as [Hsisk| Hsisk]. {
  apply Hp in Hsisk; [ flia Hkin Hsisk | | flia Hkin ].
  flia Hnit.
}
f_equal.
apply IHit; [ | flia Hski | easy ].
split; [ flia Hkin | flia Hnit ].
Qed.

Theorem comp_transp_permut_id : ∀ n σ i j k,
  is_permut_fun σ n
  → i < k
  → k < j < n
  → σ k = i
  → comp (transposition i (σ i)) σ j = σ j.
Proof.
intros * Hp Hikn Hkp Hski.
unfold comp, transposition.
do 2 rewrite if_eqb_eq_dec.
destruct (Nat.eq_dec (σ j) i) as [Hsji| Hsji]. {
  exfalso.
  rewrite <- Hski in Hsji.
  apply Hp in Hsji; [ flia Hkp Hsji | easy | flia Hkp ].
}
destruct (Nat.eq_dec (σ j) (σ i)) as [Hspi| Hspi]; [ | easy ].
apply Hp in Hspi; [ | easy | flia Hikn Hkp ].
flia Hikn Hkp Hspi.
Qed.

Theorem nb_good_loop_comp_transp_permit_id : ∀ n it σ i k,
  is_permut_fun σ n
  → i < n
  → k < n
  → n = k + it
  → (∀ j, k ≤ j → comp (transposition i (σ i)) σ j = σ j)
  → nb_good_loop it k (comp (transposition i (σ i)) σ) =
    nb_good_loop it k σ.
Proof.
intros * Hp Hin Hkn Hnit Hj.
revert i k Hin Hkn Hj Hnit.
induction it; intros; [ easy | cbn ].
unfold comp at 1, transposition at 1, Nat.b2n.
do 4 rewrite if_eqb_eq_dec.
destruct (Nat.eq_dec (σ k) i) as [Hski| Hski]. {
  rewrite Hski.
  destruct (Nat.eq_dec i k) as [Hik| Hik]. {
    move Hik at top; subst k.
    rewrite Hski.
    rewrite <- if_eqb_eq_dec, Nat.eqb_refl.
    f_equal.
    clear.
    remember (i + 1) as k eqn:Hk; clear Hk.
    revert i k.
    induction it; intros; [ easy | cbn ].
    unfold comp at 1, transposition at 1, Nat.b2n.
    do 4 rewrite if_eqb_eq_dec.
    destruct (Nat.eq_dec (σ k) i) as [Hki| Hki]. {
      rewrite Hki.
      now rewrite IHit.
    }
    now rewrite IHit.
  }
  destruct (Nat.eq_dec (σ i) k) as [Hsik| Hsik]. {
    exfalso.
    specialize (Hj k (le_refl _)).
    unfold comp, transposition in Hj.
    rewrite Hski, Nat.eqb_refl in Hj.
    apply Hik, Hp; [ easy | easy | congruence ].
  }
  f_equal.
  specialize (Hj k (le_refl _)).
  unfold comp, transposition in Hj.
  rewrite Hski, Nat.eqb_refl in Hj.
  rewrite <- Hj in Hski.
  apply Hp in Hski; [ congruence | easy | easy ].
}
destruct (Nat.eq_dec (σ k) (σ i)) as [Hsksi| Hsksi]. {
  apply Hp in Hsksi; [ | easy | easy ].
  subst k.
  rewrite <- if_eqb_eq_dec, Nat.eqb_refl.
  destruct (Nat.eq_dec (σ i) i) as [H| H]; [ easy | clear H ].
  specialize (Hj i (le_refl _)).
  unfold comp, transposition in Hj.
  rewrite if_eqb_eq_dec in Hj.
  destruct (Nat.eq_dec (σ i) i) as [H| H]; [ easy | clear H ].
  rewrite Nat.eqb_refl in Hj.
  congruence.
}
f_equal.
destruct (Nat.eq_dec (k + 1) n) as [Hk1n| Hk1n]. {
  destruct it; [ easy | ].
  flia Hnit Hk1n.
}
rewrite IHit; [ easy | easy | flia Hkn Hk1n | | flia Hnit ].
intros j Hkj.
apply Hj; flia Hkj.
Qed.

Theorem nb_good_loop_comp_transp2 : ∀ n it σ i,
  is_permut_fun σ n
  → (∀ k, k < i → σ k = k)
  → σ i ≠ i
  → σ (σ i) ≠ i
  → σ (σ i) ≠ σ i
  → n = i + 1 + it
  → nb_good_loop it (i + 1) (comp (transposition i (σ i)) σ) =
    nb_good_loop it (i + 1) σ.
Proof.
intros * Hp Hi Hsii Hssii Hssisi Hnit.
remember (σ i) as j eqn:Hj; symmetry in Hj.
remember (permut_fun_inv σ n i) as k eqn:Hk.
assert (Hkd : σ k = i). {
  subst k.
  apply fun_permut_fun_inv; [ easy | flia Hnit ].
}
assert (Hik : i < k). {
  assert (H1 : i ≤ k). {
    apply Nat.nlt_ge; intros H.
    apply Hi in H.
    rewrite Hkd in H; move H at top; subst k.
    congruence.
  }
  destruct (Nat.eq_dec i k) as [Hik| Hik]; [ | flia Hik H1 ].
  move Hik at top; subst k.
  congruence.
}
assert (Hjk : j ≠ k). {
  now intros H; move H at top; subst k.
}
assert (Hij : i < j). {
  apply Nat.nle_gt; intros H.
  assert (H' : j < i) by flia Hsii H.
  now apply Hi in H'.
}
assert (Hkn : k < n). {
  rewrite Hk.
  apply permut_fun_ub; [ | flia Hnit ].
  now apply permut_fun_inv_is_permut.
}
clear Hk.
clear Hi.
clear Hj.
clear Hsii.
clear Hssii.
remember (i + 1) as p eqn:Hp'.
assert (Hip : i < p) by flia Hp'.
clear Hp'.
revert i j k p Hssisi Hnit Hkd Hik Hjk Hij Hip Hkn.
induction it; intros; [ easy | cbn ].
replace (p + S it) with (p + 1 + it) in Hnit by flia.
unfold comp at 1, transposition at 1, Nat.b2n.
do 4 rewrite if_eqb_eq_dec.
destruct (Nat.eq_dec (σ p) i) as [Hspi| Hspi]. {
  rewrite Hspi.
  rewrite <- Hkd in Hspi.
  apply Hp in Hspi; [ | flia Hnit | easy ].
  move Hspi at top; subst p.
  destruct (Nat.eq_dec j k) as [H| H]; [ easy | clear H ].
  destruct (Nat.eq_dec i k) as [H| H]; [ flia Hip H | clear H ].
  cbn.
  apply IHit with (k := k); try easy; flia Hip.
}
destruct (Nat.eq_dec (σ p) j) as [Hspj| Hspj]. {
  rewrite Hspj.
  destruct (Nat.eq_dec i p) as [H| H]; [ flia Hip H | clear H ].
  destruct (Nat.eq_dec j p) as [Hjp| Hjp]. {
    now move Hjp at top; subst p.
  }
  cbn.
  apply IHit with (k := k); try easy; flia Hip.
}
f_equal.
apply IHit with (k := k); try easy; flia Hip.
Qed.

Theorem nb_good_loop_comp_transp' : ∀ n it σ i d,
  is_permut_fun σ n
  → i < n
  → d ≠ 0
  → (∀ k, k < i → σ k = k)
  → (∀ k, k < d → σ (i + k) ≠ i)
  → σ (σ i) = i
  → n = i + d + it
  → nb_good_loop it (i + d) (comp (transposition i (σ i)) σ) =
     nb_good_loop it (i + d) σ + 1.
Proof.
intros * Hp Hin Hdz Hskk Hsii Hssi Hnit.
revert i d Hin Hdz Hskk Hsii Hssi Hnit.
induction it; intros; cbn. {
  exfalso.
  destruct Hp as (Hp1, Hp2).
  rewrite Nat.add_0_r in Hnit.
  specialize (Hp1 i Hin) as H1.
  clear - d Hin Hnit Hsii Hskk Hssi H1.
  assert (Hisi : i ≤ σ i). {
    apply Nat.nlt_ge; intros H2.
    specialize (Hskk (σ i) H2) as H3.
    flia Hssi H2 H3.
  }
  specialize (Hsii (σ i - i)) as H2.
  assert (H : σ i - i < d). {
    apply Nat.add_lt_mono_r with (p := i).
    rewrite (Nat.add_comm d), <- Hnit.
    now rewrite Nat.sub_add.
  }
  specialize (H2 H); clear H.
  rewrite Nat.add_sub_assoc in H2; [ | easy ].
  now rewrite Nat.add_comm, Nat.add_sub in H2.
}
replace (i + d + S it) with (i + d + 1 + it) in Hnit by flia.
unfold comp at 1, transposition at 1, Nat.b2n.
do 4 rewrite if_eqb_eq_dec.
destruct (Nat.eq_dec (σ (i + d)) i) as [Hsi2i| Hsi2i]. {
  rewrite Hsi2i.
  destruct (Nat.eq_dec (σ i) (i + d)) as [Hsiid| Hsiid]. {
    destruct (Nat.eq_dec i (i + d)) as [H| H]; [ flia Hdz H | clear H ].
    rewrite Nat.add_0_l, Nat.add_comm; f_equal.
    apply nb_good_loop_comp_transp with (n := n); [ easy | | | easy ]. {
      flia Hnit.
    }
    flia Hsiid.
  }
  destruct (Nat.eq_dec i (i + d)) as [H| H]; [ flia Hdz H | clear H ].
  rewrite <- Nat.add_assoc; cbn.
  replace (i + d + 1 + it) with (i + (d + 1) + it) in Hnit by flia.
  rewrite <- Hssi in Hsi2i at 2.
  apply Nat.neq_sym in Hsiid.
  apply Hp in Hsi2i; [ easy | flia Hnit | ].
  now apply Hp.
}
destruct (Nat.eq_dec (σ (i + d)) (σ i)) as [Hsidsi| Hsidsi]. {
  apply Hp in Hsidsi; [ | flia Hnit | easy ].
  flia Hdz Hsidsi.
}
rewrite <- (Nat.add_assoc (if Nat.eq_dec _ _ then _ else _)).
f_equal.
rewrite <- Nat.add_assoc.
replace (i + d + 1 + it) with (i + (d + 1) + it) in Hnit by flia.
apply IHit; try easy; [ flia | ].
intros k Hk.
destruct (Nat.eq_dec k d) as [Hkd| Hkd]; [ now subst k | ].
apply Hsii.
flia Hk Hkd.
Qed.

Theorem nb_good_loop_comp_transp_eq : ∀ it n σ i k,
  is_permut_fun σ n
  → first_non_fixpoint n 0 σ = Some i
  → k ≤ i
  → n = k + it
  → nb_good_loop it k (comp (transposition i (σ i)) σ) =
    nb_good_loop it k σ + 1 + Nat.b2n (σ (σ i) =? i).
Proof.
intros * Hp Hi Hki Hnit.
apply first_non_fixpoint_Some_iff in Hi.
rewrite Nat.sub_0_r in Hi.
destruct Hi as (_ & Hin & Hi & Hsii).
revert i k Hin Hi Hsii Hki Hnit.
induction it; intros; cbn. {
  flia Hin Hki Hnit.
}
replace (k + S it) with (k + 1 + it) in Hnit by flia.
unfold comp at 1, transposition at 1, Nat.b2n.
do 5 rewrite if_eqb_eq_dec.
destruct (Nat.eq_dec (σ k) i) as [Hski| Hski]. {
  destruct (Nat.eq_dec k i) as [Heki| Heki]; [ congruence | ].
  assert (H : 0 ≤ k < i) by flia Hki Heki.
  specialize (Hi _ H); clear H.
  congruence.
}
destruct (Nat.eq_dec (σ k) (σ i)) as [Hsksi| Hsksi]. {
  apply Hp in Hsksi; [ | flia Hnit | easy ].
  move Hsksi at top; subst k.
  rewrite <- if_eqb_eq_dec, Nat.eqb_refl.
  clear Hski Hki.
  destruct (Nat.eq_dec (σ i) i) as [H| H]; [ easy | clear H ].
  rewrite Nat.add_0_l.
  destruct (Nat.eq_dec (σ (σ i)) i) as [Hssii| Hssii]. {
    rewrite Nat.add_comm; f_equal.
    apply nb_good_loop_comp_transp' with (n := n); try easy. {
      intros k Hk.
      apply Hi.
      split; [ flia | easy ].
    }
    intros k Hk.
    destruct k; [ | flia Hk ].
    now rewrite Nat.add_0_r.
  }
  rewrite Nat.add_comm, Nat.add_0_r; f_equal.
  destruct (Nat.eq_dec (σ (σ i)) (σ i)) as [Hssisi| Hssisi]. {
    apply Hp in Hssisi; [ easy | | easy ].
    now apply Hp.
  }
  apply nb_good_loop_comp_transp2 with (n := n); try easy.
  intros k Hk.
  apply Hi; flia Hk.
}
do 2 rewrite <- Nat.add_assoc.
f_equal.
destruct (Nat.eq_dec k i) as [Hk1i| Hk1i]. {
  now move Hk1i at top; subst k.
}
rewrite IHit; try easy; [ | flia Hki Hk1i ].
unfold Nat.b2n.
rewrite if_eqb_eq_dec.
symmetry.
apply Nat.add_assoc.
Qed.

Theorem first_non_fixpoint_enough_iter : ∀ n m σ i j,
  n ≤ m
  → first_non_fixpoint n i σ = Some j
  → first_non_fixpoint m i σ = Some j.
Proof.
intros * Hnm Hij.
revert i j n σ Hnm Hij.
induction m; intros; cbn. {
  now apply Nat.le_0_r in Hnm; subst n.
}
rewrite if_eqb_eq_dec.
destruct (Nat.eq_dec i (σ i)) as [Hii| Hii]. {
  destruct n; [ easy | ].
  cbn in Hij.
  rewrite <- Hii, Nat.eqb_refl in Hij.
  apply Nat.succ_le_mono in Hnm.
  now apply IHm with (n := n).
}
apply first_non_fixpoint_Some_iff in Hij.
destruct Hij as (Hij & Hjin & Hikj & Hjj).
destruct (Nat.eq_dec i j) as [H1| H1]; [ now subst i | ].
exfalso; apply Hii; symmetry.
apply Hikj.
split; [ flia | flia Hij H1 ].
Qed.

(* If we add a row (column) of A multiplied by a scalar k to another
   row (column) of A, then the determinant will not change. *)
(* https://math.vanderbilt.edu/sapirmv/msapir/proofdet1.html *)
(* doing it only when the first row is 0; can be generalized later *)

Definition mat_add_row_mul_scal_row n (M : matrix n n T) i1 v i2 :=
  mk_mat n n
    (λ i j,
     if Nat.eq_dec i i1 then (mat_el M i1 j + v * mat_el M i2 j)%F
     else mat_el M i j).

(* *)

Definition mat_mul_row_by_scal n k (M : matrix n n T) s :=
  mk_mat n n
    (λ i j,
     if Nat.eq_dec i k then (s * mat_el M i j)%F else mat_el M i j).

(* If we multiply a row (column) of A by a number, the determinant of
   A will be multiplied by the same number. *)
(* https://math.vanderbilt.edu/sapirmv/msapir/proofdet1.html
   point 1 *)

(* Well, since my definition of the determinant only covers the
   row 0, we can prove that only when i=0; this will able us to
   prove next theorems, swapping rows by going via row 0 *)

Theorem det_mul_row_0_by_scal :
  rngl_has_opp = true ∨ rngl_has_sous = true →
  rngl_is_comm = true →
  ∀ n (A : matrix n n T) v,
  n ≠ 0
  → determinant (mat_mul_row_by_scal 0 A v) = (v * determinant A)%F.
Proof.
intros Hom Hic * Hnz.
unfold determinant; cbn.
destruct n; [ easy | clear Hnz ].
cbn.
rewrite rngl_mul_summation_distr_l; [ | easy ].
apply rngl_summation_eq_compat.
intros j Hj.
rewrite (rngl_mul_comm Hic (minus_one_pow j)).
do 2 rewrite <- rngl_mul_assoc.
f_equal.
rewrite (rngl_mul_comm Hic (mat_el A 0 j)).
do 2 rewrite <- rngl_mul_assoc.
f_equal.
rewrite rngl_mul_comm; [ f_equal | easy ].
f_equal.
apply matrix_eq; cbn.
rename j into k; rename Hj into Hk.
intros i j Hi Hj.
destruct (Nat.eq_dec (i + 1) 0) as [H| H]; [ flia H | easy ].
Qed.

(* If the i-th row (column) in A is a sum of the i-th row (column) of
   a matrix B and the i-th row (column) of a matrix C and all other
   rows in B and C are equal to the corresponding rows in A (that is B
   and C differ from A by one row only), then det(A)=det(B)+det(C). *)
(* https://math.vanderbilt.edu/sapirmv/msapir/proofdet1.html
   point 2 *)

(* Well, since my definition of the discriminant only covers the
   row 0, we can prove that only when i=0; this will able us to
   prove the next theorem, swapping rows by going via row 0 *)

Theorem det_sum_row_row : ∀ n (A B C : matrix n n T),
  n ≠ 0
  → (∀ j, mat_el A 0 j = (mat_el B 0 j + mat_el C 0 j)%F)
  → (∀ i j, i ≠ 0 → mat_el B i j = mat_el A i j)
  → (∀ i j, i ≠ 0 → mat_el C i j = mat_el A i j)
  → determinant A = (determinant B + determinant C)%F.
Proof.
intros * Hnz Hbc Hb Hc.
unfold determinant.
destruct n; [ easy | clear Hnz ].
cbn.
assert (Hab : ∀ j, subm A 0 j = subm B 0 j). {
  intros.
  apply matrix_eq; cbn.
  intros i j' Hi Hj'.
  destruct (lt_dec j' j); symmetry; apply Hb; flia.
}
assert (Hac : ∀ j, subm A 0 j = subm C 0 j). {
  intros.
  apply matrix_eq; cbn.
  intros i j' Hi Hj'.
  destruct (lt_dec j' j); symmetry; apply Hc; flia.
}
erewrite rngl_summation_eq_compat. 2: {
  intros j Hj.
  rewrite Hbc.
  rewrite rngl_mul_add_distr_l.
  rewrite rngl_mul_add_distr_r.
  rewrite Hab at 1.
  rewrite Hac at 1.
  easy.
}
cbn.
now apply rngl_summation_add_distr.
Qed.

(* If two rows (columns) in A are equal then det(A)=0. *)
(* https://math.vanderbilt.edu/sapirmv/msapir/proofdet1.html
   point 3 *)
(* doing it only when the first row is 0; can be generalized later *)

Definition δ_lt i k := Nat.b2n (i <? k).

Theorem subm_subm_swap : ∀ n (A : matrix (S n) (S n) T) i j k l,
  subm (subm A i j) k l =
  subm (subm A (k + δ_lt i k) (l + δ_lt j l)) (i - δ_lt k i) (j - δ_lt l j).
Proof.
intros.
apply matrix_eq; cbn.
intros i' j' Hi' Hj'.
f_equal. {
  do 2 rewrite <- Nat.add_assoc; f_equal.
  rewrite Nat.add_comm.
  unfold δ_lt.
  remember (k <=? i') as a eqn:Ha.
  remember (i <=? i' + Nat.b2n a) as b eqn:Hb.
  remember (i <? k) as c eqn:Hc.
  remember (k <? i) as d eqn:Hd.
  remember (i - Nat.b2n d <=? i') as e eqn:He.
  remember (k + Nat.b2n c <=? i' + Nat.b2n e) as f eqn:Hf.
  move b before a; move c before b; move d before c; move e before d.
  move f before e.
  symmetry in Ha, Hb, Hc, Hd, He, Hf.
  destruct a, b, d, e, f; cbn; try easy; exfalso. {
    apply Nat.leb_le in Ha; apply Nat.leb_le in Hb; apply Nat.leb_le in Hd.
    apply Nat.leb_le in He; apply Nat.leb_nle in Hf.
    destruct c; [ apply Nat.ltb_lt in Hc; flia Ha Hb Hc Hd He Hf | ].
    cbn in Hf.
    apply Nat.ltb_nlt in Hc; flia Ha Hb Hc Hd He Hf.
  } {
    apply Nat.leb_le in Ha; apply Nat.leb_le in Hb; apply Nat.leb_le in Hd.
    apply Nat.leb_nle in He; apply Nat.leb_le in Hf.
    destruct c; [ apply Nat.ltb_lt in Hc; flia Ha Hb Hc Hd He Hf | ].
    apply Nat.ltb_nlt in Hc; flia Ha Hb Hc Hd He Hf.
  } {
    apply Nat.leb_le in Ha; apply Nat.leb_le in Hb; apply Nat.leb_le in Hd.
    apply Nat.leb_nle in He; apply Nat.leb_nle in Hf.
    destruct c; [ apply Nat.ltb_lt in Hc; flia Ha Hb Hc Hd He Hf | ].
    apply Nat.ltb_nlt in Hc; flia Ha Hb Hc Hd He Hf.
  } {
    apply Nat.leb_le in Ha; apply Nat.leb_le in Hb; apply Nat.leb_nle in Hd.
    apply Nat.leb_le in He; apply Nat.leb_nle in Hf.
    destruct c; [ apply Nat.ltb_lt in Hc; flia Ha Hb Hc Hd He Hf | ].
    cbn in Hf.
    apply Nat.ltb_nlt in Hc; flia Ha Hb Hc Hd He Hf.
  } {
    apply Nat.leb_le in Ha; apply Nat.leb_le in Hb; apply Nat.leb_nle in Hd.
    apply Nat.leb_nle in He; apply Nat.leb_le in Hf.
    destruct c; [ apply Nat.ltb_lt in Hc; flia Ha Hb Hc Hd He Hf | ].
    apply Nat.ltb_nlt in Hc; flia Ha Hb Hc Hd He Hf.
  } {
    apply Nat.leb_le in Ha; apply Nat.leb_le in Hb; apply Nat.leb_nle in Hd.
    apply Nat.leb_nle in He; apply Nat.leb_nle in Hf.
    destruct c; [ apply Nat.ltb_lt in Hc; flia Ha Hb Hc Hd He Hf | ].
    apply Nat.ltb_nlt in Hc; flia Ha Hb Hc Hd He Hf.
  } {
    apply Nat.leb_le in Ha; apply Nat.leb_nle in Hb; apply Nat.leb_le in Hd.
    apply Nat.leb_le in He; apply Nat.leb_le in Hf.
    destruct c; [ apply Nat.ltb_lt in Hc; flia Ha Hb Hc Hd He Hf | ].
    apply Nat.ltb_nlt in Hc; flia Ha Hb Hc Hd He Hf.
  } {
    apply Nat.leb_le in Ha; apply Nat.leb_nle in Hb; apply Nat.leb_le in Hd.
    apply Nat.leb_nle in He; apply Nat.leb_nle in Hf.
    destruct c; [ apply Nat.ltb_lt in Hc; flia Ha Hb Hc Hd He Hf | ].
    apply Nat.ltb_nlt in Hc; flia Ha Hb Hc Hd He Hf.
  } {
    apply Nat.leb_le in Ha; apply Nat.leb_nle in Hb; apply Nat.leb_nle in Hd.
    apply Nat.leb_le in He; apply Nat.leb_le in Hf.
    destruct c; [ apply Nat.ltb_lt in Hc; flia Ha Hb Hc Hd He Hf | ].
    apply Nat.ltb_nlt in Hc; flia Ha Hb Hc Hd He Hf.
  } {
    apply Nat.leb_le in Ha; apply Nat.leb_nle in Hb; apply Nat.leb_nle in Hd.
    apply Nat.leb_nle in He; apply Nat.leb_nle in Hf.
    destruct c; [ apply Nat.ltb_lt in Hc; flia Ha Hb Hc Hd He Hf | ].
    apply Nat.ltb_nlt in Hc; flia Ha Hb Hc Hd He Hf.
  } {
    apply Nat.leb_nle in Ha; apply Nat.leb_le in Hb; apply Nat.leb_le in Hd.
    apply Nat.leb_le in He; apply Nat.leb_le in Hf.
    destruct c; [ apply Nat.ltb_lt in Hc; flia Ha Hb Hc Hd He Hf | ].
    cbn in He.
    apply Nat.ltb_nlt in Hc; flia Ha Hb Hc Hd He Hf.
  } {
    apply Nat.leb_nle in Ha; apply Nat.leb_le in Hb; apply Nat.leb_le in Hd.
    apply Nat.leb_nle in He; apply Nat.leb_nle in Hf.
    destruct c; [ apply Nat.ltb_lt in Hc; flia Ha Hb Hc Hd He Hf | ].
    cbn in Hb.
    apply Nat.ltb_nlt in Hc; flia Ha Hb Hc Hd He Hf.
  } {
    apply Nat.leb_nle in Ha; apply Nat.leb_le in Hb; apply Nat.leb_nle in Hd.
    apply Nat.leb_le in He; apply Nat.leb_le in Hf.
    destruct c; [ apply Nat.ltb_lt in Hc; flia Ha Hb Hc Hd He Hf | ].
    cbn in Hb.
    apply Nat.ltb_nlt in Hc; flia Ha Hb Hc Hd He Hf.
  } {
    apply Nat.leb_nle in Ha; apply Nat.leb_le in Hb; apply Nat.leb_nle in Hd.
    apply Nat.leb_nle in He; apply Nat.leb_nle in Hf.
    destruct c; [ apply Nat.ltb_lt in Hc; flia Ha Hb Hc Hd He Hf | ].
    apply Nat.ltb_nlt in Hc; flia Ha Hb Hc Hd He Hf.
  } {
    apply Nat.leb_nle in Ha; apply Nat.leb_nle in Hb; apply Nat.leb_le in Hd.
    apply Nat.leb_le in He; apply Nat.leb_le in Hf.
    destruct c; [ apply Nat.ltb_lt in Hc; flia Ha Hb Hc Hd He Hf | ].
    cbn in He.
    apply Nat.ltb_nlt in Hc; flia Ha Hb Hc Hd He Hf.
  } {
    apply Nat.leb_nle in Ha; apply Nat.leb_nle in Hb; apply Nat.leb_le in Hd.
    apply Nat.leb_le in He; apply Nat.leb_nle in Hf.
    destruct c; [ apply Nat.ltb_lt in Hc; flia Ha Hb Hc Hd He Hf | ].
    cbn in He.
    apply Nat.ltb_nlt in Hc; flia Ha Hb Hc Hd He Hf.
  } {
    apply Nat.leb_nle in Ha; apply Nat.leb_nle in Hb; apply Nat.leb_le in Hd.
    apply Nat.leb_nle in He; apply Nat.leb_le in Hf.
    destruct c; [ apply Nat.ltb_lt in Hc; flia Ha Hb Hc Hd He Hf | ].
    apply Nat.ltb_nlt in Hc; flia Ha Hb Hc Hd He Hf.
  } {
    apply Nat.leb_nle in Ha; apply Nat.leb_nle in Hb; apply Nat.leb_nle in Hd.
    apply Nat.leb_le in He; apply Nat.leb_le in Hf.
    destruct c; [ apply Nat.ltb_lt in Hc; flia Ha Hb Hc Hd He Hf | ].
    apply Nat.ltb_nlt in Hc; flia Ha Hb Hc Hd He Hf.
  } {
    apply Nat.leb_nle in Ha; apply Nat.leb_nle in Hb; apply Nat.leb_nle in Hd.
    apply Nat.leb_le in He; apply Nat.leb_nle in Hf.
    destruct c; [ apply Nat.ltb_lt in Hc; flia Ha Hb Hc Hd He Hf | ].
    apply Nat.ltb_nlt in Hc; flia Ha Hb Hc Hd He Hf.
  } {
    apply Nat.leb_nle in Ha; apply Nat.leb_nle in Hb; apply Nat.leb_nle in Hd.
    apply Nat.leb_nle in He; apply Nat.leb_le in Hf.
    destruct c; [ apply Nat.ltb_lt in Hc; flia Ha Hb Hc Hd He Hf | ].
    apply Nat.ltb_nlt in Hc; flia Ha Hb Hc Hd He Hf.
  }
} {
  do 2 rewrite <- Nat.add_assoc; f_equal.
  rewrite Nat.add_comm.
  unfold δ_lt.
  remember (l <=? j') as a eqn:Ha.
  remember (j <=? j' + Nat.b2n a) as b eqn:Hb.
  remember (j <? l) as c eqn:Hc.
  remember (l <? j) as d eqn:Hd.
  remember (j - Nat.b2n d <=? j') as e eqn:He.
  remember (l + Nat.b2n c <=? j' + Nat.b2n e) as f eqn:Hf.
  move b before a; move c before b; move d before c; move e before d.
  move f before e.
  symmetry in Ha, Hb, Hc, Hd, He, Hf.
  destruct a, b, d, e, f; cbn; try easy; exfalso. {
    apply Nat.leb_le in Ha; apply Nat.leb_le in Hb; apply Nat.leb_le in Hd.
    apply Nat.leb_le in He; apply Nat.leb_nle in Hf.
    destruct c; [ apply Nat.ltb_lt in Hc; flia Ha Hb Hc Hd He Hf | ].
    cbn in He, Hf.
    apply Nat.ltb_nlt in Hc; flia Ha Hb Hc Hd He Hf.
  } {
    apply Nat.leb_le in Ha; apply Nat.leb_le in Hb; apply Nat.leb_le in Hd.
    apply Nat.leb_nle in He; apply Nat.leb_le in Hf.
    destruct c; [ apply Nat.ltb_lt in Hc; flia Ha Hb Hc Hd He Hf | ].
    apply Nat.ltb_nlt in Hc; flia Ha Hb Hc Hd He Hf.
  } {
    apply Nat.leb_le in Ha; apply Nat.leb_le in Hb; apply Nat.leb_le in Hd.
    apply Nat.leb_nle in He; apply Nat.leb_nle in Hf.
    destruct c; [ apply Nat.ltb_lt in Hc; flia Ha Hb Hc Hd He Hf | ].
    apply Nat.ltb_nlt in Hc; flia Ha Hb Hc Hd He Hf.
  } {
    apply Nat.leb_le in Ha; apply Nat.leb_le in Hb; apply Nat.leb_nle in Hd.
    apply Nat.leb_le in He; apply Nat.leb_nle in Hf.
    destruct c; [ apply Nat.ltb_lt in Hc; flia Ha Hb Hc Hd He Hf | ].
    cbn in Hf.
    apply Nat.ltb_nlt in Hc; flia Ha Hb Hc Hd He Hf.
  } {
    apply Nat.leb_le in Ha; apply Nat.leb_le in Hb; apply Nat.leb_nle in Hd.
    apply Nat.leb_nle in He; apply Nat.leb_le in Hf.
    destruct c; [ apply Nat.ltb_lt in Hc; flia Ha Hb Hc Hd He Hf | ].
    apply Nat.ltb_nlt in Hc; flia Ha Hb Hc Hd He Hf.
  } {
    apply Nat.leb_le in Ha; apply Nat.leb_le in Hb; apply Nat.leb_nle in Hd.
    apply Nat.leb_nle in He; apply Nat.leb_nle in Hf.
    destruct c; [ apply Nat.ltb_lt in Hc; flia Ha Hb Hc Hd He Hf | ].
    apply Nat.ltb_nlt in Hc; flia Ha Hb Hc Hd He Hf.
  } {
    apply Nat.leb_le in Ha; apply Nat.leb_nle in Hb; apply Nat.leb_le in Hd.
    apply Nat.leb_le in He; apply Nat.leb_le in Hf.
    destruct c; [ apply Nat.ltb_lt in Hc; flia Ha Hb Hc Hd He Hf | ].
    apply Nat.ltb_nlt in Hc; flia Ha Hb Hc Hd He Hf.
  } {
    apply Nat.leb_le in Ha; apply Nat.leb_nle in Hb; apply Nat.leb_le in Hd.
    apply Nat.leb_nle in He; apply Nat.leb_nle in Hf.
    destruct c; [ apply Nat.ltb_lt in Hc; flia Ha Hb Hc Hd He Hf | ].
    apply Nat.ltb_nlt in Hc; cbn in Hc; flia Ha Hb Hc Hd He Hf.
  } {
    apply Nat.leb_le in Ha; apply Nat.leb_nle in Hb; apply Nat.leb_nle in Hd.
    apply Nat.leb_le in He; apply Nat.leb_le in Hf.
    destruct c; [ apply Nat.ltb_lt in Hc; flia Ha Hb Hc Hd He Hf | ].
    apply Nat.ltb_nlt in Hc; flia Ha Hb Hc Hd He Hf.
  } {
    apply Nat.leb_le in Ha; apply Nat.leb_nle in Hb; apply Nat.leb_nle in Hd.
    apply Nat.leb_nle in He; apply Nat.leb_nle in Hf.
    destruct c; [ apply Nat.ltb_lt in Hc; flia Ha Hb Hc Hd He Hf | ].
    apply Nat.ltb_nlt in Hc; flia Ha Hb Hc Hd He Hf.
  } {
    apply Nat.leb_nle in Ha; apply Nat.leb_le in Hb; apply Nat.leb_le in Hd.
    apply Nat.leb_le in He; apply Nat.leb_le in Hf.
    destruct c; [ apply Nat.ltb_lt in Hc; flia Ha Hb Hc Hd He Hf | ].
    cbn in He.
    apply Nat.ltb_nlt in Hc; flia Ha Hb Hc Hd He Hf.
  } {
    apply Nat.leb_nle in Ha; apply Nat.leb_le in Hb; apply Nat.leb_le in Hd.
    apply Nat.leb_nle in He; apply Nat.leb_nle in Hf.
    destruct c; [ apply Nat.ltb_lt in Hc; flia Ha Hb Hc Hd He Hf | ].
    cbn in Hb.
    apply Nat.ltb_nlt in Hc; flia Ha Hb Hc Hd He Hf.
  } {
    apply Nat.leb_nle in Ha; apply Nat.leb_le in Hb; apply Nat.leb_nle in Hd.
    apply Nat.leb_le in He; apply Nat.leb_le in Hf.
    destruct c; [ apply Nat.ltb_lt in Hc; flia Ha Hb Hc Hd He Hf | ].
    cbn in Hb.
    apply Nat.ltb_nlt in Hc; flia Ha Hb Hc Hd He Hf.
  } {
    apply Nat.leb_nle in Ha; apply Nat.leb_le in Hb; apply Nat.leb_nle in Hd.
    apply Nat.leb_nle in He; apply Nat.leb_nle in Hf.
    destruct c; [ apply Nat.ltb_lt in Hc; flia Ha Hb Hc Hd He Hf | ].
    apply Nat.ltb_nlt in Hc; flia Ha Hb Hc Hd He Hf.
  } {
    apply Nat.leb_nle in Ha; apply Nat.leb_nle in Hb; apply Nat.leb_le in Hd.
    apply Nat.leb_le in He; apply Nat.leb_le in Hf.
    destruct c; [ apply Nat.ltb_lt in Hc; flia Ha Hb Hc Hd He Hf | ].
    cbn in He.
    apply Nat.ltb_nlt in Hc; flia Ha Hb Hc Hd He Hf.
  } {
    apply Nat.leb_nle in Ha; apply Nat.leb_nle in Hb; apply Nat.leb_le in Hd.
    apply Nat.leb_le in He; apply Nat.leb_nle in Hf.
    destruct c; [ apply Nat.ltb_lt in Hc; flia Ha Hb Hc Hd He Hf | ].
    cbn in He.
    apply Nat.ltb_nlt in Hc; flia Ha Hb Hc Hd He Hf.
  } {
    apply Nat.leb_nle in Ha; apply Nat.leb_nle in Hb; apply Nat.leb_le in Hd.
    apply Nat.leb_nle in He; apply Nat.leb_le in Hf.
    destruct c; [ apply Nat.ltb_lt in Hc; flia Ha Hb Hc Hd He Hf | ].
    apply Nat.ltb_nlt in Hc; flia Ha Hb Hc Hd He Hf.
  } {
    apply Nat.leb_nle in Ha; apply Nat.leb_nle in Hb; apply Nat.leb_nle in Hd.
    apply Nat.leb_le in He; apply Nat.leb_le in Hf.
    destruct c; [ apply Nat.ltb_lt in Hc; flia Ha Hb Hc Hd He Hf | ].
    apply Nat.ltb_nlt in Hc; flia Ha Hb Hc Hd He Hf.
  } {
    apply Nat.leb_nle in Ha; apply Nat.leb_nle in Hb; apply Nat.leb_nle in Hd.
    apply Nat.leb_le in He; apply Nat.leb_nle in Hf.
    destruct c; [ apply Nat.ltb_lt in Hc; flia Ha Hb Hc Hd He Hf | ].
    apply Nat.ltb_nlt in Hc; flia Ha Hb Hc Hd He Hf.
  } {
    apply Nat.leb_nle in Ha; apply Nat.leb_nle in Hb; apply Nat.leb_nle in Hd.
    apply Nat.leb_nle in He; apply Nat.leb_le in Hf.
    destruct c; [ apply Nat.ltb_lt in Hc; flia Ha Hb Hc Hd He Hf | ].
    apply Nat.ltb_nlt in Hc; flia Ha Hb Hc Hd He Hf.
  }
}
Qed.

Definition swap_in_permut n i j k := vect_swap_elem (canon_permut n k) i j.

(* comatrix *)

Definition comatrix {n} (M : matrix n n T) : matrix n n T :=
  {| mat_el i j := (minus_one_pow (i + j) * determinant (subm M i j))%F |}.

Theorem mat_swap_same_rows : ∀ n (M : matrix n n T) i,
  mat_swap_rows i i M = M.
Proof.
intros.
rename i into k.
apply matrix_eq.
intros i j Hi Hj.
unfold mat_swap_rows; cbn.
destruct (Nat.eq_dec i k); [ now subst i | easy ].
Qed.

Theorem mat_swap_rows_comm : ∀ n (M : matrix n n T) p q,
  mat_swap_rows p q M = mat_swap_rows q p M.
Proof.
intros.
apply matrix_eq.
intros i j Hi Hj; cbn.
now destruct (Nat.eq_dec i p), (Nat.eq_dec i q); subst.
Qed.

Theorem subm_mat_swap_rows_lt : ∀ n (M : matrix n n T) p q r j,
  p < r
  → q < r
  → subm (mat_swap_rows p q M) r j = mat_swap_rows p q (subm M r j).
Proof.
intros * Hp Hq.
apply matrix_eq.
rename j into k.
intros i j Hi Hj; cbn.
destruct (Nat.eq_dec (i + Nat.b2n (r <=? i)) p) as [H1| H1]. {
  remember (r <=? i) as b eqn:Hb1; symmetry in Hb1.
  destruct b; cbn in H1. {
    apply Nat.leb_le in Hb1.
    flia Hp Hb1 H1.
  }
  apply Nat.leb_nle in Hb1.
  rewrite Nat.add_0_r in H1; subst i; clear Hb1.
  rewrite <- if_eqb_eq_dec, Nat.eqb_refl.
  remember (r <=? q) as b eqn:Hb1; symmetry in Hb1.
  destruct b; cbn. {
    apply Nat.leb_le in Hb1; flia Hq Hb1.
  }
  now rewrite Nat.add_0_r.
}
destruct (Nat.eq_dec (i + Nat.b2n (r <=? i)) q) as [H2| H2]. {
  remember (r <=? i) as b eqn:Hb1; symmetry in Hb1.
  destruct b; cbn in H2. {
    apply Nat.leb_le in Hb1.
    flia Hq Hb1 H2.
  }
  cbn in H1; rewrite Nat.add_0_r in H1, H2.
  subst i; clear Hb1.
  rewrite <- (if_eqb_eq_dec q q), Nat.eqb_refl.
  destruct (Nat.eq_dec q p) as [H| H]; [ easy | clear H ].
  remember (r <=? p) as b eqn:Hb1; symmetry in Hb1.
  destruct b; [ | now rewrite Nat.add_0_r ].
  apply Nat.leb_le in Hb1.
  flia Hp Hb1.
}
destruct (Nat.eq_dec i p) as [H3| H3]. {
  subst i.
  apply Nat.nle_gt, Nat.leb_nle in Hp.
  rewrite Hp in H1; cbn in H1.
  now rewrite Nat.add_0_r in H1.
}
destruct (Nat.eq_dec i q) as [H4| H4]. {
  subst i.
  apply Nat.nle_gt, Nat.leb_nle in Hq.
  rewrite Hq in H2; cbn in H2.
  now rewrite Nat.add_0_r in H2.
}
easy.
Qed.

Theorem mat_el_mat_swap_rows : ∀ n (M : matrix n n T) p q j,
  mat_el (mat_swap_rows p q M) q j = mat_el M p j.
Proof.
intros.
cbn.
destruct (Nat.eq_dec q p) as [Hqp| Hqp]; [ now subst q | ].
now rewrite <- if_eqb_eq_dec, Nat.eqb_refl.
Qed.

Theorem mat_el_circ_rot_rows_succ_1 : ∀ n (M : matrix n n T) i j p q,
  p + q < i
  → mat_el M i j =
    mat_el (fold_left (λ M' k, mat_swap_rows k (k + 1) M') (seq p q) M)
      i j.
Proof.
intros * Hpi.
induction q; [ easy | ].
rewrite seq_S; cbn.
rewrite fold_left_app; cbn.
destruct (Nat.eq_dec i (p + q)) as [Hip| Hip]; [ flia Hpi Hip | ].
destruct (Nat.eq_dec i (p + q + 1)) as [Hip1| Hip1]; [ flia Hpi Hip1 | ].
apply IHq.
flia Hpi Hip.
Qed.

Theorem mat_el_circ_rot_rows : ∀ n (M : matrix n n T) i j,
  mat_el M 0 j =
    mat_el (fold_left (λ M' k, mat_swap_rows k (k + 1) M') (seq 0 i) M) i j.
Proof.
intros.
induction i; [ easy | ].
rewrite seq_S.
rewrite fold_left_app.
cbn - [ mat_swap_rows ].
rewrite Nat.add_1_r.
rewrite mat_el_mat_swap_rows.
apply IHi.
Qed.

Theorem mat_el_circ_rot_rows_outside : ∀ n (M : matrix n n T) i j p q,
  i < p
  → mat_el M i j =
    mat_el (fold_left (λ M' k, mat_swap_rows k (k + 1) M')
      (seq p q) M) i j.
Proof.
intros * Hip.
induction q; [ easy | ].
rewrite seq_S; cbn.
rewrite fold_left_app; cbn.
destruct (Nat.eq_dec i (p + q)) as [Hipq| Hipq]; [ flia Hip Hipq | ].
destruct (Nat.eq_dec i (p + q + 1)) as [Hip1| Hip1]; [ flia Hip Hip1 | ].
apply IHq.
Qed.

Theorem mat_el_circ_rot_rows_succ : ∀ n (M : matrix n n T) i j p,
  i + 1 ≠ p
  → mat_el M (i + 1) j =
    mat_el
      (fold_left (λ (M' : matrix n n T) (k : nat), mat_swap_rows k (k + 1) M')
         (seq 0 (p - 1)) M) (i + Nat.b2n (p <=? i)) j.
Proof.
intros * Hi1p.
destruct (le_dec p i) as [Hpi| Hpi]. {
  apply Nat.leb_le in Hpi; rewrite Hpi.
  apply mat_el_circ_rot_rows_succ_1.
  apply Nat.leb_le in Hpi; cbn; flia Hpi.
}
apply Nat.leb_nle in Hpi; rewrite Hpi; cbn.
rewrite Nat.add_0_r.
apply Nat.leb_nle in Hpi.
apply Nat.nle_gt in Hpi.
replace (p - 1) with (i + (p - i - 1)) by flia Hpi.
rewrite seq_app, fold_left_app; cbn.
rewrite mat_el_circ_rot_rows_succ_1 with (p := 0) (q := i); [ | flia ].
remember (fold_left (λ M' k, mat_swap_rows k (k + 1) M') (seq 0 i) M)
  as A eqn:HA.
replace (p - i - 1) with (S (p - i - 2)) by flia Hi1p Hpi.
rewrite <- cons_seq; cbn.
rewrite <- mat_el_mat_swap_rows with (q := i).
rewrite mat_swap_rows_comm.
remember (mat_swap_rows i (i + 1) A) as B eqn:HB.
apply mat_el_circ_rot_rows_outside; flia.
Qed.

Theorem subm_mat_swap_rows_succ_succ : ∀ n (M : matrix n n T) i j,
  subm (mat_swap_rows (i + 1) (i + 2) (mat_swap_rows i (i + 1) M)) (S i) j =
  subm (mat_swap_rows i (i + 1) M) (S (S i)) j.
Proof.
intros.
apply matrix_eq.
rename i into p; rename j into q.
intros i j Hi Hj.
cbn - [ "<=?" ].
destruct (Nat.eq_dec (p + 2) p) as [H| H]; [ flia H | clear H ].
destruct (Nat.eq_dec (p + 2) (p + 1)) as [H| H]; [ flia H | clear H ].
destruct (Nat.eq_dec (p + 1) (p + 1)) as [H| H]; [ clear H | easy ].
destruct (Nat.eq_dec (p + 1) p) as [H| H]; [ flia H | clear H ].
destruct (le_dec (S p) i) as [Hspi| Hspi]. {
  apply Nat.leb_le in Hspi; rewrite Hspi; cbn - [ "<=?" ].
  apply Nat.leb_le in Hspi.
  destruct (Nat.eq_dec (i + 1) (p + 1)) as [Hip| Hip]; [ flia Hspi Hip | ].
  destruct (Nat.eq_dec (i + 1) (p + 2)) as [Hip2| Hip2]. {
    destruct (le_dec (S (S p)) i) as [Hsspi| Hsspi]; [ flia Hsspi Hip2 | ].
    apply Nat.leb_nle in Hsspi; rewrite Hsspi; cbn.
    rewrite Nat.add_0_r.
    destruct (Nat.eq_dec i p) as [H| H]; [ flia H Hip2 | clear H ].
    destruct (Nat.eq_dec i (p + 1)) as [H| H]; [ clear H | flia Hip2 H ].
    easy.
  }
  destruct (Nat.eq_dec (i + 1) p) as [H| H]; [ flia Hspi H | clear H ].
  destruct (le_dec (S (S p)) i) as [Hsspi| Hsspi]. {
    apply Nat.leb_le in Hsspi; rewrite Hsspi; cbn.
    apply Nat.leb_le in Hsspi.
    destruct (Nat.eq_dec (i + 1) p) as [H| H]; [ flia H Hsspi | clear H ].
    destruct (Nat.eq_dec (i + 1) (p + 1)) as [H| H]; [ flia H Hspi | easy ].
  }
  flia Hspi Hip2 Hsspi.
}
apply Nat.leb_nle in Hspi; rewrite Hspi; cbn - [ "<=?" ].
apply Nat.leb_nle in Hspi.
rewrite Nat.add_0_r.
destruct (Nat.eq_dec i (p + 1)) as [H| H]; [ flia H Hspi | clear H ].
destruct (Nat.eq_dec i (p + 2)) as [H| H]; [ flia H Hspi | clear H ].
destruct (Nat.eq_dec i p) as [Hip| Hip]. {
  subst p.
  destruct (le_dec (S (S i)) i) as [Hssi| Hssi]; [ flia Hssi | ].
  apply Nat.leb_nle in Hssi; rewrite Hssi; cbn.
  rewrite Nat.add_0_r.
  now rewrite <- if_eqb_eq_dec, Nat.eqb_refl.
}
destruct (le_dec (S (S p)) i) as [Hsspi| Hsspi]; [ flia Hspi Hsspi | ].
apply Nat.leb_nle in Hsspi; rewrite Hsspi; cbn.
apply Nat.leb_nle in Hsspi.
rewrite Nat.add_0_r.
destruct (Nat.eq_dec i p) as [H| H]; [ flia H Hip | clear H ].
destruct (Nat.eq_dec i (p + 1)) as [H| H]; [ flia H Hspi | easy ].
Qed.

Theorem subm_mat_swap_rows_circ : ∀ n (M : matrix n n T) p q,
  subm (mat_swap_rows 0 p M) 0 q =
  subm (fold_left (λ M' k, mat_swap_rows k (k + 1) M') (seq 0 (p - 1)) M) p q.
Proof.
intros.
apply matrix_eq.
intros i j Hi Hj.
cbn.
destruct (Nat.eq_dec (i + 1) 0) as [H| H]; [ flia H | clear H ].
remember (j + Nat.b2n (q <=? j)) as k eqn:Hk.
assert (H : k < n). {
  destruct (le_dec q j) as [Hqj| Hqj]. {
    apply Nat.leb_le in Hqj; rewrite Hqj in Hk.
    cbn in Hk.
    flia Hj Hk.
  } {
    apply Nat.leb_nle in Hqj; rewrite Hqj in Hk.
    cbn in Hk.
    flia Hj Hk.
  }
}
clear q j Hj Hk.
rename k into j; move j before i.
rename H into Hj.
destruct (Nat.eq_dec (i + 1) p) as [Hip| Hip]. {
  subst p.
  rewrite Nat.add_sub.
  assert (H : ¬ (i + 1 ≤ i)) by flia.
  apply Nat.leb_nle in H; rewrite H; clear H; cbn.
  rewrite Nat.add_0_r.
  apply mat_el_circ_rot_rows.
} {
  now apply mat_el_circ_rot_rows_succ.
}
Qed.

Theorem mat_swap_rows_fold_left : ∀ n (M : matrix n n T) i,
  mat_swap_rows i (S i)
    (fold_left (λ M' k, mat_swap_rows k (k + 1) M') (seq 0 i) M) =
   fold_left (λ M' k, mat_swap_rows k (k + 1) M') (seq 0 (S i)) M.
Proof.
intros.
rewrite seq_S; cbn.
rewrite fold_left_app; cbn.
now rewrite Nat.add_1_r.
Qed.

Theorem subm_fold_left_lt : ∀ n (M : matrix n n T) i j m,
  m < i
  → subm
      (fold_left (λ M' k, mat_swap_rows k (k + 1) M')
         (seq 0 m) M) i j =
    fold_left
      (λ M' k, mat_swap_rows k (k + 1) M')
      (seq 0 m) (subm M i j).
Proof.
intros * Hmi.
revert i Hmi.
induction m; intros; [ easy | ].
rewrite seq_S; cbn.
do 2 rewrite fold_left_app; cbn.
rewrite <- IHm; [ | flia Hmi ].
apply subm_mat_swap_rows_lt; flia Hmi.
Qed.

Theorem determinant_circular_shift_rows :
  rngl_is_comm = true →
  rngl_has_opp = true →
  rngl_has_inv = true →
  rngl_is_integral = true →
  rngl_has_1_neq_0 = true →
  rngl_has_dec_eq = true →
  rngl_characteristic = 0 →
  ∀ n (M : matrix n n T) i,
  i < n
  → determinant (fold_left (λ M' k, mat_swap_rows k (k + 1) M') (seq 0 i) M) =
    (minus_one_pow i * determinant M)%F.
Proof.
intros Hic Hop Hiv Hit H10 Hde Hch * Hin.
revert M.
induction i; intros; [ now cbn; rewrite rngl_mul_1_l | ].
assert (H : i < n) by flia Hin.
specialize (IHi H); clear H.
rewrite seq_S; cbn.
rewrite fold_left_app; cbn.
rewrite determinant_alternating; try easy; [ | flia | flia Hin | flia Hin ].
rewrite IHi.
rewrite minus_one_pow_succ; [ | easy ].
now rewrite rngl_mul_opp_l.
Qed.

Theorem determinant_subm_mat_swap_rows_0_i :
  rngl_is_comm = true →
  rngl_has_opp = true →
  rngl_has_inv = true →
  rngl_is_integral = true →
  rngl_has_1_neq_0 = true →
  rngl_has_dec_eq = true →
  rngl_characteristic = 0 →
  ∀ n (M : matrix n n T) i j,
  0 < i < n
  → determinant (subm (mat_swap_rows 0 i M) 0 j) =
    (- minus_one_pow i * determinant (subm M i j))%F.
Proof.
intros Hic Hop Hiv Hit H10 Hde Hch * (Hiz, Hin).
rewrite subm_mat_swap_rows_circ.
destruct i; [ flia Hiz | ].
rewrite minus_one_pow_succ; [ | easy ].
rewrite rngl_opp_involutive; [ | easy ].
rewrite Nat.sub_succ, Nat.sub_0_r.
rewrite subm_fold_left_lt; [ | flia ].
remember (subm M (S i) j) as A eqn:HA.
apply determinant_circular_shift_rows; try easy.
flia Hin.
Qed.

(* Laplace formulas *)

Theorem laplace_formula_on_rows :
  rngl_is_comm = true →
  rngl_has_opp = true →
  rngl_has_inv = true →
  rngl_is_integral = true →
  rngl_has_1_neq_0 = true →
  rngl_has_dec_eq = true →
  rngl_characteristic = 0 →
  ∀ n (M : matrix n n T) i,
  i < n
  → determinant M = Σ (j = 0, n - 1), mat_el M i j * mat_el (comatrix M) i j.
Proof.
intros Hic Hop Hin Hit H10 Hde Hch * Hlin.
destruct (Nat.eq_dec i 0) as [Hiz| Hiz]. {
  subst i.
  destruct n; [ easy | cbn ].
  rewrite Nat.sub_0_r at 1.
  symmetry.
  apply rngl_summation_eq_compat.
  intros j Hj.
  rewrite rngl_mul_comm; [ | easy ].
  now rewrite rngl_mul_mul_swap.
}
move i before n.
move Hiz after Hlin.
destruct n; [ easy | cbn ].
rewrite Nat.sub_0_r at 1.
symmetry.
erewrite rngl_summation_eq_compat. 2: {
  intros j Hj.
  rewrite rngl_mul_comm; [ | easy ].
  rewrite rngl_mul_mul_swap; [ | easy ].
  easy.
}
cbn.
rename i into p.
remember (mat_swap_rows 0 p M) as M'.
erewrite rngl_summation_eq_compat. 2: {
  intros j Hj.
  rewrite rngl_mul_mul_swap; [ | easy ].
  rewrite Nat.add_comm.
  rewrite minus_one_pow_add_r; [ | easy | easy ].
  do 2 rewrite <- rngl_mul_assoc.
  rewrite rngl_mul_comm; [ | easy ].
  rewrite rngl_mul_assoc.
  remember (minus_one_pow p * _)%F as x eqn:Hx.
  rewrite <- rngl_opp_involutive in Hx; [ | easy ].
  rewrite <- rngl_mul_opp_l in Hx; [ | easy ].
  specialize determinant_subm_mat_swap_rows_0_i as H1.
  specialize (H1 Hic Hop Hin Hit H10 Hde Hch).
  specialize (H1 _ M p j).
  cbn in H1.
  rewrite <- H1 in Hx; [ | flia Hiz Hlin ].
  subst x; clear H1.
  rewrite rngl_mul_comm; [ | easy ].
  rewrite rngl_mul_assoc, rngl_mul_mul_swap; [ | easy ].
  replace (mat_el M p j) with (mat_el (mat_swap_rows 0 p M) 0 j) by easy.
  rewrite <- HeqM'.
  rewrite rngl_mul_opp_r; [ | easy ].
  easy.
}
cbn.
rewrite <- rngl_opp_summation; [ | easy | easy ].
do 2 rewrite <- determinant_succ.
subst M'.
rewrite <- rngl_opp_involutive; [ | easy ].
f_equal.
apply determinant_alternating; try easy; [ flia Hiz | flia ].
Qed.

Theorem permut_comp_assoc : ∀ n (f g h : vector n nat),
  (f ° (g ° h) = (f ° g) ° h)%F.
Proof. easy. Qed.

Theorem comp_permut_inv_r : ∀ n f,
  is_permut f
  → (f ° permut_inv f = mk_vect n id).
Proof.
intros * Hf.
apply vector_eq; cbn.
intros i Hi.
unfold comp.
now apply fun_permut_fun_inv.
Qed.

Theorem comp_id_l : ∀ A B (f : A → B), comp id f = f.
Proof. easy. Qed.

Definition sym_gr (n : nat) :=
  map (λ v, canon_permut n v) (seq 0 n!).

Theorem det_any_permut :
  rngl_has_opp = true →
  rngl_has_inv = true →
  rngl_is_comm = true →
  rngl_has_dec_eq = true →
  rngl_has_1_neq_0 = true →
  rngl_is_integral = true →
  rngl_characteristic = 0 →
  ∀ n (M : matrix n n T) (σ : vector n nat),
  n ≠ 0
  → is_permut σ
  → determinant M =
    (Σ (μ ∈ sym_gr n), ε μ * ε σ *
     Π (k = 0, n - 1), mat_el M (vect_el σ k) (vect_el μ k))%F.
Proof.
intros Hop Hiv Hic Hde H10 Hit Hch * Hnz Hσ.
unfold is_permut in Hσ.
destruct Hσ as (Hσ_lt, Hσ_inj).
erewrite rngl_summation_list_eq_compat. 2: {
  intros μ Hμ.
  remember (permut_inv σ ° μ) as ν eqn:Hν.
  assert (Hσν : σ ° ν = μ). {
    rewrite Hν.
    rewrite permut_comp_assoc.
    apply vector_eq.
    intros i Hi; cbn.
    unfold comp.
    rewrite fun_permut_fun_inv; [ easy | easy | ].
    unfold sym_gr in Hμ.
    apply in_map_iff in Hμ.
    destruct Hμ as (j & Hj & Hjs).
    rewrite <- Hj.
    apply vect_el_canon_permut_ub; [ | easy ].
    now apply in_seq in Hjs.
  }
  subst ν.
  rewrite <- Hσν at 1.
  assert (Hpμ : is_permut μ). {
    unfold sym_gr in Hμ.
    apply in_map_iff in Hμ.
    destruct Hμ as (i & Hi & His).
    rewrite <- Hi.
    apply in_seq in His.
    now apply canon_permut_is_permut.
  }
  rewrite signature_comp;
    [ | easy | easy | easy | easy | easy | easy | easy | easy | ]. 2: {
    apply is_permut_comp; [ now apply permut_inv_is_permut | easy ].
  }
(*
  rewrite signature_comp;
    [ | easy | easy | easy | easy | easy | easy | easy | | easy ]. 2: {
    now apply permut_inv_is_permut.
  }
*)
  rewrite rngl_mul_comm; [ | easy ].
  do 2 rewrite rngl_mul_assoc.
  rewrite rngl_mul_mul_swap; [ | easy ].
  rewrite rngl_mul_comm; [ | easy ].
  rewrite <- rngl_mul_assoc.
  rewrite ε_square;
    [ | easy | easy | easy | easy | easy | easy | easy | easy ].
  rewrite rngl_mul_1_r.
  erewrite rngl_product_eq_compat. 2: {
    intros i Hi.
    rewrite <- Hσν at 1.
    easy.
  }
  easy.
}
(**)
cbn - [ "°" ].
(*2*)
unfold sym_gr.
rewrite <- rngl_summation_list_change_var.
rewrite rngl_summation_seq_summation; [ | apply fact_neq_0 ].
rewrite Nat.add_0_l.
(*3*)
remember (map (λ i, (ε (permut_inv σ ° canon_permut n i) *
  Π (i0 = 0, n - 1), mat_el M (vect_el σ i0) (vect_el (σ ° (permut_inv σ ° canon_permut n i)) i0))%F) (seq 0 n!)) as d eqn:Hd.
Check det_is_det_by_any_permut.
enough (H : determinant M = Σ (i = 0, n! - 1), nth i d 0). {
  rewrite Hd in H.
  erewrite rngl_summation_eq_compat in H. 2: {
    intros i Hi.
    rewrite List_map_nth_in with (a := 0).
    easy.
    rewrite seq_length.
    specialize (fact_neq_0 n) as H1.
    flia Hi H1.
  }
  cbn in H.
  rewrite H.
  apply rngl_summation_eq_compat.
  intros i Hi.
  f_equal. {
    f_equal; f_equal.
    rewrite seq_nth; [ easy | ].
    specialize (fact_neq_0 n) as H1.
    flia Hi H1.
  }
  apply rngl_product_eq_compat.
  intros j Hj.
  f_equal.
  cbn.
  rewrite seq_nth; [ easy | ].
  specialize (fact_neq_0 n) as H1.
  flia Hi H1.
}
apply det_is_det_by_any_permut; try easy.
unfold determinant'_list.
set (f := λ i, permut_inv σ ° canon_permut n i).
erewrite map_ext_in in Hd. 2: {
  intros i Hi.
  replace (permut_inv σ ° canon_permut n i) with (f i) by easy.
  easy.
}
erewrite map_ext_in. 2: {
  intros i Hi.
  replace n with (S (n - 1)) at 2 by flia Hnz.
  rewrite rngl_product_succ_succ.
  erewrite rngl_product_eq_compat. 2: {
    intros j Hj.
    now rewrite Nat.sub_succ, Nat.sub_0_r.
  }
  rewrite <- ε_of_canon_permut_ε; try easy.
  apply in_seq in Hi; flia Hi.
}
remember (canon_permut n) as g eqn:Hg.
subst d.
...
etransitivity. {
...
  apply Permutation_map with (l' := map f (seq 0 n!)).
Search (Permutation (map _ _)).
Print canon_permut_inv.
Search canon_permut_inv.
Check (map (canon_permut_inv n) (seq 0 n!)).
Check ε.
  apply Permutation_map with (l' := map (canon_permut_inv n ° permut_inv σ ° canon_permut n) (seq 0 n!)).
  apply Permutation_map with (l' := map (λ i, vect_el (permut_inv σ) i) (seq 0 n!)).
f = canon_permut_inv n ° permut_inv σ ° canon_permut n
...
}
rewrite map_map.
...
Search (map _ _ = map _ _).
...
map_map: ∀ (A B C : Type) (f : A → B) (g : B → C) (l : list A), map g (map f l) = map (λ x : A, g (f x)) l
...
permut_inv σ ° canon_permut n i = canon_permut n (f i)
...
f = canon_permut_inv n ° permut_inv σ ° canon_permut n

...
  ============================
  Permutation
    (map
       (λ i : nat,
          (ε (permut_inv σ ° canon_permut n i) *
           Π (i0 = 0, n - 1), mat_el M (vect_el σ i0) (vect_el (σ ° (permut_inv σ ° canon_permut n i)) i0))%F)
       (seq 0 n!))
    (map (λ k : nat, (ε_canon_permut n k * Π (i = 1, n), mat_el M (i - 1) (vect_el (canon_permut n k) (i - 1)))%F)
       (seq 0 n!))
...
apply det_is_det_by_any_permut.
...3
rewrite det_is_det_by_canon_permut; try easy.
unfold determinant'.
Search determinant'.

...2
rewrite rngl_summation_list_change_var with
  (f := λ i, permut_inv σ ° i)
  (g :=
     λ k,
     (ε k * Π (i = 0, n - 1), mat_el M (vect_el σ i) (vect_el (σ ° k) i))%F).
unfold sym_gr.
rewrite map_map.
rewrite det_is_det_by_canon_permut; try easy.
unfold determinant'.
(*1*)
Search (Σ (_ ∈ map _ _), _).
...1
rewrite rngl_summation_map_seq.
rewrite rngl_summation_seq_summation; [ | apply fact_neq_0 ].
rewrite Nat.add_0_l.
...
cbn.
rewrite det_is_det_by_canon_permut; try easy.
unfold determinant'.
unfold sym_gr.
rewrite rngl_summation_map_seq.
rewrite rngl_summation_seq_summation; [ | apply fact_neq_0 ].
rewrite Nat.add_0_l.
remember (canon_permut n) as μ eqn:Hμ.
symmetry.
erewrite rngl_summation_eq_compat. 2: {
  intros i Hi.
  rewrite <- rngl_product_succ_succ'.
  replace (S (n - 1)) with n by flia Hnz.
  easy.
}
symmetry.
...
  Hμ : μ = canon_permut n
  ============================
  Σ (k = 0, n! - 1), ε (μ k) * Π (i = 1, n), mat_el M (i - 1) (vect_el (μ k) (i - 1)) =
  Σ (i = 0, n! - 1),
  ε (permut_inv σ ° μ i) *
  Π (i0 = 1, n),
  mat_el M (vect_el σ (i0 - 1))
    (comp (vect_el σ) (comp (permut_fun_inv (vect_el σ) n) (vect_el (μ i))) (i0 - 1)%nat)
...
apply rngl_summation_eq_compat.
intros i Hi.
symmetry.
rewrite rngl_mul_comm; [ | easy ].
rewrite <- rngl_mul_assoc.
f_equal.
rewrite <- rngl_product_succ_succ'.
replace (S (n - 1)) with n by flia Hnz.
rewrite rngl_product_shift; [ | now apply Nat.neq_0_lt_0 ].
symmetry.
rewrite rngl_product_shift; [ | now apply Nat.neq_0_lt_0 ].
erewrite rngl_product_eq_compat. 2: {
  intros j Hj.
  now rewrite Nat.add_comm, Nat.add_sub.
}
symmetry.
erewrite rngl_product_eq_compat. 2: {
  intros j Hj.
  now rewrite Nat.add_comm, Nat.add_sub.
}
symmetry.
...
Search (_ * _ = 1)%F.
rngl_mul_move_1_r:
  ∀ (T : Type) (ro : ring_like_op T),
    ring_like_prop T → rngl_has_inv = true → ∀ a b : T, b ≠ 0%F → (a * b)%F = 1%F ↔ a = b⁻¹%F
...

rewrite ε_ws_ε.
unfold ε_ws.
unfold ε_fun_ws.
unfold sign_diff.

...
unfold ε, ε_fun.
unfold δ.
Search ε.
Print ε_ws.
Print ε_fun_ws.
...
  rewrite <- signature_comp;
    [ | easy | easy | easy | easy | easy | easy | easy | easy | easy ].
  unfold ε at 2.
  unfold ε_fun.
  cbn.
...
rewrite <- signature_comp_fun.
Search (ε _ * ε _)%F.
...
   apply is_permut_permut_inv.
...
  rewrite <- rngl_product_succ_succ'.
  replace (S (n - 1)) with n by flia Hnz.
  erewrite rngl_product_eq_compat. 2: {
    intros i Hi.
    rewrite <- Hσν at 1.
    rewrite permut_comp_assoc.
    rewrite comp_permut_inv_r; [ cbn | easy ].
    unfold id.
    easy.
  }
  cbn.
  rewrite permut_comp_assoc.
  rewrite comp_permut_inv_r; [ | easy ].
  unfold ε at 1; cbn.
  rewrite comp_id_l.
  replace (ε_fun (vect_el μ) n) with (ε μ) by easy.
  rewrite rngl_mul_mul_swap, rngl_mul_comm; [ | easy | easy ].
  easy.
}
cbn.
rewrite <- rngl_mul_summation_list_distr_l; [ | easy ].
unfold sym_gr.
rewrite rngl_summation_map_seq.
rewrite rngl_summation_seq_summation; [ | apply fact_neq_0 ].
cbn.
Print determinant'.
...
erewrite rngl_summation_eq_compat. 2: {
  intros k Hk.
Print determinant'.
...
  erewrite rngl_product_eq_compat. 2: {
    intros i Hi.
...

replace (n!) with (S (n! - 1) - 0).
remember (λ v : nat, canon_permut n v) as h eqn:Hh.
remember 0 as b eqn:Hb.
rewrite Hb at 2.
remember (n! - 1) as e eqn:He.
Check rngl_summation_change_var.
...
Search (Σ (_ ∈ map _ _), _)%F.
rewrite <- rngl_summation_change_var.
Print determinant'.
...

Theorem determinant_transp :
  rngl_is_comm = true →
  rngl_has_opp = true →
  rngl_has_inv = true →
  rngl_is_integral = true →
  rngl_has_1_neq_0 = true →
  rngl_has_dec_eq = true →
  rngl_characteristic = 0 →
  ∀ n (M : matrix n n T), determinant M⁺ = determinant M.
Proof.
intros Hic Hop Hiv Hit H10 Hde Hch *.
rewrite det_is_det_by_canon_permut; try easy.
rewrite determinant'_by_list; try easy.
symmetry.
rewrite det_is_det_by_canon_permut; try easy.
rewrite determinant'_by_list; try easy.
apply rngl_summation_permut; cycle 1. {
  unfold determinant'_list.
  now rewrite map_length, seq_length.
} {
  unfold determinant'_list.
  now rewrite map_length, seq_length.
}
unfold determinant'_list.
cbn.
erewrite map_ext_in. 2: {
  intros m Hm.
  apply in_seq in Hm.
  now rewrite <- ε_of_canon_permut_ε.
}
symmetry.
erewrite map_ext_in. 2: {
  intros m Hm.
  apply in_seq in Hm.
  now rewrite <- ε_of_canon_permut_ε.
}
symmetry.
remember (canon_permut n) as f eqn:Hf.
...
look at
https://proofwiki.org/wiki/Permutation_of_Determinant_Indices
...
Search canon_permut.
Print FinFun.Injective.
Print FinFun.Surjective.
Print Module FinFun.
Print FinFun.Finite.
Print FinFun.Full.
Definition is_symmetric_group n (f : nat → vector n nat) :=
  FinFun.Injective nat {
...
Definition is_symmetric_group n (f : nat → vector n nat) :=
  (∀ i j, i < n! → j < n! → f i = f j → i = j) ∧
  (∀ v, ∃ i, i < n! ∧ f i = v).
...
Theorem glop : ∀ n (M : matrix n n T) (f g : nat → vector n nat),
  is_symmetric_group f
  → is_symmetric_group f
  → determinant M =
      (Σ (i = 1, n!), ε (f i) * ε (g i) *
       Π (j = 1, n), mat_el M (vect_el (f i) j) (vect_el (g i) j))%F.
...
Check determinant_multilinear.
About nat_bijection_Permutation.
Search (Permutation (map _ _)).
Search determinant'_list.
Search canon_permut.
...
Print FinFun.Injective.
Print FinFun.Surjective.
Search FinFun.Surjective.
Theorem glop : ∀ A B (f g : A → B) l,
  FinFun.Injective f
  → FinFun.Injective g
  → FinFun.Surjective f
  → FinFun.Surjective g
  → Permutation (map f l) (map g l).
Proof.
intros * Hif Hig Hsf Hsg.
unfold FinFun.Injective in Hif, Hig.
unfold FinFun.Surjective in Hsf, Hsg.
induction l as [| x]; [ easy | ].
cbn.
Search Permutation (_ :: _).
...
destruct n; [ easy | ].
destruct n. {
  now subst f; unfold iter_seq, iter_list; cbn.
}
destruct n. {
  subst f; unfold iter_seq, iter_list; cbn.
  repeat rewrite rngl_mul_1_l.
  rewrite rngl_mul_1_r.
  rewrite (rngl_mul_comm Hic (mat_el M 0 1)).
  easy.
}
...
cbn in Hf.
subst f.
remember (S n) as sn; cbn; subst sn.
Print canon_permut_fun.
...
apply det_is_det_by_any_permut; try easy.
unfold determinant'_list.
Search determinant'_list.
Search (Permutation (map _ _)).
About nat_bijection_Permutation.
etransitivity. {
About permut_fun_Permutation.
...
Search Permutation.
apply nat_bijection_Permutation.
Check Permutation_map.
Check Permutation_trans.
...
permut_fun_Permutation: ∀ (f : nat → nat) (n : nat), is_permut_fun f n → Permutation (map f (seq 0 n)) (seq 0 n)

cbn.
transitivity (seq 0 n!).
Check Permutation_trans.

Search (Permutation (map _ _)).
apply Permutation_trans with (l' := seq 0 n!).
eapply Permutation_trans. {
apply permut_fun_Permutation.
...
intros Hic Hop Hiv Hit H10 Hde Hch *.
rewrite det_is_det_by_canon_permut; try easy.
unfold determinant'.
symmetry.
rewrite det_is_det_by_canon_permut; try easy.
unfold determinant'.
cbn.
Search determinant'.
...
intros Hic Hop Hin Hit H10 Hde Hch * Hlin.
intros.
...

Theorem laplace_formula_on_cols :
  rngl_is_comm = true →
  rngl_has_opp = true →
  rngl_has_inv = true →
  rngl_is_integral = true →
  rngl_has_1_neq_0 = true →
  rngl_has_dec_eq = true →
  rngl_characteristic = 0 →
  ∀ n (M : matrix n n T) j,
  j < n
  → determinant M = Σ (i = 0, n - 1), mat_el M i j * mat_el (comatrix M) i j.
Proof.
intros Hic Hop Hin Hit H10 Hde Hch * Hlin.
...
Check determinant_transp.
...

Theorem mat_swap_rows_involutive : ∀ n (M : matrix n n T) i j,
  mat_swap_rows i j (mat_swap_rows i j M) = M.
Proof.
intros.
apply matrix_eq.
intros p q Hp Hq; cbn.
destruct (Nat.eq_dec p i) as [Hpi| Hpi]. {
  subst p.
  destruct (Nat.eq_dec j i) as [Hji| Hji]; [ now subst j | ].
  now rewrite <- (if_eqb_eq_dec j), Nat.eqb_refl.
}
destruct (Nat.eq_dec p j) as [Hpj| Hpj]; [ | easy ].
subst p.
now rewrite <- (if_eqb_eq_dec i), Nat.eqb_refl.
Qed.

(*
The following two theorems, "determinant_with_row" and determinant_with_bad_row
have some similitudes.
  The theorem "determinant_with_row" says that we can compute the determinant
by going through any row (not necessarily the 0th one). Here, row "i".
  The theorem "determinant_with_bad_row" says that if we go through another
row "k" different from "i", the same formula (where "M i j" is replaced
with "M k j") returns 0. It is what I call a "bad determinant formula".

determinant_with_row
  ∀ (i n : nat) (M : matrix (S n) (S n) T),
  i ≤ n
  → Σ (j = 0, n), minus_one_pow (i + j) * M i j * det (subm M i j) = det M

determinant_with_bad_row
  ∀ (i k n : nat) (M : matrix (S n) (S n) T),
  i ≤ n → k ≤ n → i ≠ k
  → Σ (j = 0, n), minus_one_pow (i + j) * M k j * det (subm M i j) = 0%F

Isn't it strange? (or beautiful?)
*)

Theorem determinant_with_row :
  rngl_is_comm = true →
  rngl_has_opp = true →
  rngl_has_inv = true →
  rngl_is_integral = true →
  rngl_has_1_neq_0 = true →
  rngl_has_dec_eq = true →
  rngl_characteristic = 0 →
  ∀ i n (M : matrix (S n) (S n) T),
  i ≤ n
  → Σ (j = 0, n),
    minus_one_pow (i + j) * mat_el M i j * determinant (subm M i j) =
    determinant M.
Proof.
intros Hic Hop Hiv Hit H10 Hde Hch * Hin.
symmetry.
destruct (Nat.eq_dec i 0) as [Hiz| Hiz]; [ now subst i | ].
apply rngl_opp_inj; [ easy | ].
rewrite <- determinant_alternating with (p := 0) (q := i); try easy;
  [ | flia Hiz | flia | flia Hin ].
rewrite determinant_succ at 1.
erewrite rngl_summation_eq_compat. 2: {
  intros j Hj.
  rewrite mat_swap_rows_comm.
  rewrite mat_el_mat_swap_rows.
  easy.
}
rewrite rngl_opp_summation; [ | easy | easy ].
apply rngl_summation_eq_compat.
intros j Hj.
rewrite <- rngl_mul_assoc; symmetry.
rewrite <- rngl_mul_opp_r; [ | easy ].
rewrite (Nat.add_comm i j).
rewrite minus_one_pow_add_r; [ | easy | easy ].
do 2 rewrite <- rngl_mul_assoc.
f_equal.
rewrite rngl_mul_comm; [ | easy ].
rewrite <- rngl_mul_assoc.
f_equal.
rewrite rngl_mul_opp_l, <- rngl_mul_opp_r; [ | easy | easy ].
rewrite rngl_mul_comm; [ | easy ].
symmetry.
rewrite mat_swap_rows_comm.
apply determinant_subm_mat_swap_rows_0_i; try easy.
flia Hiz Hin.
Qed.

Theorem determinant_with_bad_row :
  rngl_is_comm = true →
  rngl_has_opp = true →
  rngl_has_inv = true →
  rngl_is_integral = true →
  rngl_has_1_neq_0 = true →
  rngl_has_dec_eq = true →
  rngl_characteristic = 0 →
  ∀ i k n (M : matrix (S n) (S n) T),
  i ≤ n
  → k ≤ n
  → i ≠ k
  → Σ (j = 0, n),
    minus_one_pow (i + j) * mat_el M k j * determinant (subm M i j) = 0%F.
Proof.
intros Hic Hop Hiv Hit H10 Hde Hch.
intros * Hi Hk Hik.
remember
  (mk_mat (S n) (S n) (λ p q, mat_el M (if Nat.eq_dec p i then k else p) q))
  as A eqn:HA.
assert (H1 : determinant A = 0%F). {
  subst A.
  apply Nat.lt_succ_r in Hi.
  apply Nat.lt_succ_r in Hk.
  apply determinant_same_rows with (p := i) (q := k); try easy.
  intros j.
  cbn.
  rewrite <- (if_eqb_eq_dec i), Nat.eqb_refl.
  now destruct (Nat.eq_dec k i).
}
rewrite <- determinant_with_row with (i := i) in H1; try easy.
rewrite <- H1 at 2.
apply rngl_summation_eq_compat.
intros j Hj.
do 2 rewrite <- rngl_mul_assoc.
f_equal; f_equal. {
  rewrite HA; cbn.
  now rewrite <- if_eqb_eq_dec, Nat.eqb_refl.
}
f_equal.
rewrite HA.
apply matrix_eq.
intros p q Hp Hq; cbn.
destruct (Nat.eq_dec (p + Nat.b2n (i <=? p)) i) as [Hpi| Hpi]; [ | easy ].
destruct (le_dec i p) as [Hip| Hip]. {
  apply Nat.leb_le in Hip.
  rewrite Hip in Hpi.
  cbn in Hpi.
  apply Nat.leb_le in Hip.
  flia Hpi Hip.
} {
  apply Nat.leb_nle in Hip.
  rewrite Hip in Hpi.
  cbn in Hpi.
  apply Nat.leb_nle in Hip.
  flia Hpi Hip.
}
Qed.

Theorem matrix_comatrix_mul :
  rngl_is_comm = true →
  rngl_has_opp = true →
  rngl_has_inv = true →
  rngl_is_integral = true →
  rngl_has_1_neq_0 = true →
  rngl_has_dec_eq = true →
  rngl_characteristic = 0 →
  ∀ n (M : matrix n n T),
  (M * (comatrix M)⁺ = determinant M × mI n)%M.
Proof.
intros Hic Hop Hiv Hit H10 Hde Hch *.
apply matrix_eq.
intros i j Hi Hj.
rewrite laplace_formula_on_rows with (i := i); try easy; cbn.
destruct (Nat.eq_dec i j) as [Hij| Hij]. {
  subst j.
  now rewrite rngl_mul_1_r.
}
rewrite rngl_mul_0_r; [ | now left ].
destruct n; [ easy | ].
rewrite Nat.sub_succ at 1.
rewrite Nat.sub_0_r.
erewrite rngl_summation_eq_compat. 2: {
  intros k Hk.
  rewrite rngl_mul_comm; [ | easy ].
  rewrite rngl_mul_mul_swap; [ | easy ].
  easy.
}
cbn.
apply -> Nat.lt_succ_r in Hi.
apply -> Nat.lt_succ_r in Hj.
apply Nat.neq_sym in Hij.
now apply determinant_with_bad_row.
Qed.

Theorem comatrix_matrix_mul :
  rngl_is_comm = true →
  rngl_has_opp = true →
  rngl_has_inv = true →
  rngl_is_integral = true →
  rngl_has_1_neq_0 = true →
  rngl_has_dec_eq = true →
  rngl_characteristic = 0 →
  ∀ n (M : matrix n n T),
  ((comatrix M)⁺ * M = determinant M × mI n)%M.
Proof.
intros Hic Hop Hiv Hit H10 Hde Hch *.
apply matrix_eq.
intros i j Hi Hj.
rewrite laplace_formula_on_cols with (j := j); try easy; cbn.
destruct (Nat.eq_dec i j) as [Hij| Hij]. {
  subst i.
  rewrite rngl_mul_1_r.
  apply rngl_summation_eq_compat.
  intros k Hk.
  rewrite rngl_mul_mul_swap; [ | easy ].
  rewrite rngl_mul_assoc.
  f_equal.
  now apply rngl_mul_comm.
}
rewrite rngl_mul_0_r; [ | now left ].
...
destruct n; [ easy | ].
rewrite Nat.sub_succ at 1.
rewrite Nat.sub_0_r.
erewrite rngl_summation_eq_compat. 2: {
  intros k Hk.
  rewrite rngl_mul_comm; [ | easy ].
  rewrite rngl_mul_mul_swap; [ | easy ].
  easy.
}
cbn.
apply -> Nat.lt_succ_r in Hi.
apply -> Nat.lt_succ_r in Hj.
apply Nat.neq_sym in Hij.
now apply determinant_with_bad_row.
Qed.

Definition mat_inv n (M : matrix n n T) :=
  ((determinant M)⁻¹ × (comatrix M)⁺)%M.

Theorem matrix_right_inv :
  rngl_is_comm = true →
  rngl_has_opp = true →
  rngl_has_inv = true →
  rngl_is_integral = true →
  rngl_has_1_neq_0 = true →
  rngl_has_dec_eq = true →
  rngl_characteristic = 0 →
  ∀ n (M : matrix n n T),
  determinant M ≠ 0%F → (M * mat_inv M = mI n)%M.
Proof.
intros Hic Hop Hiv Hit H10 Hde Hch *.
intros Hdz.
unfold mat_inv.
rewrite mat_mul_mul_scal_l; [ | easy | easy ].
rewrite matrix_comatrix_mul; try easy.
rewrite mat_mul_scal_l_mul_assoc; [ | easy ].
rewrite rngl_mul_inv_l; [ | easy | easy ].
now apply mat_mul_scal_1_l.
Qed.

Theorem matrix_left_inv :
  rngl_is_comm = true →
  rngl_has_opp = true →
  rngl_has_inv = true →
  rngl_is_integral = true →
  rngl_has_1_neq_0 = true →
  rngl_has_dec_eq = true →
  rngl_characteristic = 0 →
  ∀ n (M : matrix n n T),
  determinant M ≠ 0%F → (mat_inv M * M = mI n)%M.
Proof.
intros Hic Hop Hiv Hit H10 Hde Hch *.
intros Hdz.
unfold mat_inv.
rewrite mat_mul_scal_l_mul; [ | easy ].
...
rewrite matrix_comatrix_mul; try easy.
rewrite mat_mul_scal_l_mul_assoc; [ | easy ].
rewrite rngl_mul_inv_l; [ | easy | easy ].
now apply mat_mul_scal_1_l.
...

End a.

Arguments determinant {T ro} {n%nat} M%M.
Arguments det_from_row {T}%type {ro} {n}%nat M%M i%nat.
Arguments det_from_col {T}%type {ro} {n}%nat M%M j%nat.
Arguments comatrix {T}%type {ro} {n}%nat M%M.
Arguments subm {T m n} M%M i%nat j%nat.
